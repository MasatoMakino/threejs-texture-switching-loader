"use strict";(self.webpackChunk_masatomakino_threejs_texture_switching_loader=self.webpackChunk_masatomakino_threejs_texture_switching_loader||[]).push([[736],{75:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $V: () => (/* binding */ Spherical),\n/* harmony export */   CP7: () => (/* binding */ WebGLRenderer),\n/* harmony export */   CtF: () => (/* binding */ Cache),\n/* harmony export */   FM8: () => (/* binding */ Vector2),\n/* harmony export */   Ilk: () => (/* binding */ Color),\n/* harmony export */   JOQ: () => (/* binding */ Plane),\n/* harmony export */   Kj0: () => (/* binding */ Mesh),\n/* harmony export */   M8C: () => (/* binding */ MathUtils),\n/* harmony export */   Mig: () => (/* binding */ AmbientLight),\n/* harmony export */   Pa4: () => (/* binding */ Vector3),\n/* harmony export */   QRU: () => (/* binding */ ImageBitmapLoader),\n/* harmony export */   QmN: () => (/* binding */ TOUCH),\n/* harmony export */   ROQ: () => (/* binding */ CanvasTexture),\n/* harmony export */   RsA: () => (/* binding */ MOUSE),\n/* harmony export */   _fP: () => (/* binding */ Quaternion),\n/* harmony export */   cPb: () => (/* binding */ PerspectiveCamera),\n/* harmony export */   dpR: () => (/* binding */ TextureLoader),\n/* harmony export */   pBf: () => (/* binding */ EventDispatcher),\n/* harmony export */   vBJ: () => (/* binding */ MeshBasicMaterial),\n/* harmony export */   xo$: () => (/* binding */ SphereGeometry),\n/* harmony export */   xsS: () => (/* binding */ Scene),\n/* harmony export */   y8_: () => (/* binding */ AxesHelper),\n/* harmony export */   zHn: () => (/* binding */ Ray)\n/* harmony export */ });\n/* unused harmony exports ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, BackSide, BasicDepthPacking, BasicShadowMap, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Camera, CameraHelper, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleGeometry, ClampToEdgeWrapping, Clock, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DetachedBindMode, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DisplayP3ColorSpace, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, IcosahedronGeometry, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheGeometry, Layers, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearDisplayP3ColorSpace, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, LinearTransfer, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, Material, MaterialLoader, Matrix3, Matrix4, MaxEquation, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronGeometry, OneFactor, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, P3Primaries, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, Path, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Raycaster, Rec709Primaries, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RenderTarget, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TangentSpaceNormalMap, TetrahedronGeometry, Texture, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector4, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WebGLUtils, WebGPUCoordinateSystem, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, createCanvasElement */\n/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = '165';\n\nconst MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst CullFaceFrontBack = 3;\nconst BasicShadowMap = 0;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst ConstantColorFactor = 211;\nconst OneMinusConstantColorFactor = 212;\nconst ConstantAlphaFactor = 213;\nconst OneMinusConstantAlphaFactor = 214;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\nconst AgXToneMapping = 6;\nconst NeutralToneMapping = 7;\nconst AttachedBindMode = 'attached';\nconst DetachedBindMode = 'detached';\n\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipMapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst NearestMipMapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipMapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst LinearMipMapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedInt248Type = 1020;\nconst UnsignedInt5999Type = 35902;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBAIntegerFormat = 1033;\n\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst RGB_BPTC_SIGNED_Format = 36494;\nconst RGB_BPTC_UNSIGNED_Format = 36495;\nconst RED_RGTC1_Format = 36283;\nconst SIGNED_RED_RGTC1_Format = 36284;\nconst RED_GREEN_RGTC2_Format = 36285;\nconst SIGNED_RED_GREEN_RGTC2_Format = 36286;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\n\n// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\nconst NoColorSpace = '';\nconst SRGBColorSpace = 'srgb';\nconst LinearSRGBColorSpace = 'srgb-linear';\nconst DisplayP3ColorSpace = 'display-p3';\nconst LinearDisplayP3ColorSpace = 'display-p3-linear';\n\nconst LinearTransfer = 'linear';\nconst SRGBTransfer = 'srgb';\n\nconst Rec709Primaries = 'rec709';\nconst P3Primaries = 'p3';\n\nconst ZeroStencilOp = 0;\nconst KeepStencilOp = 7680;\nconst ReplaceStencilOp = 7681;\nconst IncrementStencilOp = 7682;\nconst DecrementStencilOp = 7683;\nconst IncrementWrapStencilOp = 34055;\nconst DecrementWrapStencilOp = 34056;\nconst InvertStencilOp = 5386;\n\nconst NeverStencilFunc = 512;\nconst LessStencilFunc = 513;\nconst EqualStencilFunc = 514;\nconst LessEqualStencilFunc = 515;\nconst GreaterStencilFunc = 516;\nconst NotEqualStencilFunc = 517;\nconst GreaterEqualStencilFunc = 518;\nconst AlwaysStencilFunc = 519;\n\nconst NeverCompare = 512;\nconst LessCompare = 513;\nconst EqualCompare = 514;\nconst LessEqualCompare = 515;\nconst GreaterCompare = 516;\nconst NotEqualCompare = 517;\nconst GreaterEqualCompare = 518;\nconst AlwaysCompare = 519;\n\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst StreamDrawUsage = 35040;\nconst StaticReadUsage = 35045;\nconst DynamicReadUsage = 35049;\nconst StreamReadUsage = 35041;\nconst StaticCopyUsage = 35046;\nconst DynamicCopyUsage = 35050;\nconst StreamCopyUsage = 35042;\n\nconst GLSL1 = '100';\nconst GLSL3 = '300 es';\n\nconst WebGLCoordinateSystem = 2000;\nconst WebGPUCoordinateSystem = 2001;\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}\n\nconst _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nclass Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tVector2.prototype.isVector2 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\n\t}\n\n}\n\nclass Matrix3 {\n\n\tconstructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tMatrix3.prototype.isMatrix3 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tscale( sx, sy ) {\n\n\t\tthis.premultiply( _m3.makeScale( sx, sy ) );\n\n\t\treturn this;\n\n\t}\n\n\trotate( theta ) {\n\n\t\tthis.premultiply( _m3.makeRotation( - theta ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( tx, ty ) {\n\n\t\tthis.premultiply( _m3.makeTranslation( tx, ty ) );\n\n\t\treturn this;\n\n\t}\n\n\t// for 2D Transforms\n\n\tmakeTranslation( x, y ) {\n\n\t\tif ( x.isVector2 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x.x,\n\t\t\t\t0, 1, x.y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x,\n\t\t\t\t0, 1, y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotation( theta ) {\n\n\t\t// counterclockwise\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0,\n\t\t\ts, c, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0,\n\t\t\t0, y, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nconst _m3 = /*@__PURE__*/ new Matrix3();\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nfunction createElementNS( name ) {\n\n\treturn document.createElementNS( 'http://www.w3.org/1999/xhtml', name );\n\n}\n\nfunction createCanvasElement() {\n\n\tconst canvas = createElementNS( 'canvas' );\n\tcanvas.style.display = 'block';\n\treturn canvas;\n\n}\n\nconst _cache = {};\n\nfunction warnOnce( message ) {\n\n\tif ( message in _cache ) return;\n\n\t_cache[ message ] = true;\n\n\tconsole.warn( message );\n\n}\n\nfunction probeAsync( gl, sync, interval ) {\n\n\treturn new Promise( function ( resolve, reject ) {\n\n\t\tfunction probe() {\n\n\t\t\tswitch ( gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 ) ) {\n\n\t\t\t\tcase gl.WAIT_FAILED:\n\t\t\t\t\treject();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.TIMEOUT_EXPIRED:\n\t\t\t\t\tsetTimeout( probe, interval );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tresolve();\n\n\t\t\t}\n\n\t\t}\n\n\t\tsetTimeout( probe, interval );\n\n\t} );\n\n}\n\n/**\n * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping\n * or clipping. Based on W3C specifications for sRGB and Display P3,\n * and ICC specifications for the D50 connection space. Values in/out\n * are _linear_ sRGB and _linear_ Display P3.\n *\n * Note that both sRGB and Display P3 use the sRGB transfer functions.\n *\n * Reference:\n * - http://www.russellcottrell.com/photo/matrixCalculator.htm\n */\n\nconst LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().set(\n\t0.8224621, 0.177538, 0.0,\n\t0.0331941, 0.9668058, 0.0,\n\t0.0170827, 0.0723974, 0.9105199,\n);\n\nconst LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().set(\n\t1.2249401, - 0.2249404, 0.0,\n\t- 0.0420569, 1.0420571, 0.0,\n\t- 0.0196376, - 0.0786361, 1.0982735\n);\n\n/**\n * Defines supported color spaces by transfer function and primaries,\n * and provides conversions to/from the Linear-sRGB reference space.\n */\nconst COLOR_SPACES = {\n\t[ LinearSRGBColorSpace ]: {\n\t\ttransfer: LinearTransfer,\n\t\tprimaries: Rec709Primaries,\n\t\ttoReference: ( color ) => color,\n\t\tfromReference: ( color ) => color,\n\t},\n\t[ SRGBColorSpace ]: {\n\t\ttransfer: SRGBTransfer,\n\t\tprimaries: Rec709Primaries,\n\t\ttoReference: ( color ) => color.convertSRGBToLinear(),\n\t\tfromReference: ( color ) => color.convertLinearToSRGB(),\n\t},\n\t[ LinearDisplayP3ColorSpace ]: {\n\t\ttransfer: LinearTransfer,\n\t\tprimaries: P3Primaries,\n\t\ttoReference: ( color ) => color.applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),\n\t\tfromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ),\n\t},\n\t[ DisplayP3ColorSpace ]: {\n\t\ttransfer: SRGBTransfer,\n\t\tprimaries: P3Primaries,\n\t\ttoReference: ( color ) => color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),\n\t\tfromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB(),\n\t},\n};\n\nconst SUPPORTED_WORKING_COLOR_SPACES = new Set( [ LinearSRGBColorSpace, LinearDisplayP3ColorSpace ] );\n\nconst ColorManagement = {\n\n\tenabled: true,\n\n\t_workingColorSpace: LinearSRGBColorSpace,\n\n\tget workingColorSpace() {\n\n\t\treturn this._workingColorSpace;\n\n\t},\n\n\tset workingColorSpace( colorSpace ) {\n\n\t\tif ( ! SUPPORTED_WORKING_COLOR_SPACES.has( colorSpace ) ) {\n\n\t\t\tthrow new Error( `Unsupported working color space, \"${ colorSpace }\".` );\n\n\t\t}\n\n\t\tthis._workingColorSpace = colorSpace;\n\n\t},\n\n\tconvert: function ( color, sourceColorSpace, targetColorSpace ) {\n\n\t\tif ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {\n\n\t\t\treturn color;\n\n\t\t}\n\n\t\tconst sourceToReference = COLOR_SPACES[ sourceColorSpace ].toReference;\n\t\tconst targetFromReference = COLOR_SPACES[ targetColorSpace ].fromReference;\n\n\t\treturn targetFromReference( sourceToReference( color ) );\n\n\t},\n\n\tfromWorkingColorSpace: function ( color, targetColorSpace ) {\n\n\t\treturn this.convert( color, this._workingColorSpace, targetColorSpace );\n\n\t},\n\n\ttoWorkingColorSpace: function ( color, sourceColorSpace ) {\n\n\t\treturn this.convert( color, sourceColorSpace, this._workingColorSpace );\n\n\t},\n\n\tgetPrimaries: function ( colorSpace ) {\n\n\t\treturn COLOR_SPACES[ colorSpace ].primaries;\n\n\t},\n\n\tgetTransfer: function ( colorSpace ) {\n\n\t\tif ( colorSpace === NoColorSpace ) return LinearTransfer;\n\n\t\treturn COLOR_SPACES[ colorSpace ].transfer;\n\n\t},\n\n};\n\n\nfunction SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nfunction LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n\nlet _canvas;\n\nclass ImageUtils {\n\n\tstatic getDataURL( image ) {\n\n\t\tif ( /^data:/i.test( image.src ) ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tif ( typeof HTMLCanvasElement === 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tlet canvas;\n\n\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tconst context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n\tstatic sRGBToLinear( image ) {\n\n\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\tconst canvas = createElementNS( 'canvas' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\tconst imageData = context.getImageData( 0, 0, image.width, image.height );\n\t\t\tconst data = imageData.data;\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;\n\n\t\t\t}\n\n\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\treturn canvas;\n\n\t\t} else if ( image.data ) {\n\n\t\t\tconst data = image.data.slice( 0 );\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tif ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {\n\n\t\t\t\t\tdata[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assuming float\n\n\t\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdata: data,\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );\n\t\t\treturn image;\n\n\t\t}\n\n\t}\n\n}\n\nlet _sourceId = 0;\n\nclass Source {\n\n\tconstructor( data = null ) {\n\n\t\tthis.isSource = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _sourceId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.data = data;\n\t\tthis.dataReady = true;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.images[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\t\t\tuuid: this.uuid,\n\t\t\turl: ''\n\t\t};\n\n\t\tconst data = this.data;\n\n\t\tif ( data !== null ) {\n\n\t\t\tlet url;\n\n\t\t\tif ( Array.isArray( data ) ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\turl = [];\n\n\t\t\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( data[ i ].isDataTexture ) {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ].image ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// texture\n\n\t\t\t\turl = serializeImage( data );\n\n\t\t\t}\n\n\t\t\toutput.url = url;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.images[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nfunction serializeImage( image ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t// default images\n\n\t\treturn ImageUtils.getDataURL( image );\n\n\t} else {\n\n\t\tif ( image.data ) {\n\n\t\t\t// images of DataTexture\n\n\t\t\treturn {\n\t\t\t\tdata: Array.from( image.data ),\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\ttype: image.data.constructor.name\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\treturn {};\n\n\t\t}\n\n\t}\n\n}\n\nlet _textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {\n\n\t\tsuper();\n\n\t\tthis.isTexture = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _textureId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.source = new Source( image );\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\t\tthis.channel = 0;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\tthis.colorSpace = colorSpace;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t\tthis.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n\t\tthis.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n\n\t}\n\n\tget image() {\n\n\t\treturn this.source.data;\n\n\t}\n\n\tset image( value = null ) {\n\n\t\tthis.source.data = value;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.source = source.source;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\t\tthis.channel = source.channel;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.colorSpace = source.colorSpace;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\timage: this.source.toJSON( meta ).uuid,\n\n\t\t\tmapping: this.mapping,\n\t\t\tchannel: this.channel,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\tinternalFormat: this.internalFormat,\n\t\t\ttype: this.type,\n\t\t\tcolorSpace: this.colorSpace,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tgenerateMipmaps: this.generateMipmaps,\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.source.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tset needsPMREMUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.pmremVersion ++;\n\n\t\t}\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.DEFAULT_ANISOTROPY = 1;\n\nclass Vector4 {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tVector4.prototype.isVector4 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.z;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.z = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.w;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.w = value;\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\t\tthis.w *= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tsetAxisAngleFromQuaternion( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tconst s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetAxisAngleFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tlet angle, x, y, z; // variables for result\n\t\tconst epsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tconst xx = ( m11 + 1 ) / 2;\n\t\t\tconst yy = ( m22 + 1 ) / 2;\n\t\t\tconst zz = ( m33 + 1 ) / 2;\n\t\t\tconst xy = ( m12 + m21 ) / 4;\n\t\t\tconst xz = ( m13 + m31 ) / 4;\n\t\t\tconst yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tlet s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\t\tthis.w = Math.max( minVal, Math.min( maxVal, this.w ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\t\tthis.w = Math.trunc( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\t\tthis.w = v1.w + ( v2.w - v1.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\t\tthis.w = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\t\tyield this.w;\n\n\t}\n\n}\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nclass RenderTarget extends EventDispatcher {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.isRenderTarget = true;\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.depth = 1;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\tconst image = { width: width, height: height, depth: 1 };\n\n\t\toptions = Object.assign( {\n\t\t\tgenerateMipmaps: false,\n\t\t\tinternalFormat: null,\n\t\t\tminFilter: LinearFilter,\n\t\t\tdepthBuffer: true,\n\t\t\tstencilBuffer: false,\n\t\t\tresolveDepthBuffer: true,\n\t\t\tresolveStencilBuffer: true,\n\t\t\tdepthTexture: null,\n\t\t\tsamples: 0,\n\t\t\tcount: 1\n\t\t}, options );\n\n\t\tconst texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\ttexture.flipY = false;\n\t\ttexture.generateMipmaps = options.generateMipmaps;\n\t\ttexture.internalFormat = options.internalFormat;\n\n\t\tthis.textures = [];\n\n\t\tconst count = options.count;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.textures[ i ] = texture.clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\n\t\t}\n\n\t\tthis.depthBuffer = options.depthBuffer;\n\t\tthis.stencilBuffer = options.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = options.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = options.resolveStencilBuffer;\n\n\t\tthis.depthTexture = options.depthTexture;\n\n\t\tthis.samples = options.samples;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this.textures[ 0 ];\n\n\t}\n\n\tset texture( value ) {\n\n\t\tthis.textures[ 0 ] = value;\n\n\t}\n\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tfor ( let i = 0, il = this.textures.length; i < il; i ++ ) {\n\n\t\t\t\tthis.textures[ i ].image.width = width;\n\t\t\t\tthis.textures[ i ].image.height = height;\n\t\t\t\tthis.textures[ i ].image.depth = depth;\n\n\t\t\t}\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.scissor.copy( source.scissor );\n\t\tthis.scissorTest = source.scissorTest;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.textures.length = 0;\n\n\t\tfor ( let i = 0, il = source.textures.length; i < il; i ++ ) {\n\n\t\t\tthis.textures[ i ] = source.textures[ i ].clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\n\t\t}\n\n\t\t// ensure image object is not shared, see #20328\n\n\t\tconst image = Object.assign( {}, source.texture.image );\n\t\tthis.texture.source = new Source( image );\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = source.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = source.resolveStencilBuffer;\n\n\t\tif ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nclass WebGLRenderTarget extends RenderTarget {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLRenderTarget = true;\n\n\t}\n\n}\n\nclass DataArrayTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper( null );\n\n\t\tthis.isDataArrayTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t\tthis.layerUpdates = new Set();\n\n\t}\n\n\taddLayerUpdate( layerIndex ) {\n\n\t\tthis.layerUpdates.add( layerIndex );\n\n\t}\n\n\tclearLayerUpdates() {\n\n\t\tthis.layerUpdates.clear();\n\n\t}\n\n}\n\nclass WebGLArrayRenderTarget extends (/* unused pure expression or super */ null && (WebGLRenderTarget)) {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLArrayRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new DataArrayTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Data3DTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t// Users can still set in DataTexture3D directly.\n\t\t//\n\t\t//\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n\t\t// \ttexture.anisotropy = 16;\n\t\t//\n\t\t// See #14839\n\n\t\tsuper( null );\n\n\t\tthis.isData3DTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nclass WebGL3DRenderTarget extends (/* unused pure expression or super */ null && (WebGLRenderTarget)) {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGL3DRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new Data3DTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis.isQuaternion = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update = true ) {\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize(); // normalize calls _onChangeCallback()\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\treturn this.copy( qa ).slerp( qb, t );\n\n\t}\n\n\trandom() {\n\n\t\t// sets this quaternion to a uniform random unit quaternnion\n\n\t\t// Ken Shoemake\n\t\t// Uniform random rotations\n\t\t// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.\n\n\t\tconst theta1 = 2 * Math.PI * Math.random();\n\t\tconst theta2 = 2 * Math.PI * Math.random();\n\n\t\tconst x0 = Math.random();\n\t\tconst r1 = Math.sqrt( 1 - x0 );\n\t\tconst r2 = Math.sqrt( x0 );\n\n\t\treturn this.set(\n\t\t\tr1 * Math.sin( theta1 ),\n\t\t\tr1 * Math.cos( theta1 ),\n\t\t\tr2 * Math.sin( theta2 ),\n\t\t\tr2 * Math.cos( theta2 ),\n\t\t);\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.toArray();\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._w;\n\n\t}\n\n}\n\nclass Vector3 {\n\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\tVector3.prototype.isVector3 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t}\n\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyEuler( euler ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );\n\n\t}\n\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t// quaternion q is assumed to have unit length\n\n\t\tconst vx = this.x, vy = this.y, vz = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// t = 2 * cross( q.xyz, v );\n\t\tconst tx = 2 * ( qy * vz - qz * vy );\n\t\tconst ty = 2 * ( qz * vx - qx * vz );\n\t\tconst tz = 2 * ( qx * vy - qy * vx );\n\n\t\t// v + q.w * t + cross( q.xyz, t );\n\t\tthis.x = vx + qw * tx + qy * tz - qz * ty;\n\t\tthis.y = vy + qw * ty + qz * tx - qx * tz;\n\t\tthis.z = vz + qw * tz + qx * ty - qy * tx;\n\n\t\treturn this;\n\n\t}\n\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector$c.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector$c );\n\n\t}\n\n\treflect( normal ) {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\treturn this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\tsetFromEuler( e ) {\n\n\t\tthis.x = e._x;\n\t\tthis.y = e._y;\n\t\tthis.z = e._z;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromColor( c ) {\n\n\t\tthis.x = c.r;\n\t\tthis.y = c.g;\n\t\tthis.z = c.b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\trandomDirection() {\n\n\t\t// https://mathworld.wolfram.com/SpherePointPicking.html\n\n\t\tconst theta = Math.random() * Math.PI * 2;\n\t\tconst u = Math.random() * 2 - 1;\n\t\tconst c = Math.sqrt( 1 - u * u );\n\n\t\tthis.x = c * Math.cos( theta );\n\t\tthis.y = u;\n\t\tthis.z = c * Math.sin( theta );\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\n\t}\n\n}\n\nconst _vector$c = /*@__PURE__*/ new Vector3();\nconst _quaternion$4 = /*@__PURE__*/ new Quaternion();\n\nclass Box3 {\n\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox3 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromArray( array ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\tthis.expandByPoint( _vector$b.fromArray( array, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object, precise = false ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object, precise );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\texpandByObject( object, precise = false ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t// precise AABB computation based on vertex data requires at least a position attribute.\n\t\t\t// instancing isn't supported so far and uses the normal (conservative) code path.\n\n\t\t\tif ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tif ( object.isMesh === true ) {\n\n\t\t\t\t\t\tobject.getVertexPosition( i, _vector$b );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector$b.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_vector$b.applyMatrix4( object.matrixWorld );\n\t\t\t\t\tthis.expandByPoint( _vector$b );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( object.boundingBox !== undefined ) {\n\n\t\t\t\t\t// object-level bounding box\n\n\t\t\t\t\tif ( object.boundingBox === null ) {\n\n\t\t\t\t\t\tobject.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$4.copy( object.boundingBox );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// geometry-level bounding box\n\n\t\t\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$4.copy( geometry.boundingBox );\n\n\t\t\t\t}\n\n\t\t\t\t_box$4.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tthis.union( _box$4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ], precise );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector$b );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0$2.subVectors( triangle.a, _center );\n\t\t_v1$7.subVectors( triangle.b, _center );\n\t\t_v2$4.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1$7, _v0$2 );\n\t\t_f1.subVectors( _v2$4, _v1$7 );\n\t\t_f2.subVectors( _v0$2, _v2$4 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$b ).distanceTo( point );\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t} else {\n\n\t\t\tthis.getCenter( target.center );\n\n\t\t\ttarget.radius = this.getSize( _vector$b ).length() * 0.5;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector$b = /*@__PURE__*/ new Vector3();\n\nconst _box$4 = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0$2 = /*@__PURE__*/ new Vector3();\nconst _v1$7 = /*@__PURE__*/ new Vector3();\nconst _v2$4 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the separating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the separating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is separating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nconst _box$3 = /*@__PURE__*/ new Box3();\nconst _v1$6 = /*@__PURE__*/ new Vector3();\nconst _v2$3 = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\tthis.isSphere = true;\n\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box$3.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.center.copy( point );\n\n\t\t\tthis.radius = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_v1$6.subVectors( point, this.center );\n\n\t\tconst lengthSq = _v1$6.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t// calculate the minimal sphere\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\n\t\t\tconst delta = ( length - this.radius ) * 0.5;\n\n\t\t\tthis.center.addScaledVector( _v1$6, delta / length );\n\n\t\t\tthis.radius += delta;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunion( sphere ) {\n\n\t\tif ( sphere.isEmpty() ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.copy( sphere );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.center.equals( sphere.center ) === true ) {\n\n\t\t\t this.radius = Math.max( this.radius, sphere.radius );\n\n\t\t} else {\n\n\t\t\t_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$a = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal$1 = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, t );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector$a ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t\treturn _vector$a.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector$a.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector$a.dot( this.direction );\n\t\tconst d2 = _vector$a.dot( _vector$a ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if t1 is behind the ray - if so, return null\n\t\tif ( t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector$a ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal$1.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal$1 );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal$1 );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix4 {\n\n\tconstructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tMatrix4.prototype.isMatrix4 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tcopyPosition( m ) {\n\n\t\tconst te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix3( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractRotation( m ) {\n\n\t\t// this method does not support reflection matrices\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();\n\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();\n\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();\n\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromEuler( euler ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromQuaternion( q ) {\n\n\t\treturn this.compose( _zero, q, _one );\n\n\t}\n\n\tlookAt( eye, target, up ) {\n\n\t\tconst te = this.elements;\n\n\t\t_z.subVectors( eye, target );\n\n\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t// eye and target are in the same position\n\n\t\t\t_z.z = 1;\n\n\t\t}\n\n\t\t_z.normalize();\n\t\t_x.crossVectors( up, _z );\n\n\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t// up and z are parallel\n\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t_z.x += 0.0001;\n\n\t\t\t} else {\n\n\t\t\t\t_z.z += 0.0001;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t}\n\n\t\t_x.normalize();\n\t\t_y.crossVectors( _z, _x );\n\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t}\n\n\ttranspose() {\n\n\t\tconst te = this.elements;\n\t\tlet tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tsetPosition( x, y, z ) {\n\n\t\tconst te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tinvert() {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\tscale( v ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxScaleOnAxis() {\n\n\t\tconst te = this.elements;\n\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t}\n\n\tmakeTranslation( x, y, z ) {\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x.x,\n\t\t\t\t0, 1, 0, x.y,\n\t\t\t\t0, 0, 1, x.z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationX( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationY( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationZ( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationAxis( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tconst c = Math.cos( angle );\n\t\tconst s = Math.sin( angle );\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeShear( xy, xz, yx, yz, zx, zy ) {\n\n\t\tthis.set(\n\n\t\t\t1, yx, zx, 0,\n\t\t\txy, 1, zy, 0,\n\t\t\txz, yz, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tdecompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tlet sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\tconst sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\tconst sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = this.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\tposition.x = te[ 12 ];\n\t\tposition.y = te[ 13 ];\n\t\tposition.z = te[ 14 ];\n\n\t\t// scale the rotation part\n\t\t_m1$4.copy( this );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1$4.elements[ 0 ] *= invSX;\n\t\t_m1$4.elements[ 1 ] *= invSX;\n\t\t_m1$4.elements[ 2 ] *= invSX;\n\n\t\t_m1$4.elements[ 4 ] *= invSY;\n\t\t_m1$4.elements[ 5 ] *= invSY;\n\t\t_m1$4.elements[ 6 ] *= invSY;\n\n\t\t_m1$4.elements[ 8 ] *= invSZ;\n\t\t_m1$4.elements[ 9 ] *= invSZ;\n\t\t_m1$4.elements[ 10 ] *= invSZ;\n\n\t\tquaternion.setFromRotationMatrix( _m1$4 );\n\n\t\tscale.x = sx;\n\t\tscale.y = sy;\n\t\tscale.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tmakePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = 2 * near / ( right - left );\n\t\tconst y = 2 * near / ( top - bottom );\n\n\t\tconst a = ( right + left ) / ( right - left );\n\t\tconst b = ( top + bottom ) / ( top - bottom );\n\n\t\tlet c, d;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tc = - ( far + near ) / ( far - near );\n\t\t\td = ( - 2 * far * near ) / ( far - near );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tc = - far / ( far - near );\n\t\t\td = ( - far * near ) / ( far - near );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a; \tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b; \tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c; \tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t}\n\n\tmakeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst w = 1.0 / ( right - left );\n\t\tconst h = 1.0 / ( top - bottom );\n\t\tconst p = 1.0 / ( far - near );\n\n\t\tconst x = ( right + left ) * w;\n\t\tconst y = ( top + bottom ) * h;\n\n\t\tlet z, zInv;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tz = ( far + near ) * p;\n\t\t\tzInv = - 2 * p;\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tz = near * p;\n\t\t\tzInv = - 1 * p;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\t\tte[ 8 ] = 0; \t\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0; \t\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0; \t\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0; \t\tte[ 6 ] = 0;\t\tte[ 10 ] = zInv;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0; \t\tte[ 7 ] = 0;\t\tte[ 11 ] = 0;\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n}\n\nconst _v1$5 = /*@__PURE__*/ new Vector3();\nconst _m1$4 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nconst _matrix$2 = /*@__PURE__*/ new Matrix4();\nconst _quaternion$3 = /*@__PURE__*/ new Quaternion();\n\nclass Euler {\n\n\tconstructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {\n\n\t\tthis.isEuler = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget order() {\n\n\t\treturn this._order;\n\n\t}\n\n\tset order( value ) {\n\n\t\tthis._order = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, order = this._order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t}\n\n\tcopy( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m, order = this._order, update = true ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements;\n\t\tconst m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tconst m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tconst m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromQuaternion( q, order, update ) {\n\n\t\t_matrix$2.makeRotationFromQuaternion( q );\n\n\t\treturn this.setFromRotationMatrix( _matrix$2, order, update );\n\n\t}\n\n\tsetFromVector3( v, order = this._order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order );\n\n\t}\n\n\treorder( newOrder ) {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t_quaternion$3.setFromEuler( this );\n\n\t\treturn this.setFromQuaternion( _quaternion$3, newOrder );\n\n\t}\n\n\tequals( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t}\n\n\tfromArray( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._order;\n\n\t}\n\n}\n\nEuler.DEFAULT_ORDER = 'XYZ';\n\nclass Layers {\n\n\tconstructor() {\n\n\t\tthis.mask = 1 | 0;\n\n\t}\n\n\tset( channel ) {\n\n\t\tthis.mask = ( 1 << channel | 0 ) >>> 0;\n\n\t}\n\n\tenable( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t}\n\n\tenableAll() {\n\n\t\tthis.mask = 0xffffffff | 0;\n\n\t}\n\n\ttoggle( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t}\n\n\tdisable( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t}\n\n\tdisableAll() {\n\n\t\tthis.mask = 0;\n\n\t}\n\n\ttest( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n\tisEnabled( channel ) {\n\n\t\treturn ( this.mask & ( 1 << channel | 0 ) ) !== 0;\n\n\t}\n\n}\n\nlet _object3DId = 0;\n\nconst _v1$4 = /*@__PURE__*/ new Vector3();\nconst _q1 = /*@__PURE__*/ new Quaternion();\nconst _m1$3 = /*@__PURE__*/ new Matrix4();\nconst _target = /*@__PURE__*/ new Vector3();\n\nconst _position$3 = /*@__PURE__*/ new Vector3();\nconst _scale$2 = /*@__PURE__*/ new Vector3();\nconst _quaternion$2 = /*@__PURE__*/ new Quaternion();\n\nconst _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );\nconst _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nconst _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );\n\nconst _addedEvent = { type: 'added' };\nconst _removedEvent = { type: 'removed' };\n\nconst _childaddedEvent = { type: 'childadded', child: null };\nconst _childremovedEvent = { type: 'childremoved', child: null };\n\nclass Object3D extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isObject3D = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DEFAULT_UP.clone();\n\n\t\tconst position = new Vector3();\n\t\tconst rotation = new Euler();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation._onChange( onRotationChange );\n\t\tquaternion._onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n\n\t\tthis.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.animations = [];\n\n\t\tthis.userData = {};\n\n\t}\n\n\tonBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\tonAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tonAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tthis.matrix.premultiply( matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tthis.quaternion.premultiply( q );\n\n\t\treturn this;\n\n\t}\n\n\tsetRotationFromAxisAngle( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t}\n\n\tsetRotationFromEuler( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t}\n\n\tsetRotationFromMatrix( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t}\n\n\tsetRotationFromQuaternion( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t}\n\n\trotateOnAxis( axis, angle ) {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.multiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateOnWorldAxis( axis, angle ) {\n\n\t\t// rotate object on axis in world space\n\t\t// axis is assumed to be normalized\n\t\t// method assumes no rotated parent\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.premultiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\treturn this.rotateOnAxis( _xAxis, angle );\n\n\t}\n\n\trotateY( angle ) {\n\n\t\treturn this.rotateOnAxis( _yAxis, angle );\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\treturn this.rotateOnAxis( _zAxis, angle );\n\n\t}\n\n\ttranslateOnAxis( axis, distance ) {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_v1$4.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\tthis.position.add( _v1$4.multiplyScalar( distance ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslateX( distance ) {\n\n\t\treturn this.translateOnAxis( _xAxis, distance );\n\n\t}\n\n\ttranslateY( distance ) {\n\n\t\treturn this.translateOnAxis( _yAxis, distance );\n\n\t}\n\n\ttranslateZ( distance ) {\n\n\t\treturn this.translateOnAxis( _zAxis, distance );\n\n\t}\n\n\tlocalToWorld( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t}\n\n\tworldToLocal( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( _m1$3.copy( this.matrixWorld ).invert() );\n\n\t}\n\n\tlookAt( x, y, z ) {\n\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\t_target.copy( x );\n\n\t\t} else {\n\n\t\t\t_target.set( x, y, z );\n\n\t\t}\n\n\t\tconst parent = this.parent;\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_position$3.setFromMatrixPosition( this.matrixWorld );\n\n\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t_m1$3.lookAt( _position$3, _target, this.up );\n\n\t\t} else {\n\n\t\t\t_m1$3.lookAt( _target, _position$3, this.up );\n\n\t\t}\n\n\t\tthis.quaternion.setFromRotationMatrix( _m1$3 );\n\n\t\tif ( parent ) {\n\n\t\t\t_m1$3.extractRotation( parent.matrixWorld );\n\t\t\t_q1.setFromRotationMatrix( _m1$3 );\n\t\t\tthis.quaternion.premultiply( _q1.invert() );\n\n\t\t}\n\n\t}\n\n\tadd( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object can\\'t be added as a child of itself.', object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object && object.isObject3D ) {\n\n\t\t\tobject.removeFromParent();\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t\t_childaddedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t\t_childaddedEvent.child = null;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t\t_childremovedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childremovedEvent );\n\t\t\t_childremovedEvent.child = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremoveFromParent() {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tparent.remove( this );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclear() {\n\n\t\treturn this.remove( ... this.children );\n\n\t}\n\n\tattach( object ) {\n\n\t\t// adds object as a child of this, while maintaining the object's world transform\n\n\t\t// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_m1$3.copy( this.matrixWorld ).invert();\n\n\t\tif ( object.parent !== null ) {\n\n\t\t\tobject.parent.updateWorldMatrix( true, false );\n\n\t\t\t_m1$3.multiply( object.parent.matrixWorld );\n\n\t\t}\n\n\t\tobject.applyMatrix4( _m1$3 );\n\n\t\tobject.removeFromParent();\n\t\tobject.parent = this;\n\t\tthis.children.push( object );\n\n\t\tobject.updateWorldMatrix( false, true );\n\n\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t_childaddedEvent.child = object;\n\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t_childaddedEvent.child = null;\n\n\t\treturn this;\n\n\t}\n\n\tgetObjectById( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t}\n\n\tgetObjectByName( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t}\n\n\tgetObjectByProperty( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( let i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = this.children[ i ];\n\t\t\tconst object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tgetObjectsByProperty( name, value, result = [] ) {\n\n\t\tif ( this[ name ] === value ) result.push( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].getObjectsByProperty( name, value, result );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgetWorldPosition( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t}\n\n\tgetWorldQuaternion( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, target, _scale$2 );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldScale( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, _quaternion$2, target );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t}\n\n\traycast( /* raycaster, intersects */ ) {}\n\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseVisible( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseAncestors( callback ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst child = children[ i ];\n\n\t\t\tif ( child.matrixWorldAutoUpdate === true || force === true ) {\n\n\t\t\t\tchild.updateMatrixWorld( force );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {\n\n\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t}\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.parent === null ) {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t}\n\n\t\t// update children\n\n\t\tif ( updateChildren === true ) {\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tif ( child.matrixWorldAutoUpdate === true ) {\n\n\t\t\t\t\tchild.updateWorldMatrix( false, true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\t// meta is a string when called from JSON.stringify\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tconst output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tshapes: {},\n\t\t\t\tskeletons: {},\n\t\t\t\tanimations: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tconst object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\tif ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;\n\n\t\tobject.layers = this.layers.mask;\n\t\tobject.matrix = this.matrix.toArray();\n\t\tobject.up = this.up.toArray();\n\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t// object specific properties\n\n\t\tif ( this.isInstancedMesh ) {\n\n\t\t\tobject.type = 'InstancedMesh';\n\t\t\tobject.count = this.count;\n\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\tif ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();\n\n\t\t}\n\n\t\tif ( this.isBatchedMesh ) {\n\n\t\t\tobject.type = 'BatchedMesh';\n\t\t\tobject.perObjectFrustumCulled = this.perObjectFrustumCulled;\n\t\t\tobject.sortObjects = this.sortObjects;\n\n\t\t\tobject.drawRanges = this._drawRanges;\n\t\t\tobject.reservedRanges = this._reservedRanges;\n\n\t\t\tobject.visibility = this._visibility;\n\t\t\tobject.active = this._active;\n\t\t\tobject.bounds = this._bounds.map( bound => ( {\n\t\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\t\tboxMin: bound.box.min.toArray(),\n\t\t\t\tboxMax: bound.box.max.toArray(),\n\n\t\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\t\tsphereRadius: bound.sphere.radius,\n\t\t\t\tsphereCenter: bound.sphere.center.toArray()\n\t\t\t} ) );\n\n\t\t\tobject.maxGeometryCount = this._maxGeometryCount;\n\t\t\tobject.maxVertexCount = this._maxVertexCount;\n\t\t\tobject.maxIndexCount = this._maxIndexCount;\n\n\t\t\tobject.geometryInitialized = this._geometryInitialized;\n\t\t\tobject.geometryCount = this._geometryCount;\n\n\t\t\tobject.matricesTexture = this._matricesTexture.toJSON( meta );\n\n\t\t\tif ( this._colorsTexture !== null ) object.colorsTexture = this._colorsTexture.toJSON( meta );\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tobject.boundingSphere = {\n\t\t\t\t\tcenter: object.boundingSphere.center.toArray(),\n\t\t\t\t\tradius: object.boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tobject.boundingBox = {\n\t\t\t\t\tmin: object.boundingBox.min.toArray(),\n\t\t\t\t\tmax: object.boundingBox.max.toArray()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction serialize( library, element ) {\n\n\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t}\n\n\t\t\treturn element.uuid;\n\n\t\t}\n\n\t\tif ( this.isScene ) {\n\n\t\t\tif ( this.background ) {\n\n\t\t\t\tif ( this.background.isColor ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON();\n\n\t\t\t\t} else if ( this.background.isTexture ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON( meta ).uuid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {\n\n\t\t\t\tobject.environment = this.environment.toJSON( meta ).uuid;\n\n\t\t\t}\n\n\t\t} else if ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.isSkinnedMesh ) {\n\n\t\t\tobject.bindMode = this.bindMode;\n\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\tif ( this.skeleton !== undefined ) {\n\n\t\t\t\tserialize( meta.skeletons, this.skeleton );\n\n\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\tconst uuids = [];\n\n\t\t\t\tfor ( let i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = uuids;\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.animations.length > 0 ) {\n\n\t\t\tobject.animations = [];\n\n\t\t\tfor ( let i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\t\tconst animation = this.animations[ i ];\n\n\t\t\t\tobject.animations.push( serialize( meta.animations, animation ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst geometries = extractFromCache( meta.geometries );\n\t\t\tconst materials = extractFromCache( meta.materials );\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst shapes = extractFromCache( meta.shapes );\n\t\t\tconst skeletons = extractFromCache( meta.skeletons );\n\t\t\tconst animations = extractFromCache( meta.animations );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\t\t\tif ( skeletons.length > 0 ) output.skeletons = skeletons;\n\t\t\tif ( animations.length > 0 ) output.animations = animations;\n\t\t\tif ( nodes.length > 0 ) output.nodes = nodes;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t}\n\n\tclone( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t}\n\n\tcopy( source, recursive = true ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.rotation.order = source.rotation.order;\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\tthis.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.layers.mask = source.layers.mask;\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.animations = source.animations.slice();\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tconst child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nObject3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nObject3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\nObject3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n\nconst _v0$1 = /*@__PURE__*/ new Vector3();\nconst _v1$3 = /*@__PURE__*/ new Vector3();\nconst _v2$2 = /*@__PURE__*/ new Vector3();\nconst _v3$2 = /*@__PURE__*/ new Vector3();\n\nconst _vab = /*@__PURE__*/ new Vector3();\nconst _vac = /*@__PURE__*/ new Vector3();\nconst _vbc = /*@__PURE__*/ new Vector3();\nconst _vap = /*@__PURE__*/ new Vector3();\nconst _vbp = /*@__PURE__*/ new Vector3();\nconst _vcp = /*@__PURE__*/ new Vector3();\n\nclass Triangle {\n\n\tconstructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t}\n\n\tstatic getNormal( a, b, c, target ) {\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0$1.subVectors( a, b );\n\t\ttarget.cross( _v0$1 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t}\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tstatic getBarycoord( point, a, b, c, target ) {\n\n\t\t_v0$1.subVectors( c, a );\n\t\t_v1$3.subVectors( b, a );\n\t\t_v2$2.subVectors( point, a );\n\n\t\tconst dot00 = _v0$1.dot( _v0$1 );\n\t\tconst dot01 = _v0$1.dot( _v1$3 );\n\t\tconst dot02 = _v0$1.dot( _v2$2 );\n\t\tconst dot11 = _v1$3.dot( _v1$3 );\n\t\tconst dot12 = _v1$3.dot( _v2$2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\ttarget.set( 0, 0, 0 );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t}\n\n\tstatic containsPoint( point, a, b, c ) {\n\n\t\t// if the triangle is degenerate then we can't contain a point\n\t\tif ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );\n\n\t}\n\n\tstatic getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {\n\n\t\tif ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {\n\n\t\t\ttarget.x = 0;\n\t\t\ttarget.y = 0;\n\t\t\tif ( 'z' in target ) target.z = 0;\n\t\t\tif ( 'w' in target ) target.w = 0;\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( v1, _v3$2.x );\n\t\ttarget.addScaledVector( v2, _v3$2.y );\n\t\ttarget.addScaledVector( v3, _v3$2.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic isFrontFacing( a, b, c, direction ) {\n\n\t\t_v0$1.subVectors( c, b );\n\t\t_v1$3.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n\tset( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPointsAndIndices( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAttributeAndIndices( attribute, i0, i1, i2 ) {\n\n\t\tthis.a.fromBufferAttribute( attribute, i0 );\n\t\tthis.b.fromBufferAttribute( attribute, i1 );\n\t\tthis.c.fromBufferAttribute( attribute, i2 );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t}\n\n\tgetArea() {\n\n\t\t_v0$1.subVectors( this.c, this.b );\n\t\t_v1$3.subVectors( this.a, this.b );\n\n\t\treturn _v0$1.cross( _v1$3 ).length() * 0.5;\n\n\t}\n\n\tgetMidpoint( target ) {\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t}\n\n\tgetNormal( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t}\n\n\tgetPlane( target ) {\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t}\n\n\tgetBarycoord( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t}\n\n\tgetInterpolation( point, v1, v2, v3, target ) {\n\n\t\treturn Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t}\n\n\tisFrontFacing( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t}\n\n\tclosestPointToPoint( p, target ) {\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t}\n\n\tequals( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n}\n\nconst _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb( p, q, t ) {\n\n\tif ( t < 0 ) t += 1;\n\tif ( t > 1 ) t -= 1;\n\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\tif ( t < 1 / 2 ) return q;\n\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\treturn p;\n\n}\n\nclass Color {\n\n\tconstructor( r, g, b ) {\n\n\t\tthis.isColor = true;\n\n\t\tthis.r = 1;\n\t\tthis.g = 1;\n\t\tthis.b = 1;\n\n\t\treturn this.set( r, g, b );\n\n\t}\n\n\tset( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\n\t\t\tconst value = r;\n\n\t\t\tif ( value && value.isColor ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.setRGB( r, g, b );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetHex( hex, colorSpace = SRGBColorSpace ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\th = euclideanModulo( h, 1 );\n\t\ts = clamp( s, 0, 1 );\n\t\tl = clamp( l, 0, 1 );\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tconst p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tconst q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetStyle( style, colorSpace = SRGBColorSpace ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tlet m;\n\n\t\tif ( m = /^(\\w+)\\(([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tlet color;\n\t\t\tconst name = m[ 1 ];\n\t\t\tconst components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setHSL(\n\t\t\t\t\t\t\tparseFloat( color[ 1 ] ) / 360,\n\t\t\t\t\t\t\tparseFloat( color[ 2 ] ) / 100,\n\t\t\t\t\t\t\tparseFloat( color[ 3 ] ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color model ' + style );\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f\\d]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tconst hex = m[ 1 ];\n\t\t\tconst size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\treturn this.setRGB(\n\t\t\t\t\tparseInt( hex.charAt( 0 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 1 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 2 ), 16 ) / 15,\n\t\t\t\t\tcolorSpace\n\t\t\t\t);\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\treturn this.setHex( parseInt( hex, 16 ), colorSpace );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Invalid hex color ' + style );\n\n\t\t\t}\n\n\t\t} else if ( style && style.length > 0 ) {\n\n\t\t\treturn this.setColorName( style, colorSpace );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetColorName( style, colorSpace = SRGBColorSpace ) {\n\n\t\t// color keywords\n\t\tconst hex = _colorKeywords[ style.toLowerCase() ];\n\n\t\tif ( hex !== undefined ) {\n\n\t\t\t// red\n\t\t\tthis.setHex( hex, colorSpace );\n\n\t\t} else {\n\n\t\t\t// unknown color\n\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t}\n\n\tcopy( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t}\n\n\tcopySRGBToLinear( color ) {\n\n\t\tthis.r = SRGBToLinear( color.r );\n\t\tthis.g = SRGBToLinear( color.g );\n\t\tthis.b = SRGBToLinear( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tcopyLinearToSRGB( color ) {\n\n\t\tthis.r = LinearToSRGB( color.r );\n\t\tthis.g = LinearToSRGB( color.g );\n\t\tthis.b = LinearToSRGB( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tconvertSRGBToLinear() {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t}\n\n\tconvertLinearToSRGB() {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t}\n\n\tgetHex( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\treturn Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );\n\n\t}\n\n\tgetHexString( colorSpace = SRGBColorSpace ) {\n\n\t\treturn ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );\n\n\t}\n\n\tgetHSL( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tconst max = Math.max( r, g, b );\n\t\tconst min = Math.min( r, g, b );\n\n\t\tlet hue, saturation;\n\t\tconst lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tconst delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t}\n\n\tgetRGB( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\ttarget.r = _color.r;\n\t\ttarget.g = _color.g;\n\t\ttarget.b = _color.b;\n\n\t\treturn target;\n\n\t}\n\n\tgetStyle( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tif ( colorSpace !== SRGBColorSpace ) {\n\n\t\t\t// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\n\t\t\treturn `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;\n\n\t\t}\n\n\t\treturn `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;\n\n\t}\n\n\toffsetHSL( h, s, l ) {\n\n\t\tthis.getHSL( _hslA );\n\n\t\treturn this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );\n\n\t}\n\n\tadd( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t}\n\n\taddColors( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t}\n\n\tlerp( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpColors( color1, color2, alpha ) {\n\n\t\tthis.r = color1.r + ( color2.r - color1.r ) * alpha;\n\t\tthis.g = color1.g + ( color2.g - color1.g ) * alpha;\n\t\tthis.b = color1.b + ( color2.b - color1.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpHSL( color, alpha ) {\n\n\t\tthis.getHSL( _hslA );\n\t\tcolor.getHSL( _hslB );\n\n\t\tconst h = lerp( _hslA.h, _hslB.h, alpha );\n\t\tconst s = lerp( _hslA.s, _hslB.s, alpha );\n\t\tconst l = lerp( _hslA.l, _hslB.l, alpha );\n\n\t\tthis.setHSL( h, s, l );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\tthis.r = v.x;\n\t\tthis.g = v.y;\n\t\tthis.b = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst r = this.r, g = this.g, b = this.b;\n\t\tconst e = m.elements;\n\n\t\tthis.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;\n\t\tthis.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;\n\t\tthis.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.r = attribute.getX( index );\n\t\tthis.g = attribute.getY( index );\n\t\tthis.b = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.getHex();\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.r;\n\t\tyield this.g;\n\t\tyield this.b;\n\n\t}\n\n}\n\nconst _color = /*@__PURE__*/ new Color();\n\nColor.NAMES = _colorKeywords;\n\nlet _materialId = 0;\n\nclass Material extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isMaterial = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _materialId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.vertexColors = false;\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\t\tthis.alphaHash = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\t\tthis.blendColor = new Color( 0, 0, 0 );\n\t\tthis.blendAlpha = 0;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.stencilWriteMask = 0xff;\n\t\tthis.stencilFunc = AlwaysStencilFunc;\n\t\tthis.stencilRef = 0;\n\t\tthis.stencilFuncMask = 0xff;\n\t\tthis.stencilFail = KeepStencilOp;\n\t\tthis.stencilZFail = KeepStencilOp;\n\t\tthis.stencilZPass = KeepStencilOp;\n\t\tthis.stencilWrite = false;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.shadowSide = null;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.dithering = false;\n\n\t\tthis.alphaToCoverage = false;\n\t\tthis.premultipliedAlpha = false;\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.visible = true;\n\n\t\tthis.toneMapped = true;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\n\t\tthis._alphaTest = 0;\n\n\t}\n\n\tget alphaTest() {\n\n\t\treturn this._alphaTest;\n\n\t}\n\n\tset alphaTest( value ) {\n\n\t\tif ( this._alphaTest > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._alphaTest = value;\n\n\t}\n\n\tonBuild( /* shaderobject, renderer */ ) {}\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}\n\n\tonBeforeCompile( /* shaderobject, renderer */ ) {}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.onBeforeCompile.toString();\n\n\t}\n\n\tsetValues( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( const key in values ) {\n\n\t\t\tconst newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRootObject ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.sheen !== undefined ) data.sheen = this.sheen;\n\t\tif ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();\n\t\tif ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;\n\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\tif ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\tif ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;\n\t\tif ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\tif ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;\n\t\tif ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\tif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {\n\n\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {\n\n\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {\n\n\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;\n\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.dispersion !== undefined ) data.dispersion = this.dispersion;\n\n\t\tif ( this.iridescence !== undefined ) data.iridescence = this.iridescence;\n\t\tif ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;\n\t\tif ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n\n\t\tif ( this.iridescenceMap && this.iridescenceMap.isTexture ) {\n\n\t\t\tdata.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {\n\n\t\t\tdata.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;\n\t\tif ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;\n\n\t\tif ( this.anisotropyMap && this.anisotropyMap.isTexture ) {\n\n\t\t\tdata.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\n\t\tif ( this.lightMap && this.lightMap.isTexture ) {\n\n\t\t\tdata.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\n\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n\t\t}\n\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\tif ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;\n\t\tif ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\n\t\t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\n\t\t}\n\n\t\tif ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();\n\t\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n\t\tif ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;\n\t\tif ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;\n\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.transmission !== undefined ) data.transmission = this.transmission;\n\t\tif ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;\n\t\tif ( this.thickness !== undefined ) data.thickness = this.thickness;\n\t\tif ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;\n\t\tif ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;\n\t\tif ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors === true ) data.vertexColors = true;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = true;\n\n\t\tif ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;\n\t\tif ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;\n\t\tif ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;\n\t\tif ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;\n\t\tif ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;\n\t\tif ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;\n\t\tif ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();\n\t\tif ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;\n\n\t\tif ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;\n\t\tif ( this.depthTest === false ) data.depthTest = this.depthTest;\n\t\tif ( this.depthWrite === false ) data.depthWrite = this.depthWrite;\n\t\tif ( this.colorWrite === false ) data.colorWrite = this.colorWrite;\n\n\t\tif ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;\n\t\tif ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;\n\t\tif ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;\n\t\tif ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;\n\t\tif ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;\n\t\tif ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;\n\t\tif ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;\n\t\tif ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;\n\n\t\t// rotation (SpriteMaterial)\n\t\tif ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\tif ( this.polygonOffset === true ) data.polygonOffset = true;\n\t\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tif ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.alphaHash === true ) data.alphaHash = true;\n\t\tif ( this.alphaToCoverage === true ) data.alphaToCoverage = true;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;\n\t\tif ( this.forceSinglePass === true ) data.forceSinglePass = true;\n\n\t\tif ( this.wireframe === true ) data.wireframe = true;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\tif ( this.flatShading === true ) data.flatShading = true;\n\n\t\tif ( this.visible === false ) data.visible = false;\n\n\t\tif ( this.toneMapped === false ) data.toneMapped = false;\n\n\t\tif ( this.fog === false ) data.fog = false;\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\tthis.blendColor.copy( source.blendColor );\n\t\tthis.blendAlpha = source.blendAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\tthis.stencilFunc = source.stencilFunc;\n\t\tthis.stencilRef = source.stencilRef;\n\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\tthis.stencilFail = source.stencilFail;\n\t\tthis.stencilZFail = source.stencilZFail;\n\t\tthis.stencilZPass = source.stencilZPass;\n\t\tthis.stencilWrite = source.stencilWrite;\n\n\t\tconst srcPlanes = source.clippingPlanes;\n\t\tlet dstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tconst n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\t\tthis.clipIntersection = source.clipIntersection;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tthis.shadowSide = source.shadowSide;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.dithering = source.dithering;\n\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaHash = source.alphaHash;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\tthis.forceSinglePass = source.forceSinglePass;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.toneMapped = source.toneMapped;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\nclass MeshBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshBasicMaterial = true;\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst _tables = /*@__PURE__*/ _generateTables();\n\nfunction _generateTables() {\n\n\t// float32 to float16 helpers\n\n\tconst buffer = new ArrayBuffer( 4 );\n\tconst floatView = new Float32Array( buffer );\n\tconst uint32View = new Uint32Array( buffer );\n\n\tconst baseTable = new Uint32Array( 512 );\n\tconst shiftTable = new Uint32Array( 512 );\n\n\tfor ( let i = 0; i < 256; ++ i ) {\n\n\t\tconst e = i - 127;\n\n\t\t// very small number (0, -0)\n\n\t\tif ( e < - 27 ) {\n\n\t\t\tbaseTable[ i ] = 0x0000;\n\t\t\tbaseTable[ i | 0x100 ] = 0x8000;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// small number (denorm)\n\n\t\t} else if ( e < - 14 ) {\n\n\t\t\tbaseTable[ i ] = 0x0400 >> ( - e - 14 );\n\t\t\tbaseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;\n\t\t\tshiftTable[ i ] = - e - 1;\n\t\t\tshiftTable[ i | 0x100 ] = - e - 1;\n\n\t\t\t// normal number\n\n\t\t} else if ( e <= 15 ) {\n\n\t\t\tbaseTable[ i ] = ( e + 15 ) << 10;\n\t\t\tbaseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t\t// large number (Infinity, -Infinity)\n\n\t\t} else if ( e < 128 ) {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// stay (NaN, Infinity, -Infinity)\n\n\t\t} else {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t}\n\n\t}\n\n\t// float16 to float32 helpers\n\n\tconst mantissaTable = new Uint32Array( 2048 );\n\tconst exponentTable = new Uint32Array( 64 );\n\tconst offsetTable = new Uint32Array( 64 );\n\n\tfor ( let i = 1; i < 1024; ++ i ) {\n\n\t\tlet m = i << 13; // zero pad mantissa bits\n\t\tlet e = 0; // zero exponent\n\n\t\t// normalized\n\t\twhile ( ( m & 0x00800000 ) === 0 ) {\n\n\t\t\tm <<= 1;\n\t\t\te -= 0x00800000; // decrement exponent\n\n\t\t}\n\n\t\tm &= ~ 0x00800000; // clear leading 1 bit\n\t\te += 0x38800000; // adjust bias\n\n\t\tmantissaTable[ i ] = m | e;\n\n\t}\n\n\tfor ( let i = 1024; i < 2048; ++ i ) {\n\n\t\tmantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );\n\n\t}\n\n\tfor ( let i = 1; i < 31; ++ i ) {\n\n\t\texponentTable[ i ] = i << 23;\n\n\t}\n\n\texponentTable[ 31 ] = 0x47800000;\n\texponentTable[ 32 ] = 0x80000000;\n\n\tfor ( let i = 33; i < 63; ++ i ) {\n\n\t\texponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );\n\n\t}\n\n\texponentTable[ 63 ] = 0xc7800000;\n\n\tfor ( let i = 1; i < 64; ++ i ) {\n\n\t\tif ( i !== 32 ) {\n\n\t\t\toffsetTable[ i ] = 1024;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tfloatView: floatView,\n\t\tuint32View: uint32View,\n\t\tbaseTable: baseTable,\n\t\tshiftTable: shiftTable,\n\t\tmantissaTable: mantissaTable,\n\t\texponentTable: exponentTable,\n\t\toffsetTable: offsetTable\n\t};\n\n}\n\n// float32 to float16\n\nfunction toHalfFloat( val ) {\n\n\tif ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );\n\n\tval = clamp( val, - 65504, 65504 );\n\n\t_tables.floatView[ 0 ] = val;\n\tconst f = _tables.uint32View[ 0 ];\n\tconst e = ( f >> 23 ) & 0x1ff;\n\treturn _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );\n\n}\n\n// float16 to float32\n\nfunction fromHalfFloat( val ) {\n\n\tconst m = val >> 10;\n\t_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];\n\treturn _tables.floatView[ 0 ];\n\n}\n\nconst DataUtils = {\n\ttoHalfFloat: toHalfFloat,\n\tfromHalfFloat: fromHalfFloat,\n};\n\nconst _vector$9 = /*@__PURE__*/ new Vector3();\nconst _vector2$1 = /*@__PURE__*/ new Vector2();\n\nclass BufferAttribute {\n\n\tconstructor( array, itemSize, normalized = false ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.isBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis._updateRange = { offset: 0, count: - 1 };\n\t\tthis.updateRanges = [];\n\t\tthis.gpuType = FloatType;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tget updateRange() {\n\n\t\twarnOnce( 'THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.' ); // @deprecated, r159\n\t\treturn this._updateRange;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.usage = source.usage;\n\t\tthis.gpuType = source.gpuType;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( let i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyArray( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tif ( this.itemSize === 2 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector2$1.fromBufferAttribute( this, i );\n\t\t\t\t_vector2$1.applyMatrix3( m );\n\n\t\t\t\tthis.setXY( i, _vector2$1.x, _vector2$1.y );\n\n\t\t\t}\n\n\t\t} else if ( this.itemSize === 3 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector$9.fromBufferAttribute( this, i );\n\t\t\t\t_vector$9.applyMatrix3( m );\n\n\t\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\t// Matching BufferAttribute constructor, do not normalize the array.\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.itemSize + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.array[ index * this.itemSize + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.array[ index * this.itemSize ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.array[ index * this.itemSize + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.array[ index * this.itemSize + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.array[ index * this.itemSize + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.from( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( this.usage !== StaticDrawUsage ) data.usage = this.usage;\n\n\t\treturn data;\n\n\t}\n\n}\n\n//\n\nclass Int8BufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)) {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8BufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)) {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8ClampedBufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)) {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8ClampedArray( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int16BufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)) {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int32BufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)) {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float16BufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)) {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t\tthis.isFloat16BufferAttribute = true;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = fromHalfFloat( this.array[ index * this.itemSize ] );\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = toHalfFloat( x );\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\t\tthis.array[ index + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nclass Float32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nlet _id$2 = 0;\n\nconst _m1$2 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box$2 = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector$8 = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBufferGeometry = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id$2 ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\t\tthis.morphTargetsRelative = false;\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\tthis.userData = {};\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t_m1$2.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1$2.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1$2.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1$2.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1$2.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1$2.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tconst position = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box$2.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.min, _box$2.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.max, _box$2.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$2.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$2.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box$2.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box$2.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box$2.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box$2.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box$2.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box$2.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector$8.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector$8.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector$8.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector$8.fromBufferAttribute( normals, i );\n\n\t\t\t_vector$8.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t}\n\n\t}\n\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nconst _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();\nconst _ray$3 = /*@__PURE__*/ new Ray();\nconst _sphere$6 = /*@__PURE__*/ new Sphere();\nconst _sphereHitAt = /*@__PURE__*/ new Vector3();\n\nconst _vA$1 = /*@__PURE__*/ new Vector3();\nconst _vB$1 = /*@__PURE__*/ new Vector3();\nconst _vC$1 = /*@__PURE__*/ new Vector3();\n\nconst _tempA = /*@__PURE__*/ new Vector3();\nconst _morphA = /*@__PURE__*/ new Vector3();\n\nconst _uvA$1 = /*@__PURE__*/ new Vector2();\nconst _uvB$1 = /*@__PURE__*/ new Vector2();\nconst _uvC$1 = /*@__PURE__*/ new Vector2();\n\nconst _normalA = /*@__PURE__*/ new Vector3();\nconst _normalB = /*@__PURE__*/ new Vector3();\nconst _normalC = /*@__PURE__*/ new Vector3();\n\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\n\nclass Mesh extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isMesh = true;\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.attributes.position;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\n\t\ttarget.fromBufferAttribute( position, index );\n\n\t\tconst morphInfluences = this.morphTargetInfluences;\n\n\t\tif ( morphPosition && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morphAttribute, index );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( target ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttarget.add( _morphA );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$6.copy( geometry.boundingSphere );\n\t\t_sphere$6.applyMatrix4( matrixWorld );\n\n\t\t// check distance from ray origin to bounding sphere\n\n\t\t_ray$3.copy( raycaster.ray ).recast( raycaster.near );\n\n\t\tif ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {\n\n\t\t\tif ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;\n\n\t\t\tif ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;\n\n\t\t}\n\n\t\t// convert ray to local space of mesh\n\n\t\t_inverseMatrix$3.copy( matrixWorld ).invert();\n\t\t_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$3 );\n\n\t}\n\n\t_computeIntersections( raycaster, intersects, rayLocalSpace ) {\n\n\t\tlet intersection;\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.attributes.position;\n\t\tconst uv = geometry.attributes.uv;\n\t\tconst uv1 = geometry.attributes.uv1;\n\t\tconst normal = geometry.attributes.normal;\n\t\tconst groups = geometry.groups;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = i;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {\n\n\tobject.getVertexPosition( a, _vA$1 );\n\tobject.getVertexPosition( b, _vB$1 );\n\tobject.getVertexPosition( c, _vC$1 );\n\n\tconst intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA$1.fromBufferAttribute( uv, a );\n\t\t\t_uvB$1.fromBufferAttribute( uv, b );\n\t\t\t_uvC$1.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA$1.fromBufferAttribute( uv1, a );\n\t\t\t_uvB$1.fromBufferAttribute( uv1, b );\n\t\t\t_uvC$1.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3() );\n\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );\n\n\t\tintersection.face = face;\n\n\t}\n\n\treturn intersection;\n\n}\n\nclass BoxGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n\t}\n\n}\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms( src ) {\n\n\tconst dst = {};\n\n\tfor ( const u in src ) {\n\n\t\tdst[ u ] = {};\n\n\t\tfor ( const p in src[ u ] ) {\n\n\t\t\tconst property = src[ u ][ p ];\n\n\t\t\tif ( property && ( property.isColor ||\n\t\t\t\tproperty.isMatrix3 || property.isMatrix4 ||\n\t\t\t\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\n\t\t\t\tproperty.isTexture || property.isQuaternion ) ) {\n\n\t\t\t\tif ( property.isRenderTargetTexture ) {\n\n\t\t\t\t\tconsole.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );\n\t\t\t\t\tdst[ u ][ p ] = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdst[ u ][ p ] = property.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( Array.isArray( property ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.slice();\n\n\t\t\t} else {\n\n\t\t\t\tdst[ u ][ p ] = property;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction mergeUniforms( uniforms ) {\n\n\tconst merged = {};\n\n\tfor ( let u = 0; u < uniforms.length; u ++ ) {\n\n\t\tconst tmp = cloneUniforms( uniforms[ u ] );\n\n\t\tfor ( const p in tmp ) {\n\n\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t}\n\n\t}\n\n\treturn merged;\n\n}\n\nfunction cloneUniformsGroups( src ) {\n\n\tconst dst = [];\n\n\tfor ( let u = 0; u < src.length; u ++ ) {\n\n\t\tdst.push( src[ u ].clone() );\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction getUnlitUniformColorSpace( renderer ) {\n\n\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\tif ( currentRenderTarget === null ) {\n\n\t\t// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398\n\t\treturn renderer.outputColorSpace;\n\n\t}\n\n\t// https://github.com/mrdoob/three.js/issues/27868\n\tif ( currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\treturn currentRenderTarget.texture.colorSpace;\n\n\t}\n\n\treturn ColorManagement.workingColorSpace;\n\n}\n\n// Legacy\n\nconst UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\nclass ShaderMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShaderMaterial = true;\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\t\tthis.uniformsGroups = [];\n\n\t\tthis.vertexShader = default_vertex;\n\t\tthis.fragmentShader = default_fragment;\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.forceSinglePass = true;\n\n\t\tthis.extensions = {\n\t\t\tclipCullDistance: false, // set to use vertex shader clipping\n\t\t\tmultiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv1': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\t\tthis.uniformsNeedUpdate = false;\n\n\t\tthis.glslVersion = null;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = cloneUniforms( source.uniforms );\n\t\tthis.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );\n\n\t\tthis.defines = Object.assign( {}, source.defines );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.extensions = Object.assign( {}, source.extensions );\n\n\t\tthis.glslVersion = source.glslVersion;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.glslVersion = this.glslVersion;\n\t\tdata.uniforms = {};\n\n\t\tfor ( const name in this.uniforms ) {\n\n\t\t\tconst uniform = this.uniforms[ name ];\n\t\t\tconst value = uniform.value;\n\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 't',\n\t\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isColor ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'c',\n\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v2',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\n\t\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\tdata.lights = this.lights;\n\t\tdata.clipping = this.clipping;\n\n\t\tconst extensions = {};\n\n\t\tfor ( const key in this.extensions ) {\n\n\t\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t\t}\n\n\t\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass Camera extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isCamera = true;\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t\tthis.projectionMatrix = new Matrix4();\n\t\tthis.projectionMatrixInverse = new Matrix4();\n\n\t\tthis.coordinateSystem = WebGLCoordinateSystem;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\tthis.coordinateSystem = source.coordinateSystem;\n\n\t\treturn this;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\treturn super.getWorldDirection( target ).negate();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tsuper.updateWorldMatrix( updateParents, updateChildren );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _v3$1 = /*@__PURE__*/ new Vector3();\nconst _minTarget = /*@__PURE__*/ new Vector2();\nconst _maxTarget = /*@__PURE__*/ new Vector2();\n\n\nclass PerspectiveCamera extends Camera {\n\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isPerspectiveCamera = true;\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\tgetEffectiveFOV() {\n\n\t\treturn RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.\n\t * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.\n\t */\n\tgetViewBounds( distance, minTarget, maxTarget ) {\n\n\t\t_v3$1.set( - 1, - 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tminTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );\n\n\t\t_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tmaxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );\n\n\t}\n\n\t/**\n\t * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.\n\t * Copies the result into the target Vector2, where x is width and y is height.\n\t */\n\tgetViewSize( distance, target ) {\n\n\t\tthis.getViewBounds( distance, _minTarget, _maxTarget );\n\n\t\treturn target.subVectors( _maxTarget, _minTarget );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst fov = - 90; // negative fov is not an error\nconst aspect = 1;\n\nclass CubeCamera extends Object3D {\n\n\tconstructor( near, far, renderTarget ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.coordinateSystem = null;\n\t\tthis.activeMipmapLevel = 0;\n\n\t\tconst cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.layers = this.layers;\n\t\tthis.add( cameraPX );\n\n\t\tconst cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.layers = this.layers;\n\t\tthis.add( cameraNX );\n\n\t\tconst cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.layers = this.layers;\n\t\tthis.add( cameraPY );\n\n\t\tconst cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.layers = this.layers;\n\t\tthis.add( cameraNY );\n\n\t\tconst cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.layers = this.layers;\n\t\tthis.add( cameraPZ );\n\n\t\tconst cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.layers = this.layers;\n\t\tthis.add( cameraNZ );\n\n\t}\n\n\tupdateCoordinateSystem() {\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tconst cameras = this.children.concat();\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;\n\n\t\tfor ( const camera of cameras ) this.remove( camera );\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, 1, 0 );\n\t\t\tcameraPX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, 1, 0 );\n\t\t\tcameraNX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, - 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tfor ( const camera of cameras ) {\n\n\t\t\tthis.add( camera );\n\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\tupdate( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tconst { renderTarget, activeMipmapLevel } = this;\n\n\t\tif ( this.coordinateSystem !== renderer.coordinateSystem ) {\n\n\t\t\tthis.coordinateSystem = renderer.coordinateSystem;\n\n\t\t\tthis.updateCoordinateSystem();\n\n\t\t}\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentActiveCubeFace = renderer.getActiveCubeFace();\n\t\tconst currentActiveMipmapLevel = renderer.getActiveMipmapLevel();\n\n\t\tconst currentXrEnabled = renderer.xr.enabled;\n\n\t\trenderer.xr.enabled = false;\n\n\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPX );\n\n\t\trenderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNX );\n\n\t\trenderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPY );\n\n\t\trenderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNY );\n\n\t\trenderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPZ );\n\n\t\t// mipmaps are generated during the last call of render()\n\t\t// at this point, all sides of the cube render target are defined\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNZ );\n\n\t\trenderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\n\t\trenderTarget.texture.needsPMREMUpdate = true;\n\n\t}\n\n}\n\nclass CubeTexture extends Texture {\n\n\tconstructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tsuper( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tget images() {\n\n\t\treturn this.image;\n\n\t}\n\n\tset images( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n}\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, size, options );\n\n\t\tthis.isWebGLCubeRenderTarget = true;\n\n\t\tconst image = { width: size, height: size, depth: 1 };\n\t\tconst images = [ image, image, image, image, image, image ];\n\n\t\tthis.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n\t\t// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture ) {\n\n\t\tthis.texture.type = texture.type;\n\t\tthis.texture.colorSpace = texture.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\tthis.texture.minFilter = texture.minFilter;\n\t\tthis.texture.magFilter = texture.magFilter;\n\n\t\tconst shader = {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t};\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\tname: 'CubemapFromEquirect',\n\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tside: BackSide,\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tmaterial.uniforms.tEquirect.value = texture;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst currentMinFilter = texture.minFilter;\n\n\t\t// Avoid blurred poles\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\t\tcamera.update( renderer, mesh );\n\n\t\ttexture.minFilter = currentMinFilter;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n\tclear( renderer, color, depth, stencil ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( this, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n}\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\tthis.isPlane = true;\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = normal;\n\t\tthis.constant = constant;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\treturn target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( line.start ).addScaledVector( direction, t );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _sphere$5 = /*@__PURE__*/ new Sphere();\nconst _vector$7 = /*@__PURE__*/ new Vector3();\n\nclass Frustum {\n\n\tconstructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {\n\n\t\tthis.planes = [ p0, p1, p2, p3, p4, p5 ];\n\n\t}\n\n\tset( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tconst planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( frustum ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst planes = this.planes;\n\t\tconst me = m.elements;\n\t\tconst me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tconst me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tconst me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tconst me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tintersectsObject( object ) {\n\n\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\n\t\t\t_sphere$5.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t} else {\n\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$5.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t}\n\n\t\treturn this.intersectsSphere( _sphere$5 );\n\n\t}\n\n\tintersectsSprite( sprite ) {\n\n\t\t_sphere$5.center.set( 0, 0, 0 );\n\t\t_sphere$5.radius = 0.7071067811865476;\n\t\t_sphere$5.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere$5 );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst planes = this.planes;\n\t\tconst center = sphere.center;\n\t\tconst negRadius = - sphere.radius;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = planes[ i ];\n\n\t\t\t// corner at max distance\n\n\t\t\t_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\tif ( plane.distanceToPoint( _vector$7 ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nfunction WebGLAnimation() {\n\n\tlet context = null;\n\tlet isAnimating = false;\n\tlet animationLoop = null;\n\tlet requestId = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tanimationLoop( time, frame );\n\n\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t}\n\n\treturn {\n\n\t\tstart: function () {\n\n\t\t\tif ( isAnimating === true ) return;\n\t\t\tif ( animationLoop === null ) return;\n\n\t\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t\t\tisAnimating = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tcontext.cancelAnimationFrame( requestId );\n\n\t\t\tisAnimating = false;\n\n\t\t},\n\n\t\tsetAnimationLoop: function ( callback ) {\n\n\t\t\tanimationLoop = callback;\n\n\t\t},\n\n\t\tsetContext: function ( value ) {\n\n\t\t\tcontext = value;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLAttributes( gl ) {\n\n\tconst buffers = new WeakMap();\n\n\tfunction createBuffer( attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage;\n\t\tconst size = array.byteLength;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\t\tgl.bufferData( bufferType, array, usage );\n\n\t\tattribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: buffer,\n\t\t\ttype: type,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version,\n\t\t\tsize: size\n\t\t};\n\n\t}\n\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst updateRange = attribute._updateRange; // @deprecated, r159\n\t\tconst updateRanges = attribute.updateRanges;\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\tif ( updateRange.count === - 1 && updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t}\n\n\t\tif ( updateRanges.length !== 0 ) {\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\n\t\t\t\tgl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, range.start, range.count );\n\n\t\t\t}\n\n\t\t\tattribute.clearUpdateRanges();\n\n\t\t}\n\n\t\t// @deprecated, r159\n\t\tif ( updateRange.count !== - 1 ) {\n\n\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\tarray, updateRange.offset, updateRange.count );\n\n\t\t\tupdateRange.count = - 1; // reset range\n\n\t\t}\n\n\t\tattribute.onUploadCallback();\n\n\t}\n\n\t//\n\n\tfunction get( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn buffers.get( attribute );\n\n\t}\n\n\tfunction remove( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data ) {\n\n\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\tbuffers.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction update( attribute, bufferType ) {\n\n\t\tif ( attribute.isGLBufferAttribute ) {\n\n\t\t\tconst cached = buffers.get( attribute );\n\n\t\t\tif ( ! cached || cached.version < attribute.version ) {\n\n\t\t\t\tbuffers.set( attribute, {\n\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\tversion: attribute.version\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\n\n\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\tif ( data.size !== attribute.array.byteLength ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLAttributes: The size of the buffer attribute\\'s array buffer does not match the original size. Resizing buffer attributes is not supported.' );\n\n\t\t\t}\n\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\tdata.version = attribute.version;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update\n\n\t};\n\n}\n\nclass PlaneGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tconst width_half = width / 2;\n\t\tconst height_half = height / 2;\n\n\t\tconst gridX = Math.floor( widthSegments );\n\t\tconst gridY = Math.floor( heightSegments );\n\n\t\tconst gridX1 = gridX + 1;\n\t\tconst gridY1 = gridY + 1;\n\n\t\tconst segment_width = width / gridX;\n\t\tconst segment_height = height / gridY;\n\n\t\t//\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tconst x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );\n\n\t}\n\n}\n\nvar alphahash_fragment = \"#ifdef USE_ALPHAHASH\\n\\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\\n#endif\";\n\nvar alphahash_pars_fragment = \"#ifdef USE_ALPHAHASH\\n\\tconst float ALPHA_HASH_SCALE = 0.05;\\n\\tfloat hash2D( vec2 value ) {\\n\\t\\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\\n\\t}\\n\\tfloat hash3D( vec3 value ) {\\n\\t\\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\\n\\t}\\n\\tfloat getAlphaHashThreshold( vec3 position ) {\\n\\t\\tfloat maxDeriv = max(\\n\\t\\t\\tlength( dFdx( position.xyz ) ),\\n\\t\\t\\tlength( dFdy( position.xyz ) )\\n\\t\\t);\\n\\t\\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\\n\\t\\tvec2 pixScales = vec2(\\n\\t\\t\\texp2( floor( log2( pixScale ) ) ),\\n\\t\\t\\texp2( ceil( log2( pixScale ) ) )\\n\\t\\t);\\n\\t\\tvec2 alpha = vec2(\\n\\t\\t\\thash3D( floor( pixScales.x * position.xyz ) ),\\n\\t\\t\\thash3D( floor( pixScales.y * position.xyz ) )\\n\\t\\t);\\n\\t\\tfloat lerpFactor = fract( log2( pixScale ) );\\n\\t\\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\\n\\t\\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\\n\\t\\tvec3 cases = vec3(\\n\\t\\t\\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\\n\\t\\t\\t( x - 0.5 * a ) / ( 1.0 - a ),\\n\\t\\t\\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\\n\\t\\t);\\n\\t\\tfloat threshold = ( x < ( 1.0 - a ) )\\n\\t\\t\\t? ( ( x < a ) ? cases.x : cases.y )\\n\\t\\t\\t: cases.z;\\n\\t\\treturn clamp( threshold , 1.0e-6, 1.0 );\\n\\t}\\n#endif\";\n\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\\n#endif\";\n\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar alphatest_fragment = \"#ifdef USE_ALPHATEST\\n\\t#ifdef ALPHA_TO_COVERAGE\\n\\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\\n\\tif ( diffuseColor.a == 0.0 ) discard;\\n\\t#else\\n\\tif ( diffuseColor.a < alphaTest ) discard;\\n\\t#endif\\n#endif\";\n\nvar alphatest_pars_fragment = \"#ifdef USE_ALPHATEST\\n\\tuniform float alphaTest;\\n#endif\";\n\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_CLEARCOAT ) \\n\\t\\tclearcoatSpecularIndirect *= ambientOcclusion;\\n\\t#endif\\n\\t#if defined( USE_SHEEN ) \\n\\t\\tsheenSpecularIndirect *= ambientOcclusion;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\\n\\t#endif\\n#endif\";\n\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\nvar batching_pars_vertex = \"#ifdef USE_BATCHING\\n\\tattribute float batchId;\\n\\tuniform highp sampler2D batchingTexture;\\n\\tmat4 getBatchingMatrix( const in float i ) {\\n\\t\\tint size = textureSize( batchingTexture, 0 ).x;\\n\\t\\tint j = int( i ) * 4;\\n\\t\\tint x = j % size;\\n\\t\\tint y = j / size;\\n\\t\\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\\n\\t\\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\\n\\t\\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\\n\\t\\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\\n\\t\\treturn mat4( v1, v2, v3, v4 );\\n\\t}\\n#endif\\n#ifdef USE_BATCHING_COLOR\\n\\tuniform sampler2D batchingColorTexture;\\n\\tvec3 getBatchingColor( const in float i ) {\\n\\t\\tint size = textureSize( batchingColorTexture, 0 ).x;\\n\\t\\tint j = int( i );\\n\\t\\tint x = j % size;\\n\\t\\tint y = j / size;\\n\\t\\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\\n\\t}\\n#endif\";\n\nvar batching_vertex = \"#ifdef USE_BATCHING\\n\\tmat4 batchingMatrix = getBatchingMatrix( batchId );\\n#endif\";\n\nvar begin_vertex = \"vec3 transformed = vec3( position );\\n#ifdef USE_ALPHAHASH\\n\\tvPosition = vec3( position );\\n#endif\";\n\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\n\nvar bsdfs = \"float G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n} // validated\";\n\nvar iridescence_fragment = \"#ifdef USE_IRIDESCENCE\\n\\tconst mat3 XYZ_TO_REC709 = mat3(\\n\\t\\t 3.2404542, -0.9692660,  0.0556434,\\n\\t\\t-1.5371385,  1.8760108, -0.2040259,\\n\\t\\t-0.4985314,  0.0415560,  1.0572252\\n\\t);\\n\\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\\n\\t\\tvec3 sqrtF0 = sqrt( fresnel0 );\\n\\t\\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\\n\\t}\\n\\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\\n\\t\\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\\n\\t}\\n\\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\\n\\t\\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\\n\\t}\\n\\tvec3 evalSensitivity( float OPD, vec3 shift ) {\\n\\t\\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\\n\\t\\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\\n\\t\\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\\n\\t\\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\\n\\t\\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\\n\\t\\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\\n\\t\\txyz /= 1.0685e-7;\\n\\t\\tvec3 rgb = XYZ_TO_REC709 * xyz;\\n\\t\\treturn rgb;\\n\\t}\\n\\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\\n\\t\\tvec3 I;\\n\\t\\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\\n\\t\\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\\n\\t\\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\\n\\t\\tif ( cosTheta2Sq < 0.0 ) {\\n\\t\\t\\treturn vec3( 1.0 );\\n\\t\\t}\\n\\t\\tfloat cosTheta2 = sqrt( cosTheta2Sq );\\n\\t\\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\\n\\t\\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\\n\\t\\tfloat T121 = 1.0 - R12;\\n\\t\\tfloat phi12 = 0.0;\\n\\t\\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\\n\\t\\tfloat phi21 = PI - phi12;\\n\\t\\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\\t\\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\\n\\t\\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\\n\\t\\tvec3 phi23 = vec3( 0.0 );\\n\\t\\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\\n\\t\\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\\n\\t\\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\\n\\t\\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\\n\\t\\tvec3 phi = vec3( phi21 ) + phi23;\\n\\t\\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\\n\\t\\tvec3 r123 = sqrt( R123 );\\n\\t\\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\\n\\t\\tvec3 C0 = R12 + Rs;\\n\\t\\tI = C0;\\n\\t\\tvec3 Cm = Rs - T121;\\n\\t\\tfor ( int m = 1; m <= 2; ++ m ) {\\n\\t\\t\\tCm *= r123;\\n\\t\\t\\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\\n\\t\\t\\tI += Cm * Sm;\\n\\t\\t}\\n\\t\\treturn max( I, vec3( 0.0 ) );\\n\\t}\\n#endif\";\n\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vBumpMapUv );\\n\\t\\tvec2 dSTdy = dFdy( vBumpMapUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\\n\\t\\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#ifdef ALPHA_TO_COVERAGE\\n\\t\\tfloat distanceToPlane, distanceGradient;\\n\\t\\tfloat clipOpacity = 1.0;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\\n\\t\\t\\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\\n\\t\\t\\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\\n\\t\\t\\tif ( clipOpacity == 0.0 ) discard;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\t\\tfloat unionClipOpacity = 1.0;\\n\\t\\t\\t#pragma unroll_loop_start\\n\\t\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\t\\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\\n\\t\\t\\t\\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\\n\\t\\t\\t\\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\\n\\t\\t\\t}\\n\\t\\t\\t#pragma unroll_loop_end\\n\\t\\t\\tclipOpacity *= 1.0 - unionClipOpacity;\\n\\t\\t#endif\\n\\t\\tdiffuseColor.a *= clipOpacity;\\n\\t\\tif ( diffuseColor.a == 0.0 ) discard;\\n\\t#else\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\t\\tbool clipped = true;\\n\\t\\t\\t#pragma unroll_loop_start\\n\\t\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t\\t}\\n\\t\\t\\t#pragma unroll_loop_end\\n\\t\\t\\tif ( clipped ) discard;\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\";\n\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\";\n\nvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\nvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\\n#ifdef USE_BATCHING_COLOR\\n\\tvec3 batchingColor = getBatchingColor( batchId );\\n\\tvColor.xyz *= batchingColor.xyz;\\n#endif\";\n\nvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nvec3 pow2( const in vec3 x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract( sin( sn ) * c );\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\n#ifdef USE_ALPHAHASH\\n\\tvarying vec3 vPosition;\\n#endif\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat luminance( const in vec3 rgb ) {\\n\\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\\n\\treturn dot( weights, rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n}\\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n} // validated\";\n\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\\n\\t\\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\\n\\t\\tuv.x *= CUBEUV_TEXEL_WIDTH;\\n\\t\\tuv.y *= CUBEUV_TEXEL_HEIGHT;\\n\\t\\t#ifdef texture2DGradEXT\\n\\t\\t\\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn texture2D( envMap, uv ).rgb;\\n\\t\\t#endif\\n\\t}\\n\\t#define cubeUV_r0 1.0\\n\\t#define cubeUV_m0 - 2.0\\n\\t#define cubeUV_r1 0.8\\n\\t#define cubeUV_m1 - 1.0\\n\\t#define cubeUV_r4 0.4\\n\\t#define cubeUV_m4 2.0\\n\\t#define cubeUV_r5 0.305\\n\\t#define cubeUV_m5 3.0\\n\\t#define cubeUV_r6 0.21\\n\\t#define cubeUV_m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= cubeUV_r1 ) {\\n\\t\\t\\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\\n\\t\\t} else if ( roughness >= cubeUV_r4 ) {\\n\\t\\t\\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\\n\\t\\t} else if ( roughness >= cubeUV_r5 ) {\\n\\t\\t\\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\\n\\t\\t} else if ( roughness >= cubeUV_r6 ) {\\n\\t\\t\\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\";\n\nvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = objectTangent;\\n#endif\\n#ifdef USE_BATCHING\\n\\tmat3 bm = mat3( batchingMatrix );\\n\\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\\n\\ttransformedNormal = bm * transformedNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\ttransformedTangent = bm * transformedTangent;\\n\\t#endif\\n#endif\\n#ifdef USE_INSTANCING\\n\\tmat3 im = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\\n\\ttransformedNormal = im * transformedNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\ttransformedTangent = im * transformedTangent;\\n\\t#endif\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\n\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\\n#endif\";\n\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\nvar colorspace_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\nvar colorspace_pars_fragment = \"\\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\\n\\tvec3( 0.8224621, 0.177538, 0.0 ),\\n\\tvec3( 0.0331941, 0.9668058, 0.0 ),\\n\\tvec3( 0.0170827, 0.0723974, 0.9105199 )\\n);\\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\\n\\tvec3( 1.2249401, - 0.2249404, 0.0 ),\\n\\tvec3( - 0.0420569, 1.0420571, 0.0 ),\\n\\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\\n);\\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\\n\\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\\n}\\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\\n\\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\\n}\\nvec4 LinearTransferOETF( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 sRGBTransferOETF( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn sRGBTransferOETF( value );\\n}\";\n\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\nvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform mat3 envMapRotation;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\";\n\nvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tvFogDepth = - mvPosition.z;\\n#endif\";\n\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float vFogDepth;\\n#endif\";\n\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float vFogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\nvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn vec3( texture2D( gradientMap, coord ).r );\\n\\t#else\\n\\t\\tvec2 fw = fwidth( coord ) * 0.5;\\n\\t\\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\\n\\t#endif\\n}\";\n\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\nvar lights_lambert_fragment = \"LambertMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_lambert_pars_fragment = \"varying vec3 vViewPosition;\\nstruct LambertMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Lambert\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Lambert\";\n\nvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\n#if defined( USE_LIGHT_PROBES )\\n\\tuniform vec3 lightProbe[ 9 ];\\n#endif\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\\n\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\treturn irradiance;\\n}\\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif ( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n}\\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\\n\\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\\n\\t\\tlight.color = directionalLight.color;\\n\\t\\tlight.direction = directionalLight.direction;\\n\\t\\tlight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\\n\\t\\tvec3 lVector = pointLight.position - geometryPosition;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tlight.color = pointLight.color;\\n\\t\\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\\n\\t\\tvec3 lVector = spotLight.position - geometryPosition;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat angleCos = dot( light.direction, spotLight.direction );\\n\\t\\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\tif ( spotAttenuation > 0.0 ) {\\n\\t\\t\\tfloat lightDistance = length( lVector );\\n\\t\\t\\tlight.color = spotLight.color * spotAttenuation;\\n\\t\\t\\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t\\t} else {\\n\\t\\t\\tlight.color = vec3( 0.0 );\\n\\t\\t\\tlight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\\n\\t\\tfloat dotNL = dot( normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\nvar envmap_physical_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tvec3 getIBLIrradiance( const in vec3 normal ) {\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\\n\\t\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\tvec3 reflectVec = reflect( - viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\\n\\t\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\\n\\t\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\t\\tvec3 bentNormal = cross( bitangent, viewDir );\\n\\t\\t\\t\\tbentNormal = normalize( cross( bentNormal, bitangent ) );\\n\\t\\t\\t\\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\\n\\t\\t\\t\\treturn getIBLRadiance( viewDir, bentNormal, roughness );\\n\\t\\t\\t#else\\n\\t\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\n\nvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\";\n\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\";\n\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\\nmaterial.roughness = min( material.roughness, 1.0 );\\n#ifdef IOR\\n\\tmaterial.ior = ior;\\n\\t#ifdef USE_SPECULAR\\n\\t\\tfloat specularIntensityFactor = specularIntensity;\\n\\t\\tvec3 specularColorFactor = specularColor;\\n\\t\\t#ifdef USE_SPECULAR_COLORMAP\\n\\t\\t\\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\\n\\t\\t#endif\\n\\t\\t#ifdef USE_SPECULAR_INTENSITYMAP\\n\\t\\t\\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\\n\\t\\t#endif\\n\\t\\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\\n\\t#else\\n\\t\\tfloat specularIntensityFactor = 1.0;\\n\\t\\tvec3 specularColorFactor = vec3( 1.0 );\\n\\t\\tmaterial.specularF90 = 1.0;\\n\\t#endif\\n\\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.specularF90 = 1.0;\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\tmaterial.clearcoatF0 = vec3( 0.04 );\\n\\tmaterial.clearcoatF90 = 1.0;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_DISPERSION\\n\\tmaterial.dispersion = dispersion;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tmaterial.iridescence = iridescence;\\n\\tmaterial.iridescenceIOR = iridescenceIOR;\\n\\t#ifdef USE_IRIDESCENCEMAP\\n\\t\\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\t\\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\\n\\t#else\\n\\t\\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\\n\\t#endif\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheenColor;\\n\\t#ifdef USE_SHEEN_COLORMAP\\n\\t\\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\\n\\t#endif\\n\\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\\n\\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\t\\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\\n\\t#endif\\n#endif\\n#ifdef USE_ANISOTROPY\\n\\t#ifdef USE_ANISOTROPYMAP\\n\\t\\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\\n\\t\\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\\n\\t\\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\\n\\t#else\\n\\t\\tvec2 anisotropyV = anisotropyVector;\\n\\t#endif\\n\\tmaterial.anisotropy = length( anisotropyV );\\n\\tif( material.anisotropy == 0.0 ) {\\n\\t\\tanisotropyV = vec2( 1.0, 0.0 );\\n\\t} else {\\n\\t\\tanisotropyV /= material.anisotropy;\\n\\t\\tmaterial.anisotropy = saturate( material.anisotropy );\\n\\t}\\n\\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\\n\\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\\n\\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\\n#endif\";\n\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat roughness;\\n\\tvec3 specularColor;\\n\\tfloat specularF90;\\n\\tfloat dispersion;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat clearcoat;\\n\\t\\tfloat clearcoatRoughness;\\n\\t\\tvec3 clearcoatF0;\\n\\t\\tfloat clearcoatF90;\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tfloat iridescence;\\n\\t\\tfloat iridescenceIOR;\\n\\t\\tfloat iridescenceThickness;\\n\\t\\tvec3 iridescenceFresnel;\\n\\t\\tvec3 iridescenceF0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tvec3 sheenColor;\\n\\t\\tfloat sheenRoughness;\\n\\t#endif\\n\\t#ifdef IOR\\n\\t\\tfloat ior;\\n\\t#endif\\n\\t#ifdef USE_TRANSMISSION\\n\\t\\tfloat transmission;\\n\\t\\tfloat transmissionAlpha;\\n\\t\\tfloat thickness;\\n\\t\\tfloat attenuationDistance;\\n\\t\\tvec3 attenuationColor;\\n\\t#endif\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tfloat anisotropy;\\n\\t\\tfloat alphaT;\\n\\t\\tvec3 anisotropyT;\\n\\t\\tvec3 anisotropyB;\\n\\t#endif\\n};\\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\\nvec3 sheenSpecularDirect = vec3( 0.0 );\\nvec3 sheenSpecularIndirect = vec3(0.0 );\\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\\n    float x2 = x * x;\\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\\n}\\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\n#ifdef USE_ANISOTROPY\\n\\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\\n\\t\\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\\n\\t\\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\\n\\t\\tfloat v = 0.5 / ( gv + gl );\\n\\t\\treturn saturate(v);\\n\\t}\\n\\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\\n\\t\\tfloat a2 = alphaT * alphaB;\\n\\t\\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\\n\\t\\thighp float v2 = dot( v, v );\\n\\t\\tfloat w2 = a2 / v2;\\n\\t\\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\\n\\t}\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\\n\\t\\tvec3 f0 = material.clearcoatF0;\\n\\t\\tfloat f90 = material.clearcoatF90;\\n\\t\\tfloat roughness = material.clearcoatRoughness;\\n\\t\\tfloat alpha = pow2( roughness );\\n\\t\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\t\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\t\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\t\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\t\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\t\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\t\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\t\\tfloat D = D_GGX( alpha, dotNH );\\n\\t\\treturn F * ( V * D );\\n\\t}\\n#endif\\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\\n\\tvec3 f0 = material.specularColor;\\n\\tfloat f90 = material.specularF90;\\n\\tfloat roughness = material.roughness;\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tF = mix( F, material.iridescenceFresnel, material.iridescence );\\n\\t#endif\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tfloat dotTL = dot( material.anisotropyT, lightDir );\\n\\t\\tfloat dotTV = dot( material.anisotropyT, viewDir );\\n\\t\\tfloat dotTH = dot( material.anisotropyT, halfDir );\\n\\t\\tfloat dotBL = dot( material.anisotropyB, lightDir );\\n\\t\\tfloat dotBV = dot( material.anisotropyB, viewDir );\\n\\t\\tfloat dotBH = dot( material.anisotropyB, halfDir );\\n\\t\\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\\n\\t\\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\\n\\t#else\\n\\t\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\t\\tfloat D = D_GGX( alpha, dotNH );\\n\\t#endif\\n\\treturn F * ( V * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie( float roughness, float dotNH ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tfloat invAlpha = 1.0 / alpha;\\n\\tfloat cos2h = dotNH * dotNH;\\n\\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\\n\\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\\n}\\nfloat V_Neubelt( float dotNV, float dotNL ) {\\n\\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\\n}\\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat D = D_Charlie( sheenRoughness, dotNH );\\n\\tfloat V = V_Neubelt( dotNV, dotNL );\\n\\treturn sheenColor * ( D * V );\\n}\\n#endif\\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat r2 = roughness * roughness;\\n\\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\\n\\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\\n\\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\\n\\treturn saturate( DG * RECIPROCAL_PI );\\n}\\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\\n\\treturn fab;\\n}\\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\treturn specularColor * fab.x + specularF90 * fab.y;\\n}\\n#ifdef USE_IRIDESCENCE\\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#else\\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#endif\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\\n\\t#else\\n\\t\\tvec3 Fr = specularColor;\\n\\t#endif\\n\\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\\n\\tfloat Ess = fab.x + fab.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometryNormal;\\n\\t\\tvec3 viewDir = geometryViewDir;\\n\\t\\tvec3 position = geometryPosition;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.roughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = dotNLcc * directLight.color;\\n\\t\\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\\n\\t#endif\\n\\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\\n\\t#endif\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\\n\\t#else\\n\\t\\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\\n\\t#endif\\n\\tvec3 totalScattering = singleScattering + multiScattering;\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\\n\\treflectedLight.indirectSpecular += radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\nvar lights_fragment_begin = \"\\nvec3 geometryPosition = - vViewPosition;\\nvec3 geometryNormal = normal;\\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\nvec3 geometryClearcoatNormal = vec3( 0.0 );\\n#ifdef USE_CLEARCOAT\\n\\tgeometryClearcoatNormal = clearcoatNormal;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\\n\\tif ( material.iridescenceThickness == 0.0 ) {\\n\\t\\tmaterial.iridescence = 0.0;\\n\\t} else {\\n\\t\\tmaterial.iridescence = saturate( material.iridescence );\\n\\t}\\n\\tif ( material.iridescence > 0.0 ) {\\n\\t\\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\\n\\t\\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\\n\\t}\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointLightInfo( pointLight, geometryPosition, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tvec4 spotColor;\\n\\tvec3 spotLightCoord;\\n\\tbool inSpotLightMap;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\\n\\t\\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\\n\\t\\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\\n\\t\\t#else\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\\t\\t#endif\\n\\t\\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\\n\\t\\t\\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\\n\\t\\t\\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\\n\\t\\t\\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\\n\\t\\t\\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\\n\\t\\t#endif\\n\\t\\t#undef SPOT_LIGHT_MAP_INDEX\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalLightInfo( directionalLight, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#if defined( USE_LIGHT_PROBES )\\n\\t\\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\n\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getIBLIrradiance( geometryNormal );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\\n\\t#else\\n\\t\\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\\n\\t#endif\\n#endif\";\n\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n#endif\";\n\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF )\\n\\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tvFragDepth = 1.0 + gl_Position.w;\\n\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n#endif\";\n\nvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\\n\\t#ifdef DECODE_VIDEO_TEXTURE\\n\\t\\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\\n\\t\\n\\t#endif\\n\\tdiffuseColor *= sampledDiffuseColor;\\n#endif\";\n\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\nvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\t#if defined( USE_POINTS_UV )\\n\\t\\tvec2 uv = vUv;\\n\\t#else\\n\\t\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\t#endif\\n#endif\\n#ifdef USE_MAP\\n\\tdiffuseColor *= texture2D( map, uv );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\n\nvar map_particle_pars_fragment = \"#if defined( USE_POINTS_UV )\\n\\tvarying vec2 vUv;\\n#else\\n\\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\t\\tuniform mat3 uvTransform;\\n\\t#endif\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\nvar morphinstance_vertex = \"#ifdef USE_INSTANCING_MORPH\\n\\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\\n\\t}\\n#endif\";\n\nvar morphcolor_vertex = \"#if defined( USE_MORPHCOLORS )\\n\\tvColor *= morphTargetBaseInfluence;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t#if defined( USE_COLOR_ALPHA )\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\\n\\t\\t#elif defined( USE_COLOR )\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\\n\\t}\\n#endif\";\n\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_INSTANCING_MORPH\\n\\t\\tuniform float morphTargetBaseInfluence;\\n\\t\\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\\t#endif\\n\\tuniform sampler2DArray morphTargetsTexture;\\n\\tuniform ivec2 morphTargetsTextureSize;\\n\\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\\n\\t\\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\\n\\t\\tint y = texelIndex / morphTargetsTextureSize.x;\\n\\t\\tint x = texelIndex - y * morphTargetsTextureSize.x;\\n\\t\\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\\n\\t\\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\\n\\t}\\n#endif\";\n\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\\n\\t}\\n#endif\";\n\nvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = dFdx( vViewPosition );\\n\\tvec3 fdy = dFdy( vViewPosition );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal *= faceDirection;\\n\\t#endif\\n#endif\\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\\n\\t#ifdef USE_TANGENT\\n\\t\\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\\n\\t#else\\n\\t\\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\\n\\t\\t#if defined( USE_NORMALMAP )\\n\\t\\t\\tvNormalMapUv\\n\\t\\t#elif defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tvClearcoatNormalMapUv\\n\\t\\t#else\\n\\t\\t\\tvUv\\n\\t\\t#endif\\n\\t\\t);\\n\\t#endif\\n\\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\\n\\t\\ttbn[0] *= faceDirection;\\n\\t\\ttbn[1] *= faceDirection;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\t#ifdef USE_TANGENT\\n\\t\\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\\n\\t#else\\n\\t\\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\\n\\t#endif\\n\\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\\n\\t\\ttbn2[0] *= faceDirection;\\n\\t\\ttbn2[1] *= faceDirection;\\n\\t#endif\\n#endif\\nvec3 nonPerturbedNormal = normal;\";\n\nvar normal_fragment_maps = \"#ifdef USE_NORMALMAP_OBJECTSPACE\\n\\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\tnormal = normalize( tbn * mapN );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\n\nvar normal_pars_fragment = \"#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\";\n\nvar normal_pars_vertex = \"#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\";\n\nvar normal_vertex = \"#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\";\n\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef USE_NORMALMAP_OBJECTSPACE\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\\n\\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( uv.st );\\n\\t\\tvec2 st1 = dFdy( uv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\\n\\t\\treturn mat3( T * scale, B * scale, N );\\n\\t}\\n#endif\";\n\nvar clearcoat_normal_fragment_begin = \"#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal = nonPerturbedNormal;\\n#endif\";\n\nvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\\n#endif\";\n\nvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\";\n\nvar iridescence_pars_fragment = \"#ifdef USE_IRIDESCENCEMAP\\n\\tuniform sampler2D iridescenceMap;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tuniform sampler2D iridescenceThicknessMap;\\n#endif\";\n\nvar opaque_fragment = \"#ifdef OPAQUE\\ndiffuseColor.a = 1.0;\\n#endif\\n#ifdef USE_TRANSMISSION\\ndiffuseColor.a *= material.transmissionAlpha;\\n#endif\\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\";\n\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec2 packDepthToRG( in highp float v ) {\\n\\treturn packDepthToRGBA( v ).yx;\\n}\\nfloat unpackRGToDepth( const in highp vec2 v ) {\\n\\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\\n\\treturn depth * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * depth - far );\\n}\";\n\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\nvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_BATCHING\\n\\tmvPosition = batchingMatrix * mvPosition;\\n#endif\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\n\nvar dithering_fragment = \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\nvar dithering_pars_fragment = \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\nvar shadowmap_pars_fragment = \"#if NUM_SPOT_LIGHT_COORDS > 0\\n\\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#if NUM_SPOT_LIGHT_MAPS > 0\\n\\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\\n\\t\\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\t\\n\\t\\tfloat lightToPositionLength = length( lightToPosition );\\n\\t\\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\\n\\t\\t\\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\t\\tdp += shadowBias;\\n\\t\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\t\\tshadow = (\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n#endif\";\n\nvar shadowmap_pars_vertex = \"#if NUM_SPOT_LIGHT_COORDS > 0\\n\\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\\n\\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\";\n\nvar shadowmap_vertex = \"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\\n\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\tvec4 shadowWorldPosition;\\n#endif\\n#if defined( USE_SHADOWMAP )\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if NUM_SPOT_LIGHT_COORDS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition;\\n\\t\\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\t\\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\\n\\t\\t#endif\\n\\t\\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\";\n\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\tuniform highp sampler2D boneTexture;\\n\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\tint size = textureSize( boneTexture, 0 ).x;\\n\\t\\tint j = int( i ) * 4;\\n\\t\\tint x = j % size;\\n\\t\\tint y = j / size;\\n\\t\\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\\n\\t\\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\\n\\t\\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\\n\\t\\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\\n\\t\\treturn mat4( v1, v2, v3, v4 );\\n\\t}\\n#endif\";\n\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\n\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn saturate( toneMappingExposure * color );\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(  1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,  1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\\n\\tvec3( 1.6605, - 0.1246, - 0.0182 ),\\n\\tvec3( - 0.5876, 1.1329, - 0.1006 ),\\n\\tvec3( - 0.0728, - 0.0083, 1.1187 )\\n);\\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\\n\\tvec3( 0.6274, 0.0691, 0.0164 ),\\n\\tvec3( 0.3293, 0.9195, 0.0880 ),\\n\\tvec3( 0.0433, 0.0113, 0.8956 )\\n);\\nvec3 agxDefaultContrastApprox( vec3 x ) {\\n\\tvec3 x2 = x * x;\\n\\tvec3 x4 = x2 * x2;\\n\\treturn + 15.5 * x4 * x2\\n\\t\\t- 40.14 * x4 * x\\n\\t\\t+ 31.96 * x4\\n\\t\\t- 6.868 * x2 * x\\n\\t\\t+ 0.4298 * x2\\n\\t\\t+ 0.1191 * x\\n\\t\\t- 0.00232;\\n}\\nvec3 AgXToneMapping( vec3 color ) {\\n\\tconst mat3 AgXInsetMatrix = mat3(\\n\\t\\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\\n\\t\\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\\n\\t\\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\\n\\t);\\n\\tconst mat3 AgXOutsetMatrix = mat3(\\n\\t\\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\\n\\t\\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\\n\\t\\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\\n\\t);\\n\\tconst float AgxMinEv = - 12.47393;\\tconst float AgxMaxEv = 4.026069;\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\\n\\tcolor = AgXInsetMatrix * color;\\n\\tcolor = max( color, 1e-10 );\\tcolor = log2( color );\\n\\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\\n\\tcolor = clamp( color, 0.0, 1.0 );\\n\\tcolor = agxDefaultContrastApprox( color );\\n\\tcolor = AgXOutsetMatrix * color;\\n\\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\\n\\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\\n\\tcolor = clamp( color, 0.0, 1.0 );\\n\\treturn color;\\n}\\nvec3 NeutralToneMapping( vec3 color ) {\\n\\tconst float StartCompression = 0.8 - 0.04;\\n\\tconst float Desaturation = 0.15;\\n\\tcolor *= toneMappingExposure;\\n\\tfloat x = min( color.r, min( color.g, color.b ) );\\n\\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\\n\\tcolor -= offset;\\n\\tfloat peak = max( color.r, max( color.g, color.b ) );\\n\\tif ( peak < StartCompression ) return color;\\n\\tfloat d = 1. - StartCompression;\\n\\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\\n\\tcolor *= newPeak / peak;\\n\\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\\n\\treturn mix( color, vec3( newPeak ), g );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\n\nvar transmission_fragment = \"#ifdef USE_TRANSMISSION\\n\\tmaterial.transmission = transmission;\\n\\tmaterial.transmissionAlpha = 1.0;\\n\\tmaterial.thickness = thickness;\\n\\tmaterial.attenuationDistance = attenuationDistance;\\n\\tmaterial.attenuationColor = attenuationColor;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 n = inverseTransformDirection( normal, viewMatrix );\\n\\tvec4 transmitted = getIBLVolumeRefraction(\\n\\t\\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\\n\\t\\tmaterial.attenuationColor, material.attenuationDistance );\\n\\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\\n\\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\\n#endif\";\n\nvar transmission_pars_fragment = \"#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform float attenuationDistance;\\n\\tuniform vec3 attenuationColor;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec3 vWorldPosition;\\n\\tfloat w0( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\\n\\t}\\n\\tfloat w1( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\\n\\t}\\n\\tfloat w2( float a ){\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\\n\\t}\\n\\tfloat w3( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * a * a );\\n\\t}\\n\\tfloat g0( float a ) {\\n\\t\\treturn w0( a ) + w1( a );\\n\\t}\\n\\tfloat g1( float a ) {\\n\\t\\treturn w2( a ) + w3( a );\\n\\t}\\n\\tfloat h0( float a ) {\\n\\t\\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\\n\\t}\\n\\tfloat h1( float a ) {\\n\\t\\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\\n\\t}\\n\\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\\n\\t\\tuv = uv * texelSize.zw + 0.5;\\n\\t\\tvec2 iuv = floor( uv );\\n\\t\\tvec2 fuv = fract( uv );\\n\\t\\tfloat g0x = g0( fuv.x );\\n\\t\\tfloat g1x = g1( fuv.x );\\n\\t\\tfloat h0x = h0( fuv.x );\\n\\t\\tfloat h1x = h1( fuv.x );\\n\\t\\tfloat h0y = h0( fuv.y );\\n\\t\\tfloat h1y = h1( fuv.y );\\n\\t\\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\\t\\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\\n\\t\\t\\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\\n\\t}\\n\\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\\n\\t\\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\\n\\t\\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\\n\\t\\tvec2 fLodSizeInv = 1.0 / fLodSize;\\n\\t\\tvec2 cLodSizeInv = 1.0 / cLodSize;\\n\\t\\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\\n\\t\\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\\n\\t\\treturn mix( fSample, cSample, fract( lod ) );\\n\\t}\\n\\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\\n\\t\\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\\n\\t\\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\\n\\t\\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\\n\\t\\treturn normalize( refractionVector ) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\\n\\t\\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\\n\\t}\\n\\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\\n\\t\\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\\n\\t\\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\\n\\t}\\n\\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\\n\\t\\tif ( isinf( attenuationDistance ) ) {\\n\\t\\t\\treturn vec3( 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\\t\\t\\treturn transmittance;\\n\\t\\t}\\n\\t}\\n\\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\\n\\t\\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\\n\\t\\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\\n\\t\\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\\n\\t\\tvec4 transmittedLight;\\n\\t\\tvec3 transmittance;\\n\\t\\t#ifdef USE_DISPERSION\\n\\t\\t\\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\\n\\t\\t\\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\\n\\t\\t\\tfor ( int i = 0; i < 3; i ++ ) {\\n\\t\\t\\t\\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\\n\\t\\t\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\t\\n\\t\\t\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\\t\\t\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\t\\t\\trefractionCoords += 1.0;\\n\\t\\t\\t\\trefractionCoords /= 2.0;\\n\\t\\t\\n\\t\\t\\t\\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\\n\\t\\t\\t\\ttransmittedLight[ i ] = transmissionSample[ i ];\\n\\t\\t\\t\\ttransmittedLight.a += transmissionSample.a;\\n\\t\\t\\t\\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\\n\\t\\t\\t}\\n\\t\\t\\ttransmittedLight.a /= 3.0;\\n\\t\\t\\n\\t\\t#else\\n\\t\\t\\n\\t\\t\\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n\\t\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\\t\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\t\\trefractionCoords += 1.0;\\n\\t\\t\\trefractionCoords /= 2.0;\\n\\t\\t\\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\\n\\t\\t\\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\\n\\t\\t\\n\\t\\t#endif\\n\\t\\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\\n\\t\\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\\n\\t\\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\\n\\t\\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\\n\\t}\\n#endif\";\n\nvar uv_pars_fragment = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tvarying vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\\tvarying vec2 vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tvarying vec2 vNormalMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tvarying vec2 vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tvarying vec2 vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvarying vec2 vClearcoatNormalMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tvarying vec2 vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tvarying vec2 vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tvarying vec2 vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tvarying vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tvarying vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tvarying vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tvarying vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tuniform mat3 transmissionMapTransform;\\n\\tvarying vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tuniform mat3 thicknessMapTransform;\\n\\tvarying vec2 vThicknessMapUv;\\n#endif\";\n\nvar uv_pars_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform mat3 mapTransform;\\n\\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform mat3 alphaMapTransform;\\n\\tvarying vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tuniform mat3 lightMapTransform;\\n\\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\\tuniform mat3 aoMapTransform;\\n\\tvarying vec2 vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tuniform mat3 bumpMapTransform;\\n\\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tuniform mat3 normalMapTransform;\\n\\tvarying vec2 vNormalMapUv;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\\tuniform mat3 displacementMapTransform;\\n\\tvarying vec2 vDisplacementMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tuniform mat3 emissiveMapTransform;\\n\\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tuniform mat3 metalnessMapTransform;\\n\\tvarying vec2 vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tuniform mat3 roughnessMapTransform;\\n\\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tuniform mat3 anisotropyMapTransform;\\n\\tvarying vec2 vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tuniform mat3 clearcoatMapTransform;\\n\\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform mat3 clearcoatNormalMapTransform;\\n\\tvarying vec2 vClearcoatNormalMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform mat3 clearcoatRoughnessMapTransform;\\n\\tvarying vec2 vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tuniform mat3 sheenColorMapTransform;\\n\\tvarying vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tuniform mat3 sheenRoughnessMapTransform;\\n\\tvarying vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tuniform mat3 iridescenceMapTransform;\\n\\tvarying vec2 vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tuniform mat3 iridescenceThicknessMapTransform;\\n\\tvarying vec2 vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tuniform mat3 specularMapTransform;\\n\\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tuniform mat3 specularColorMapTransform;\\n\\tvarying vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tuniform mat3 specularIntensityMapTransform;\\n\\tvarying vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tuniform mat3 transmissionMapTransform;\\n\\tvarying vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tuniform mat3 thicknessMapTransform;\\n\\tvarying vec2 vThicknessMapUv;\\n#endif\";\n\nvar uv_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvUv = vec3( uv, 1 ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_AOMAP\\n\\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\";\n\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_BATCHING\\n\\t\\tworldPosition = batchingMatrix * worldPosition;\\n\\t#endif\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\n\nconst vertex$h = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\nconst fragment$h = \"uniform sampler2D t2D;\\nuniform float backgroundIntensity;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\t#ifdef DECODE_VIDEO_TEXTURE\\n\\t\\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\\n\\t#endif\\n\\ttexColor.rgb *= backgroundIntensity;\\n\\tgl_FragColor = texColor;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$g = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nconst fragment$g = \"#ifdef ENVMAP_TYPE_CUBE\\n\\tuniform samplerCube envMap;\\n#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\tuniform sampler2D envMap;\\n#endif\\nuniform float flipEnvMap;\\nuniform float backgroundBlurriness;\\nuniform float backgroundIntensity;\\nuniform mat3 backgroundRotation;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\\n\\t#else\\n\\t\\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t#endif\\n\\ttexColor.rgb *= backgroundIntensity;\\n\\tgl_FragColor = texColor;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$f = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nconst fragment$f = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\\tgl_FragColor = texColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$e = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\";\n\nconst fragment$e = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <clipping_planes_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}\";\n\nconst vertex$d = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\nconst fragment$d = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\nconst vertex$c = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\nconst fragment$c = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$b = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$b = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nconst vertex$a = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinbase_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$a = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$9 = \"#define LAMBERT\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$9 = \"#define LAMBERT\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_lambert_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_lambert_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$8 = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\nconst fragment$8 = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$7 = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\nconst fragment$7 = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\\n\\t#ifdef OPAQUE\\n\\t\\tgl_FragColor.a = 1.0;\\n\\t#endif\\n}\";\n\nconst vertex$6 = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$6 = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$5 = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec3 vWorldPosition;\\n#endif\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition.xyz;\\n#endif\\n}\";\n\nconst fragment$5 = \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define IOR\\n\\t#define USE_SPECULAR\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef IOR\\n\\tuniform float ior;\\n#endif\\n#ifdef USE_SPECULAR\\n\\tuniform float specularIntensity;\\n\\tuniform vec3 specularColor;\\n\\t#ifdef USE_SPECULAR_COLORMAP\\n\\t\\tuniform sampler2D specularColorMap;\\n\\t#endif\\n\\t#ifdef USE_SPECULAR_INTENSITYMAP\\n\\t\\tuniform sampler2D specularIntensityMap;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_DISPERSION\\n\\tuniform float dispersion;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tuniform float iridescence;\\n\\tuniform float iridescenceIOR;\\n\\tuniform float iridescenceThicknessMinimum;\\n\\tuniform float iridescenceThicknessMaximum;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheenColor;\\n\\tuniform float sheenRoughness;\\n\\t#ifdef USE_SHEEN_COLORMAP\\n\\t\\tuniform sampler2D sheenColorMap;\\n\\t#endif\\n\\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\t\\tuniform sampler2D sheenRoughnessMap;\\n\\t#endif\\n#endif\\n#ifdef USE_ANISOTROPY\\n\\tuniform vec2 anisotropyVector;\\n\\t#ifdef USE_ANISOTROPYMAP\\n\\t\\tuniform sampler2D anisotropyMap;\\n\\t#endif\\n#endif\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <iridescence_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_physical_pars_fragment>\\n#include <transmission_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <iridescence_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\n\\t#include <transmission_fragment>\\n\\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\\n\\t#ifdef USE_SHEEN\\n\\t\\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\\n\\t\\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\\n\\t\\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\\n\\t\\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\\n\\t#endif\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$4 = \"#define TOON\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$4 = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$3 = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n#ifdef USE_POINTS_UV\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\\nvoid main() {\\n\\t#ifdef USE_POINTS_UV\\n\\t\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\t#endif\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$3 = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nconst vertex$2 = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$2 = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <logdepthbuf_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nconst vertex$1 = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$1 = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nconst ShaderChunk = {\n\talphahash_fragment: alphahash_fragment,\n\talphahash_pars_fragment: alphahash_pars_fragment,\n\talphamap_fragment: alphamap_fragment,\n\talphamap_pars_fragment: alphamap_pars_fragment,\n\talphatest_fragment: alphatest_fragment,\n\talphatest_pars_fragment: alphatest_pars_fragment,\n\taomap_fragment: aomap_fragment,\n\taomap_pars_fragment: aomap_pars_fragment,\n\tbatching_pars_vertex: batching_pars_vertex,\n\tbatching_vertex: batching_vertex,\n\tbegin_vertex: begin_vertex,\n\tbeginnormal_vertex: beginnormal_vertex,\n\tbsdfs: bsdfs,\n\tiridescence_fragment: iridescence_fragment,\n\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\tclipping_planes_fragment: clipping_planes_fragment,\n\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\tclipping_planes_vertex: clipping_planes_vertex,\n\tcolor_fragment: color_fragment,\n\tcolor_pars_fragment: color_pars_fragment,\n\tcolor_pars_vertex: color_pars_vertex,\n\tcolor_vertex: color_vertex,\n\tcommon: common,\n\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\tdefaultnormal_vertex: defaultnormal_vertex,\n\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\tdisplacementmap_vertex: displacementmap_vertex,\n\temissivemap_fragment: emissivemap_fragment,\n\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\tcolorspace_fragment: colorspace_fragment,\n\tcolorspace_pars_fragment: colorspace_pars_fragment,\n\tenvmap_fragment: envmap_fragment,\n\tenvmap_common_pars_fragment: envmap_common_pars_fragment,\n\tenvmap_pars_fragment: envmap_pars_fragment,\n\tenvmap_pars_vertex: envmap_pars_vertex,\n\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\tenvmap_vertex: envmap_vertex,\n\tfog_vertex: fog_vertex,\n\tfog_pars_vertex: fog_pars_vertex,\n\tfog_fragment: fog_fragment,\n\tfog_pars_fragment: fog_pars_fragment,\n\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\tlightmap_pars_fragment: lightmap_pars_fragment,\n\tlights_lambert_fragment: lights_lambert_fragment,\n\tlights_lambert_pars_fragment: lights_lambert_pars_fragment,\n\tlights_pars_begin: lights_pars_begin,\n\tlights_toon_fragment: lights_toon_fragment,\n\tlights_toon_pars_fragment: lights_toon_pars_fragment,\n\tlights_phong_fragment: lights_phong_fragment,\n\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\tlights_physical_fragment: lights_physical_fragment,\n\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\tlights_fragment_begin: lights_fragment_begin,\n\tlights_fragment_maps: lights_fragment_maps,\n\tlights_fragment_end: lights_fragment_end,\n\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\tmap_fragment: map_fragment,\n\tmap_pars_fragment: map_pars_fragment,\n\tmap_particle_fragment: map_particle_fragment,\n\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\tmetalnessmap_fragment: metalnessmap_fragment,\n\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\tmorphinstance_vertex: morphinstance_vertex,\n\tmorphcolor_vertex: morphcolor_vertex,\n\tmorphnormal_vertex: morphnormal_vertex,\n\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\tmorphtarget_vertex: morphtarget_vertex,\n\tnormal_fragment_begin: normal_fragment_begin,\n\tnormal_fragment_maps: normal_fragment_maps,\n\tnormal_pars_fragment: normal_pars_fragment,\n\tnormal_pars_vertex: normal_pars_vertex,\n\tnormal_vertex: normal_vertex,\n\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\tclearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n\tclearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n\tclearcoat_pars_fragment: clearcoat_pars_fragment,\n\tiridescence_pars_fragment: iridescence_pars_fragment,\n\topaque_fragment: opaque_fragment,\n\tpacking: packing,\n\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\tproject_vertex: project_vertex,\n\tdithering_fragment: dithering_fragment,\n\tdithering_pars_fragment: dithering_pars_fragment,\n\troughnessmap_fragment: roughnessmap_fragment,\n\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\tshadowmap_vertex: shadowmap_vertex,\n\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\tskinbase_vertex: skinbase_vertex,\n\tskinning_pars_vertex: skinning_pars_vertex,\n\tskinning_vertex: skinning_vertex,\n\tskinnormal_vertex: skinnormal_vertex,\n\tspecularmap_fragment: specularmap_fragment,\n\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\ttonemapping_fragment: tonemapping_fragment,\n\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\ttransmission_fragment: transmission_fragment,\n\ttransmission_pars_fragment: transmission_pars_fragment,\n\tuv_pars_fragment: uv_pars_fragment,\n\tuv_pars_vertex: uv_pars_vertex,\n\tuv_vertex: uv_vertex,\n\tworldpos_vertex: worldpos_vertex,\n\n\tbackground_vert: vertex$h,\n\tbackground_frag: fragment$h,\n\tbackgroundCube_vert: vertex$g,\n\tbackgroundCube_frag: fragment$g,\n\tcube_vert: vertex$f,\n\tcube_frag: fragment$f,\n\tdepth_vert: vertex$e,\n\tdepth_frag: fragment$e,\n\tdistanceRGBA_vert: vertex$d,\n\tdistanceRGBA_frag: fragment$d,\n\tequirect_vert: vertex$c,\n\tequirect_frag: fragment$c,\n\tlinedashed_vert: vertex$b,\n\tlinedashed_frag: fragment$b,\n\tmeshbasic_vert: vertex$a,\n\tmeshbasic_frag: fragment$a,\n\tmeshlambert_vert: vertex$9,\n\tmeshlambert_frag: fragment$9,\n\tmeshmatcap_vert: vertex$8,\n\tmeshmatcap_frag: fragment$8,\n\tmeshnormal_vert: vertex$7,\n\tmeshnormal_frag: fragment$7,\n\tmeshphong_vert: vertex$6,\n\tmeshphong_frag: fragment$6,\n\tmeshphysical_vert: vertex$5,\n\tmeshphysical_frag: fragment$5,\n\tmeshtoon_vert: vertex$4,\n\tmeshtoon_frag: fragment$4,\n\tpoints_vert: vertex$3,\n\tpoints_frag: fragment$3,\n\tshadow_vert: vertex$2,\n\tshadow_frag: fragment$2,\n\tsprite_vert: vertex$1,\n\tsprite_frag: fragment$1\n};\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nconst UniformsLib = {\n\n\tcommon: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\n\t\tmap: { value: null },\n\t\tmapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\n\t\talphaTest: { value: 0 }\n\n\t},\n\n\tspecularmap: {\n\n\t\tspecularMap: { value: null },\n\t\tspecularMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tenvmap: {\n\n\t\tenvMap: { value: null },\n\t\tenvMapRotation: { value: /*@__PURE__*/ new Matrix3() },\n\t\tflipEnvMap: { value: - 1 },\n\t\treflectivity: { value: 1.0 }, // basic, lambert, phong\n\t\tior: { value: 1.5 }, // physical\n\t\trefractionRatio: { value: 0.98 }, // basic, lambert, phong\n\n\t},\n\n\taomap: {\n\n\t\taoMap: { value: null },\n\t\taoMapIntensity: { value: 1 },\n\t\taoMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tlightmap: {\n\n\t\tlightMap: { value: null },\n\t\tlightMapIntensity: { value: 1 },\n\t\tlightMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tbumpmap: {\n\n\t\tbumpMap: { value: null },\n\t\tbumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\tbumpScale: { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\tnormalMap: { value: null },\n\t\tnormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\tnormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\tdisplacementMap: { value: null },\n\t\tdisplacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\tdisplacementScale: { value: 1 },\n\t\tdisplacementBias: { value: 0 }\n\n\t},\n\n\temissivemap: {\n\n\t\temissiveMap: { value: null },\n\t\temissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\tmetalnessMap: { value: null },\n\t\tmetalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\troughnessmap: {\n\n\t\troughnessMap: { value: null },\n\t\troughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tgradientmap: {\n\n\t\tgradientMap: { value: null }\n\n\t},\n\n\tfog: {\n\n\t\tfogDensity: { value: 0.00025 },\n\t\tfogNear: { value: 1 },\n\t\tfogFar: { value: 2000 },\n\t\tfogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\tambientLightColor: { value: [] },\n\n\t\tlightProbe: { value: [] },\n\n\t\tdirectionalLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tcolor: {}\n\t\t} },\n\n\t\tdirectionalLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tdirectionalShadowMap: { value: [] },\n\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\tspotLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdirection: {},\n\t\t\tdistance: {},\n\t\t\tconeCos: {},\n\t\t\tpenumbraCos: {},\n\t\t\tdecay: {}\n\t\t} },\n\n\t\tspotLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tspotLightMap: { value: [] },\n\t\tspotShadowMap: { value: [] },\n\t\tspotLightMatrix: { value: [] },\n\n\t\tpointLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdecay: {},\n\t\t\tdistance: {}\n\t\t} },\n\n\t\tpointLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {},\n\t\t\tshadowCameraNear: {},\n\t\t\tshadowCameraFar: {}\n\t\t} },\n\n\t\tpointShadowMap: { value: [] },\n\t\tpointShadowMatrix: { value: [] },\n\n\t\themisphereLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tskyColor: {},\n\t\t\tgroundColor: {}\n\t\t} },\n\n\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\trectAreaLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\twidth: {},\n\t\t\theight: {}\n\t\t} },\n\n\t\tltc_1: { value: null },\n\t\tltc_2: { value: null }\n\n\t},\n\n\tpoints: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\t\tsize: { value: 1.0 },\n\t\tscale: { value: 1.0 },\n\t\tmap: { value: null },\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\talphaTest: { value: 0 },\n\t\tuvTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tsprite: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\t\tcenter: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },\n\t\trotation: { value: 0.0 },\n\t\tmap: { value: null },\n\t\tmapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\talphaTest: { value: 0 }\n\n\t}\n\n};\n\nconst ShaderLib = {\n\n\tbasic: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t},\n\n\tlambert: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t},\n\n\tphong: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\t\tspecular: { value: /*@__PURE__*/ new Color( 0x111111 ) },\n\t\t\t\tshininess: { value: 30 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t},\n\n\tstandard: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.roughnessmap,\n\t\t\tUniformsLib.metalnessmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\t\troughness: { value: 1.0 },\n\t\t\t\tmetalness: { value: 0.0 },\n\t\t\t\tenvMapIntensity: { value: 1 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t},\n\n\ttoon: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.gradientmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshtoon_vert,\n\t\tfragmentShader: ShaderChunk.meshtoon_frag\n\n\t},\n\n\tmatcap: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tmatcap: { value: null }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\n\t},\n\n\tpoints: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.points,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.points_vert,\n\t\tfragmentShader: ShaderChunk.points_frag\n\n\t},\n\n\tdashed: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tscale: { value: 1 },\n\t\t\t\tdashSize: { value: 1 },\n\t\t\t\ttotalSize: { value: 2 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t},\n\n\tdepth: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.depth_vert,\n\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t},\n\n\tnormal: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshnormal_vert,\n\t\tfragmentShader: ShaderChunk.meshnormal_frag\n\n\t},\n\n\tsprite: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.sprite,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\tfragmentShader: ShaderChunk.sprite_frag\n\n\t},\n\n\tbackground: {\n\n\t\tuniforms: {\n\t\t\tuvTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tt2D: { value: null },\n\t\t\tbackgroundIntensity: { value: 1 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.background_vert,\n\t\tfragmentShader: ShaderChunk.background_frag\n\n\t},\n\n\tbackgroundCube: {\n\n\t\tuniforms: {\n\t\t\tenvMap: { value: null },\n\t\t\tflipEnvMap: { value: - 1 },\n\t\t\tbackgroundBlurriness: { value: 0 },\n\t\t\tbackgroundIntensity: { value: 1 },\n\t\t\tbackgroundRotation: { value: /*@__PURE__*/ new Matrix3() }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.backgroundCube_vert,\n\t\tfragmentShader: ShaderChunk.backgroundCube_frag\n\n\t},\n\n\tcube: {\n\n\t\tuniforms: {\n\t\t\ttCube: { value: null },\n\t\t\ttFlip: { value: - 1 },\n\t\t\topacity: { value: 1.0 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.cube_vert,\n\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t},\n\n\tequirect: {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t},\n\n\tdistanceRGBA: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\treferencePosition: { value: /*@__PURE__*/ new Vector3() },\n\t\t\t\tnearDistance: { value: 1 },\n\t\t\t\tfarDistance: { value: 1000 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t},\n\n\tshadow: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.lights,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tcolor: { value: /*@__PURE__*/ new Color( 0x00000 ) },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\tfragmentShader: ShaderChunk.shadow_frag\n\n\t}\n\n};\n\nShaderLib.physical = {\n\n\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\tShaderLib.standard.uniforms,\n\t\t{\n\t\t\tclearcoat: { value: 0 },\n\t\t\tclearcoatMap: { value: null },\n\t\t\tclearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tclearcoatNormalMap: { value: null },\n\t\t\tclearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tclearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },\n\t\t\tclearcoatRoughness: { value: 0 },\n\t\t\tclearcoatRoughnessMap: { value: null },\n\t\t\tclearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tdispersion: { value: 0 },\n\t\t\tiridescence: { value: 0 },\n\t\t\tiridescenceMap: { value: null },\n\t\t\tiridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tiridescenceIOR: { value: 1.3 },\n\t\t\tiridescenceThicknessMinimum: { value: 100 },\n\t\t\tiridescenceThicknessMaximum: { value: 400 },\n\t\t\tiridescenceThicknessMap: { value: null },\n\t\t\tiridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tsheen: { value: 0 },\n\t\t\tsheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\tsheenColorMap: { value: null },\n\t\t\tsheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tsheenRoughness: { value: 1 },\n\t\t\tsheenRoughnessMap: { value: null },\n\t\t\tsheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\ttransmission: { value: 0 },\n\t\t\ttransmissionMap: { value: null },\n\t\t\ttransmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\ttransmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },\n\t\t\ttransmissionSamplerMap: { value: null },\n\t\t\tthickness: { value: 0 },\n\t\t\tthicknessMap: { value: null },\n\t\t\tthicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tattenuationDistance: { value: 0 },\n\t\t\tattenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\tspecularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },\n\t\t\tspecularColorMap: { value: null },\n\t\t\tspecularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tspecularIntensity: { value: 1 },\n\t\t\tspecularIntensityMap: { value: null },\n\t\t\tspecularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tanisotropyVector: { value: /*@__PURE__*/ new Vector2() },\n\t\t\tanisotropyMap: { value: null },\n\t\t\tanisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t}\n\t] ),\n\n\tvertexShader: ShaderChunk.meshphysical_vert,\n\tfragmentShader: ShaderChunk.meshphysical_frag\n\n};\n\nconst _rgb = { r: 0, b: 0, g: 0 };\nconst _e1$1 = /*@__PURE__*/ new Euler();\nconst _m1$1 = /*@__PURE__*/ new Matrix4();\n\nfunction WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {\n\n\tconst clearColor = new Color( 0x000000 );\n\tlet clearAlpha = alpha === true ? 0 : 1;\n\n\tlet planeMesh;\n\tlet boxMesh;\n\n\tlet currentBackground = null;\n\tlet currentBackgroundVersion = 0;\n\tlet currentTonemapping = null;\n\n\tfunction getBackground( scene ) {\n\n\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\tif ( background && background.isTexture ) {\n\n\t\t\tconst usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background\n\t\t\tbackground = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );\n\n\t\t}\n\n\t\treturn background;\n\n\t}\n\n\tfunction render( scene ) {\n\n\t\tlet forceClear = false;\n\t\tconst background = getBackground( scene );\n\n\t\tif ( background === null ) {\n\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t} else if ( background && background.isColor ) {\n\n\t\t\tsetClear( background, 1 );\n\t\t\tforceClear = true;\n\n\t\t}\n\n\t\tconst environmentBlendMode = renderer.xr.getEnvironmentBlendMode();\n\n\t\tif ( environmentBlendMode === 'additive' ) {\n\n\t\t\tstate.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );\n\n\t\t} else if ( environmentBlendMode === 'alpha-blend' ) {\n\n\t\t\tstate.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );\n\n\t\t}\n\n\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\t// buffers might not be writable which is required to ensure a correct clear\n\n\t\t\tstate.buffers.depth.setTest( true );\n\t\t\tstate.buffers.depth.setMask( true );\n\t\t\tstate.buffers.color.setMask( true );\n\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t}\n\n\tfunction addToRenderList( renderList, scene ) {\n\n\t\tconst background = getBackground( scene );\n\n\t\tif ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\tnew BoxGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.backgroundCube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.backgroundCube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'normal' );\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'uv' );\n\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\t// add \"envMap\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( boxMesh.material, 'envMap', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( boxMesh );\n\n\t\t\t}\n\n\t\t\t_e1$1.copy( scene.backgroundRotation );\n\n\t\t\t// accommodate left-handed frame\n\t\t\t_e1$1.x *= - 1; _e1$1.y *= - 1; _e1$1.z *= - 1;\n\n\t\t\tif ( background.isCubeTexture && background.isRenderTargetTexture === false ) {\n\n\t\t\t\t// environment maps which are not cube render targets or PMREMs follow a different convention\n\t\t\t\t_e1$1.y *= - 1;\n\t\t\t\t_e1$1.z *= - 1;\n\n\t\t\t}\n\n\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\tboxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;\n\t\t\tboxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;\n\t\t\tboxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\t\t\tboxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4( _m1$1.makeRotationFromEuler( _e1$1 ) );\n\t\t\tboxMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tboxMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tboxMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\n\n\t\t} else if ( background && background.isTexture ) {\n\n\t\t\tif ( planeMesh === undefined ) {\n\n\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\tnew PlaneGeometry( 2, 2 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tplaneMesh.geometry.deleteAttribute( 'normal' );\n\n\t\t\t\t// add \"map\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( planeMesh );\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\t\t\tplaneMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\t\t\tplaneMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;\n\n\t\t\tif ( background.matrixAutoUpdate === true ) {\n\n\t\t\t\tbackground.updateMatrix();\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tplaneMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\n\n\t\t}\n\n\t}\n\n\tfunction setClear( color, alpha ) {\n\n\t\tcolor.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );\n\n\t\tstate.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );\n\n\t}\n\n\treturn {\n\n\t\tgetClearColor: function () {\n\n\t\t\treturn clearColor;\n\n\t\t},\n\t\tsetClearColor: function ( color, alpha = 1 ) {\n\n\t\t\tclearColor.set( color );\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\tgetClearAlpha: function () {\n\n\t\t\treturn clearAlpha;\n\n\t\t},\n\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\trender: render,\n\t\taddToRenderList: addToRenderList\n\n\t};\n\n}\n\nfunction WebGLBindingStates( gl, attributes ) {\n\n\tconst maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\n\tconst bindingStates = {};\n\n\tconst defaultState = createBindingState( null );\n\tlet currentState = defaultState;\n\tlet forceUpdate = false;\n\n\tfunction setup( object, material, program, geometry, index ) {\n\n\t\tlet updateBuffers = false;\n\n\t\tconst state = getBindingState( geometry, program, material );\n\n\t\tif ( currentState !== state ) {\n\n\t\t\tcurrentState = state;\n\t\t\tbindVertexArrayObject( currentState.object );\n\n\t\t}\n\n\t\tupdateBuffers = needsUpdate( object, geometry, program, index );\n\n\t\tif ( updateBuffers ) saveCache( object, geometry, program, index );\n\n\t\tif ( index !== null ) {\n\n\t\t\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tif ( updateBuffers || forceUpdate ) {\n\n\t\t\tforceUpdate = false;\n\n\t\t\tsetupVertexAttributes( object, material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createVertexArrayObject() {\n\n\t\treturn gl.createVertexArray();\n\n\t}\n\n\tfunction bindVertexArrayObject( vao ) {\n\n\t\treturn gl.bindVertexArray( vao );\n\n\t}\n\n\tfunction deleteVertexArrayObject( vao ) {\n\n\t\treturn gl.deleteVertexArray( vao );\n\n\t}\n\n\tfunction getBindingState( geometry, program, material ) {\n\n\t\tconst wireframe = ( material.wireframe === true );\n\n\t\tlet programMap = bindingStates[ geometry.id ];\n\n\t\tif ( programMap === undefined ) {\n\n\t\t\tprogramMap = {};\n\t\t\tbindingStates[ geometry.id ] = programMap;\n\n\t\t}\n\n\t\tlet stateMap = programMap[ program.id ];\n\n\t\tif ( stateMap === undefined ) {\n\n\t\t\tstateMap = {};\n\t\t\tprogramMap[ program.id ] = stateMap;\n\n\t\t}\n\n\t\tlet state = stateMap[ wireframe ];\n\n\t\tif ( state === undefined ) {\n\n\t\t\tstate = createBindingState( createVertexArrayObject() );\n\t\t\tstateMap[ wireframe ] = state;\n\n\t\t}\n\n\t\treturn state;\n\n\t}\n\n\tfunction createBindingState( vao ) {\n\n\t\tconst newAttributes = [];\n\t\tconst enabledAttributes = [];\n\t\tconst attributeDivisors = [];\n\n\t\tfor ( let i = 0; i < maxVertexAttributes; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\t\t\tenabledAttributes[ i ] = 0;\n\t\t\tattributeDivisors[ i ] = 0;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\tgeometry: null,\n\t\t\tprogram: null,\n\t\t\twireframe: false,\n\n\t\t\tnewAttributes: newAttributes,\n\t\t\tenabledAttributes: enabledAttributes,\n\t\t\tattributeDivisors: attributeDivisors,\n\t\t\tobject: vao,\n\t\t\tattributes: {},\n\t\t\tindex: null\n\n\t\t};\n\n\t}\n\n\tfunction needsUpdate( object, geometry, program, index ) {\n\n\t\tconst cachedAttributes = currentState.attributes;\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tlet attributesNum = 0;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tconst cachedAttribute = cachedAttributes[ name ];\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cachedAttribute === undefined ) return true;\n\n\t\t\t\tif ( cachedAttribute.attribute !== geometryAttribute ) return true;\n\n\t\t\t\tif ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;\n\n\t\t\t\tattributesNum ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( currentState.attributesNum !== attributesNum ) return true;\n\n\t\tif ( currentState.index !== index ) return true;\n\n\t\treturn false;\n\n\t}\n\n\tfunction saveCache( object, geometry, program, index ) {\n\n\t\tconst cache = {};\n\t\tconst attributes = geometry.attributes;\n\t\tlet attributesNum = 0;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tlet attribute = attributes[ name ];\n\n\t\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tconst data = {};\n\t\t\t\tdata.attribute = attribute;\n\n\t\t\t\tif ( attribute && attribute.data ) {\n\n\t\t\t\t\tdata.data = attribute.data;\n\n\t\t\t\t}\n\n\t\t\t\tcache[ name ] = data;\n\n\t\t\t\tattributesNum ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcurrentState.attributes = cache;\n\t\tcurrentState.attributesNum = attributesNum;\n\n\t\tcurrentState.index = index;\n\n\t}\n\n\tfunction initAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\n\t\tfor ( let i = 0, il = newAttributes.length; i < il; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tenableAttributeAndDivisor( attribute, 0 );\n\n\t}\n\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\tconst attributeDivisors = currentState.attributeDivisors;\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\tgl.vertexAttribDivisor( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t}\n\n\tfunction disableUnusedAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\tfor ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {\n\n\t\tif ( integer === true ) {\n\n\t\t\tgl.vertexAttribIPointer( index, size, type, stride, offset );\n\n\t\t} else {\n\n\t\t\tgl.vertexAttribPointer( index, size, type, normalized, stride, offset );\n\n\t\t}\n\n\t}\n\n\tfunction setupVertexAttributes( object, material, program, geometry ) {\n\n\t\tinitAttributes();\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\n\t\t\t\t\tconst attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\t// check for integer attributes\n\n\t\t\t\t\tconst integer = ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType );\n\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\tvertexAttribPointer(\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tnormalized,\n\t\t\t\t\t\t\t\tstride * bytesPerElement,\n\t\t\t\t\t\t\t\t( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,\n\t\t\t\t\t\t\t\tinteger\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\tvertexAttribPointer(\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tnormalized,\n\t\t\t\t\t\t\t\tsize * bytesPerElement,\n\t\t\t\t\t\t\t\t( size / programAttribute.locationSize ) * i * bytesPerElement,\n\t\t\t\t\t\t\t\tinteger\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tconst value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tgl.vertexAttrib2fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tgl.vertexAttrib3fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tgl.vertexAttrib4fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tgl.vertexAttrib1fv( programAttribute.location, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdisableUnusedAttributes();\n\n\t}\n\n\tfunction dispose() {\n\n\t\treset();\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tfor ( const programId in programMap ) {\n\n\t\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[ programId ];\n\n\t\t\t}\n\n\t\t\tdelete bindingStates[ geometryId ];\n\n\t\t}\n\n\t}\n\n\tfunction releaseStatesOfGeometry( geometry ) {\n\n\t\tif ( bindingStates[ geometry.id ] === undefined ) return;\n\n\t\tconst programMap = bindingStates[ geometry.id ];\n\n\t\tfor ( const programId in programMap ) {\n\n\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ programId ];\n\n\t\t}\n\n\t\tdelete bindingStates[ geometry.id ];\n\n\t}\n\n\tfunction releaseStatesOfProgram( program ) {\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tif ( programMap[ program.id ] === undefined ) continue;\n\n\t\t\tconst stateMap = programMap[ program.id ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ program.id ];\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\tresetDefaultState();\n\t\tforceUpdate = true;\n\n\t\tif ( currentState === defaultState ) return;\n\n\t\tcurrentState = defaultState;\n\t\tbindVertexArrayObject( currentState.object );\n\n\t}\n\n\t// for backward-compatibility\n\n\tfunction resetDefaultState() {\n\n\t\tdefaultState.geometry = null;\n\t\tdefaultState.program = null;\n\t\tdefaultState.wireframe = false;\n\n\t}\n\n\treturn {\n\n\t\tsetup: setup,\n\t\treset: reset,\n\t\tresetDefaultState: resetDefaultState,\n\t\tdispose: dispose,\n\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\n\t\tinitAttributes: initAttributes,\n\t\tenableAttribute: enableAttribute,\n\t\tdisableUnusedAttributes: disableUnusedAttributes\n\n\t};\n\n}\n\nfunction WebGLBufferRenderer( gl, extensions, info ) {\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawArrays( mode, start, count );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tgl.drawArraysInstanced( mode, start, count, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\tfunction renderMultiDraw( starts, counts, drawCount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.render( starts[ i ], counts[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\textension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\tfunction renderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < starts.length; i ++ ) {\n\n\t\t\t\trenderInstances( starts[ i ], counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\textension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < primcount.length; i ++ ) {\n\n\t\t\t\tinfo.update( elementCount, mode, primcount[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\tthis.renderMultiDraw = renderMultiDraw;\n\tthis.renderMultiDrawInstances = renderMultiDrawInstances;\n\n}\n\nfunction WebGLCapabilities( gl, extensions, parameters, utils ) {\n\n\tlet maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction textureFormatReadable( textureFormat ) {\n\n\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction textureTypeReadable( textureType ) {\n\n\t\tconst halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) );\n\n\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)\n\t\t\ttextureType !== FloatType && ! halfFloatSupportedByExt ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tlet precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tconst maxPrecision = getMaxPrecision( precision );\n\n\tif ( maxPrecision !== precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\tprecision = maxPrecision;\n\n\t}\n\n\tconst logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n\tconst maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\tconst maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tconst maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\tconst maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tconst maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tconst maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\tconst maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\tconst maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\tconst vertexTextures = maxVertexTextures > 0;\n\n\tconst maxSamples = gl.getParameter( gl.MAX_SAMPLES );\n\n\treturn {\n\n\t\tisWebGL2: true, // keeping this for backwards compatibility\n\n\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\ttextureFormatReadable: textureFormatReadable,\n\t\ttextureTypeReadable: textureTypeReadable,\n\n\t\tprecision: precision,\n\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\tmaxTextures: maxTextures,\n\t\tmaxVertexTextures: maxVertexTextures,\n\t\tmaxTextureSize: maxTextureSize,\n\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\tmaxAttributes: maxAttributes,\n\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\tmaxVaryings: maxVaryings,\n\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\tvertexTextures: vertexTextures,\n\n\t\tmaxSamples: maxSamples\n\n\t};\n\n}\n\nfunction WebGLClipping( properties ) {\n\n\tconst scope = this;\n\n\tlet globalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false;\n\n\tconst plane = new Plane(),\n\t\tviewNormalMatrix = new Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping ) {\n\n\t\tconst enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\n\t};\n\n\tthis.setGlobalState = function ( planes, camera ) {\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\n\t};\n\n\tthis.setState = function ( material, camera, useCache ) {\n\n\t\tconst planes = material.clippingPlanes,\n\t\t\tclipIntersection = material.clipIntersection,\n\t\t\tclipShadows = material.clipShadows;\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4;\n\n\t\t\tlet dstArray = materialProperties.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, useCache );\n\n\t\t\tfor ( let i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\tlet dstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\tscope.numIntersection = 0;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\nfunction WebGLCubeMaps( renderer ) {\n\n\tlet cubemaps = new WeakMap();\n\n\tfunction mapTextureMapping( texture, mapping ) {\n\n\t\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\t\ttexture.mapping = CubeReflectionMapping;\n\n\t\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\t\ttexture.mapping = CubeRefractionMapping;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\tif ( cubemaps.has( texture ) ) {\n\n\t\t\t\t\tconst cubemap = cubemaps.get( texture ).texture;\n\t\t\t\t\treturn mapTextureMapping( cubemap, texture.mapping );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\tif ( image && image.height > 0 ) {\n\n\t\t\t\t\t\tconst renderTarget = new WebGLCubeRenderTarget( image.height );\n\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\t\t\t\t\t\tcubemaps.set( texture, renderTarget );\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\treturn mapTextureMapping( renderTarget.texture, texture.mapping );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemap = cubemaps.get( texture );\n\n\t\tif ( cubemap !== undefined ) {\n\n\t\t\tcubemaps.delete( texture );\n\t\t\tcubemap.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubemaps = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nclass OrthographicCamera extends Camera {\n\n\tconstructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isOrthographicCamera = true;\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t}\n\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tconst dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tconst cx = ( this.right + this.left ) / 2;\n\t\tconst cy = ( this.top + this.bottom ) / 2;\n\n\t\tlet left = cx - dx;\n\t\tlet right = cx + dx;\n\t\tlet top = cy + dy;\n\t\tlet bottom = cy - dy;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;\n\t\t\tconst scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;\n\n\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\tright = left + scaleW * this.view.width;\n\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\tbottom = top - scaleH * this.view.height;\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera();\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\nlet _oldXrEnabled = false;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 ) ];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\n\t\tthis._compileMaterial( this._blurMaterial );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\t\t_oldXrEnabled = this._renderer.xr.enabled;\n\n\t\tthis._renderer.xr.enabled = false;\n\n\t\tthis._setSize( 256 );\n\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t * The smallest supported equirectangular image size is 64 x 32.\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t * The smallest supported cube size is 16 x 16.\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tthis._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tthis._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\n\t}\n\n\t// private interface\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\tthis._renderer.xr.enabled = _oldXrEnabled;\n\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\t\t_oldXrEnabled = this._renderer.xr.enabled;\n\n\t\tthis._renderer.xr.enabled = false;\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: LinearFilter,\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: HalfFloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\tdepthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst fov = 90;\n\t\tconst aspect = 1;\n\t\tconst cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\t\tconst toneMapping = renderer.toneMapping;\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.autoClear = false;\n\n\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\tname: 'PMREM.Background',\n\t\t\tside: BackSide,\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t} );\n\n\t\tconst backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundMaterial.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundMaterial.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\t\tif ( useSolidColor ) {\n\n\t\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\tbackgroundBox.geometry.dispose();\n\t\tbackgroundBox.material.dispose();\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\n\t\t\t}\n\n\t\t\tthis._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tconst mesh = new Mesh( this._lodPlanes[ 0 ], material );\n\n\t\tconst uniforms = material.uniforms;\n\n\t\tuniforms[ 'envMap' ].value = texture;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\tconst n = this._lodPlanes.length;\n\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error(\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\t\tblurUniforms[ 'samples' ].value = samples;\n\t\tblurUniforms[ 'weights' ].value = weights;\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\t\tblurUniforms[ 'mipInt' ].value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\n\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tconst fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = new Float32Array( MAX_SAMPLES );\n\tconst poleAxis = new Vector3( 0, 1, 0 );\n\tconst shaderMaterial = new ShaderMaterial( {\n\n\t\tname: 'SphericalGaussianBlur',\n\n\t\tdefines: {\n\t\t\t'n': MAX_SAMPLES,\n\t\t\t'CUBEUV_TEXEL_WIDTH': 1.0 / width,\n\t\t\t'CUBEUV_TEXEL_HEIGHT': 1.0 / height,\n\t\t\t'CUBEUV_MAX_MIP': `${lodMax}.0`,\n\t\t},\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectMaterial() {\n\n\treturn new ShaderMaterial( {\n\n\t\tname: 'EquirectangularToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCubemapMaterial() {\n\n\treturn new ShaderMaterial( {\n\n\t\tname: 'CubemapToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'flipEnvMap': { value: - 1 }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn /* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n\n}\n\nfunction WebGLCubeUVMaps( renderer ) {\n\n\tlet cubeUVmaps = new WeakMap();\n\n\tlet pmremGenerator = null;\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tconst isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );\n\t\t\tconst isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t\t\t// equirect/cube map to cubeUV conversion\n\n\t\t\tif ( isEquirectMap || isCubeMap ) {\n\n\t\t\t\tlet renderTarget = cubeUVmaps.get( texture );\n\n\t\t\t\tconst currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;\n\n\t\t\t\tif ( texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion ) {\n\n\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\n\n\t\t\t\t\trenderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );\n\t\t\t\t\trenderTarget.texture.pmremVersion = texture.pmremVersion;\n\n\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\n\n\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( renderTarget !== undefined ) {\n\n\t\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {\n\n\t\t\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\n\n\t\t\t\t\t\t\trenderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );\n\t\t\t\t\t\t\trenderTarget.texture.pmremVersion = texture.pmremVersion;\n\n\t\t\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction isCubeTextureComplete( image ) {\n\n\t\tlet count = 0;\n\t\tconst length = 6;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t\t}\n\n\t\treturn count === length;\n\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemapUV = cubeUVmaps.get( texture );\n\n\t\tif ( cubemapUV !== undefined ) {\n\n\t\t\tcubeUVmaps.delete( texture );\n\t\t\tcubemapUV.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubeUVmaps = new WeakMap();\n\n\t\tif ( pmremGenerator !== null ) {\n\n\t\t\tpmremGenerator.dispose();\n\t\t\tpmremGenerator = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction WebGLExtensions( gl ) {\n\n\tconst extensions = {};\n\n\tfunction getExtension( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tlet extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t}\n\n\treturn {\n\n\t\thas: function ( name ) {\n\n\t\t\treturn getExtension( name ) !== null;\n\n\t\t},\n\n\t\tinit: function () {\n\n\t\t\tgetExtension( 'EXT_color_buffer_float' );\n\t\t\tgetExtension( 'WEBGL_clip_cull_distance' );\n\t\t\tgetExtension( 'OES_texture_float_linear' );\n\t\t\tgetExtension( 'EXT_color_buffer_half_float' );\n\t\t\tgetExtension( 'WEBGL_multisampled_render_to_texture' );\n\t\t\tgetExtension( 'WEBGL_render_shared_exponent' );\n\n\t\t},\n\n\t\tget: function ( name ) {\n\n\t\t\tconst extension = getExtension( name );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\twarnOnce( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t}\n\n\t\t\treturn extension;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLGeometries( gl, attributes, info, bindingStates ) {\n\n\tconst geometries = {};\n\tconst wireframeAttributes = new WeakMap();\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tconst geometry = event.target;\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\tattributes.remove( geometry.index );\n\n\t\t}\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tattributes.remove( geometry.attributes[ name ] );\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tconst array = geometry.morphAttributes[ name ];\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.remove( array[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\tconst attribute = wireframeAttributes.get( geometry );\n\n\t\tif ( attribute ) {\n\n\t\t\tattributes.remove( attribute );\n\t\t\twireframeAttributes.delete( geometry );\n\n\t\t}\n\n\t\tbindingStates.releaseStatesOfGeometry( geometry );\n\n\t\tif ( geometry.isInstancedBufferGeometry === true ) {\n\n\t\t\tdelete geometry._maxInstanceCount;\n\n\t\t}\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction get( object, geometry ) {\n\n\t\tif ( geometries[ geometry.id ] === true ) return geometry;\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tgeometries[ geometry.id ] = true;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction update( geometry ) {\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates.\n\n\t\tfor ( const name in geometryAttributes ) {\n\n\t\t\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = morphAttributes[ name ];\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateWireframeAttribute( geometry ) {\n\n\t\tconst indices = [];\n\n\t\tconst geometryIndex = geometry.index;\n\t\tconst geometryPosition = geometry.attributes.position;\n\t\tlet version = 0;\n\n\t\tif ( geometryIndex !== null ) {\n\n\t\t\tconst array = geometryIndex.array;\n\t\t\tversion = geometryIndex.version;\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = array[ i + 0 ];\n\t\t\t\tconst b = array[ i + 1 ];\n\t\t\t\tconst c = array[ i + 2 ];\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else if ( geometryPosition !== undefined ) {\n\n\t\t\tconst array = geometryPosition.array;\n\t\t\tversion = geometryPosition.version;\n\n\t\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tconst a = i + 0;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\t\tattribute.version = version;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates\n\n\t\t//\n\n\t\tconst previousAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( previousAttribute ) attributes.remove( previousAttribute );\n\n\t\t//\n\n\t\twireframeAttributes.set( geometry, attribute );\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tconst currentAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( currentAttribute ) {\n\n\t\t\tconst geometryIndex = geometry.index;\n\n\t\t\tif ( geometryIndex !== null ) {\n\n\t\t\t\t// if the attribute is obsolete, create a new one\n\n\t\t\t\tif ( currentAttribute.version < geometryIndex.version ) {\n\n\t\t\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t}\n\n\t\treturn wireframeAttributes.get( geometry );\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tupdate: update,\n\n\t\tgetWireframeAttribute: getWireframeAttribute\n\n\t};\n\n}\n\nfunction WebGLIndexedBufferRenderer( gl, extensions, info ) {\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tlet type, bytesPerElement;\n\n\tfunction setIndex( value ) {\n\n\t\ttype = value.type;\n\t\tbytesPerElement = value.bytesPerElement;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tgl.drawElementsInstanced( mode, count, type, start * bytesPerElement, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\tfunction renderMultiDraw( starts, counts, drawCount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.render( starts[ i ] / bytesPerElement, counts[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\textension.multiDrawElementsWEBGL( mode, counts, 0, type, starts, 0, drawCount );\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\tfunction renderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < starts.length; i ++ ) {\n\n\t\t\t\trenderInstances( starts[ i ] / bytesPerElement, counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\textension.multiDrawElementsInstancedWEBGL( mode, counts, 0, type, starts, 0, primcount, 0, drawCount );\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < primcount.length; i ++ ) {\n\n\t\t\t\tinfo.update( elementCount, mode, primcount[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\tthis.renderMultiDraw = renderMultiDraw;\n\tthis.renderMultiDrawInstances = renderMultiDrawInstances;\n\n}\n\nfunction WebGLInfo( gl ) {\n\n\tconst memory = {\n\t\tgeometries: 0,\n\t\ttextures: 0\n\t};\n\n\tconst render = {\n\t\tframe: 0,\n\t\tcalls: 0,\n\t\ttriangles: 0,\n\t\tpoints: 0,\n\t\tlines: 0\n\t};\n\n\tfunction update( count, mode, instanceCount ) {\n\n\t\trender.calls ++;\n\n\t\tswitch ( mode ) {\n\n\t\t\tcase gl.TRIANGLES:\n\t\t\t\trender.triangles += instanceCount * ( count / 3 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINES:\n\t\t\t\trender.lines += instanceCount * ( count / 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINE_STRIP:\n\t\t\t\trender.lines += instanceCount * ( count - 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINE_LOOP:\n\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tcase gl.POINTS:\n\t\t\t\trender.points += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\trender.calls = 0;\n\t\trender.triangles = 0;\n\t\trender.points = 0;\n\t\trender.lines = 0;\n\n\t}\n\n\treturn {\n\t\tmemory: memory,\n\t\trender: render,\n\t\tprograms: null,\n\t\tautoReset: true,\n\t\treset: reset,\n\t\tupdate: update\n\t};\n\n}\n\nfunction WebGLMorphtargets( gl, capabilities, textures ) {\n\n\tconst morphTextures = new WeakMap();\n\tconst morph = new Vector4();\n\n\tfunction update( object, geometry, program ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\t// the following encodes morph targets into an array of data textures. Each layer represents a single morph target.\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\tlet entry = morphTextures.get( geometry );\n\n\t\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\t\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\t\t\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\t\tlet vertexDataCount = 0;\n\n\t\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\t\tlet height = 1;\n\n\t\t\tif ( width > capabilities.maxTextureSize ) {\n\n\t\t\t\theight = Math.ceil( width / capabilities.maxTextureSize );\n\t\t\t\twidth = capabilities.maxTextureSize;\n\n\t\t\t}\n\n\t\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\t\tconst texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\t\ttexture.type = FloatType;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\t// fill buffer\n\n\t\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t\tmorph.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\t\tbuffer[ offset + stride + 0 ] = morph.x;\n\t\t\t\t\t\tbuffer[ offset + stride + 1 ] = morph.y;\n\t\t\t\t\t\tbuffer[ offset + stride + 2 ] = morph.z;\n\t\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t\tmorph.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\t\tbuffer[ offset + stride + 4 ] = morph.x;\n\t\t\t\t\t\tbuffer[ offset + stride + 5 ] = morph.y;\n\t\t\t\t\t\tbuffer[ offset + stride + 6 ] = morph.z;\n\t\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t\tmorph.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\t\tbuffer[ offset + stride + 8 ] = morph.x;\n\t\t\t\t\t\tbuffer[ offset + stride + 9 ] = morph.y;\n\t\t\t\t\t\tbuffer[ offset + stride + 10 ] = morph.z;\n\t\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tentry = {\n\t\t\t\tcount: morphTargetsCount,\n\t\t\t\ttexture: texture,\n\t\t\t\tsize: new Vector2( width, height )\n\t\t\t};\n\n\t\t\tmorphTextures.set( geometry, entry );\n\n\t\t\tfunction disposeTexture() {\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t\tmorphTextures.delete( geometry );\n\n\t\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t\t}\n\n\t\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\t//\n\t\tif ( object.isInstancedMesh === true && object.morphTexture !== null ) {\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTexture', object.morphTexture, textures );\n\n\t\t} else {\n\n\t\t\tlet morphInfluencesSum = 0;\n\n\t\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t\t}\n\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );\n\n\t\t}\n\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\nfunction WebGLObjects( gl, geometries, attributes, info ) {\n\n\tlet updateMap = new WeakMap();\n\n\tfunction update( object ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\tconst geometry = object.geometry;\n\t\tconst buffergeometry = geometries.get( object, geometry );\n\n\t\t// Update once per frame\n\n\t\tif ( updateMap.get( buffergeometry ) !== frame ) {\n\n\t\t\tgeometries.update( buffergeometry );\n\n\t\t\tupdateMap.set( buffergeometry, frame );\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh ) {\n\n\t\t\tif ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {\n\n\t\t\t\tobject.addEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\t\t}\n\n\t\t\tif ( updateMap.get( object ) !== frame ) {\n\n\t\t\t\tattributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );\n\n\t\t\t\tif ( object.instanceColor !== null ) {\n\n\t\t\t\t\tattributes.update( object.instanceColor, gl.ARRAY_BUFFER );\n\n\t\t\t\t}\n\n\t\t\t\tupdateMap.set( object, frame );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tconst skeleton = object.skeleton;\n\n\t\t\tif ( updateMap.get( skeleton ) !== frame ) {\n\n\t\t\t\tskeleton.update();\n\n\t\t\t\tupdateMap.set( skeleton, frame );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tupdateMap = new WeakMap();\n\n\t}\n\n\tfunction onInstancedMeshDispose( event ) {\n\n\t\tconst instancedMesh = event.target;\n\n\t\tinstancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\tattributes.remove( instancedMesh.instanceMatrix );\n\n\t\tif ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update,\n\t\tdispose: dispose\n\n\t};\n\n}\n\nclass DepthTexture extends Texture {\n\n\tconstructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat ) {\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t\t}\n\n\t\tif ( type === undefined && format === DepthFormat ) type = UnsignedIntType;\n\t\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isDepthTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.compareFunction = null;\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.compareFunction = source.compareFunction;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [textures] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'textures' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (textures factorizations):\n *\n * .upload( gl, seq, values, textures )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (textures factorizations):\n *\n * .setValue( gl, name, value, textures )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\n\nconst emptyTexture = /*@__PURE__*/ new Texture();\n\nconst emptyShadowTexture = /*@__PURE__*/ new DepthTexture( 1, 1 );\nemptyShadowTexture.compareFunction = LessEqualCompare;\n\nconst emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();\nconst empty3dTexture = /*@__PURE__*/ new Data3DTexture();\nconst emptyCubeTexture = /*@__PURE__*/ new CubeTexture();\n\n// --- Utilities ---\n\n// Array Caches (provide typed arrays for temporary by size)\n\nconst arrayCacheF32 = [];\nconst arrayCacheI32 = [];\n\n// Float32Array caches used for uploading Matrix uniforms\n\nconst mat4array = new Float32Array( 16 );\nconst mat3array = new Float32Array( 9 );\nconst mat2array = new Float32Array( 4 );\n\n// Flattening for arrays of vectors and matrices\n\nfunction flatten( array, nBlocks, blockSize ) {\n\n\tconst firstElem = array[ 0 ];\n\n\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t// unoptimized: ! isNaN( firstElem )\n\t// see http://jacksondunstan.com/articles/983\n\n\tconst n = nBlocks * blockSize;\n\tlet r = arrayCacheF32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Float32Array( n );\n\t\tarrayCacheF32[ n ] = r;\n\n\t}\n\n\tif ( nBlocks !== 0 ) {\n\n\t\tfirstElem.toArray( r, 0 );\n\n\t\tfor ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\toffset += blockSize;\n\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t}\n\n\t}\n\n\treturn r;\n\n}\n\nfunction arraysEqual( a, b ) {\n\n\tif ( a.length !== b.length ) return false;\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction copyArray( a, b ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ i ] = b[ i ];\n\n\t}\n\n}\n\n// Texture unit allocation\n\nfunction allocTexUnits( textures, n ) {\n\n\tlet r = arrayCacheI32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Int32Array( n );\n\t\tarrayCacheI32[ n ] = r;\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\tr[ i ] = textures.allocateTextureUnit();\n\n\t}\n\n\treturn r;\n\n}\n\n// --- Setters ---\n\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n\n// Single scalar\n\nfunction setValueV1f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1f( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single float vector (from flat array or THREE.VectorN)\n\nfunction setValueV2f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2f( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else if ( v.r !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {\n\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\n\t\t\tcache[ 0 ] = v.r;\n\t\t\tcache[ 1 ] = v.g;\n\t\t\tcache[ 2 ] = v.b;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single matrix (from flat array or THREE.MatrixN)\n\nfunction setValueM2( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat2array.set( elements );\n\n\t\tgl.uniformMatrix2fv( this.addr, false, mat2array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM3( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat3array.set( elements );\n\n\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM4( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat4array.set( elements );\n\n\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\n// Single integer / boolean\n\nfunction setValueV1i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1i( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single integer / boolean vector (from flat array or THREE.VectorN)\n\nfunction setValueV2i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2i( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3i( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4i( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single unsigned integer\n\nfunction setValueV1ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1ui( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single unsigned integer vector (from flat array or THREE.VectorN)\n\nfunction setValueV2ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2ui( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3ui( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n\n// Single texture (2D / Cube)\n\nfunction setValueT1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\tconst emptyTexture2D = ( this.type === gl.SAMPLER_2D_SHADOW ) ? emptyShadowTexture : emptyTexture;\n\n\ttextures.setTexture2D( v || emptyTexture2D, unit );\n\n}\n\nfunction setValueT3D1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture3D( v || empty3dTexture, unit );\n\n}\n\nfunction setValueT6( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTextureCube( v || emptyCubeTexture, unit );\n\n}\n\nfunction setValueT2DArray1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture2DArray( v || emptyArrayTexture, unit );\n\n}\n\n// Helper to pick the right setter for the singular case\n\nfunction getSingularSetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1f; // FLOAT\n\t\tcase 0x8b50: return setValueV2f; // _VEC2\n\t\tcase 0x8b51: return setValueV3f; // _VEC3\n\t\tcase 0x8b52: return setValueV4f; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2; // _MAT2\n\t\tcase 0x8b5b: return setValueM3; // _MAT3\n\t\tcase 0x8b5c: return setValueM4; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2i; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3i; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4i; // _VEC4\n\n\t\tcase 0x1405: return setValueV1ui; // UINT\n\t\tcase 0x8dc6: return setValueV2ui; // _VEC2\n\t\tcase 0x8dc7: return setValueV3ui; // _VEC3\n\t\tcase 0x8dc8: return setValueV4ui; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1;\n\n\t\tcase 0x8b5f: // SAMPLER_3D\n\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\t\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n\t\t\treturn setValueT3D1;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6;\n\n\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n\t\t\treturn setValueT2DArray1;\n\n\t}\n\n}\n\n\n// Array of scalars\n\nfunction setValueV1fArray( gl, v ) {\n\n\tgl.uniform1fv( this.addr, v );\n\n}\n\n// Array of vectors (from flat array or array of THREE.VectorN)\n\nfunction setValueV2fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 2 );\n\n\tgl.uniform2fv( this.addr, data );\n\n}\n\nfunction setValueV3fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 3 );\n\n\tgl.uniform3fv( this.addr, data );\n\n}\n\nfunction setValueV4fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniform4fv( this.addr, data );\n\n}\n\n// Array of matrices (from flat array or array of THREE.MatrixN)\n\nfunction setValueM2Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniformMatrix2fv( this.addr, false, data );\n\n}\n\nfunction setValueM3Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 9 );\n\n\tgl.uniformMatrix3fv( this.addr, false, data );\n\n}\n\nfunction setValueM4Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 16 );\n\n\tgl.uniformMatrix4fv( this.addr, false, data );\n\n}\n\n// Array of integer / boolean\n\nfunction setValueV1iArray( gl, v ) {\n\n\tgl.uniform1iv( this.addr, v );\n\n}\n\n// Array of integer / boolean vectors (from flat array)\n\nfunction setValueV2iArray( gl, v ) {\n\n\tgl.uniform2iv( this.addr, v );\n\n}\n\nfunction setValueV3iArray( gl, v ) {\n\n\tgl.uniform3iv( this.addr, v );\n\n}\n\nfunction setValueV4iArray( gl, v ) {\n\n\tgl.uniform4iv( this.addr, v );\n\n}\n\n// Array of unsigned integer\n\nfunction setValueV1uiArray( gl, v ) {\n\n\tgl.uniform1uiv( this.addr, v );\n\n}\n\n// Array of unsigned integer vectors (from flat array)\n\nfunction setValueV2uiArray( gl, v ) {\n\n\tgl.uniform2uiv( this.addr, v );\n\n}\n\nfunction setValueV3uiArray( gl, v ) {\n\n\tgl.uniform3uiv( this.addr, v );\n\n}\n\nfunction setValueV4uiArray( gl, v ) {\n\n\tgl.uniform4uiv( this.addr, v );\n\n}\n\n\n// Array of textures (2D / 3D / Cube / 2DArray)\n\nfunction setValueT1Array( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT3DArray( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT6Array( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT2DArrayArray( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );\n\n\t}\n\n}\n\n\n// Helper to pick the right setter for a pure (bottom-level) array\n\nfunction getPureArraySetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1fArray; // FLOAT\n\t\tcase 0x8b50: return setValueV2fArray; // _VEC2\n\t\tcase 0x8b51: return setValueV3fArray; // _VEC3\n\t\tcase 0x8b52: return setValueV4fArray; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2Array; // _MAT2\n\t\tcase 0x8b5b: return setValueM3Array; // _MAT3\n\t\tcase 0x8b5c: return setValueM4Array; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4\n\n\t\tcase 0x1405: return setValueV1uiArray; // UINT\n\t\tcase 0x8dc6: return setValueV2uiArray; // _VEC2\n\t\tcase 0x8dc7: return setValueV3uiArray; // _VEC3\n\t\tcase 0x8dc8: return setValueV4uiArray; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1Array;\n\n\t\tcase 0x8b5f: // SAMPLER_3D\n\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\t\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n\t\t\treturn setValueT3DArray;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6Array;\n\n\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n\t\t\treturn setValueT2DArrayArray;\n\n\t}\n\n}\n\n// --- Uniform Classes ---\n\nclass SingleUniform {\n\n\tconstructor( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.type = activeInfo.type;\n\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n}\n\nclass PureArrayUniform {\n\n\tconstructor( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.type = activeInfo.type;\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n}\n\nclass StructuredUniform {\n\n\tconstructor( id ) {\n\n\t\tthis.id = id;\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t}\n\n\tsetValue( gl, value, textures ) {\n\n\t\tconst seq = this.seq;\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ], textures );\n\n\t\t}\n\n\t}\n\n}\n\n// --- Top-level ---\n\n// Parser - builds up the property tree from the path strings\n\nconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g;\n\n// extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform( container, uniformObject ) {\n\n\tcontainer.seq.push( uniformObject );\n\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n}\n\nfunction parseUniform( activeInfo, addr, container ) {\n\n\tconst path = activeInfo.name,\n\t\tpathLength = path.length;\n\n\t// reset RegExp object, because of the early exit of a previous run\n\tRePathPart.lastIndex = 0;\n\n\twhile ( true ) {\n\n\t\tconst match = RePathPart.exec( path ),\n\t\t\tmatchEnd = RePathPart.lastIndex;\n\n\t\tlet id = match[ 1 ];\n\t\tconst idIsIndex = match[ 2 ] === ']',\n\t\t\tsubscript = match[ 3 ];\n\n\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\n\n\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\tconst map = container.map;\n\t\t\tlet next = map[ id ];\n\n\t\t\tif ( next === undefined ) {\n\n\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\taddUniform( container, next );\n\n\t\t\t}\n\n\t\t\tcontainer = next;\n\n\t\t}\n\n\t}\n\n}\n\n// Root Container\n\nclass WebGLUniforms {\n\n\tconstructor( gl, program ) {\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t\tconst n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\tfor ( let i = 0; i < n; ++ i ) {\n\n\t\t\tconst info = gl.getActiveUniform( program, i ),\n\t\t\t\taddr = gl.getUniformLocation( program, info.name );\n\n\t\t\tparseUniform( info, addr, this );\n\n\t\t}\n\n\t}\n\n\tsetValue( gl, name, value, textures ) {\n\n\t\tconst u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, textures );\n\n\t}\n\n\tsetOptional( gl, object, name ) {\n\n\t\tconst v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t}\n\n\tstatic upload( gl, seq, values, textures ) {\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\t\tu.setValue( gl, v.value, textures );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic seqWithValue( seq, values ) {\n\n\t\tconst r = [];\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t}\n\n}\n\nfunction WebGLShader( gl, type, string ) {\n\n\tconst shader = gl.createShader( type );\n\n\tgl.shaderSource( shader, string );\n\tgl.compileShader( shader );\n\n\treturn shader;\n\n}\n\n// From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/\nconst COMPLETION_STATUS_KHR = 0x91B1;\n\nlet programIdCount = 0;\n\nfunction handleSource( string, errorLine ) {\n\n\tconst lines = string.split( '\\n' );\n\tconst lines2 = [];\n\n\tconst from = Math.max( errorLine - 6, 0 );\n\tconst to = Math.min( errorLine + 6, lines.length );\n\n\tfor ( let i = from; i < to; i ++ ) {\n\n\t\tconst line = i + 1;\n\t\tlines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );\n\n\t}\n\n\treturn lines2.join( '\\n' );\n\n}\n\nfunction getEncodingComponents( colorSpace ) {\n\n\tconst workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );\n\tconst encodingPrimaries = ColorManagement.getPrimaries( colorSpace );\n\n\tlet gamutMapping;\n\n\tif ( workingPrimaries === encodingPrimaries ) {\n\n\t\tgamutMapping = '';\n\n\t} else if ( workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries ) {\n\n\t\tgamutMapping = 'LinearDisplayP3ToLinearSRGB';\n\n\t} else if ( workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries ) {\n\n\t\tgamutMapping = 'LinearSRGBToLinearDisplayP3';\n\n\t}\n\n\tswitch ( colorSpace ) {\n\n\t\tcase LinearSRGBColorSpace:\n\t\tcase LinearDisplayP3ColorSpace:\n\t\t\treturn [ gamutMapping, 'LinearTransferOETF' ];\n\n\t\tcase SRGBColorSpace:\n\t\tcase DisplayP3ColorSpace:\n\t\t\treturn [ gamutMapping, 'sRGBTransferOETF' ];\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported color space:', colorSpace );\n\t\t\treturn [ gamutMapping, 'LinearTransferOETF' ];\n\n\t}\n\n}\n\nfunction getShaderErrors( gl, shader, type ) {\n\n\tconst status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );\n\tconst errors = gl.getShaderInfoLog( shader ).trim();\n\n\tif ( status && errors === '' ) return '';\n\n\tconst errorMatches = /ERROR: 0:(\\d+)/.exec( errors );\n\tif ( errorMatches ) {\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\tconst errorLine = parseInt( errorMatches[ 1 ] );\n\t\treturn type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + handleSource( gl.getShaderSource( shader ), errorLine );\n\n\t} else {\n\n\t\treturn errors;\n\n\t}\n\n}\n\nfunction getTexelEncodingFunction( functionName, colorSpace ) {\n\n\tconst components = getEncodingComponents( colorSpace );\n\treturn `vec4 ${functionName}( vec4 value ) { return ${components[ 0 ]}( ${components[ 1 ]}( value ) ); }`;\n\n}\n\nfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\tlet toneMappingName;\n\n\tswitch ( toneMapping ) {\n\n\t\tcase LinearToneMapping:\n\t\t\ttoneMappingName = 'Linear';\n\t\t\tbreak;\n\n\t\tcase ReinhardToneMapping:\n\t\t\ttoneMappingName = 'Reinhard';\n\t\t\tbreak;\n\n\t\tcase CineonToneMapping:\n\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\tbreak;\n\n\t\tcase ACESFilmicToneMapping:\n\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\tbreak;\n\n\t\tcase AgXToneMapping:\n\t\t\ttoneMappingName = 'AgX';\n\t\t\tbreak;\n\n\t\tcase NeutralToneMapping:\n\t\t\ttoneMappingName = 'Neutral';\n\t\t\tbreak;\n\n\t\tcase CustomToneMapping:\n\t\t\ttoneMappingName = 'Custom';\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );\n\t\t\ttoneMappingName = 'Linear';\n\n\t}\n\n\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\n}\n\nfunction generateVertexExtensions( parameters ) {\n\n\tconst chunks = [\n\t\tparameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',\n\t\tparameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',\n\t];\n\n\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n}\n\nfunction generateDefines( defines ) {\n\n\tconst chunks = [];\n\n\tfor ( const name in defines ) {\n\n\t\tconst value = defines[ name ];\n\n\t\tif ( value === false ) continue;\n\n\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t}\n\n\treturn chunks.join( '\\n' );\n\n}\n\nfunction fetchAttributeLocations( gl, program ) {\n\n\tconst attributes = {};\n\n\tconst n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\tfor ( let i = 0; i < n; i ++ ) {\n\n\t\tconst info = gl.getActiveAttrib( program, i );\n\t\tconst name = info.name;\n\n\t\tlet locationSize = 1;\n\t\tif ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;\n\t\tif ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;\n\t\tif ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;\n\n\t\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\tattributes[ name ] = {\n\t\t\ttype: info.type,\n\t\t\tlocation: gl.getAttribLocation( program, name ),\n\t\t\tlocationSize: locationSize\n\t\t};\n\n\t}\n\n\treturn attributes;\n\n}\n\nfunction filterEmptyLine( string ) {\n\n\treturn string !== '';\n\n}\n\nfunction replaceLightNums( string, parameters ) {\n\n\tconst numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;\n\n\treturn string\n\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )\n\t\t.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )\n\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )\n\t\t.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )\n\t\t.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )\n\t\t.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )\n\t\t.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );\n\n}\n\nfunction replaceClippingPlaneNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\n\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\n\n}\n\n// Resolve Includes\n\nconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\nfunction resolveIncludes( string ) {\n\n\treturn string.replace( includePattern, includeReplacer );\n\n}\n\nconst shaderChunkMap = new Map();\n\nfunction includeReplacer( match, include ) {\n\n\tlet string = ShaderChunk[ include ];\n\n\tif ( string === undefined ) {\n\n\t\tconst newInclude = shaderChunkMap.get( include );\n\n\t\tif ( newInclude !== undefined ) {\n\n\t\t\tstring = ShaderChunk[ newInclude ];\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Shader chunk \"%s\" has been deprecated. Use \"%s\" instead.', include, newInclude );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t}\n\n\t}\n\n\treturn resolveIncludes( string );\n\n}\n\n// Unroll Loops\n\nconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\nfunction unrollLoops( string ) {\n\n\treturn string.replace( unrollLoopPattern, loopReplacer );\n\n}\n\nfunction loopReplacer( match, start, end, snippet ) {\n\n\tlet string = '';\n\n\tfor ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\tstring += snippet\n\t\t\t.replace( /\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]' )\n\t\t\t.replace( /UNROLLED_LOOP_INDEX/g, i );\n\n\t}\n\n\treturn string;\n\n}\n\n//\n\nfunction generatePrecision( parameters ) {\n\n\tlet precisionstring = `precision ${parameters.precision} float;\n\tprecision ${parameters.precision} int;\n\tprecision ${parameters.precision} sampler2D;\n\tprecision ${parameters.precision} samplerCube;\n\tprecision ${parameters.precision} sampler3D;\n\tprecision ${parameters.precision} sampler2DArray;\n\tprecision ${parameters.precision} sampler2DShadow;\n\tprecision ${parameters.precision} samplerCubeShadow;\n\tprecision ${parameters.precision} sampler2DArrayShadow;\n\tprecision ${parameters.precision} isampler2D;\n\tprecision ${parameters.precision} isampler3D;\n\tprecision ${parameters.precision} isamplerCube;\n\tprecision ${parameters.precision} isampler2DArray;\n\tprecision ${parameters.precision} usampler2D;\n\tprecision ${parameters.precision} usampler3D;\n\tprecision ${parameters.precision} usamplerCube;\n\tprecision ${parameters.precision} usampler2DArray;\n\t`;\n\n\tif ( parameters.precision === 'highp' ) {\n\n\t\tprecisionstring += '\\n#define HIGH_PRECISION';\n\n\t} else if ( parameters.precision === 'mediump' ) {\n\n\t\tprecisionstring += '\\n#define MEDIUM_PRECISION';\n\n\t} else if ( parameters.precision === 'lowp' ) {\n\n\t\tprecisionstring += '\\n#define LOW_PRECISION';\n\n\t}\n\n\treturn precisionstring;\n\n}\n\nfunction generateShadowMapTypeDefine( parameters ) {\n\n\tlet shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t} else if ( parameters.shadowMapType === VSMShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n\n\t}\n\n\treturn shadowMapTypeDefine;\n\n}\n\nfunction generateEnvMapTypeDefine( parameters ) {\n\n\tlet envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase CubeReflectionMapping:\n\t\t\tcase CubeRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\tbreak;\n\n\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapTypeDefine;\n\n}\n\nfunction generateEnvMapModeDefine( parameters ) {\n\n\tlet envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase CubeRefractionMapping:\n\n\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapModeDefine;\n\n}\n\nfunction generateEnvMapBlendingDefine( parameters ) {\n\n\tlet envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.combine ) {\n\n\t\t\tcase MultiplyOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\tbreak;\n\n\t\t\tcase MixOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\tbreak;\n\n\t\t\tcase AddOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapBlendingDefine;\n\n}\n\nfunction generateCubeUVSize( parameters ) {\n\n\tconst imageHeight = parameters.envMapCubeUVHeight;\n\n\tif ( imageHeight === null ) return null;\n\n\tconst maxMip = Math.log2( imageHeight ) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\treturn { texelWidth, texelHeight, maxMip };\n\n}\n\nfunction WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {\n\n\t// TODO Send this event to Three.js DevTools\n\t// console.log( 'WebGLProgram', cacheKey );\n\n\tconst gl = renderer.getContext();\n\n\tconst defines = parameters.defines;\n\n\tlet vertexShader = parameters.vertexShader;\n\tlet fragmentShader = parameters.fragmentShader;\n\n\tconst shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );\n\tconst envMapTypeDefine = generateEnvMapTypeDefine( parameters );\n\tconst envMapModeDefine = generateEnvMapModeDefine( parameters );\n\tconst envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );\n\tconst envMapCubeUVSize = generateCubeUVSize( parameters );\n\n\tconst customVertexExtensions = generateVertexExtensions( parameters );\n\n\tconst customDefines = generateDefines( defines );\n\n\tconst program = gl.createProgram();\n\n\tlet prefixVertex, prefixFragment;\n\tlet versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\\n' : '';\n\n\tif ( parameters.isRawShaderMaterial ) {\n\n\t\tprefixVertex = [\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixVertex.length > 0 ) {\n\n\t\t\tprefixVertex += '\\n';\n\n\t\t}\n\n\t\tprefixFragment = [\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixFragment.length > 0 ) {\n\n\t\t\tprefixFragment += '\\n';\n\n\t\t}\n\n\t} else {\n\n\t\tprefixVertex = [\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',\n\t\t\tparameters.batching ? '#define USE_BATCHING' : '',\n\t\t\tparameters.batchingColor ? '#define USE_BATCHING_COLOR' : '',\n\t\t\tparameters.instancing ? '#define USE_INSTANCING' : '',\n\t\t\tparameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',\n\t\t\tparameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',\n\n\t\t\tparameters.useFog && parameters.fog ? '#define USE_FOG' : '',\n\t\t\tparameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\tparameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',\n\t\t\tparameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',\n\t\t\tparameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\n\t\t\tparameters.anisotropy ? '#define USE_ANISOTROPY' : '',\n\t\t\tparameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',\n\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\n\t\t\tparameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',\n\t\t\tparameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',\n\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',\n\t\t\tparameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',\n\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.alphaHash ? '#define USE_ALPHAHASH' : '',\n\n\t\t\tparameters.transmission ? '#define USE_TRANSMISSION' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\t\t\tparameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n\t\t\tparameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',\n\t\t\tparameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',\n\n\t\t\t//\n\n\t\t\tparameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',\n\t\t\tparameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',\n\t\t\tparameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',\n\t\t\tparameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',\n\t\t\tparameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',\n\t\t\tparameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',\n\t\t\tparameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',\n\t\t\tparameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',\n\n\t\t\tparameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',\n\t\t\tparameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',\n\n\t\t\tparameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',\n\n\t\t\tparameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',\n\t\t\tparameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',\n\t\t\tparameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',\n\n\t\t\tparameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',\n\t\t\tparameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',\n\n\t\t\tparameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',\n\t\t\tparameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',\n\n\t\t\tparameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',\n\t\t\tparameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',\n\t\t\tparameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',\n\n\t\t\tparameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',\n\t\t\tparameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',\n\n\t\t\t//\n\n\t\t\tparameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUv1s ? '#define USE_UV1' : '',\n\t\t\tparameters.vertexUv2s ? '#define USE_UV2' : '',\n\t\t\tparameters.vertexUv3s ? '#define USE_UV3' : '',\n\n\t\t\tparameters.pointsUvs ? '#define USE_POINTS_UV' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\n\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t( parameters.morphColors ) ? '#define USE_MORPHCOLORS' : '',\n\t\t\t( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',\n\t\t\t( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\tparameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\n\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t'#ifdef USE_INSTANCING',\n\n\t\t\t'\tattribute mat4 instanceMatrix;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_INSTANCING_COLOR',\n\n\t\t\t'\tattribute vec3 instanceColor;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_INSTANCING_MORPH',\n\n\t\t\t'\tuniform sampler2D morphTexture;',\n\n\t\t\t'#endif',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec3 normal;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'#ifdef USE_UV1',\n\n\t\t\t'\tattribute vec2 uv1;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_UV2',\n\n\t\t\t'\tattribute vec2 uv2;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_UV3',\n\n\t\t\t'\tattribute vec2 uv3;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_TANGENT',\n\n\t\t\t'\tattribute vec4 tangent;',\n\n\t\t\t'#endif',\n\n\t\t\t'#if defined( USE_COLOR_ALPHA )',\n\n\t\t\t'\tattribute vec4 color;',\n\n\t\t\t'#elif defined( USE_COLOR )',\n\n\t\t\t'\tattribute vec3 color;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t'#endif',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tprefixFragment = [\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.useFog && parameters.fog ? '#define USE_FOG' : '',\n\t\t\tparameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.matcap ? '#define USE_MATCAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\tparameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',\n\t\t\tparameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\n\t\t\tparameters.anisotropy ? '#define USE_ANISOTROPY' : '',\n\t\t\tparameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',\n\n\t\t\tparameters.clearcoat ? '#define USE_CLEARCOAT' : '',\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\n\t\t\tparameters.dispersion ? '#define USE_DISPERSION' : '',\n\n\t\t\tparameters.iridescence ? '#define USE_IRIDESCENCE' : '',\n\t\t\tparameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',\n\t\t\tparameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',\n\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',\n\t\t\tparameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',\n\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.alphaTest ? '#define USE_ALPHATEST' : '',\n\t\t\tparameters.alphaHash ? '#define USE_ALPHAHASH' : '',\n\n\t\t\tparameters.sheen ? '#define USE_SHEEN' : '',\n\t\t\tparameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',\n\t\t\tparameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',\n\n\t\t\tparameters.transmission ? '#define USE_TRANSMISSION' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\t\t\tparameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n\t\t\tparameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUv1s ? '#define USE_UV1' : '',\n\t\t\tparameters.vertexUv2s ? '#define USE_UV2' : '',\n\t\t\tparameters.vertexUv3s ? '#define USE_UV3' : '',\n\n\t\t\tparameters.pointsUvs ? '#define USE_POINTS_UV' : '',\n\n\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\n\t\t\tparameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',\n\n\t\t\tparameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\n\n\t\t\tparameters.dithering ? '#define DITHERING' : '',\n\t\t\tparameters.opaque ? '#define OPAQUE' : '',\n\n\t\t\tShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tgetTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),\n\n\t\t\tparameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tvertexShader = resolveIncludes( vertexShader );\n\tvertexShader = replaceLightNums( vertexShader, parameters );\n\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\n\n\tfragmentShader = resolveIncludes( fragmentShader );\n\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\n\n\tvertexShader = unrollLoops( vertexShader );\n\tfragmentShader = unrollLoops( fragmentShader );\n\n\tif ( parameters.isRawShaderMaterial !== true ) {\n\n\t\t// GLSL 3.0 conversion for built-in materials and ShaderMaterial\n\n\t\tversionString = '#version 300 es\\n';\n\n\t\tprefixVertex = [\n\t\t\tcustomVertexExtensions,\n\t\t\t'#define attribute in',\n\t\t\t'#define varying out',\n\t\t\t'#define texture2D texture'\n\t\t].join( '\\n' ) + '\\n' + prefixVertex;\n\n\t\tprefixFragment = [\n\t\t\t'#define varying in',\n\t\t\t( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',\n\t\t\t( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',\n\t\t\t'#define gl_FragDepthEXT gl_FragDepth',\n\t\t\t'#define texture2D texture',\n\t\t\t'#define textureCube texture',\n\t\t\t'#define texture2DProj textureProj',\n\t\t\t'#define texture2DLodEXT textureLod',\n\t\t\t'#define texture2DProjLodEXT textureProjLod',\n\t\t\t'#define textureCubeLodEXT textureLod',\n\t\t\t'#define texture2DGradEXT textureGrad',\n\t\t\t'#define texture2DProjGradEXT textureProjGrad',\n\t\t\t'#define textureCubeGradEXT textureGrad'\n\t\t].join( '\\n' ) + '\\n' + prefixFragment;\n\n\t}\n\n\tconst vertexGlsl = versionString + prefixVertex + vertexShader;\n\tconst fragmentGlsl = versionString + prefixFragment + fragmentShader;\n\n\t// console.log( '*VERTEX*', vertexGlsl );\n\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\tconst glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\tconst glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\tgl.attachShader( program, glVertexShader );\n\tgl.attachShader( program, glFragmentShader );\n\n\t// Force a particular attribute to index 0.\n\n\tif ( parameters.index0AttributeName !== undefined ) {\n\n\t\tgl.bindAttribLocation( program, 0, parameters.index0AttributeName );\n\n\t} else if ( parameters.morphTargets === true ) {\n\n\t\t// programs with morphTargets displace position out of attribute 0\n\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t}\n\n\tgl.linkProgram( program );\n\n\tfunction onFirstUse( self ) {\n\n\t\t// check for link errors\n\t\tif ( renderer.debug.checkShaderErrors ) {\n\n\t\t\tconst programLog = gl.getProgramInfoLog( program ).trim();\n\t\t\tconst vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\n\t\t\tconst fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\n\n\t\t\tlet runnable = true;\n\t\t\tlet haveDiagnostics = true;\n\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\t\trunnable = false;\n\n\t\t\t\tif ( typeof renderer.debug.onShaderError === 'function' ) {\n\n\t\t\t\t\trenderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default error reporting\n\n\t\t\t\t\tconst vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\t\t\tconst fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +\n\t\t\t\t\t\t'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\\n\\n' +\n\t\t\t\t\t\t'Material Name: ' + self.name + '\\n' +\n\t\t\t\t\t\t'Material Type: ' + self.type + '\\n\\n' +\n\t\t\t\t\t\t'Program Info Log: ' + programLog + '\\n' +\n\t\t\t\t\t\tvertexErrors + '\\n' +\n\t\t\t\t\t\tfragmentErrors\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( programLog !== '' ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );\n\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\t\thaveDiagnostics = false;\n\n\t\t\t}\n\n\t\t\tif ( haveDiagnostics ) {\n\n\t\t\t\tself.diagnostics = {\n\n\t\t\t\t\trunnable: runnable,\n\n\t\t\t\t\tprogramLog: programLog,\n\n\t\t\t\t\tvertexShader: {\n\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t\t},\n\n\t\t\t\t\tfragmentShader: {\n\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Clean up\n\n\t\t// Crashes in iOS9 and iOS10. #18402\n\t\t// gl.detachShader( program, glVertexShader );\n\t\t// gl.detachShader( program, glFragmentShader );\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\tcachedUniforms = new WebGLUniforms( gl, program );\n\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t}\n\n\t// set up caching for uniform locations\n\n\tlet cachedUniforms;\n\n\tthis.getUniforms = function () {\n\n\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t// Populates cachedUniforms and cachedAttributes\n\t\t\tonFirstUse( this );\n\n\t\t}\n\n\t\treturn cachedUniforms;\n\n\t};\n\n\t// set up caching for attribute locations\n\n\tlet cachedAttributes;\n\n\tthis.getAttributes = function () {\n\n\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t// Populates cachedAttributes and cachedUniforms\n\t\t\tonFirstUse( this );\n\n\t\t}\n\n\t\treturn cachedAttributes;\n\n\t};\n\n\t// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,\n\t// flag the program as ready immediately. It may cause a stall when it's first used.\n\n\tlet programReady = ( parameters.rendererExtensionParallelShaderCompile === false );\n\n\tthis.isReady = function () {\n\n\t\tif ( programReady === false ) {\n\n\t\t\tprogramReady = gl.getProgramParameter( program, COMPLETION_STATUS_KHR );\n\n\t\t}\n\n\t\treturn programReady;\n\n\t};\n\n\t// free resource\n\n\tthis.destroy = function () {\n\n\t\tbindingStates.releaseStatesOfProgram( this );\n\n\t\tgl.deleteProgram( program );\n\t\tthis.program = undefined;\n\n\t};\n\n\t//\n\n\tthis.type = parameters.shaderType;\n\tthis.name = parameters.shaderName;\n\tthis.id = programIdCount ++;\n\tthis.cacheKey = cacheKey;\n\tthis.usedTimes = 1;\n\tthis.program = program;\n\tthis.vertexShader = glVertexShader;\n\tthis.fragmentShader = glFragmentShader;\n\n\treturn this;\n\n}\n\nlet _id$1 = 0;\n\nclass WebGLShaderCache {\n\n\tconstructor() {\n\n\t\tthis.shaderCache = new Map();\n\t\tthis.materialCache = new Map();\n\n\t}\n\n\tupdate( material ) {\n\n\t\tconst vertexShader = material.vertexShader;\n\t\tconst fragmentShader = material.fragmentShader;\n\n\t\tconst vertexShaderStage = this._getShaderStage( vertexShader );\n\t\tconst fragmentShaderStage = this._getShaderStage( fragmentShader );\n\n\t\tconst materialShaders = this._getShaderCacheForMaterial( material );\n\n\t\tif ( materialShaders.has( vertexShaderStage ) === false ) {\n\n\t\t\tmaterialShaders.add( vertexShaderStage );\n\t\t\tvertexShaderStage.usedTimes ++;\n\n\t\t}\n\n\t\tif ( materialShaders.has( fragmentShaderStage ) === false ) {\n\n\t\t\tmaterialShaders.add( fragmentShaderStage );\n\t\t\tfragmentShaderStage.usedTimes ++;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( material ) {\n\n\t\tconst materialShaders = this.materialCache.get( material );\n\n\t\tfor ( const shaderStage of materialShaders ) {\n\n\t\t\tshaderStage.usedTimes --;\n\n\t\t\tif ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );\n\n\t\t}\n\n\t\tthis.materialCache.delete( material );\n\n\t\treturn this;\n\n\t}\n\n\tgetVertexShaderID( material ) {\n\n\t\treturn this._getShaderStage( material.vertexShader ).id;\n\n\t}\n\n\tgetFragmentShaderID( material ) {\n\n\t\treturn this._getShaderStage( material.fragmentShader ).id;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shaderCache.clear();\n\t\tthis.materialCache.clear();\n\n\t}\n\n\t_getShaderCacheForMaterial( material ) {\n\n\t\tconst cache = this.materialCache;\n\t\tlet set = cache.get( material );\n\n\t\tif ( set === undefined ) {\n\n\t\t\tset = new Set();\n\t\t\tcache.set( material, set );\n\n\t\t}\n\n\t\treturn set;\n\n\t}\n\n\t_getShaderStage( code ) {\n\n\t\tconst cache = this.shaderCache;\n\t\tlet stage = cache.get( code );\n\n\t\tif ( stage === undefined ) {\n\n\t\t\tstage = new WebGLShaderStage( code );\n\t\t\tcache.set( code, stage );\n\n\t\t}\n\n\t\treturn stage;\n\n\t}\n\n}\n\nclass WebGLShaderStage {\n\n\tconstructor( code ) {\n\n\t\tthis.id = _id$1 ++;\n\n\t\tthis.code = code;\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\nfunction WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {\n\n\tconst _programLayers = new Layers();\n\tconst _customShaders = new WebGLShaderCache();\n\tconst _activeChannels = new Set();\n\tconst programs = [];\n\n\tconst logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n\tconst SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;\n\n\tlet precision = capabilities.precision;\n\n\tconst shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshToonMaterial: 'toon',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tMeshMatcapMaterial: 'matcap',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points',\n\t\tShadowMaterial: 'shadow',\n\t\tSpriteMaterial: 'sprite'\n\t};\n\n\tfunction getChannel( value ) {\n\n\t\t_activeChannels.add( value );\n\n\t\tif ( value === 0 ) return 'uv';\n\n\t\treturn `uv${ value }`;\n\n\t}\n\n\tfunction getParameters( material, lights, shadows, scene, object ) {\n\n\t\tconst fog = scene.fog;\n\t\tconst geometry = object.geometry;\n\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\n\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\n\t\tconst envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\tlet morphTextureStride = 0;\n\n\t\tif ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;\n\t\tif ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;\n\t\tif ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;\n\n\t\t//\n\n\t\tlet vertexShader, fragmentShader;\n\t\tlet customVertexShaderID, customFragmentShaderID;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\n\t\t\tvertexShader = shader.vertexShader;\n\t\t\tfragmentShader = shader.fragmentShader;\n\n\t\t} else {\n\n\t\t\tvertexShader = material.vertexShader;\n\t\t\tfragmentShader = material.fragmentShader;\n\n\t\t\t_customShaders.update( material );\n\n\t\t\tcustomVertexShaderID = _customShaders.getVertexShaderID( material );\n\t\t\tcustomFragmentShaderID = _customShaders.getFragmentShaderID( material );\n\n\t\t}\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tconst IS_INSTANCEDMESH = object.isInstancedMesh === true;\n\t\tconst IS_BATCHEDMESH = object.isBatchedMesh === true;\n\n\t\tconst HAS_MAP = !! material.map;\n\t\tconst HAS_MATCAP = !! material.matcap;\n\t\tconst HAS_ENVMAP = !! envMap;\n\t\tconst HAS_AOMAP = !! material.aoMap;\n\t\tconst HAS_LIGHTMAP = !! material.lightMap;\n\t\tconst HAS_BUMPMAP = !! material.bumpMap;\n\t\tconst HAS_NORMALMAP = !! material.normalMap;\n\t\tconst HAS_DISPLACEMENTMAP = !! material.displacementMap;\n\t\tconst HAS_EMISSIVEMAP = !! material.emissiveMap;\n\n\t\tconst HAS_METALNESSMAP = !! material.metalnessMap;\n\t\tconst HAS_ROUGHNESSMAP = !! material.roughnessMap;\n\n\t\tconst HAS_ANISOTROPY = material.anisotropy > 0;\n\t\tconst HAS_CLEARCOAT = material.clearcoat > 0;\n\t\tconst HAS_DISPERSION = material.dispersion > 0;\n\t\tconst HAS_IRIDESCENCE = material.iridescence > 0;\n\t\tconst HAS_SHEEN = material.sheen > 0;\n\t\tconst HAS_TRANSMISSION = material.transmission > 0;\n\n\t\tconst HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;\n\n\t\tconst HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;\n\t\tconst HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;\n\t\tconst HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;\n\n\t\tconst HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;\n\t\tconst HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;\n\n\t\tconst HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;\n\t\tconst HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;\n\n\t\tconst HAS_SPECULARMAP = !! material.specularMap;\n\t\tconst HAS_SPECULAR_COLORMAP = !! material.specularColorMap;\n\t\tconst HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;\n\n\t\tconst HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;\n\t\tconst HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;\n\n\t\tconst HAS_GRADIENTMAP = !! material.gradientMap;\n\n\t\tconst HAS_ALPHAMAP = !! material.alphaMap;\n\n\t\tconst HAS_ALPHATEST = material.alphaTest > 0;\n\n\t\tconst HAS_ALPHAHASH = !! material.alphaHash;\n\n\t\tconst HAS_EXTENSIONS = !! material.extensions;\n\n\t\tlet toneMapping = NoToneMapping;\n\n\t\tif ( material.toneMapped ) {\n\n\t\t\tif ( currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\t\t\ttoneMapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst parameters = {\n\n\t\t\tshaderID: shaderID,\n\t\t\tshaderType: material.type,\n\t\t\tshaderName: material.name,\n\n\t\t\tvertexShader: vertexShader,\n\t\t\tfragmentShader: fragmentShader,\n\t\t\tdefines: material.defines,\n\n\t\t\tcustomVertexShaderID: customVertexShaderID,\n\t\t\tcustomFragmentShaderID: customFragmentShaderID,\n\n\t\t\tisRawShaderMaterial: material.isRawShaderMaterial === true,\n\t\t\tglslVersion: material.glslVersion,\n\n\t\t\tprecision: precision,\n\n\t\t\tbatching: IS_BATCHEDMESH,\n\t\t\tbatchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,\n\t\t\tinstancing: IS_INSTANCEDMESH,\n\t\t\tinstancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,\n\t\t\tinstancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,\n\n\t\t\tsupportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,\n\t\t\toutputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),\n\t\t\talphaToCoverage: !! material.alphaToCoverage,\n\n\t\t\tmap: HAS_MAP,\n\t\t\tmatcap: HAS_MATCAP,\n\t\t\tenvMap: HAS_ENVMAP,\n\t\t\tenvMapMode: HAS_ENVMAP && envMap.mapping,\n\t\t\tenvMapCubeUVHeight: envMapCubeUVHeight,\n\t\t\taoMap: HAS_AOMAP,\n\t\t\tlightMap: HAS_LIGHTMAP,\n\t\t\tbumpMap: HAS_BUMPMAP,\n\t\t\tnormalMap: HAS_NORMALMAP,\n\t\t\tdisplacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,\n\t\t\temissiveMap: HAS_EMISSIVEMAP,\n\n\t\t\tnormalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,\n\t\t\tnormalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,\n\n\t\t\tmetalnessMap: HAS_METALNESSMAP,\n\t\t\troughnessMap: HAS_ROUGHNESSMAP,\n\n\t\t\tanisotropy: HAS_ANISOTROPY,\n\t\t\tanisotropyMap: HAS_ANISOTROPYMAP,\n\n\t\t\tclearcoat: HAS_CLEARCOAT,\n\t\t\tclearcoatMap: HAS_CLEARCOATMAP,\n\t\t\tclearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,\n\t\t\tclearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,\n\n\t\t\tdispersion: HAS_DISPERSION,\n\n\t\t\tiridescence: HAS_IRIDESCENCE,\n\t\t\tiridescenceMap: HAS_IRIDESCENCEMAP,\n\t\t\tiridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,\n\n\t\t\tsheen: HAS_SHEEN,\n\t\t\tsheenColorMap: HAS_SHEEN_COLORMAP,\n\t\t\tsheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,\n\n\t\t\tspecularMap: HAS_SPECULARMAP,\n\t\t\tspecularColorMap: HAS_SPECULAR_COLORMAP,\n\t\t\tspecularIntensityMap: HAS_SPECULAR_INTENSITYMAP,\n\n\t\t\ttransmission: HAS_TRANSMISSION,\n\t\t\ttransmissionMap: HAS_TRANSMISSIONMAP,\n\t\t\tthicknessMap: HAS_THICKNESSMAP,\n\n\t\t\tgradientMap: HAS_GRADIENTMAP,\n\n\t\t\topaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,\n\n\t\t\talphaMap: HAS_ALPHAMAP,\n\t\t\talphaTest: HAS_ALPHATEST,\n\t\t\talphaHash: HAS_ALPHAHASH,\n\n\t\t\tcombine: material.combine,\n\n\t\t\t//\n\n\t\t\tmapUv: HAS_MAP && getChannel( material.map.channel ),\n\t\t\taoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),\n\t\t\tlightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),\n\t\t\tbumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),\n\t\t\tnormalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),\n\t\t\tdisplacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),\n\t\t\temissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),\n\n\t\t\tmetalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),\n\t\t\troughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),\n\n\t\t\tanisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),\n\n\t\t\tclearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),\n\t\t\tclearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),\n\t\t\tclearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),\n\n\t\t\tiridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),\n\t\t\tiridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),\n\n\t\t\tsheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),\n\t\t\tsheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),\n\n\t\t\tspecularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),\n\t\t\tspecularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),\n\t\t\tspecularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),\n\n\t\t\ttransmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),\n\t\t\tthicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),\n\n\t\t\talphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),\n\n\t\t\t//\n\n\t\t\tvertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),\n\t\t\tvertexColors: material.vertexColors,\n\t\t\tvertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,\n\n\t\t\tpointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),\n\n\t\t\tfog: !! fog,\n\t\t\tuseFog: material.fog === true,\n\t\t\tfogExp2: ( !! fog && fog.isFogExp2 ),\n\n\t\t\tflatShading: material.flatShading === true,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation === true,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tskinning: object.isSkinnedMesh === true,\n\n\t\t\tmorphTargets: geometry.morphAttributes.position !== undefined,\n\t\t\tmorphNormals: geometry.morphAttributes.normal !== undefined,\n\t\t\tmorphColors: geometry.morphAttributes.color !== undefined,\n\t\t\tmorphTargetsCount: morphTargetsCount,\n\t\t\tmorphTextureStride: morphTextureStride,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumSpotLightMaps: lights.spotLightMap.length,\n\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumDirLightShadows: lights.directionalShadowMap.length,\n\t\t\tnumPointLightShadows: lights.pointShadowMap.length,\n\t\t\tnumSpotLightShadows: lights.spotShadowMap.length,\n\t\t\tnumSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,\n\n\t\t\tnumLightProbes: lights.numLightProbes,\n\n\t\t\tnumClippingPlanes: clipping.numPlanes,\n\t\t\tnumClipIntersection: clipping.numIntersection,\n\n\t\t\tdithering: material.dithering,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: toneMapping,\n\n\t\t\tdecodeVideoTexture: HAS_MAP && ( material.map.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.map.colorSpace ) === SRGBTransfer ),\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\tflipSided: material.side === BackSide,\n\n\t\t\tuseDepthPacking: material.depthPacking >= 0,\n\t\t\tdepthPacking: material.depthPacking || 0,\n\n\t\t\tindex0AttributeName: material.index0AttributeName,\n\n\t\t\textensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has( 'WEBGL_clip_cull_distance' ),\n\t\t\textensionMultiDraw: HAS_EXTENSIONS && material.extensions.multiDraw === true && extensions.has( 'WEBGL_multi_draw' ),\n\n\t\t\trendererExtensionParallelShaderCompile: extensions.has( 'KHR_parallel_shader_compile' ),\n\n\t\t\tcustomProgramCacheKey: material.customProgramCacheKey()\n\n\t\t};\n\n\t\t// the usage of getChannel() determines the active texture channels for this shader\n\n\t\tparameters.vertexUv1s = _activeChannels.has( 1 );\n\t\tparameters.vertexUv2s = _activeChannels.has( 2 );\n\t\tparameters.vertexUv3s = _activeChannels.has( 3 );\n\n\t\t_activeChannels.clear();\n\n\t\treturn parameters;\n\n\t}\n\n\tfunction getProgramCacheKey( parameters ) {\n\n\t\tconst array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( parameters.customVertexShaderID );\n\t\t\tarray.push( parameters.customFragmentShaderID );\n\n\t\t}\n\n\t\tif ( parameters.defines !== undefined ) {\n\n\t\t\tfor ( const name in parameters.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( parameters.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parameters.isRawShaderMaterial === false ) {\n\n\t\t\tgetProgramCacheKeyParameters( array, parameters );\n\t\t\tgetProgramCacheKeyBooleans( array, parameters );\n\t\t\tarray.push( renderer.outputColorSpace );\n\n\t\t}\n\n\t\tarray.push( parameters.customProgramCacheKey );\n\n\t\treturn array.join();\n\n\t}\n\n\tfunction getProgramCacheKeyParameters( array, parameters ) {\n\n\t\tarray.push( parameters.precision );\n\t\tarray.push( parameters.outputColorSpace );\n\t\tarray.push( parameters.envMapMode );\n\t\tarray.push( parameters.envMapCubeUVHeight );\n\t\tarray.push( parameters.mapUv );\n\t\tarray.push( parameters.alphaMapUv );\n\t\tarray.push( parameters.lightMapUv );\n\t\tarray.push( parameters.aoMapUv );\n\t\tarray.push( parameters.bumpMapUv );\n\t\tarray.push( parameters.normalMapUv );\n\t\tarray.push( parameters.displacementMapUv );\n\t\tarray.push( parameters.emissiveMapUv );\n\t\tarray.push( parameters.metalnessMapUv );\n\t\tarray.push( parameters.roughnessMapUv );\n\t\tarray.push( parameters.anisotropyMapUv );\n\t\tarray.push( parameters.clearcoatMapUv );\n\t\tarray.push( parameters.clearcoatNormalMapUv );\n\t\tarray.push( parameters.clearcoatRoughnessMapUv );\n\t\tarray.push( parameters.iridescenceMapUv );\n\t\tarray.push( parameters.iridescenceThicknessMapUv );\n\t\tarray.push( parameters.sheenColorMapUv );\n\t\tarray.push( parameters.sheenRoughnessMapUv );\n\t\tarray.push( parameters.specularMapUv );\n\t\tarray.push( parameters.specularColorMapUv );\n\t\tarray.push( parameters.specularIntensityMapUv );\n\t\tarray.push( parameters.transmissionMapUv );\n\t\tarray.push( parameters.thicknessMapUv );\n\t\tarray.push( parameters.combine );\n\t\tarray.push( parameters.fogExp2 );\n\t\tarray.push( parameters.sizeAttenuation );\n\t\tarray.push( parameters.morphTargetsCount );\n\t\tarray.push( parameters.morphAttributeCount );\n\t\tarray.push( parameters.numDirLights );\n\t\tarray.push( parameters.numPointLights );\n\t\tarray.push( parameters.numSpotLights );\n\t\tarray.push( parameters.numSpotLightMaps );\n\t\tarray.push( parameters.numHemiLights );\n\t\tarray.push( parameters.numRectAreaLights );\n\t\tarray.push( parameters.numDirLightShadows );\n\t\tarray.push( parameters.numPointLightShadows );\n\t\tarray.push( parameters.numSpotLightShadows );\n\t\tarray.push( parameters.numSpotLightShadowsWithMaps );\n\t\tarray.push( parameters.numLightProbes );\n\t\tarray.push( parameters.shadowMapType );\n\t\tarray.push( parameters.toneMapping );\n\t\tarray.push( parameters.numClippingPlanes );\n\t\tarray.push( parameters.numClipIntersection );\n\t\tarray.push( parameters.depthPacking );\n\n\t}\n\n\tfunction getProgramCacheKeyBooleans( array, parameters ) {\n\n\t\t_programLayers.disableAll();\n\n\t\tif ( parameters.supportsVertexTextures )\n\t\t\t_programLayers.enable( 0 );\n\t\tif ( parameters.instancing )\n\t\t\t_programLayers.enable( 1 );\n\t\tif ( parameters.instancingColor )\n\t\t\t_programLayers.enable( 2 );\n\t\tif ( parameters.instancingMorph )\n\t\t\t_programLayers.enable( 3 );\n\t\tif ( parameters.matcap )\n\t\t\t_programLayers.enable( 4 );\n\t\tif ( parameters.envMap )\n\t\t\t_programLayers.enable( 5 );\n\t\tif ( parameters.normalMapObjectSpace )\n\t\t\t_programLayers.enable( 6 );\n\t\tif ( parameters.normalMapTangentSpace )\n\t\t\t_programLayers.enable( 7 );\n\t\tif ( parameters.clearcoat )\n\t\t\t_programLayers.enable( 8 );\n\t\tif ( parameters.iridescence )\n\t\t\t_programLayers.enable( 9 );\n\t\tif ( parameters.alphaTest )\n\t\t\t_programLayers.enable( 10 );\n\t\tif ( parameters.vertexColors )\n\t\t\t_programLayers.enable( 11 );\n\t\tif ( parameters.vertexAlphas )\n\t\t\t_programLayers.enable( 12 );\n\t\tif ( parameters.vertexUv1s )\n\t\t\t_programLayers.enable( 13 );\n\t\tif ( parameters.vertexUv2s )\n\t\t\t_programLayers.enable( 14 );\n\t\tif ( parameters.vertexUv3s )\n\t\t\t_programLayers.enable( 15 );\n\t\tif ( parameters.vertexTangents )\n\t\t\t_programLayers.enable( 16 );\n\t\tif ( parameters.anisotropy )\n\t\t\t_programLayers.enable( 17 );\n\t\tif ( parameters.alphaHash )\n\t\t\t_programLayers.enable( 18 );\n\t\tif ( parameters.batching )\n\t\t\t_programLayers.enable( 19 );\n\t\tif ( parameters.dispersion )\n\t\t\t_programLayers.enable( 20 );\n\t\tif ( parameters.batchingColor )\n\t\t\t_programLayers.enable( 21 );\n\n\t\tarray.push( _programLayers.mask );\n\t\t_programLayers.disableAll();\n\n\t\tif ( parameters.fog )\n\t\t\t_programLayers.enable( 0 );\n\t\tif ( parameters.useFog )\n\t\t\t_programLayers.enable( 1 );\n\t\tif ( parameters.flatShading )\n\t\t\t_programLayers.enable( 2 );\n\t\tif ( parameters.logarithmicDepthBuffer )\n\t\t\t_programLayers.enable( 3 );\n\t\tif ( parameters.skinning )\n\t\t\t_programLayers.enable( 4 );\n\t\tif ( parameters.morphTargets )\n\t\t\t_programLayers.enable( 5 );\n\t\tif ( parameters.morphNormals )\n\t\t\t_programLayers.enable( 6 );\n\t\tif ( parameters.morphColors )\n\t\t\t_programLayers.enable( 7 );\n\t\tif ( parameters.premultipliedAlpha )\n\t\t\t_programLayers.enable( 8 );\n\t\tif ( parameters.shadowMapEnabled )\n\t\t\t_programLayers.enable( 9 );\n\t\tif ( parameters.doubleSided )\n\t\t\t_programLayers.enable( 10 );\n\t\tif ( parameters.flipSided )\n\t\t\t_programLayers.enable( 11 );\n\t\tif ( parameters.useDepthPacking )\n\t\t\t_programLayers.enable( 12 );\n\t\tif ( parameters.dithering )\n\t\t\t_programLayers.enable( 13 );\n\t\tif ( parameters.transmission )\n\t\t\t_programLayers.enable( 14 );\n\t\tif ( parameters.sheen )\n\t\t\t_programLayers.enable( 15 );\n\t\tif ( parameters.opaque )\n\t\t\t_programLayers.enable( 16 );\n\t\tif ( parameters.pointsUvs )\n\t\t\t_programLayers.enable( 17 );\n\t\tif ( parameters.decodeVideoTexture )\n\t\t\t_programLayers.enable( 18 );\n\t\tif ( parameters.alphaToCoverage )\n\t\t\t_programLayers.enable( 19 );\n\n\t\tarray.push( _programLayers.mask );\n\n\t}\n\n\tfunction getUniforms( material ) {\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\t\tlet uniforms;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\t\t\tuniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t} else {\n\n\t\t\tuniforms = material.uniforms;\n\n\t\t}\n\n\t\treturn uniforms;\n\n\t}\n\n\tfunction acquireProgram( parameters, cacheKey ) {\n\n\t\tlet program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( let p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tconst preexistingProgram = programs[ p ];\n\n\t\t\tif ( preexistingProgram.cacheKey === cacheKey ) {\n\n\t\t\t\tprogram = preexistingProgram;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\tfunction releaseProgram( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tconst i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t}\n\n\tfunction releaseShaderCache( material ) {\n\n\t\t_customShaders.remove( material );\n\n\t}\n\n\tfunction dispose() {\n\n\t\t_customShaders.dispose();\n\n\t}\n\n\treturn {\n\t\tgetParameters: getParameters,\n\t\tgetProgramCacheKey: getProgramCacheKey,\n\t\tgetUniforms: getUniforms,\n\t\tacquireProgram: acquireProgram,\n\t\treleaseProgram: releaseProgram,\n\t\treleaseShaderCache: releaseShaderCache,\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tprograms: programs,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction WebGLProperties() {\n\n\tlet properties = new WeakMap();\n\n\tfunction get( object ) {\n\n\t\tlet map = properties.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\tfunction remove( object ) {\n\n\t\tproperties.delete( object );\n\n\t}\n\n\tfunction update( object, key, value ) {\n\n\t\tproperties.get( object )[ key ] = value;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tproperties = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n\nfunction WebGLRenderList() {\n\n\tconst renderItems = [];\n\tlet renderItemsIndex = 0;\n\n\tconst opaque = [];\n\tconst transmissive = [];\n\tconst transparent = [];\n\n\tfunction init() {\n\n\t\trenderItemsIndex = 0;\n\n\t\topaque.length = 0;\n\t\ttransmissive.length = 0;\n\t\ttransparent.length = 0;\n\n\t}\n\n\tfunction getNextRenderItem( object, geometry, material, groupOrder, z, group ) {\n\n\t\tlet renderItem = renderItems[ renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\trenderItems[ renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\n\t\t}\n\n\t\trenderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\tfunction push( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\ttransmissive.push( renderItem );\n\n\t\t} else if ( material.transparent === true ) {\n\n\t\t\ttransparent.push( renderItem );\n\n\t\t} else {\n\n\t\t\topaque.push( renderItem );\n\n\t\t}\n\n\t}\n\n\tfunction unshift( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\ttransmissive.unshift( renderItem );\n\n\t\t} else if ( material.transparent === true ) {\n\n\t\t\ttransparent.unshift( renderItem );\n\n\t\t} else {\n\n\t\t\topaque.unshift( renderItem );\n\n\t\t}\n\n\t}\n\n\tfunction sort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );\n\t\tif ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\tfunction finish() {\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.group = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\topaque: opaque,\n\t\ttransmissive: transmissive,\n\t\ttransparent: transparent,\n\n\t\tinit: init,\n\t\tpush: push,\n\t\tunshift: unshift,\n\t\tfinish: finish,\n\n\t\tsort: sort\n\t};\n\n}\n\nfunction WebGLRenderLists() {\n\n\tlet lists = new WeakMap();\n\n\tfunction get( scene, renderCallDepth ) {\n\n\t\tconst listArray = lists.get( scene );\n\t\tlet list;\n\n\t\tif ( listArray === undefined ) {\n\n\t\t\tlist = new WebGLRenderList();\n\t\t\tlists.set( scene, [ list ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= listArray.length ) {\n\n\t\t\t\tlist = new WebGLRenderList();\n\t\t\t\tlistArray.push( list );\n\n\t\t\t} else {\n\n\t\t\t\tlist = listArray[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tlists = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction UniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\nfunction ShadowUniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\n\n\nlet nextVersion = 0;\n\nfunction shadowCastingAndTexturingLightsFirst( lightA, lightB ) {\n\n\treturn ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );\n\n}\n\nfunction WebGLLights( extensions ) {\n\n\tconst cache = new UniformsCache();\n\n\tconst shadowCache = ShadowUniformsCache();\n\n\tconst state = {\n\n\t\tversion: 0,\n\n\t\thash: {\n\t\t\tdirectionalLength: - 1,\n\t\t\tpointLength: - 1,\n\t\t\tspotLength: - 1,\n\t\t\trectAreaLength: - 1,\n\t\t\themiLength: - 1,\n\n\t\t\tnumDirectionalShadows: - 1,\n\t\t\tnumPointShadows: - 1,\n\t\t\tnumSpotShadows: - 1,\n\t\t\tnumSpotMaps: - 1,\n\n\t\t\tnumLightProbes: - 1\n\t\t},\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tprobe: [],\n\t\tdirectional: [],\n\t\tdirectionalShadow: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotLightMap: [],\n\t\tspotShadow: [],\n\t\tspotShadowMap: [],\n\t\tspotLightMatrix: [],\n\t\trectArea: [],\n\t\trectAreaLTC1: null,\n\t\trectAreaLTC2: null,\n\t\tpoint: [],\n\t\tpointShadow: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\t\tnumSpotLightShadowsWithMaps: 0,\n\t\tnumLightProbes: 0\n\n\t};\n\n\tfor ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );\n\n\tconst vector3 = new Vector3();\n\tconst matrix4 = new Matrix4();\n\tconst matrix42 = new Matrix4();\n\n\tfunction setup( lights ) {\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tlet numDirectionalShadows = 0;\n\t\tlet numPointShadows = 0;\n\t\tlet numSpotShadows = 0;\n\t\tlet numSpotMaps = 0;\n\t\tlet numSpotShadowsWithMaps = 0;\n\n\t\tlet numLightProbes = 0;\n\n\t\t// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]\n\t\tlights.sort( shadowCastingAndTexturingLightsFirst );\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tconst color = light.color;\n\t\t\tconst intensity = light.intensity;\n\t\t\tconst distance = light.distance;\n\n\t\t\tconst shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light.isLightProbe ) {\n\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tstate.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );\n\n\t\t\t\t}\n\n\t\t\t\tnumLightProbes ++;\n\n\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.directionalShadow[ directionalLength ] = shadowUniforms;\n\t\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumDirectionalShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\n\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\tif ( light.map ) {\n\n\t\t\t\t\tstate.spotLightMap[ numSpotMaps ] = light.map;\n\t\t\t\t\tnumSpotMaps ++;\n\n\t\t\t\t\t// make sure the lightMatrix is up to date\n\t\t\t\t\t// TODO : do it if required only\n\t\t\t\t\tshadow.updateMatrices( light );\n\n\t\t\t\t\tif ( light.castShadow ) numSpotShadowsWithMaps ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.spotLightMatrix[ spotLength ] = shadow.matrix;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.spotShadow[ spotLength ] = shadowUniforms;\n\t\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\n\t\t\t\t\tnumSpotShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\n\n\t\t\t\t\tstate.pointShadow[ pointLength ] = shadowUniforms;\n\t\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumPointShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.point[ pointLength ] = uniforms;\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( rectAreaLength > 0 ) {\n\n\t\t\tif ( extensions.has( 'OES_texture_float_linear' ) === true ) {\n\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t} else {\n\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.ambient[ 0 ] = r;\n\t\tstate.ambient[ 1 ] = g;\n\t\tstate.ambient[ 2 ] = b;\n\n\t\tconst hash = state.hash;\n\n\t\tif ( hash.directionalLength !== directionalLength ||\n\t\t\thash.pointLength !== pointLength ||\n\t\t\thash.spotLength !== spotLength ||\n\t\t\thash.rectAreaLength !== rectAreaLength ||\n\t\t\thash.hemiLength !== hemiLength ||\n\t\t\thash.numDirectionalShadows !== numDirectionalShadows ||\n\t\t\thash.numPointShadows !== numPointShadows ||\n\t\t\thash.numSpotShadows !== numSpotShadows ||\n\t\t\thash.numSpotMaps !== numSpotMaps ||\n\t\t\thash.numLightProbes !== numLightProbes ) {\n\n\t\t\tstate.directional.length = directionalLength;\n\t\t\tstate.spot.length = spotLength;\n\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\tstate.point.length = pointLength;\n\t\t\tstate.hemi.length = hemiLength;\n\n\t\t\tstate.directionalShadow.length = numDirectionalShadows;\n\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\n\t\t\tstate.pointShadow.length = numPointShadows;\n\t\t\tstate.pointShadowMap.length = numPointShadows;\n\t\t\tstate.spotShadow.length = numSpotShadows;\n\t\t\tstate.spotShadowMap.length = numSpotShadows;\n\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\n\t\t\tstate.pointShadowMatrix.length = numPointShadows;\n\t\t\tstate.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;\n\t\t\tstate.spotLightMap.length = numSpotMaps;\n\t\t\tstate.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;\n\t\t\tstate.numLightProbes = numLightProbes;\n\n\t\t\thash.directionalLength = directionalLength;\n\t\t\thash.pointLength = pointLength;\n\t\t\thash.spotLength = spotLength;\n\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\thash.hemiLength = hemiLength;\n\n\t\t\thash.numDirectionalShadows = numDirectionalShadows;\n\t\t\thash.numPointShadows = numPointShadows;\n\t\t\thash.numSpotShadows = numSpotShadows;\n\t\t\thash.numSpotMaps = numSpotMaps;\n\n\t\t\thash.numLightProbes = numLightProbes;\n\n\t\t\tstate.version = nextVersion ++;\n\n\t\t}\n\n\t}\n\n\tfunction setupView( lights, camera ) {\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tconst viewMatrix = camera.matrixWorldInverse;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = state.directional[ directionalLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = state.spot[ spotLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = state.rectArea[ rectAreaLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\tmatrix42.identity();\n\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\tmatrix42.extractRotation( matrix4 );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = state.point[ pointLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = state.hemi[ hemiLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tsetup: setup,\n\t\tsetupView: setupView,\n\t\tstate: state\n\t};\n\n}\n\nfunction WebGLRenderState( extensions ) {\n\n\tconst lights = new WebGLLights( extensions );\n\n\tconst lightsArray = [];\n\tconst shadowsArray = [];\n\n\tfunction init( camera ) {\n\n\t\tstate.camera = camera;\n\n\t\tlightsArray.length = 0;\n\t\tshadowsArray.length = 0;\n\n\t}\n\n\tfunction pushLight( light ) {\n\n\t\tlightsArray.push( light );\n\n\t}\n\n\tfunction pushShadow( shadowLight ) {\n\n\t\tshadowsArray.push( shadowLight );\n\n\t}\n\n\tfunction setupLights() {\n\n\t\tlights.setup( lightsArray );\n\n\t}\n\n\tfunction setupLightsView( camera ) {\n\n\t\tlights.setupView( lightsArray, camera );\n\n\t}\n\n\tconst state = {\n\t\tlightsArray: lightsArray,\n\t\tshadowsArray: shadowsArray,\n\n\t\tcamera: null,\n\n\t\tlights: lights,\n\n\t\ttransmissionRenderTarget: {}\n\t};\n\n\treturn {\n\t\tinit: init,\n\t\tstate: state,\n\t\tsetupLights: setupLights,\n\t\tsetupLightsView: setupLightsView,\n\n\t\tpushLight: pushLight,\n\t\tpushShadow: pushShadow\n\t};\n\n}\n\nfunction WebGLRenderStates( extensions ) {\n\n\tlet renderStates = new WeakMap();\n\n\tfunction get( scene, renderCallDepth = 0 ) {\n\n\t\tconst renderStateArray = renderStates.get( scene );\n\t\tlet renderState;\n\n\t\tif ( renderStateArray === undefined ) {\n\n\t\t\trenderState = new WebGLRenderState( extensions );\n\t\t\trenderStates.set( scene, [ renderState ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= renderStateArray.length ) {\n\n\t\t\t\trenderState = new WebGLRenderState( extensions );\n\t\t\t\trenderStateArray.push( renderState );\n\n\t\t\t} else {\n\n\t\t\t\trenderState = renderStateArray[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderState;\n\n\t}\n\n\tfunction dispose() {\n\n\t\trenderStates = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nclass MeshDepthMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDepthMaterial = true;\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshDistanceMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDistanceMaterial = true;\n\n\t\tthis.type = 'MeshDistanceMaterial';\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst vertex = \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\";\n\nconst fragment = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tconst float samples = float( VSM_SAMPLES );\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\\n\\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\\n\\tfor ( float i = 0.0; i < samples; i ++ ) {\\n\\t\\tfloat uvOffset = uvStart + i * uvStride;\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean / samples;\\n\\tsquared_mean = squared_mean / samples;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\n\nfunction WebGLShadowMap( renderer, objects, capabilities ) {\n\n\tlet _frustum = new Frustum();\n\n\tconst _shadowMapSize = new Vector2(),\n\t\t_viewportSize = new Vector2(),\n\n\t\t_viewport = new Vector4(),\n\n\t\t_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),\n\t\t_distanceMaterial = new MeshDistanceMaterial(),\n\n\t\t_materialCache = {},\n\n\t\t_maxTextureSize = capabilities.maxTextureSize;\n\n\tconst shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };\n\n\tconst shadowMaterialVertical = new ShaderMaterial( {\n\t\tdefines: {\n\t\t\tVSM_SAMPLES: 8\n\t\t},\n\t\tuniforms: {\n\t\t\tshadow_pass: { value: null },\n\t\t\tresolution: { value: new Vector2() },\n\t\t\tradius: { value: 4.0 }\n\t\t},\n\n\t\tvertexShader: vertex,\n\t\tfragmentShader: fragment\n\n\t} );\n\n\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\n\tconst fullScreenTri = new BufferGeometry();\n\tfullScreenTri.setAttribute(\n\t\t'position',\n\t\tnew BufferAttribute(\n\t\t\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\n\t\t\t3\n\t\t)\n\t);\n\n\tconst fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );\n\n\tconst scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = PCFShadowMap;\n\tlet _previousType = this.type;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst activeCubeFace = renderer.getActiveCubeFace();\n\t\tconst activeMipmapLevel = renderer.getActiveMipmapLevel();\n\n\t\tconst _state = renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( NoBlending );\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// check for shadow map type changes\n\n\t\tconst toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );\n\t\tconst fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );\n\n\t\t// render depth map\n\n\t\tfor ( let i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t\tif ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\tif ( _shadowMapSize.x > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );\n\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );\n\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null || toVSM === true || fromVSM === true ) {\n\n\t\t\t\tconst pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};\n\n\t\t\t\tif ( shadow.map !== null ) {\n\n\t\t\t\t\tshadow.map.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget( shadow.map );\n\t\t\trenderer.clear();\n\n\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\t\t_viewport.set(\n\t\t\t\t\t_viewportSize.x * viewport.x,\n\t\t\t\t\t_viewportSize.y * viewport.y,\n\t\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t\t);\n\n\t\t\t\t_state.viewport( _viewport );\n\n\t\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\t\t_frustum = shadow.getFrustum();\n\n\t\t\t\trenderObject( scene, camera, shadow.camera, light, this.type );\n\n\t\t\t}\n\n\t\t\t// do blur pass for VSM\n\n\t\t\tif ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {\n\n\t\t\t\tVSMPass( shadow, camera );\n\n\t\t\t}\n\n\t\t\tshadow.needsUpdate = false;\n\n\t\t}\n\n\t\t_previousType = this.type;\n\n\t\tscope.needsUpdate = false;\n\n\t\trenderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t};\n\n\tfunction VSMPass( shadow, camera ) {\n\n\t\tconst geometry = objects.update( fullScreenMesh );\n\n\t\tif ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {\n\n\t\t\tshadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\n\t\t\tshadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\n\n\t\t\tshadowMaterialVertical.needsUpdate = true;\n\t\t\tshadowMaterialHorizontal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( shadow.mapPass === null ) {\n\n\t\t\tshadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );\n\n\t\t}\n\n\t\t// vertical pass\n\n\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\t\trenderer.setRenderTarget( shadow.mapPass );\n\t\trenderer.clear();\n\t\trenderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\n\n\t\t// horizontal pass\n\n\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\t\trenderer.setRenderTarget( shadow.map );\n\t\trenderer.clear();\n\t\trenderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );\n\n\t}\n\n\tfunction getDepthMaterial( object, material, light, type ) {\n\n\t\tlet result = null;\n\n\t\tconst customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;\n\n\t\tif ( customMaterial !== undefined ) {\n\n\t\t\tresult = customMaterial;\n\n\t\t} else {\n\n\t\t\tresult = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;\n\n\t\t\tif ( ( renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||\n\t\t\t\t( material.displacementMap && material.displacementScale !== 0 ) ||\n\t\t\t\t( material.alphaMap && material.alphaTest > 0 ) ||\n\t\t\t\t( material.map && material.alphaTest > 0 ) ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tconst keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tlet materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tlet cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\t\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tif ( type === VSMShadowMap ) {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\n\n\t\t} else {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\t}\n\n\t\tresult.alphaMap = material.alphaMap;\n\t\tresult.alphaTest = material.alphaTest;\n\t\tresult.map = material.map;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.displacementMap = material.displacementMap;\n\t\tresult.displacementScale = material.displacementScale;\n\t\tresult.displacementBias = material.displacementBias;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\n\n\t\t\tconst materialProperties = renderer.properties.get( result );\n\t\t\tmaterialProperties.light = light;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, light, type ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\tfor ( let k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ k ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, groupMaterial, light, type );\n\n\t\t\t\t\t\t\tobject.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );\n\n\t\t\t\t\t\t\trenderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\tobject.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, material, light, type );\n\n\t\t\t\t\tobject.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );\n\n\t\t\t\t\trenderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\tobject.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, light, type );\n\n\t\t}\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tconst material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t// make sure to remove the unique distance/depth materials used for shadow map rendering\n\n\t\tfor ( const id in _materialCache ) {\n\n\t\t\tconst cache = _materialCache[ id ];\n\n\t\t\tconst uuid = event.target.uuid;\n\n\t\t\tif ( uuid in cache ) {\n\n\t\t\t\tconst shadowMaterial = cache[ uuid ];\n\t\t\t\tshadowMaterial.dispose();\n\t\t\t\tdelete cache[ uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction WebGLState( gl ) {\n\n\tfunction ColorBuffer() {\n\n\t\tlet locked = false;\n\n\t\tconst color = new Vector4();\n\t\tlet currentColorMask = null;\n\t\tconst currentColorClear = new Vector4( 0, 0, 0, 0 );\n\n\t\treturn {\n\n\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\n\n\t\t\t\tif ( premultipliedAlpha === true ) {\n\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t\t}\n\n\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentColorMask = null;\n\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction DepthBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentDepthMask = null;\n\t\tlet currentDepthFunc = null;\n\t\tlet currentDepthClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\tenable( gl.DEPTH_TEST );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentDepthMask = null;\n\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction StencilBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentStencilMask = null;\n\t\tlet currentStencilFunc = null;\n\t\tlet currentStencilRef = null;\n\t\tlet currentStencilFuncMask = null;\n\t\tlet currentStencilFail = null;\n\t\tlet currentStencilZFail = null;\n\t\tlet currentStencilZPass = null;\n\t\tlet currentStencilClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\tif ( ! locked ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t     currentStencilRef !== stencilRef ||\n\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\tif ( currentStencilFail !== stencilFail ||\n\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentStencilMask = null;\n\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\tcurrentStencilRef = null;\n\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\tcurrentStencilFail = null;\n\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t//\n\n\tconst colorBuffer = new ColorBuffer();\n\tconst depthBuffer = new DepthBuffer();\n\tconst stencilBuffer = new StencilBuffer();\n\n\tconst uboBindings = new WeakMap();\n\tconst uboProgramMap = new WeakMap();\n\n\tlet enabledCapabilities = {};\n\n\tlet currentBoundFramebuffers = {};\n\tlet currentDrawbuffers = new WeakMap();\n\tlet defaultDrawbuffers = [];\n\n\tlet currentProgram = null;\n\n\tlet currentBlendingEnabled = false;\n\tlet currentBlending = null;\n\tlet currentBlendEquation = null;\n\tlet currentBlendSrc = null;\n\tlet currentBlendDst = null;\n\tlet currentBlendEquationAlpha = null;\n\tlet currentBlendSrcAlpha = null;\n\tlet currentBlendDstAlpha = null;\n\tlet currentBlendColor = new Color( 0, 0, 0 );\n\tlet currentBlendAlpha = 0;\n\tlet currentPremultipledAlpha = false;\n\n\tlet currentFlipSided = null;\n\tlet currentCullFace = null;\n\n\tlet currentLineWidth = null;\n\n\tlet currentPolygonOffsetFactor = null;\n\tlet currentPolygonOffsetUnits = null;\n\n\tconst maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\n\n\tlet lineWidthAvailable = false;\n\tlet version = 0;\n\tconst glVersion = gl.getParameter( gl.VERSION );\n\n\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^WebGL (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 1.0 );\n\n\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^OpenGL ES (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 2.0 );\n\n\t}\n\n\tlet currentTextureSlot = null;\n\tlet currentBoundTextures = {};\n\n\tconst scissorParam = gl.getParameter( gl.SCISSOR_BOX );\n\tconst viewportParam = gl.getParameter( gl.VIEWPORT );\n\n\tconst currentScissor = new Vector4().fromArray( scissorParam );\n\tconst currentViewport = new Vector4().fromArray( viewportParam );\n\n\tfunction createTexture( type, target, count, dimensions ) {\n\n\t\tconst data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tconst texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tif ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t\tgl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t} else {\n\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tconst emptyTextures = {};\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\temptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );\n\temptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );\n\n\t// init\n\n\tcolorBuffer.setClear( 0, 0, 0, 1 );\n\tdepthBuffer.setClear( 1 );\n\tstencilBuffer.setClear( 0 );\n\n\tenable( gl.DEPTH_TEST );\n\tdepthBuffer.setFunc( LessEqualDepth );\n\n\tsetFlipSided( false );\n\tsetCullFace( CullFaceBack );\n\tenable( gl.CULL_FACE );\n\n\tsetBlending( NoBlending );\n\n\t//\n\n\tfunction enable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tenabledCapabilities[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tfunction disable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tenabledCapabilities[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tfunction bindFramebuffer( target, framebuffer ) {\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n\t\t\tif ( target === gl.DRAW_FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\tif ( target === gl.FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction drawBuffers( renderTarget, framebuffer ) {\n\n\t\tlet drawBuffers = defaultDrawbuffers;\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tdrawBuffers = currentDrawbuffers.get( framebuffer );\n\n\t\t\tif ( drawBuffers === undefined ) {\n\n\t\t\t\tdrawBuffers = [];\n\t\t\t\tcurrentDrawbuffers.set( framebuffer, drawBuffers );\n\n\t\t\t}\n\n\t\t\tconst textures = renderTarget.textures;\n\n\t\t\tif ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tdrawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t}\n\n\t\t\t\tdrawBuffers.length = textures.length;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( drawBuffers[ 0 ] !== gl.BACK ) {\n\n\t\t\t\tdrawBuffers[ 0 ] = gl.BACK;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tgl.drawBuffers( drawBuffers );\n\n\t\t}\n\n\t}\n\n\tfunction useProgram( program ) {\n\n\t\tif ( currentProgram !== program ) {\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tcurrentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tconst equationToGL = {\n\t\t[ AddEquation ]: gl.FUNC_ADD,\n\t\t[ SubtractEquation ]: gl.FUNC_SUBTRACT,\n\t\t[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT\n\t};\n\n\tequationToGL[ MinEquation ] = gl.MIN;\n\tequationToGL[ MaxEquation ] = gl.MAX;\n\n\tconst factorToGL = {\n\t\t[ ZeroFactor ]: gl.ZERO,\n\t\t[ OneFactor ]: gl.ONE,\n\t\t[ SrcColorFactor ]: gl.SRC_COLOR,\n\t\t[ SrcAlphaFactor ]: gl.SRC_ALPHA,\n\t\t[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,\n\t\t[ DstColorFactor ]: gl.DST_COLOR,\n\t\t[ DstAlphaFactor ]: gl.DST_ALPHA,\n\t\t[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,\n\t\t[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,\n\t\t[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA,\n\t\t[ ConstantColorFactor ]: gl.CONSTANT_COLOR,\n\t\t[ OneMinusConstantColorFactor ]: gl.ONE_MINUS_CONSTANT_COLOR,\n\t\t[ ConstantAlphaFactor ]: gl.CONSTANT_ALPHA,\n\t\t[ OneMinusConstantAlphaFactor ]: gl.ONE_MINUS_CONSTANT_ALPHA\n\t};\n\n\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( currentBlendingEnabled === true ) {\n\n\t\t\t\tdisable( gl.BLEND );\n\t\t\t\tcurrentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( currentBlendingEnabled === false ) {\n\n\t\t\tenable( gl.BLEND );\n\t\t\tcurrentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\n\t\t\t\t\tcurrentBlendEquation = AddEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ONE, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\t\t\t\tcurrentBlendColor.set( 0, 0, 0 );\n\t\t\t\tcurrentBlendAlpha = 0;\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\tcurrentBlendDst = blendDst;\n\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tif ( blendColor.equals( currentBlendColor ) === false || blendAlpha !== currentBlendAlpha ) {\n\n\t\t\tgl.blendColor( blendColor.r, blendColor.g, blendColor.b, blendAlpha );\n\n\t\t\tcurrentBlendColor.copy( blendColor );\n\t\t\tcurrentBlendAlpha = blendAlpha;\n\n\t\t}\n\n\t\tcurrentBlending = blending;\n\t\tcurrentPremultipledAlpha = false;\n\n\t}\n\n\tfunction setMaterial( material, frontFaceCW ) {\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? disable( gl.CULL_FACE )\n\t\t\t: enable( gl.CULL_FACE );\n\n\t\tlet flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tsetFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? setBlending( NoBlending )\n\t\t\t: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha );\n\n\t\tdepthBuffer.setFunc( material.depthFunc );\n\t\tdepthBuffer.setTest( material.depthTest );\n\t\tdepthBuffer.setMask( material.depthWrite );\n\t\tcolorBuffer.setMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tstencilBuffer.setTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( material.stencilWriteMask );\n\t\t\tstencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tstencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true\n\t\t\t? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )\n\t\t\t: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t}\n\n\t//\n\n\tfunction setFlipSided( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tfunction setCullFace( cullFace ) {\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tenable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t}\n\n\tfunction setLineWidth( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tif ( lineWidthAvailable ) gl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t}\n\n\tfunction setScissorTest( scissorTest ) {\n\n\t\tif ( scissorTest ) {\n\n\t\t\tenable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tdisable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t}\n\n\t// texture\n\n\tfunction activeTexture( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tfunction bindTexture( webglType, webglTexture, webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\twebglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\t} else {\n\n\t\t\t\twebglSlot = currentTextureSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ webglSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ webglSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tfunction unbindTexture() {\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texSubImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texSubImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texSubImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texSubImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexSubImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexSubImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexSubImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexSubImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texStorage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texStorage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texStorage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texStorage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction scissor( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t}\n\n\tfunction viewport( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t}\n\n\tfunction updateUBOMapping( uniformsGroup, program ) {\n\n\t\tlet mapping = uboProgramMap.get( program );\n\n\t\tif ( mapping === undefined ) {\n\n\t\t\tmapping = new WeakMap();\n\n\t\t\tuboProgramMap.set( program, mapping );\n\n\t\t}\n\n\t\tlet blockIndex = mapping.get( uniformsGroup );\n\n\t\tif ( blockIndex === undefined ) {\n\n\t\t\tblockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );\n\n\t\t\tmapping.set( uniformsGroup, blockIndex );\n\n\t\t}\n\n\t}\n\n\tfunction uniformBlockBinding( uniformsGroup, program ) {\n\n\t\tconst mapping = uboProgramMap.get( program );\n\t\tconst blockIndex = mapping.get( uniformsGroup );\n\n\t\tif ( uboBindings.get( program ) !== blockIndex ) {\n\n\t\t\t// bind shader specific block index to global block point\n\t\t\tgl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );\n\n\t\t\tuboBindings.set( program, blockIndex );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction reset() {\n\n\t\t// reset state\n\n\t\tgl.disable( gl.BLEND );\n\t\tgl.disable( gl.CULL_FACE );\n\t\tgl.disable( gl.DEPTH_TEST );\n\t\tgl.disable( gl.POLYGON_OFFSET_FILL );\n\t\tgl.disable( gl.SCISSOR_TEST );\n\t\tgl.disable( gl.STENCIL_TEST );\n\t\tgl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\tgl.blendFunc( gl.ONE, gl.ZERO );\n\t\tgl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );\n\t\tgl.blendColor( 0, 0, 0, 0 );\n\n\t\tgl.colorMask( true, true, true, true );\n\t\tgl.clearColor( 0, 0, 0, 0 );\n\n\t\tgl.depthMask( true );\n\t\tgl.depthFunc( gl.LESS );\n\t\tgl.clearDepth( 1 );\n\n\t\tgl.stencilMask( 0xffffffff );\n\t\tgl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );\n\t\tgl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );\n\t\tgl.clearStencil( 0 );\n\n\t\tgl.cullFace( gl.BACK );\n\t\tgl.frontFace( gl.CCW );\n\n\t\tgl.polygonOffset( 0, 0 );\n\n\t\tgl.activeTexture( gl.TEXTURE0 );\n\n\t\tgl.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\tgl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );\n\t\tgl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );\n\n\t\tgl.useProgram( null );\n\n\t\tgl.lineWidth( 1 );\n\n\t\tgl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tgl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\t// reset internals\n\n\t\tenabledCapabilities = {};\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentBoundFramebuffers = {};\n\t\tcurrentDrawbuffers = new WeakMap();\n\t\tdefaultDrawbuffers = [];\n\n\t\tcurrentProgram = null;\n\n\t\tcurrentBlendingEnabled = false;\n\t\tcurrentBlending = null;\n\t\tcurrentBlendEquation = null;\n\t\tcurrentBlendSrc = null;\n\t\tcurrentBlendDst = null;\n\t\tcurrentBlendEquationAlpha = null;\n\t\tcurrentBlendSrcAlpha = null;\n\t\tcurrentBlendDstAlpha = null;\n\t\tcurrentBlendColor = new Color( 0, 0, 0 );\n\t\tcurrentBlendAlpha = 0;\n\t\tcurrentPremultipledAlpha = false;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tcurrentLineWidth = null;\n\n\t\tcurrentPolygonOffsetFactor = null;\n\t\tcurrentPolygonOffsetUnits = null;\n\n\t\tcurrentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tcurrentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\tcolorBuffer.reset();\n\t\tdepthBuffer.reset();\n\t\tstencilBuffer.reset();\n\n\t}\n\n\treturn {\n\n\t\tbuffers: {\n\t\t\tcolor: colorBuffer,\n\t\t\tdepth: depthBuffer,\n\t\t\tstencil: stencilBuffer\n\t\t},\n\n\t\tenable: enable,\n\t\tdisable: disable,\n\n\t\tbindFramebuffer: bindFramebuffer,\n\t\tdrawBuffers: drawBuffers,\n\n\t\tuseProgram: useProgram,\n\n\t\tsetBlending: setBlending,\n\t\tsetMaterial: setMaterial,\n\n\t\tsetFlipSided: setFlipSided,\n\t\tsetCullFace: setCullFace,\n\n\t\tsetLineWidth: setLineWidth,\n\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\tsetScissorTest: setScissorTest,\n\n\t\tactiveTexture: activeTexture,\n\t\tbindTexture: bindTexture,\n\t\tunbindTexture: unbindTexture,\n\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\tcompressedTexImage3D: compressedTexImage3D,\n\t\ttexImage2D: texImage2D,\n\t\ttexImage3D: texImage3D,\n\n\t\tupdateUBOMapping: updateUBOMapping,\n\t\tuniformBlockBinding: uniformBlockBinding,\n\n\t\ttexStorage2D: texStorage2D,\n\t\ttexStorage3D: texStorage3D,\n\t\ttexSubImage2D: texSubImage2D,\n\t\ttexSubImage3D: texSubImage3D,\n\t\tcompressedTexSubImage2D: compressedTexSubImage2D,\n\t\tcompressedTexSubImage3D: compressedTexSubImage3D,\n\n\t\tscissor: scissor,\n\t\tviewport: viewport,\n\n\t\treset: reset\n\n\t};\n\n}\n\nfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {\n\n\tconst multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;\n\tconst supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );\n\n\tconst _imageDimensions = new Vector2();\n\tconst _videoTextures = new WeakMap();\n\tlet _canvas;\n\n\tconst _sources = new WeakMap(); // maps WebglTexture objects to instances of Source\n\n\t// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n\t// also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n\t// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\tlet useOffscreenCanvas = false;\n\n\ttry {\n\n\t\tuseOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'\n\t\t\t// eslint-disable-next-line compat/compat\n\t\t\t&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;\n\n\t} catch ( err ) {\n\n\t\t// Ignore any errors\n\n\t}\n\n\tfunction createCanvas( width, height ) {\n\n\t\t// Use OffscreenCanvas when available. Specially needed in web workers\n\n\t\treturn useOffscreenCanvas ?\n\t\t\t// eslint-disable-next-line compat/compat\n\t\t\tnew OffscreenCanvas( width, height ) : createElementNS( 'canvas' );\n\n\t}\n\n\tfunction resizeImage( image, needsNewCanvas, maxSize ) {\n\n\t\tlet scale = 1;\n\n\t\tconst dimensions = getDimensions( image );\n\n\t\t// handle case if texture exceeds max size\n\n\t\tif ( dimensions.width > maxSize || dimensions.height > maxSize ) {\n\n\t\t\tscale = maxSize / Math.max( dimensions.width, dimensions.height );\n\n\t\t}\n\n\t\t// only perform resize if necessary\n\n\t\tif ( scale < 1 ) {\n\n\t\t\t// only perform resize for certain image types\n\n\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||\n\t\t\t\t( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) ) {\n\n\t\t\t\tconst width = Math.floor( scale * dimensions.width );\n\t\t\t\tconst height = Math.floor( scale * dimensions.height );\n\n\t\t\t\tif ( _canvas === undefined ) _canvas = createCanvas( width, height );\n\n\t\t\t\t// cube textures can't reuse the same canvas\n\n\t\t\t\tconst canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;\n\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').' );\n\n\t\t\t\treturn canvas;\n\n\t\t\t} else {\n\n\t\t\t\tif ( 'data' in image ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').' );\n\n\t\t\t\t}\n\n\t\t\t\treturn image;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction textureNeedsGenerateMipmaps( texture ) {\n\n\t\treturn texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\n\t}\n\n\tfunction generateMipmap( target ) {\n\n\t\t_gl.generateMipmap( target );\n\n\t}\n\n\tfunction getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === _gl.RED ) {\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RED_INTEGER ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8UI;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.R16UI;\n\t\t\tif ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.R32UI;\n\t\t\tif ( glType === _gl.BYTE ) internalFormat = _gl.R8I;\n\t\t\tif ( glType === _gl.SHORT ) internalFormat = _gl.R16I;\n\t\t\tif ( glType === _gl.INT ) internalFormat = _gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RG ) {\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RG_INTEGER ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8UI;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RG16UI;\n\t\t\tif ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RG32UI;\n\t\t\tif ( glType === _gl.BYTE ) internalFormat = _gl.RG8I;\n\t\t\tif ( glType === _gl.SHORT ) internalFormat = _gl.RG16I;\n\t\t\tif ( glType === _gl.INT ) internalFormat = _gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RGB ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = _gl.RGB9_E5;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RGBA ) {\n\n\t\t\tconst transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;\n\n\t\t}\n\n\t\tif ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||\n\t\t\tinternalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||\n\t\t\tinternalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\tfunction getInternalDepthFormat( useStencil, depthType ) {\n\n\t\tlet glInternalFormat;\n\t\tif ( useStencil ) {\n\n\t\t\tif ( depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH24_STENCIL8;\n\n\t\t\t} else if ( depthType === FloatType ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH32F_STENCIL8;\n\n\t\t\t} else if ( depthType === UnsignedShortType ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH24_STENCIL8;\n\t\t\t\tconsole.warn( 'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.' );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\n\t\t\t} else if ( depthType === FloatType ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t} else if ( depthType === UnsignedShortType ) {\n\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn glInternalFormat;\n\n\t}\n\n\tfunction getMipLevels( texture, image ) {\n\n\t\tif ( textureNeedsGenerateMipmaps( texture ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {\n\n\t\t\treturn Math.log2( Math.max( image.width, image.height ) ) + 1;\n\n\t\t} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {\n\n\t\t\t// user-defined mipmaps\n\n\t\t\treturn texture.mipmaps.length;\n\n\t\t} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {\n\n\t\t\treturn image.mipmaps.length;\n\n\t\t} else {\n\n\t\t\t// texture without mipmaps (only base level)\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\t_videoTextures.delete( texture );\n\n\t\t}\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tconst renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t// check if it's necessary to remove the WebGLTexture object\n\n\t\tconst source = texture.source;\n\t\tconst webglTextures = _sources.get( source );\n\n\t\tif ( webglTextures ) {\n\n\t\t\tconst webglTexture = webglTextures[ textureProperties.__cacheKey ];\n\t\t\twebglTexture.usedTimes --;\n\n\t\t\t// the WebGLTexture object is not used anymore, remove it\n\n\t\t\tif ( webglTexture.usedTimes === 0 ) {\n\n\t\t\t\tdeleteTexture( texture );\n\n\t\t\t}\n\n\t\t\t// remove the weak map entry if no WebGLTexture uses the source anymore\n\n\t\t\tif ( Object.keys( webglTextures ).length === 0 ) {\n\n\t\t\t\t_sources.delete( source );\n\n\t\t\t}\n\n\t\t}\n\n\t\tproperties.remove( texture );\n\n\t}\n\n\tfunction deleteTexture( texture ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\tconst source = texture.source;\n\t\tconst webglTextures = _sources.get( source );\n\t\tdelete webglTextures[ textureProperties.__cacheKey ];\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( Array.isArray( renderTargetProperties.__webglFramebuffer[ i ] ) ) {\n\n\t\t\t\t\tfor ( let level = 0; level < renderTargetProperties.__webglFramebuffer[ i ].length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ][ level ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( Array.isArray( renderTargetProperties.__webglFramebuffer ) ) {\n\n\t\t\t\tfor ( let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ level ] );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\n\t\t\t}\n\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\t\tif ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\tif ( renderTargetProperties.__webglColorRenderbuffer ) {\n\n\t\t\t\tfor ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {\n\n\t\t\t\t\tif ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );\n\n\t\t}\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\tconst attachmentProperties = properties.get( textures[ i ] );\n\n\t\t\tif ( attachmentProperties.__webglTexture ) {\n\n\t\t\t\t_gl.deleteTexture( attachmentProperties.__webglTexture );\n\n\t\t\t\tinfo.memory.textures --;\n\n\t\t\t}\n\n\t\t\tproperties.remove( textures[ i ] );\n\n\t\t}\n\n\t\tproperties.remove( renderTarget );\n\n\t}\n\n\t//\n\n\tlet textureUnits = 0;\n\n\tfunction resetTextureUnits() {\n\n\t\ttextureUnits = 0;\n\n\t}\n\n\tfunction allocateTextureUnit() {\n\n\t\tconst textureUnit = textureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\ttextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tfunction getTextureCacheKey( texture ) {\n\n\t\tconst array = [];\n\n\t\tarray.push( texture.wrapS );\n\t\tarray.push( texture.wrapT );\n\t\tarray.push( texture.wrapR || 0 );\n\t\tarray.push( texture.magFilter );\n\t\tarray.push( texture.minFilter );\n\t\tarray.push( texture.anisotropy );\n\t\tarray.push( texture.internalFormat );\n\t\tarray.push( texture.format );\n\t\tarray.push( texture.type );\n\t\tarray.push( texture.generateMipmaps );\n\t\tarray.push( texture.premultiplyAlpha );\n\t\tarray.push( texture.flipY );\n\t\tarray.push( texture.unpackAlignment );\n\t\tarray.push( texture.colorSpace );\n\n\t\treturn array.join();\n\n\t}\n\n\t//\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\n\n\t\tif ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tconst image = texture.image;\n\n\t\t\tif ( image === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTexture2DArray( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTexture3D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTextureCube( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadCubeTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tconst wrappingToGL = {\n\t\t[ RepeatWrapping ]: _gl.REPEAT,\n\t\t[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,\n\t\t[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT\n\t};\n\n\tconst filterToGL = {\n\t\t[ NearestFilter ]: _gl.NEAREST,\n\t\t[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,\n\t\t[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,\n\n\t\t[ LinearFilter ]: _gl.LINEAR,\n\t\t[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,\n\t\t[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR\n\t};\n\n\tconst compareToGL = {\n\t\t[ NeverCompare ]: _gl.NEVER,\n\t\t[ AlwaysCompare ]: _gl.ALWAYS,\n\t\t[ LessCompare ]: _gl.LESS,\n\t\t[ LessEqualCompare ]: _gl.LEQUAL,\n\t\t[ EqualCompare ]: _gl.EQUAL,\n\t\t[ GreaterEqualCompare ]: _gl.GEQUAL,\n\t\t[ GreaterCompare ]: _gl.GREATER,\n\t\t[ NotEqualCompare ]: _gl.NOTEQUAL\n\t};\n\n\tfunction setTextureParameters( textureType, texture ) {\n\n\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false &&\n\t\t\t( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||\n\t\t\ttexture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter ) ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.' );\n\n\t\t}\n\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );\n\n\t\tif ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );\n\n\t\t}\n\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );\n\n\t\tif ( texture.compareFunction ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tif ( texture.magFilter === NearestFilter ) return;\n\t\t\tif ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;\n\t\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initTexture( textureProperties, texture ) {\n\n\t\tlet forceUpload = false;\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t}\n\n\t\t// create Source <-> WebGLTextures mapping if necessary\n\n\t\tconst source = texture.source;\n\t\tlet webglTextures = _sources.get( source );\n\n\t\tif ( webglTextures === undefined ) {\n\n\t\t\twebglTextures = {};\n\t\t\t_sources.set( source, webglTextures );\n\n\t\t}\n\n\t\t// check if there is already a WebGLTexture object for the given texture parameters\n\n\t\tconst textureCacheKey = getTextureCacheKey( texture );\n\n\t\tif ( textureCacheKey !== textureProperties.__cacheKey ) {\n\n\t\t\t// if not, create a new instance of WebGLTexture\n\n\t\t\tif ( webglTextures[ textureCacheKey ] === undefined ) {\n\n\t\t\t\t// create new entry\n\n\t\t\t\twebglTextures[ textureCacheKey ] = {\n\t\t\t\t\ttexture: _gl.createTexture(),\n\t\t\t\t\tusedTimes: 0\n\t\t\t\t};\n\n\t\t\t\tinfo.memory.textures ++;\n\n\t\t\t\t// when a new instance of WebGLTexture was created, a texture upload is required\n\t\t\t\t// even if the image contents are identical\n\n\t\t\t\tforceUpload = true;\n\n\t\t\t}\n\n\t\t\twebglTextures[ textureCacheKey ].usedTimes ++;\n\n\t\t\t// every time the texture cache key changes, it's necessary to check if an instance of\n\t\t\t// WebGLTexture can be deleted in order to avoid a memory leak.\n\n\t\t\tconst webglTexture = webglTextures[ textureProperties.__cacheKey ];\n\n\t\t\tif ( webglTexture !== undefined ) {\n\n\t\t\t\twebglTextures[ textureProperties.__cacheKey ].usedTimes --;\n\n\t\t\t\tif ( webglTexture.usedTimes === 0 ) {\n\n\t\t\t\t\tdeleteTexture( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// store references to cache key and WebGLTexture object\n\n\t\t\ttextureProperties.__cacheKey = textureCacheKey;\n\t\t\ttextureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;\n\n\t\t}\n\n\t\treturn forceUpload;\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tlet textureType = _gl.TEXTURE_2D;\n\n\t\tif ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;\n\t\tif ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;\n\n\t\tconst forceUpload = initTexture( textureProperties, texture );\n\t\tconst source = texture.source;\n\n\t\tstate.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t\tconst sourceProperties = properties.get( source );\n\n\t\tif ( source.version !== sourceProperties.__version || forceUpload === true ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\n\t\t\tconst workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );\n\t\t\tconst texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );\n\t\t\tconst unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );\n\n\t\t\tlet image = resizeImage( texture.image, false, capabilities.maxTextureSize );\n\t\t\timage = verifyColorSpace( texture, image );\n\n\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\n\t\t\tconst glType = utils.convert( texture.type );\n\t\t\tlet glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );\n\n\t\t\tsetTextureParameters( textureType, texture );\n\n\t\t\tlet mipmap;\n\t\t\tconst mipmaps = texture.mipmaps;\n\n\t\t\tconst useTexStorage = ( texture.isVideoTexture !== true );\n\t\t\tconst allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );\n\t\t\tconst dataReady = source.dataReady;\n\t\t\tconst levels = getMipLevels( texture, image );\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tglInternalFormat = getInternalDepthFormat( texture.format === DepthStencilFormat, texture.type );\n\n\t\t\t\t//\n\n\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isDataTexture ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isCompressedTexture ) {\n\n\t\t\t\tif ( texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\t\tif ( texture.layerUpdates.size > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( const layerIndex of texture.layerUpdates ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconst layerSize = mipmap.width * mipmap.height;\n\t\t\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, mipmap.data.slice( layerSize * layerIndex, layerSize * ( layerIndex + 1 ) ), 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\ttexture.clearLayerUpdates();\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isDataArrayTexture ) {\n\n\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\tif ( texture.layerUpdates.size > 0 ) {\n\n\t\t\t\t\t\t\t// When type is GL_UNSIGNED_BYTE, each of these bytes is\n\t\t\t\t\t\t\t// interpreted as one color component, depending on format. When\n\t\t\t\t\t\t\t// type is one of GL_UNSIGNED_SHORT_5_6_5,\n\t\t\t\t\t\t\t// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_5_5_5_1, each\n\t\t\t\t\t\t\t// unsigned value is interpreted as containing all the components\n\t\t\t\t\t\t\t// for a single pixel, with the color components arranged\n\t\t\t\t\t\t\t// according to format.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// See https://registry.khronos.org/OpenGL-Refpages/es1.1/xhtml/glTexImage2D.xml\n\t\t\t\t\t\t\tlet texelSize;\n\t\t\t\t\t\t\tswitch ( glType ) {\n\n\t\t\t\t\t\t\t\tcase _gl.UNSIGNED_BYTE:\n\t\t\t\t\t\t\t\t\tswitch ( glFormat ) {\n\n\t\t\t\t\t\t\t\t\t\tcase _gl.ALPHA:\n\t\t\t\t\t\t\t\t\t\t\ttexelSize = 1;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase _gl.LUMINANCE:\n\t\t\t\t\t\t\t\t\t\t\ttexelSize = 1;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase _gl.LUMINANCE_ALPHA:\n\t\t\t\t\t\t\t\t\t\t\ttexelSize = 2;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase _gl.RGB:\n\t\t\t\t\t\t\t\t\t\t\ttexelSize = 3;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase _gl.RGBA:\n\t\t\t\t\t\t\t\t\t\t\ttexelSize = 4;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tthrow new Error( `Unknown texel size for format ${glFormat}.` );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase _gl.UNSIGNED_SHORT_4_4_4_4:\n\t\t\t\t\t\t\t\tcase _gl.UNSIGNED_SHORT_5_5_5_1:\n\t\t\t\t\t\t\t\tcase _gl.UNSIGNED_SHORT_5_6_5:\n\t\t\t\t\t\t\t\t\ttexelSize = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tthrow new Error( `Unknown texel size for type ${glType}.` );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst layerSize = image.width * image.height * texelSize;\n\n\t\t\t\t\t\t\tfor ( const layerIndex of texture.layerUpdates ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, image.data.slice( layerSize * layerIndex, layerSize * ( layerIndex + 1 ) ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttexture.clearLayerUpdates();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isFramebufferTexture ) {\n\n\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlet width = image.width, height = image.height;\n\n\t\t\t\t\t\tfor ( let i = 0; i < levels; i ++ ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );\n\n\t\t\t\t\t\t\twidth >>= 1;\n\t\t\t\t\t\t\theight >>= 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tconst dimensions = getDimensions( mipmaps[ 0 ] );\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\t\tconst dimensions = getDimensions( image );\n\n\t\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tgenerateMipmap( textureType );\n\n\t\t\t}\n\n\t\t\tsourceProperties.__version = source.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t}\n\n\tfunction uploadCubeTexture( textureProperties, texture, slot ) {\n\n\t\tif ( texture.image.length !== 6 ) return;\n\n\t\tconst forceUpload = initTexture( textureProperties, texture );\n\t\tconst source = texture.source;\n\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t\tconst sourceProperties = properties.get( source );\n\n\t\tif ( source.version !== sourceProperties.__version || forceUpload === true ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\n\t\t\tconst workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );\n\t\t\tconst texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );\n\t\t\tconst unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );\n\n\t\t\tconst isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );\n\t\t\tconst isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\n\t\t\tconst cubeImage = [];\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\tcubeImage[ i ] = resizeImage( texture.image[ i ], true, capabilities.maxCubemapSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );\n\n\t\t\t}\n\n\t\t\tconst image = cubeImage[ 0 ],\n\t\t\t\tglFormat = utils.convert( texture.format, texture.colorSpace ),\n\t\t\t\tglType = utils.convert( texture.type ),\n\t\t\t\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\n\t\t\tconst useTexStorage = ( texture.isVideoTexture !== true );\n\t\t\tconst allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );\n\t\t\tconst dataReady = source.dataReady;\n\t\t\tlet levels = getMipLevels( texture, image );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );\n\n\t\t\tlet mipmaps;\n\n\t\t\tif ( isCompressed ) {\n\n\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tmipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmipmaps = texture.mipmaps;\n\n\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t// TODO: Uniformly handle mipmap definitions\n\t\t\t\t\t// Normal textures and compressed cube textures define base level + mips with their mipmap array\n\t\t\t\t\t// Uncompressed cube textures use their mipmap array only for mips (no base level)\n\n\t\t\t\t\tif ( mipmaps.length > 0 ) levels ++;\n\n\t\t\t\t\tconst dimensions = getDimensions( cubeImage[ 0 ] );\n\n\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\t\t\t\t\t\t\tconst mipmapImage = mipmap.image[ i ].image;\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\t// We assume images for cube map have the same size.\n\t\t\t\tgenerateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t}\n\n\t\t\tsourceProperties.__version = source.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget, level ) {\n\n\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\tconst glType = utils.convert( texture.type );\n\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tif ( ! renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\tconst width = Math.max( 1, renderTarget.width >> level );\n\t\t\tconst height = Math.max( 1, renderTarget.height >> level );\n\n\t\t\tif ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t\tstate.texImage3D( textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null );\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );\n\n\t\t} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753\n\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, level );\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t// retrieve the depth attachment types\n\t\t\tconst depthTexture = renderTarget.depthTexture;\n\t\t\tconst depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;\n\t\t\tconst glInternalFormat = getInternalDepthFormat( renderTarget.stencilBuffer, depthType );\n\t\t\tconst glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\n\t\t\t// set up the attachment\n\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\t\t\tconst isUseMultisampledRTT = useMultisampledRTT( renderTarget );\n\t\t\tif ( isUseMultisampledRTT ) {\n\n\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t} else if ( isMultisample ) {\n\n\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\tconst textures = renderTarget.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\t\t\tconst glType = utils.convert( texture.type );\n\t\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\tif ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t} else if ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\tconst isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );\n\t\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\n\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tconst webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t}\n\n\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Unknown depthTexture format' );\n\n\t\t}\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\n\t\tif ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {\n\n\t\t\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// rebind framebuffer with external textures\n\tfunction rebindTextures( renderTarget, colorTexture, depthTexture ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tif ( colorTexture !== undefined ) {\n\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0 );\n\n\t\t}\n\n\t\tif ( depthTexture !== undefined ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst textureProperties = properties.get( texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\t\tconst isMultipleRenderTargets = ( textures.length > 1 );\n\n\t\tif ( ! isMultipleRenderTargets ) {\n\n\t\t\tif ( textureProperties.__webglTexture === undefined ) {\n\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t}\n\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tinfo.memory.textures ++;\n\n\t\t}\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = [];\n\n\t\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ][ level ] = _gl.createFramebuffer();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ level ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attachmentProperties = properties.get( textures[ i ] );\n\n\t\t\t\t\tif ( attachmentProperties.__webglTexture === undefined ) {\n\n\t\t\t\t\t\tattachmentProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\t\t\tinfo.memory.textures ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = [];\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\t\t\t\tconst glType = utils.convert( texture.type );\n\t\t\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );\n\t\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\t\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ][ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tgenerateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t} else if ( isMultipleRenderTargets ) {\n\n\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\tconst attachment = textures[ i ];\n\t\t\t\tconst attachmentProperties = properties.get( attachment );\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, attachmentProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, attachment );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0 );\n\n\t\t\t\tif ( textureNeedsGenerateMipmaps( attachment ) ) {\n\n\t\t\t\t\tgenerateMipmap( _gl.TEXTURE_2D );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t} else {\n\n\t\t\tlet glTextureType = _gl.TEXTURE_2D;\n\n\t\t\tif ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {\n\n\t\t\t\tglTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( glTextureType, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( glTextureType, texture );\n\n\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0 );\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tgenerateMipmap( glTextureType );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tconst target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tconst webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\tgenerateMipmap( target );\n\t\t\t\tstate.unbindTexture();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst invalidationArrayRead = [];\n\tconst invalidationArrayDraw = [];\n\n\tfunction updateMultisampleRenderTarget( renderTarget ) {\n\n\t\tif ( renderTarget.samples > 0 ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\tconst textures = renderTarget.textures;\n\t\t\t\tconst width = renderTarget.width;\n\t\t\t\tconst height = renderTarget.height;\n\t\t\t\tlet mask = _gl.COLOR_BUFFER_BIT;\n\t\t\t\tconst depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\t\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tconst isMultipleRenderTargets = ( textures.length > 1 );\n\n\t\t\t\t// If MRT we need to remove FBO attachments\n\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tif ( renderTarget.resolveDepthBuffer ) {\n\n\t\t\t\t\t\tif ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;\n\n\t\t\t\t\t\t// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)\n\n\t\t\t\t\t\tif ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\t\tconst webglTexture = properties.get( textures[ i ] ).__webglTexture;\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );\n\n\t\t\t\t\tif ( supportsInvalidateFramebuffer === true ) {\n\n\t\t\t\t\t\tinvalidationArrayRead.length = 0;\n\t\t\t\t\t\tinvalidationArrayDraw.length = 0;\n\n\t\t\t\t\t\tinvalidationArrayRead.push( _gl.COLOR_ATTACHMENT0 + i );\n\n\t\t\t\t\t\tif ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false ) {\n\n\t\t\t\t\t\t\tinvalidationArrayRead.push( depthStyle );\n\t\t\t\t\t\t\tinvalidationArrayDraw.push( depthStyle );\n\n\t\t\t\t\t\t\t_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, invalidationArrayDraw );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArrayRead );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );\n\n\t\t\t\t// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments\n\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\t\tconst webglTexture = properties.get( textures[ i ] ).__webglTexture;\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\t} else {\n\n\t\t\t\tif ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer ) {\n\n\t\t\t\t\tconst depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\n\t\t\t\t\t_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction getRenderTargetSamples( renderTarget ) {\n\n\t\treturn Math.min( capabilities.maxSamples, renderTarget.samples );\n\n\t}\n\n\tfunction useMultisampledRTT( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\treturn renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;\n\n\t}\n\n\tfunction updateVideoTexture( texture ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\t// Check the last frame we updated the VideoTexture\n\n\t\tif ( _videoTextures.get( texture ) !== frame ) {\n\n\t\t\t_videoTextures.set( texture, frame );\n\t\t\ttexture.update();\n\n\t\t}\n\n\t}\n\n\tfunction verifyColorSpace( texture, image ) {\n\n\t\tconst colorSpace = texture.colorSpace;\n\t\tconst format = texture.format;\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isCompressedTexture === true || texture.isVideoTexture === true ) return image;\n\n\t\tif ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {\n\n\t\t\t// sRGB\n\n\t\t\tif ( ColorManagement.getTransfer( colorSpace ) === SRGBTransfer ) {\n\n\t\t\t\t// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format\n\n\t\t\t\tif ( format !== RGBAFormat || type !== UnsignedByteType ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.WebGLTextures: Unsupported texture color space:', colorSpace );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction getDimensions( image ) {\n\n\t\tif ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) {\n\n\t\t\t// if intrinsic data are not available, fallback to width/height\n\n\t\t\t_imageDimensions.width = image.naturalWidth || image.width;\n\t\t\t_imageDimensions.height = image.naturalHeight || image.height;\n\n\t\t} else if ( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) {\n\n\t\t\t_imageDimensions.width = image.displayWidth;\n\t\t\t_imageDimensions.height = image.displayHeight;\n\n\t\t} else {\n\n\t\t\t_imageDimensions.width = image.width;\n\t\t\t_imageDimensions.height = image.height;\n\n\t\t}\n\n\t\treturn _imageDimensions;\n\n\t}\n\n\t//\n\n\tthis.allocateTextureUnit = allocateTextureUnit;\n\tthis.resetTextureUnits = resetTextureUnits;\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTexture2DArray = setTexture2DArray;\n\tthis.setTexture3D = setTexture3D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.rebindTextures = rebindTextures;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\tthis.setupDepthRenderbuffer = setupDepthRenderbuffer;\n\tthis.setupFrameBufferTexture = setupFrameBufferTexture;\n\tthis.useMultisampledRTT = useMultisampledRTT;\n\n}\n\nfunction WebGLUtils( gl, extensions ) {\n\n\tfunction convert( p, colorSpace = NoColorSpace ) {\n\n\t\tlet extension;\n\n\t\tconst transfer = ColorManagement.getTransfer( colorSpace );\n\n\t\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;\n\n\t\tif ( p === ByteType ) return gl.BYTE;\n\t\tif ( p === ShortType ) return gl.SHORT;\n\t\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\tif ( p === IntType ) return gl.INT;\n\t\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\tif ( p === FloatType ) return gl.FLOAT;\n\t\tif ( p === HalfFloatType ) return gl.HALF_FLOAT;\n\n\t\tif ( p === AlphaFormat ) return gl.ALPHA;\n\t\tif ( p === RGBFormat ) return gl.RGB;\n\t\tif ( p === RGBAFormat ) return gl.RGBA;\n\t\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\n\t\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\n\t\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === RedFormat ) return gl.RED;\n\t\tif ( p === RedIntegerFormat ) return gl.RED_INTEGER;\n\t\tif ( p === RGFormat ) return gl.RG;\n\t\tif ( p === RGIntegerFormat ) return gl.RG_INTEGER;\n\t\tif ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;\n\n\t\t// S3TC\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\tif ( transfer === SRGBTransfer ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// PVRTC\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ETC\n\n\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === RGBA_ETC2_EAC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ASTC\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_ASTC_4x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x12_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// BPTC\n\n\t\tif ( p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n\t\t\t\tif ( p === RGB_BPTC_SIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;\n\t\t\t\tif ( p === RGB_BPTC_UNSIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// RGTC\n\n\t\tif ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_rgtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n\t\t\t\tif ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( p === UnsignedInt248Type ) return gl.UNSIGNED_INT_24_8;\n\n\t\t// if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n\t\treturn ( gl[ p ] !== undefined ) ? gl[ p ] : null;\n\n\t}\n\n\treturn { convert: convert };\n\n}\n\nclass ArrayCamera extends PerspectiveCamera {\n\n\tconstructor( array = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isArrayCamera = true;\n\n\t\tthis.cameras = array;\n\n\t}\n\n}\n\nclass Group extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isGroup = true;\n\n\t\tthis.type = 'Group';\n\n\t}\n\n}\n\nconst _moveEvent = { type: 'move' };\n\nclass WebXRController {\n\n\tconstructor() {\n\n\t\tthis._targetRay = null;\n\t\tthis._grip = null;\n\t\tthis._hand = null;\n\n\t}\n\n\tgetHandSpace() {\n\n\t\tif ( this._hand === null ) {\n\n\t\t\tthis._hand = new Group();\n\t\t\tthis._hand.matrixAutoUpdate = false;\n\t\t\tthis._hand.visible = false;\n\n\t\t\tthis._hand.joints = {};\n\t\t\tthis._hand.inputState = { pinching: false };\n\n\t\t}\n\n\t\treturn this._hand;\n\n\t}\n\n\tgetTargetRaySpace() {\n\n\t\tif ( this._targetRay === null ) {\n\n\t\t\tthis._targetRay = new Group();\n\t\t\tthis._targetRay.matrixAutoUpdate = false;\n\t\t\tthis._targetRay.visible = false;\n\t\t\tthis._targetRay.hasLinearVelocity = false;\n\t\t\tthis._targetRay.linearVelocity = new Vector3();\n\t\t\tthis._targetRay.hasAngularVelocity = false;\n\t\t\tthis._targetRay.angularVelocity = new Vector3();\n\n\t\t}\n\n\t\treturn this._targetRay;\n\n\t}\n\n\tgetGripSpace() {\n\n\t\tif ( this._grip === null ) {\n\n\t\t\tthis._grip = new Group();\n\t\t\tthis._grip.matrixAutoUpdate = false;\n\t\t\tthis._grip.visible = false;\n\t\t\tthis._grip.hasLinearVelocity = false;\n\t\t\tthis._grip.linearVelocity = new Vector3();\n\t\t\tthis._grip.hasAngularVelocity = false;\n\t\t\tthis._grip.angularVelocity = new Vector3();\n\n\t\t}\n\n\t\treturn this._grip;\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.dispatchEvent( event );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tconnect( inputSource ) {\n\n\t\tif ( inputSource && inputSource.hand ) {\n\n\t\t\tconst hand = this._hand;\n\n\t\t\tif ( hand ) {\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Initialize hand with joints when connected\n\t\t\t\t\tthis._getHandJoint( hand, inputjoint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( { type: 'connected', data: inputSource } );\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect( inputSource ) {\n\n\t\tthis.dispatchEvent( { type: 'disconnected', data: inputSource } );\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.visible = false;\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.visible = false;\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.visible = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tupdate( inputSource, frame, referenceSpace ) {\n\n\t\tlet inputPose = null;\n\t\tlet gripPose = null;\n\t\tlet handPose = null;\n\n\t\tconst targetRay = this._targetRay;\n\t\tconst grip = this._grip;\n\t\tconst hand = this._hand;\n\n\t\tif ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {\n\n\t\t\tif ( hand && inputSource.hand ) {\n\n\t\t\t\thandPose = true;\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Update the joints groups with the XRJoint poses\n\t\t\t\t\tconst jointPose = frame.getJointPose( inputjoint, referenceSpace );\n\n\t\t\t\t\t// The transform of this joint will be updated with the joint pose on each frame\n\t\t\t\t\tconst joint = this._getHandJoint( hand, inputjoint );\n\n\t\t\t\t\tif ( jointPose !== null ) {\n\n\t\t\t\t\t\tjoint.matrix.fromArray( jointPose.transform.matrix );\n\t\t\t\t\t\tjoint.matrix.decompose( joint.position, joint.rotation, joint.scale );\n\t\t\t\t\t\tjoint.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\tjoint.jointRadius = jointPose.radius;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tjoint.visible = jointPose !== null;\n\n\t\t\t\t}\n\n\t\t\t\t// Custom events\n\n\t\t\t\t// Check pinchz\n\t\t\t\tconst indexTip = hand.joints[ 'index-finger-tip' ];\n\t\t\t\tconst thumbTip = hand.joints[ 'thumb-tip' ];\n\t\t\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\n\t\t\t\tconst distanceToPinch = 0.02;\n\t\t\t\tconst threshold = 0.005;\n\n\t\t\t\tif ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = false;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchend',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = true;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchstart',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( grip !== null && inputSource.gripSpace ) {\n\n\t\t\t\t\tgripPose = frame.getPose( inputSource.gripSpace, referenceSpace );\n\n\t\t\t\t\tif ( gripPose !== null ) {\n\n\t\t\t\t\t\tgrip.matrix.fromArray( gripPose.transform.matrix );\n\t\t\t\t\t\tgrip.matrix.decompose( grip.position, grip.rotation, grip.scale );\n\t\t\t\t\t\tgrip.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t\t\tif ( gripPose.linearVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = true;\n\t\t\t\t\t\t\tgrip.linearVelocity.copy( gripPose.linearVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( gripPose.angularVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = true;\n\t\t\t\t\t\t\tgrip.angularVelocity.copy( gripPose.angularVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( targetRay !== null ) {\n\n\t\t\t\tinputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );\n\n\t\t\t\t// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it\n\t\t\t\tif ( inputPose === null && gripPose !== null ) {\n\n\t\t\t\t\tinputPose = gripPose;\n\n\t\t\t\t}\n\n\t\t\t\tif ( inputPose !== null ) {\n\n\t\t\t\t\ttargetRay.matrix.fromArray( inputPose.transform.matrix );\n\t\t\t\t\ttargetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );\n\t\t\t\t\ttargetRay.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t\tif ( inputPose.linearVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = true;\n\t\t\t\t\t\ttargetRay.linearVelocity.copy( inputPose.linearVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( inputPose.angularVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = true;\n\t\t\t\t\t\ttargetRay.angularVelocity.copy( inputPose.angularVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.dispatchEvent( _moveEvent );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif ( targetRay !== null ) {\n\n\t\t\ttargetRay.visible = ( inputPose !== null );\n\n\t\t}\n\n\t\tif ( grip !== null ) {\n\n\t\t\tgrip.visible = ( gripPose !== null );\n\n\t\t}\n\n\t\tif ( hand !== null ) {\n\n\t\t\thand.visible = ( handPose !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// private method\n\n\t_getHandJoint( hand, inputjoint ) {\n\n\t\tif ( hand.joints[ inputjoint.jointName ] === undefined ) {\n\n\t\t\tconst joint = new Group();\n\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\tjoint.visible = false;\n\t\t\thand.joints[ inputjoint.jointName ] = joint;\n\n\t\t\thand.add( joint );\n\n\t\t}\n\n\t\treturn hand.joints[ inputjoint.jointName ];\n\n\t}\n\n}\n\nconst _occlusion_vertex = `\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}`;\n\nconst _occlusion_fragment = `\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}`;\n\nclass WebXRDepthSensing {\n\n\tconstructor() {\n\n\t\tthis.texture = null;\n\t\tthis.mesh = null;\n\n\t\tthis.depthNear = 0;\n\t\tthis.depthFar = 0;\n\n\t}\n\n\tinit( renderer, depthData, renderState ) {\n\n\t\tif ( this.texture === null ) {\n\n\t\t\tconst texture = new Texture();\n\n\t\t\tconst texProps = renderer.properties.get( texture );\n\t\t\ttexProps.__webglTexture = depthData.texture;\n\n\t\t\tif ( ( depthData.depthNear != renderState.depthNear ) || ( depthData.depthFar != renderState.depthFar ) ) {\n\n\t\t\t\tthis.depthNear = depthData.depthNear;\n\t\t\t\tthis.depthFar = depthData.depthFar;\n\n\t\t\t}\n\n\t\t\tthis.texture = texture;\n\n\t\t}\n\n\t}\n\n\tgetMesh( cameraXR ) {\n\n\t\tif ( this.texture !== null ) {\n\n\t\t\tif ( this.mesh === null ) {\n\n\t\t\t\tconst viewport = cameraXR.cameras[ 0 ].viewport;\n\t\t\t\tconst material = new ShaderMaterial( {\n\t\t\t\t\tvertexShader: _occlusion_vertex,\n\t\t\t\t\tfragmentShader: _occlusion_fragment,\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tdepthColor: { value: this.texture },\n\t\t\t\t\t\tdepthWidth: { value: viewport.z },\n\t\t\t\t\t\tdepthHeight: { value: viewport.w }\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tthis.mesh = new Mesh( new PlaneGeometry( 20, 20 ), material );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this.mesh;\n\n\t}\n\n\treset() {\n\n\t\tthis.texture = null;\n\t\tthis.mesh = null;\n\n\t}\n\n}\n\nclass WebXRManager extends EventDispatcher {\n\n\tconstructor( renderer, gl ) {\n\n\t\tsuper();\n\n\t\tconst scope = this;\n\n\t\tlet session = null;\n\n\t\tlet framebufferScaleFactor = 1.0;\n\n\t\tlet referenceSpace = null;\n\t\tlet referenceSpaceType = 'local-floor';\n\t\t// Set default foveation to maximum.\n\t\tlet foveation = 1.0;\n\t\tlet customReferenceSpace = null;\n\n\t\tlet pose = null;\n\t\tlet glBinding = null;\n\t\tlet glProjLayer = null;\n\t\tlet glBaseLayer = null;\n\t\tlet xrFrame = null;\n\n\t\tconst depthSensing = new WebXRDepthSensing();\n\t\tconst attributes = gl.getContextAttributes();\n\n\t\tlet initialRenderTarget = null;\n\t\tlet newRenderTarget = null;\n\n\t\tconst controllers = [];\n\t\tconst controllerInputSources = [];\n\n\t\tconst currentSize = new Vector2();\n\t\tlet currentPixelRatio = null;\n\n\t\t//\n\n\t\tconst cameraL = new PerspectiveCamera();\n\t\tcameraL.layers.enable( 1 );\n\t\tcameraL.viewport = new Vector4();\n\n\t\tconst cameraR = new PerspectiveCamera();\n\t\tcameraR.layers.enable( 2 );\n\t\tcameraR.viewport = new Vector4();\n\n\t\tconst cameras = [ cameraL, cameraR ];\n\n\t\tconst cameraXR = new ArrayCamera();\n\t\tcameraXR.layers.enable( 1 );\n\t\tcameraXR.layers.enable( 2 );\n\n\t\tlet _currentDepthNear = null;\n\t\tlet _currentDepthFar = null;\n\n\t\t//\n\n\t\tthis.cameraAutoUpdate = true;\n\t\tthis.enabled = false;\n\n\t\tthis.isPresenting = false;\n\n\t\tthis.getController = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getTargetRaySpace();\n\n\t\t};\n\n\t\tthis.getControllerGrip = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getGripSpace();\n\n\t\t};\n\n\t\tthis.getHand = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getHandSpace();\n\n\t\t};\n\n\t\t//\n\n\t\tfunction onSessionEvent( event ) {\n\n\t\t\tconst controllerIndex = controllerInputSources.indexOf( event.inputSource );\n\n\t\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst controller = controllers[ controllerIndex ];\n\n\t\t\tif ( controller !== undefined ) {\n\n\t\t\t\tcontroller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );\n\t\t\t\tcontroller.dispatchEvent( { type: event.type, data: event.inputSource } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onSessionEnd() {\n\n\t\t\tsession.removeEventListener( 'select', onSessionEvent );\n\t\t\tsession.removeEventListener( 'selectstart', onSessionEvent );\n\t\t\tsession.removeEventListener( 'selectend', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeeze', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeezestart', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeezeend', onSessionEvent );\n\t\t\tsession.removeEventListener( 'end', onSessionEnd );\n\t\t\tsession.removeEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst inputSource = controllerInputSources[ i ];\n\n\t\t\t\tif ( inputSource === null ) continue;\n\n\t\t\t\tcontrollerInputSources[ i ] = null;\n\n\t\t\t\tcontrollers[ i ].disconnect( inputSource );\n\n\t\t\t}\n\n\t\t\t_currentDepthNear = null;\n\t\t\t_currentDepthFar = null;\n\n\t\t\tdepthSensing.reset();\n\n\t\t\t// restore framebuffer/rendering state\n\n\t\t\trenderer.setRenderTarget( initialRenderTarget );\n\n\t\t\tglBaseLayer = null;\n\t\t\tglProjLayer = null;\n\t\t\tglBinding = null;\n\t\t\tsession = null;\n\t\t\tnewRenderTarget = null;\n\n\t\t\t//\n\n\t\t\tanimation.stop();\n\n\t\t\tscope.isPresenting = false;\n\n\t\t\trenderer.setPixelRatio( currentPixelRatio );\n\t\t\trenderer.setSize( currentSize.width, currentSize.height, false );\n\n\t\t\tscope.dispatchEvent( { type: 'sessionend' } );\n\n\t\t}\n\n\t\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t\t\tframebufferScaleFactor = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.setReferenceSpaceType = function ( value ) {\n\n\t\t\treferenceSpaceType = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getReferenceSpace = function () {\n\n\t\t\treturn customReferenceSpace || referenceSpace;\n\n\t\t};\n\n\t\tthis.setReferenceSpace = function ( space ) {\n\n\t\t\tcustomReferenceSpace = space;\n\n\t\t};\n\n\t\tthis.getBaseLayer = function () {\n\n\t\t\treturn glProjLayer !== null ? glProjLayer : glBaseLayer;\n\n\t\t};\n\n\t\tthis.getBinding = function () {\n\n\t\t\treturn glBinding;\n\n\t\t};\n\n\t\tthis.getFrame = function () {\n\n\t\t\treturn xrFrame;\n\n\t\t};\n\n\t\tthis.getSession = function () {\n\n\t\t\treturn session;\n\n\t\t};\n\n\t\tthis.setSession = async function ( value ) {\n\n\t\t\tsession = value;\n\n\t\t\tif ( session !== null ) {\n\n\t\t\t\tinitialRenderTarget = renderer.getRenderTarget();\n\n\t\t\t\tsession.addEventListener( 'select', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeeze', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezestart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezeend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'end', onSessionEnd );\n\t\t\t\tsession.addEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\t\tif ( attributes.xrCompatible !== true ) {\n\n\t\t\t\t\tawait gl.makeXRCompatible();\n\n\t\t\t\t}\n\n\t\t\t\tcurrentPixelRatio = renderer.getPixelRatio();\n\t\t\t\trenderer.getSize( currentSize );\n\n\t\t\t\tif ( session.renderState.layers === undefined ) {\n\n\t\t\t\t\tconst layerInit = {\n\t\t\t\t\t\tantialias: attributes.antialias,\n\t\t\t\t\t\talpha: true,\n\t\t\t\t\t\tdepth: attributes.depth,\n\t\t\t\t\t\tstencil: attributes.stencil,\n\t\t\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\tglBaseLayer = new XRWebGLLayer( session, gl, layerInit );\n\n\t\t\t\t\tsession.updateRenderState( { baseLayer: glBaseLayer } );\n\n\t\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\t\trenderer.setSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false );\n\n\t\t\t\t\tnewRenderTarget = new WebGLRenderTarget(\n\t\t\t\t\t\tglBaseLayer.framebufferWidth,\n\t\t\t\t\t\tglBaseLayer.framebufferHeight,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlet depthFormat = null;\n\t\t\t\t\tlet depthType = null;\n\t\t\t\t\tlet glDepthFormat = null;\n\n\t\t\t\t\tif ( attributes.depth ) {\n\n\t\t\t\t\t\tglDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n\t\t\t\t\t\tdepthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;\n\t\t\t\t\t\tdepthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst projectionlayerInit = {\n\t\t\t\t\t\tcolorFormat: gl.RGBA8,\n\t\t\t\t\t\tdepthFormat: glDepthFormat,\n\t\t\t\t\t\tscaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\tglBinding = new XRWebGLBinding( session, gl );\n\n\t\t\t\t\tglProjLayer = glBinding.createProjectionLayer( projectionlayerInit );\n\n\t\t\t\t\tsession.updateRenderState( { layers: [ glProjLayer ] } );\n\n\t\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\t\trenderer.setSize( glProjLayer.textureWidth, glProjLayer.textureHeight, false );\n\n\t\t\t\t\tnewRenderTarget = new WebGLRenderTarget(\n\t\t\t\t\t\tglProjLayer.textureWidth,\n\t\t\t\t\t\tglProjLayer.textureHeight,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\t\tdepthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil,\n\t\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\t\tsamples: attributes.antialias ? 4 : 0,\n\t\t\t\t\t\t\tresolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false )\n\t\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tnewRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278\n\n\t\t\t\tthis.setFoveation( foveation );\n\n\t\t\t\tcustomReferenceSpace = null;\n\t\t\t\treferenceSpace = await session.requestReferenceSpace( referenceSpaceType );\n\n\t\t\t\tanimation.setContext( session );\n\t\t\t\tanimation.start();\n\n\t\t\t\tscope.isPresenting = true;\n\n\t\t\t\tscope.dispatchEvent( { type: 'sessionstart' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getEnvironmentBlendMode = function () {\n\n\t\t\tif ( session !== null ) {\n\n\t\t\t\treturn session.environmentBlendMode;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction onInputSourcesChange( event ) {\n\n\t\t\t// Notify disconnected\n\n\t\t\tfor ( let i = 0; i < event.removed.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.removed[ i ];\n\t\t\t\tconst index = controllerInputSources.indexOf( inputSource );\n\n\t\t\t\tif ( index >= 0 ) {\n\n\t\t\t\t\tcontrollerInputSources[ index ] = null;\n\t\t\t\t\tcontrollers[ index ].disconnect( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Notify connected\n\n\t\t\tfor ( let i = 0; i < event.added.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.added[ i ];\n\n\t\t\t\tlet controllerIndex = controllerInputSources.indexOf( inputSource );\n\n\t\t\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t\t\t// Assign input source a controller that currently has no input source\n\n\t\t\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\t\t\tif ( i >= controllerInputSources.length ) {\n\n\t\t\t\t\t\t\tcontrollerInputSources.push( inputSource );\n\t\t\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( controllerInputSources[ i ] === null ) {\n\n\t\t\t\t\t\t\tcontrollerInputSources[ i ] = inputSource;\n\t\t\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// If all controllers do currently receive input we ignore new ones\n\n\t\t\t\t\tif ( controllerIndex === - 1 ) break;\n\n\t\t\t\t}\n\n\t\t\t\tconst controller = controllers[ controllerIndex ];\n\n\t\t\t\tif ( controller ) {\n\n\t\t\t\t\tcontroller.connect( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst cameraLPos = new Vector3();\n\t\tconst cameraRPos = new Vector3();\n\n\t\t/**\n\t\t * Assumes 2 cameras that are parallel and share an X-axis, and that\n\t\t * the cameras' projection and world matrices have already been set.\n\t\t * And that near and far planes are identical for both cameras.\n\t\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n\t\t */\n\t\tfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\t\t\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\t\t\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\t\t\tconst ipd = cameraLPos.distanceTo( cameraRPos );\n\n\t\t\tconst projL = cameraL.projectionMatrix.elements;\n\t\t\tconst projR = cameraR.projectionMatrix.elements;\n\n\t\t\t// VR systems will have identical far and near planes, and\n\t\t\t// most likely identical top and bottom frustum extents.\n\t\t\t// Use the left camera for these values.\n\t\t\tconst near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\t\t\tconst far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\t\t\tconst topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\t\t\tconst bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\t\t\tconst leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\t\t\tconst rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\t\t\tconst left = near * leftFov;\n\t\t\tconst right = near * rightFov;\n\n\t\t\t// Calculate the new camera's position offset from the\n\t\t\t// left camera. xOffset should be roughly half `ipd`.\n\t\t\tconst zOffset = ipd / ( - leftFov + rightFov );\n\t\t\tconst xOffset = zOffset * - leftFov;\n\n\t\t\t// TODO: Better way to apply this offset?\n\t\t\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.translateX( xOffset );\n\t\t\tcamera.translateZ( zOffset );\n\t\t\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t\t// Find the union of the frustum values of the cameras and scale\n\t\t\t// the values so that the near plane's position does not change in world space,\n\t\t\t// although must now be relative to the new union camera.\n\t\t\tconst near2 = near + zOffset;\n\t\t\tconst far2 = far + zOffset;\n\t\t\tconst left2 = left - xOffset;\n\t\t\tconst right2 = right + ( ipd - xOffset );\n\t\t\tconst top2 = topFov * far / far2 * near2;\n\t\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\n\t\t\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\t\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\n\t\t}\n\n\t\tfunction updateCamera( camera, parent ) {\n\n\t\t\tif ( parent === null ) {\n\n\t\t\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t\t\t}\n\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t}\n\n\t\tthis.updateCamera = function ( camera ) {\n\n\t\t\tif ( session === null ) return;\n\n\t\t\tif ( depthSensing.texture !== null ) {\n\n\t\t\t\tcamera.near = depthSensing.depthNear;\n\t\t\t\tcamera.far = depthSensing.depthFar;\n\n\t\t\t}\n\n\t\t\tcameraXR.near = cameraR.near = cameraL.near = camera.near;\n\t\t\tcameraXR.far = cameraR.far = cameraL.far = camera.far;\n\n\t\t\tif ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {\n\n\t\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\n\t\t\t\tsession.updateRenderState( {\n\t\t\t\t\tdepthNear: cameraXR.near,\n\t\t\t\t\tdepthFar: cameraXR.far\n\t\t\t\t} );\n\n\t\t\t\t_currentDepthNear = cameraXR.near;\n\t\t\t\t_currentDepthFar = cameraXR.far;\n\n\t\t\t\tcameraL.near = _currentDepthNear;\n\t\t\t\tcameraL.far = _currentDepthFar;\n\t\t\t\tcameraR.near = _currentDepthNear;\n\t\t\t\tcameraR.far = _currentDepthFar;\n\n\t\t\t\tcameraL.updateProjectionMatrix();\n\t\t\t\tcameraR.updateProjectionMatrix();\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tconst parent = camera.parent;\n\t\t\tconst cameras = cameraXR.cameras;\n\n\t\t\tupdateCamera( cameraXR, parent );\n\n\t\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t\t}\n\n\t\t\t// update projection matrix for proper view frustum culling\n\n\t\t\tif ( cameras.length === 2 ) {\n\n\t\t\t\tsetProjectionFromUnion( cameraXR, cameraL, cameraR );\n\n\t\t\t} else {\n\n\t\t\t\t// assume single camera setup (AR)\n\n\t\t\t\tcameraXR.projectionMatrix.copy( cameraL.projectionMatrix );\n\n\t\t\t}\n\n\t\t\t// update user camera and its children\n\n\t\t\tupdateUserCamera( camera, cameraXR, parent );\n\n\t\t};\n\n\t\tfunction updateUserCamera( camera, cameraXR, parent ) {\n\n\t\t\tif ( parent === null ) {\n\n\t\t\t\tcamera.matrix.copy( cameraXR.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tcamera.matrix.copy( parent.matrixWorld );\n\t\t\t\tcamera.matrix.invert();\n\t\t\t\tcamera.matrix.multiply( cameraXR.matrixWorld );\n\n\t\t\t}\n\n\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.updateMatrixWorld( true );\n\n\t\t\tcamera.projectionMatrix.copy( cameraXR.projectionMatrix );\n\t\t\tcamera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tcamera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );\n\t\t\t\tcamera.zoom = 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.getCamera = function () {\n\n\t\t\treturn cameraXR;\n\n\t\t};\n\n\t\tthis.getFoveation = function () {\n\n\t\t\tif ( glProjLayer === null && glBaseLayer === null ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn foveation;\n\n\t\t};\n\n\t\tthis.setFoveation = function ( value ) {\n\n\t\t\t// 0 = no foveation = full resolution\n\t\t\t// 1 = maximum foveation = the edges render at lower resolution\n\n\t\t\tfoveation = value;\n\n\t\t\tif ( glProjLayer !== null ) {\n\n\t\t\t\tglProjLayer.fixedFoveation = value;\n\n\t\t\t}\n\n\t\t\tif ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {\n\n\t\t\t\tglBaseLayer.fixedFoveation = value;\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.hasDepthSensing = function () {\n\n\t\t\treturn depthSensing.texture !== null;\n\n\t\t};\n\n\t\tthis.getDepthSensingMesh = function () {\n\n\t\t\treturn depthSensing.getMesh( cameraXR );\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time, frame ) {\n\n\t\t\tpose = frame.getViewerPose( customReferenceSpace || referenceSpace );\n\t\t\txrFrame = frame;\n\n\t\t\tif ( pose !== null ) {\n\n\t\t\t\tconst views = pose.views;\n\n\t\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\t\trenderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );\n\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tlet cameraXRNeedsUpdate = false;\n\n\t\t\t\t// check if it's necessary to rebuild cameraXR's camera list\n\n\t\t\t\tif ( views.length !== cameraXR.cameras.length ) {\n\n\t\t\t\t\tcameraXR.cameras.length = 0;\n\t\t\t\t\tcameraXRNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < views.length; i ++ ) {\n\n\t\t\t\t\tconst view = views[ i ];\n\n\t\t\t\t\tlet viewport = null;\n\n\t\t\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\t\t\tviewport = glBaseLayer.getViewport( view );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst glSubImage = glBinding.getViewSubImage( glProjLayer, view );\n\t\t\t\t\t\tviewport = glSubImage.viewport;\n\n\t\t\t\t\t\t// For side-by-side projection, we only produce a single texture for both eyes.\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\trenderer.setRenderTargetTextures(\n\t\t\t\t\t\t\t\tnewRenderTarget,\n\t\t\t\t\t\t\t\tglSubImage.colorTexture,\n\t\t\t\t\t\t\t\tglProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );\n\n\t\t\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet camera = cameras[ i ];\n\n\t\t\t\t\tif ( camera === undefined ) {\n\n\t\t\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\t\t\tcamera.layers.enable( i );\n\t\t\t\t\t\tcamera.viewport = new Vector4();\n\t\t\t\t\t\tcameras[ i ] = camera;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcamera.matrix.fromArray( view.transform.matrix );\n\t\t\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\t\t\t\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\t\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tcameraXR.matrix.copy( camera.matrix );\n\t\t\t\t\t\tcameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cameraXRNeedsUpdate === true ) {\n\n\t\t\t\t\t\tcameraXR.cameras.push( camera );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tconst enabledFeatures = session.enabledFeatures;\n\n\t\t\t\tif ( enabledFeatures && enabledFeatures.includes( 'depth-sensing' ) ) {\n\n\t\t\t\t\tconst depthData = glBinding.getDepthInformation( views[ 0 ] );\n\n\t\t\t\t\tif ( depthData && depthData.isValid && depthData.texture ) {\n\n\t\t\t\t\t\tdepthSensing.init( renderer, depthData, session.renderState );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst inputSource = controllerInputSources[ i ];\n\t\t\t\tconst controller = controllers[ i ];\n\n\t\t\t\tif ( inputSource !== null && controller !== undefined ) {\n\n\t\t\t\t\tcontroller.update( inputSource, frame, customReferenceSpace || referenceSpace );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );\n\n\t\t\tif ( frame.detectedPlanes ) {\n\n\t\t\t\tscope.dispatchEvent( { type: 'planesdetected', data: frame } );\n\n\t\t\t}\n\n\t\t\txrFrame = null;\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\n\t\t};\n\n\t\tthis.dispose = function () {};\n\n\t}\n\n}\n\nconst _e1 = /*@__PURE__*/ new Euler();\nconst _m1 = /*@__PURE__*/ new Matrix4();\n\nfunction WebGLMaterials( renderer, properties ) {\n\n\tfunction refreshTransformUniform( map, uniform ) {\n\n\t\tif ( map.matrixAutoUpdate === true ) {\n\n\t\t\tmap.updateMatrix();\n\n\t\t}\n\n\t\tuniform.value.copy( map.matrix );\n\n\t}\n\n\tfunction refreshFogUniforms( uniforms, fog ) {\n\n\t\tfog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );\n\n\t\tif ( fog.isFog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {\n\n\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshToonMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsToon( uniforms, material );\n\n\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsPhong( uniforms, material );\n\n\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( uniforms, material, transmissionRenderTarget );\n\n\t\t\t}\n\n\t\t} else if ( material.isMeshMatcapMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsMatcap( uniforms, material );\n\n\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshDistanceMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsDistance( uniforms, material );\n\n\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isLineBasicMaterial ) {\n\n\t\t\trefreshUniformsLine( uniforms, material );\n\n\t\t\tif ( material.isLineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsDash( uniforms, material );\n\n\t\t\t}\n\n\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\trefreshUniformsPoints( uniforms, material, pixelRatio, height );\n\n\t\t} else if ( material.isSpriteMaterial ) {\n\n\t\t\trefreshUniformsSprites( uniforms, material );\n\n\t\t} else if ( material.isShadowMaterial ) {\n\n\t\t\tuniforms.color.value.copy( material.color );\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t} else if ( material.isShaderMaterial ) {\n\n\t\t\tmaterial.uniformsNeedUpdate = false; // #15581\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.color ) {\n\n\t\t\tuniforms.diffuse.value.copy( material.color );\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\n\t\t\trefreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );\n\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\tuniforms.bumpScale.value *= - 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\n\t\t\trefreshTransformUniform( material.normalMap, uniforms.normalMapTransform );\n\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\tuniforms.normalScale.value.negate();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\n\t\t\trefreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );\n\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\trefreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\t\trefreshTransformUniform( material.specularMap, uniforms.specularMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tconst envMap = materialProperties.envMap;\n\t\tconst envMapRotation = materialProperties.envMapRotation;\n\n\t\tif ( envMap ) {\n\n\t\t\tuniforms.envMap.value = envMap;\n\n\t\t\t_e1.copy( envMapRotation );\n\n\t\t\t// accommodate left-handed frame\n\t\t\t_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;\n\n\t\t\tif ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) {\n\n\t\t\t\t// environment maps which are not cube render targets or PMREMs follow a different convention\n\t\t\t\t_e1.y *= - 1;\n\t\t\t\t_e1.z *= - 1;\n\n\t\t\t}\n\n\t\t\tuniforms.envMapRotation.value.setFromMatrix4( _m1.makeRotationFromEuler( _e1 ) );\n\n\t\t\tuniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.ior.value = material.ior;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\trefreshTransformUniform( material.lightMap, uniforms.lightMapTransform );\n\n\t\t}\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\trefreshTransformUniform( material.aoMap, uniforms.aoMapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints( uniforms, material, pixelRatio, height ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * pixelRatio;\n\t\tuniforms.scale.value = height * 0.5;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.uvTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsSprites( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.rotation.value = material.rotation;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\tuniforms.specular.value.copy( material.specular );\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t}\n\n\tfunction refreshUniformsToon( uniforms, material ) {\n\n\t\tif ( material.gradientMap ) {\n\n\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t\trefreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );\n\n\t\t}\n\n\t\tuniforms.roughness.value = material.roughness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\trefreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {\n\n\t\tuniforms.ior.value = material.ior; // also part of uniforms common\n\n\t\tif ( material.sheen > 0 ) {\n\n\t\t\tuniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );\n\n\t\t\tuniforms.sheenRoughness.value = material.sheenRoughness;\n\n\t\t\tif ( material.sheenColorMap ) {\n\n\t\t\t\tuniforms.sheenColorMap.value = material.sheenColorMap;\n\n\t\t\t\trefreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\t\tuniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;\n\n\t\t\t\trefreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.clearcoat > 0 ) {\n\n\t\t\tuniforms.clearcoat.value = material.clearcoat;\n\t\t\tuniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\n\t\t\tif ( material.clearcoatMap ) {\n\n\t\t\t\tuniforms.clearcoatMap.value = material.clearcoatMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\t\tuniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\t\tuniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );\n\n\t\t\t\tuniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );\n\n\t\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\t\tuniforms.clearcoatNormalScale.value.negate();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.dispersion > 0 ) {\n\n\t\t\tuniforms.dispersion.value = material.dispersion;\n\n\t\t}\n\n\t\tif ( material.iridescence > 0 ) {\n\n\t\t\tuniforms.iridescence.value = material.iridescence;\n\t\t\tuniforms.iridescenceIOR.value = material.iridescenceIOR;\n\t\t\tuniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];\n\t\t\tuniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];\n\n\t\t\tif ( material.iridescenceMap ) {\n\n\t\t\t\tuniforms.iridescenceMap.value = material.iridescenceMap;\n\n\t\t\t\trefreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\t\tuniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;\n\n\t\t\t\trefreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.transmission > 0 ) {\n\n\t\t\tuniforms.transmission.value = material.transmission;\n\t\t\tuniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n\t\t\tuniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );\n\n\t\t\tif ( material.transmissionMap ) {\n\n\t\t\t\tuniforms.transmissionMap.value = material.transmissionMap;\n\n\t\t\t\trefreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );\n\n\t\t\t}\n\n\t\t\tuniforms.thickness.value = material.thickness;\n\n\t\t\tif ( material.thicknessMap ) {\n\n\t\t\t\tuniforms.thicknessMap.value = material.thicknessMap;\n\n\t\t\t\trefreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );\n\n\t\t\t}\n\n\t\t\tuniforms.attenuationDistance.value = material.attenuationDistance;\n\t\t\tuniforms.attenuationColor.value.copy( material.attenuationColor );\n\n\t\t}\n\n\t\tif ( material.anisotropy > 0 ) {\n\n\t\t\tuniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );\n\n\t\t\tif ( material.anisotropyMap ) {\n\n\t\t\t\tuniforms.anisotropyMap.value = material.anisotropyMap;\n\n\t\t\t\trefreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tuniforms.specularIntensity.value = material.specularIntensity;\n\t\tuniforms.specularColor.value.copy( material.specularColor );\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tuniforms.specularColorMap.value = material.specularColorMap;\n\n\t\t\trefreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );\n\n\t\t}\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tuniforms.specularIntensityMap.value = material.specularIntensityMap;\n\n\t\t\trefreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsMatcap( uniforms, material ) {\n\n\t\tif ( material.matcap ) {\n\n\t\t\tuniforms.matcap.value = material.matcap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDistance( uniforms, material ) {\n\n\t\tconst light = properties.get( material ).light;\n\n\t\tuniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );\n\t\tuniforms.nearDistance.value = light.shadow.camera.near;\n\t\tuniforms.farDistance.value = light.shadow.camera.far;\n\n\t}\n\n\treturn {\n\t\trefreshFogUniforms: refreshFogUniforms,\n\t\trefreshMaterialUniforms: refreshMaterialUniforms\n\t};\n\n}\n\nfunction WebGLUniformsGroups( gl, info, capabilities, state ) {\n\n\tlet buffers = {};\n\tlet updateList = {};\n\tlet allocatedBindingPoints = [];\n\n\tconst maxBindingPoints = gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ); // binding points are global whereas block indices are per shader program\n\n\tfunction bind( uniformsGroup, program ) {\n\n\t\tconst webglProgram = program.program;\n\t\tstate.uniformBlockBinding( uniformsGroup, webglProgram );\n\n\t}\n\n\tfunction update( uniformsGroup, program ) {\n\n\t\tlet buffer = buffers[ uniformsGroup.id ];\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tprepareUniformsGroup( uniformsGroup );\n\n\t\t\tbuffer = createBuffer( uniformsGroup );\n\t\t\tbuffers[ uniformsGroup.id ] = buffer;\n\n\t\t\tuniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\t}\n\n\t\t// ensure to update the binding points/block indices mapping for this program\n\n\t\tconst webglProgram = program.program;\n\t\tstate.updateUBOMapping( uniformsGroup, webglProgram );\n\n\t\t// update UBO once per frame\n\n\t\tconst frame = info.render.frame;\n\n\t\tif ( updateList[ uniformsGroup.id ] !== frame ) {\n\n\t\t\tupdateBufferData( uniformsGroup );\n\n\t\t\tupdateList[ uniformsGroup.id ] = frame;\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( uniformsGroup ) {\n\n\t\t// the setup of an UBO is independent of a particular shader program but global\n\n\t\tconst bindingPointIndex = allocateBindingPointIndex();\n\t\tuniformsGroup.__bindingPointIndex = bindingPointIndex;\n\n\t\tconst buffer = gl.createBuffer();\n\t\tconst size = uniformsGroup.__size;\n\t\tconst usage = uniformsGroup.usage;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\t\tgl.bufferData( gl.UNIFORM_BUFFER, size, usage );\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\t\tgl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );\n\n\t\treturn buffer;\n\n\t}\n\n\tfunction allocateBindingPointIndex() {\n\n\t\tfor ( let i = 0; i < maxBindingPoints; i ++ ) {\n\n\t\t\tif ( allocatedBindingPoints.indexOf( i ) === - 1 ) {\n\n\t\t\t\tallocatedBindingPoints.push( i );\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconsole.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );\n\n\t\treturn 0;\n\n\t}\n\n\tfunction updateBufferData( uniformsGroup ) {\n\n\t\tconst buffer = buffers[ uniformsGroup.id ];\n\t\tconst uniforms = uniformsGroup.uniforms;\n\t\tconst cache = uniformsGroup.__cache;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\n\t\tfor ( let i = 0, il = uniforms.length; i < il; i ++ ) {\n\n\t\t\tconst uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];\n\n\t\t\tfor ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uniform = uniformArray[ j ];\n\n\t\t\t\tif ( hasUniformChanged( uniform, i, j, cache ) === true ) {\n\n\t\t\t\t\tconst offset = uniform.__offset;\n\n\t\t\t\t\tconst values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];\n\n\t\t\t\t\tlet arrayOffset = 0;\n\n\t\t\t\t\tfor ( let k = 0; k < values.length; k ++ ) {\n\n\t\t\t\t\t\tconst value = values[ k ];\n\n\t\t\t\t\t\tconst info = getUniformSize( value );\n\n\t\t\t\t\t\t// TODO add integer and struct support\n\t\t\t\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\t\t\t\tuniform.__data[ 0 ] = value;\n\t\t\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );\n\n\t\t\t\t\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t\t\t\t\t// manually converting 3x3 to 3x4\n\n\t\t\t\t\t\t\tuniform.__data[ 0 ] = value.elements[ 0 ];\n\t\t\t\t\t\t\tuniform.__data[ 1 ] = value.elements[ 1 ];\n\t\t\t\t\t\t\tuniform.__data[ 2 ] = value.elements[ 2 ];\n\t\t\t\t\t\t\tuniform.__data[ 3 ] = 0;\n\t\t\t\t\t\t\tuniform.__data[ 4 ] = value.elements[ 3 ];\n\t\t\t\t\t\t\tuniform.__data[ 5 ] = value.elements[ 4 ];\n\t\t\t\t\t\t\tuniform.__data[ 6 ] = value.elements[ 5 ];\n\t\t\t\t\t\t\tuniform.__data[ 7 ] = 0;\n\t\t\t\t\t\t\tuniform.__data[ 8 ] = value.elements[ 6 ];\n\t\t\t\t\t\t\tuniform.__data[ 9 ] = value.elements[ 7 ];\n\t\t\t\t\t\t\tuniform.__data[ 10 ] = value.elements[ 8 ];\n\t\t\t\t\t\t\tuniform.__data[ 11 ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvalue.toArray( uniform.__data, arrayOffset );\n\n\t\t\t\t\t\t\tarrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\n\t}\n\n\tfunction hasUniformChanged( uniform, index, indexArray, cache ) {\n\n\t\tconst value = uniform.value;\n\t\tconst indexString = index + '_' + indexArray;\n\n\t\tif ( cache[ indexString ] === undefined ) {\n\n\t\t\t// cache entry does not exist so far\n\n\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\tcache[ indexString ] = value;\n\n\t\t\t} else {\n\n\t\t\t\tcache[ indexString ] = value.clone();\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\tconst cachedObject = cache[ indexString ];\n\n\t\t\t// compare current value with cached entry\n\n\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\tif ( cachedObject !== value ) {\n\n\t\t\t\t\tcache[ indexString ] = value;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( cachedObject.equals( value ) === false ) {\n\n\t\t\t\t\tcachedObject.copy( value );\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction prepareUniformsGroup( uniformsGroup ) {\n\n\t\t// determine total buffer size according to the STD140 layout\n\t\t// Hint: STD140 is the only supported layout in WebGL 2\n\n\t\tconst uniforms = uniformsGroup.uniforms;\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\t\tconst chunkSize = 16; // size of a chunk in bytes\n\n\t\tfor ( let i = 0, l = uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];\n\n\t\t\tfor ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uniform = uniformArray[ j ];\n\n\t\t\t\tconst values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];\n\n\t\t\t\tfor ( let k = 0, kl = values.length; k < kl; k ++ ) {\n\n\t\t\t\t\tconst value = values[ k ];\n\n\t\t\t\t\tconst info = getUniformSize( value );\n\n\t\t\t\t\t// Calculate the chunk offset\n\t\t\t\t\tconst chunkOffsetUniform = offset % chunkSize;\n\n\t\t\t\t\t// Check for chunk overflow\n\t\t\t\t\tif ( chunkOffsetUniform !== 0 && ( chunkSize - chunkOffsetUniform ) < info.boundary ) {\n\n\t\t\t\t\t\t// Add padding and adjust offset\n\t\t\t\t\t\toffset += ( chunkSize - chunkOffsetUniform );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the following two properties will be used for partial buffer updates\n\n\t\t\t\t\tuniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );\n\t\t\t\t\tuniform.__offset = offset;\n\n\n\t\t\t\t\t// Update the global offset\n\t\t\t\t\toffset += info.storage;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ensure correct final padding\n\n\t\tconst chunkOffset = offset % chunkSize;\n\n\t\tif ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );\n\n\t\t//\n\n\t\tuniformsGroup.__size = offset;\n\t\tuniformsGroup.__cache = {};\n\n\t\treturn this;\n\n\t}\n\n\tfunction getUniformSize( value ) {\n\n\t\tconst info = {\n\t\t\tboundary: 0, // bytes\n\t\t\tstorage: 0 // bytes\n\t\t};\n\n\t\t// determine sizes according to STD140\n\n\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t// float/int/bool\n\n\t\t\tinfo.boundary = 4;\n\t\t\tinfo.storage = 4;\n\n\t\t} else if ( value.isVector2 ) {\n\n\t\t\t// vec2\n\n\t\t\tinfo.boundary = 8;\n\t\t\tinfo.storage = 8;\n\n\t\t} else if ( value.isVector3 || value.isColor ) {\n\n\t\t\t// vec3\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes\n\n\t\t} else if ( value.isVector4 ) {\n\n\t\t\t// vec4\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 16;\n\n\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t// mat3 (in STD140 a 3x3 matrix is represented as 3x4)\n\n\t\t\tinfo.boundary = 48;\n\t\t\tinfo.storage = 48;\n\n\t\t} else if ( value.isMatrix4 ) {\n\n\t\t\t// mat4\n\n\t\t\tinfo.boundary = 64;\n\t\t\tinfo.storage = 64;\n\n\t\t} else if ( value.isTexture ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );\n\n\t\t}\n\n\t\treturn info;\n\n\t}\n\n\tfunction onUniformsGroupsDispose( event ) {\n\n\t\tconst uniformsGroup = event.target;\n\n\t\tuniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\tconst index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );\n\t\tallocatedBindingPoints.splice( index, 1 );\n\n\t\tgl.deleteBuffer( buffers[ uniformsGroup.id ] );\n\n\t\tdelete buffers[ uniformsGroup.id ];\n\t\tdelete updateList[ uniformsGroup.id ];\n\n\t}\n\n\tfunction dispose() {\n\n\t\tfor ( const id in buffers ) {\n\n\t\t\tgl.deleteBuffer( buffers[ id ] );\n\n\t\t}\n\n\t\tallocatedBindingPoints = [];\n\t\tbuffers = {};\n\t\tupdateList = {};\n\n\t}\n\n\treturn {\n\n\t\tbind: bind,\n\t\tupdate: update,\n\n\t\tdispose: dispose\n\n\t};\n\n}\n\nclass WebGLRenderer {\n\n\tconstructor( parameters = {} ) {\n\n\t\tconst {\n\t\t\tcanvas = createCanvasElement(),\n\t\t\tcontext = null,\n\t\t\tdepth = true,\n\t\t\tstencil = false,\n\t\t\talpha = false,\n\t\t\tantialias = false,\n\t\t\tpremultipliedAlpha = true,\n\t\t\tpreserveDrawingBuffer = false,\n\t\t\tpowerPreference = 'default',\n\t\t\tfailIfMajorPerformanceCaveat = false,\n\t\t} = parameters;\n\n\t\tthis.isWebGLRenderer = true;\n\n\t\tlet _alpha;\n\n\t\tif ( context !== null ) {\n\n\t\t\tif ( typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLRenderer: WebGL 1 is not supported since r163.' );\n\n\t\t\t}\n\n\t\t\t_alpha = context.getContextAttributes().alpha;\n\n\t\t} else {\n\n\t\t\t_alpha = alpha;\n\n\t\t}\n\n\t\tconst uintClearColor = new Uint32Array( 4 );\n\t\tconst intClearColor = new Int32Array( 4 );\n\n\t\tlet currentRenderList = null;\n\t\tlet currentRenderState = null;\n\n\t\t// render() can be called from within a callback triggered by another render.\n\t\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\t\tconst renderListStack = [];\n\t\tconst renderStateStack = [];\n\n\t\t// public properties\n\n\t\tthis.domElement = canvas;\n\n\t\t// Debug configuration container\n\t\tthis.debug = {\n\n\t\t\t/**\n\t\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tcheckShaderErrors: true,\n\t\t\t/**\n\t\t\t * Callback for custom error reporting.\n\t\t\t * @type {?Function}\n\t\t\t */\n\t\t\tonShaderError: null\n\t\t};\n\n\t\t// clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\n\t\t// physically based shading\n\n\t\tthis._outputColorSpace = SRGBColorSpace;\n\n\t\t// tone mapping\n\n\t\tthis.toneMapping = NoToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\t// internal properties\n\n\t\tconst _this = this;\n\n\t\tlet _isContextLost = false;\n\n\t\t// internal state cache\n\n\t\tlet _currentActiveCubeFace = 0;\n\t\tlet _currentActiveMipmapLevel = 0;\n\t\tlet _currentRenderTarget = null;\n\t\tlet _currentMaterialId = - 1;\n\n\t\tlet _currentCamera = null;\n\n\t\tconst _currentViewport = new Vector4();\n\t\tconst _currentScissor = new Vector4();\n\t\tlet _currentScissorTest = null;\n\n\t\tconst _currentClearColor = new Color( 0x000000 );\n\t\tlet _currentClearAlpha = 0;\n\n\t\t//\n\n\t\tlet _width = canvas.width;\n\t\tlet _height = canvas.height;\n\n\t\tlet _pixelRatio = 1;\n\t\tlet _opaqueSort = null;\n\t\tlet _transparentSort = null;\n\n\t\tconst _viewport = new Vector4( 0, 0, _width, _height );\n\t\tconst _scissor = new Vector4( 0, 0, _width, _height );\n\t\tlet _scissorTest = false;\n\n\t\t// frustum\n\n\t\tconst _frustum = new Frustum();\n\n\t\t// clipping\n\n\t\tlet _clippingEnabled = false;\n\t\tlet _localClippingEnabled = false;\n\n\t\t// camera matrices cache\n\n\t\tconst _projScreenMatrix = new Matrix4();\n\n\t\tconst _vector3 = new Vector3();\n\n\t\tconst _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };\n\n\t\tlet _renderBackground = false;\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\t// initialize\n\n\t\tlet _gl = context;\n\n\t\tfunction getContext( contextName, contextAttributes ) {\n\n\t\t\treturn canvas.getContext( contextName, contextAttributes );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tconst contextAttributes = {\n\t\t\t\talpha: true,\n\t\t\t\tdepth,\n\t\t\t\tstencil,\n\t\t\t\tantialias,\n\t\t\t\tpremultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer,\n\t\t\t\tpowerPreference,\n\t\t\t\tfailIfMajorPerformanceCaveat,\n\t\t\t};\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );\n\n\t\t\t// event listeners must be registered before WebGL context is created, see #12753\n\t\t\tcanvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\tcanvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t\tcanvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tconst contextName = 'webgl2';\n\n\t\t\t\t_gl = getContext( contextName, contextAttributes );\n\n\t\t\t\tif ( _gl === null ) {\n\n\t\t\t\t\tif ( getContext( contextName ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\t\t\tthrow error;\n\n\t\t}\n\n\t\tlet extensions, capabilities, state, info;\n\t\tlet properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n\t\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\n\t\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n\t\tlet utils, bindingStates, uniformsGroups;\n\n\t\tfunction initGLContext() {\n\n\t\t\textensions = new WebGLExtensions( _gl );\n\t\t\textensions.init();\n\n\t\t\tutils = new WebGLUtils( _gl, extensions );\n\n\t\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters, utils );\n\n\t\t\tstate = new WebGLState( _gl );\n\n\t\t\tinfo = new WebGLInfo( _gl );\n\t\t\tproperties = new WebGLProperties();\n\t\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\n\t\t\tcubemaps = new WebGLCubeMaps( _this );\n\t\t\tcubeuvmaps = new WebGLCubeUVMaps( _this );\n\t\t\tattributes = new WebGLAttributes( _gl );\n\t\t\tbindingStates = new WebGLBindingStates( _gl, attributes );\n\t\t\tgeometries = new WebGLGeometries( _gl, attributes, info, bindingStates );\n\t\t\tobjects = new WebGLObjects( _gl, geometries, attributes, info );\n\t\t\tmorphtargets = new WebGLMorphtargets( _gl, capabilities, textures );\n\t\t\tclipping = new WebGLClipping( properties );\n\t\t\tprogramCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );\n\t\t\tmaterials = new WebGLMaterials( _this, properties );\n\t\t\trenderLists = new WebGLRenderLists();\n\t\t\trenderStates = new WebGLRenderStates( extensions );\n\t\t\tbackground = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );\n\t\t\tshadowMap = new WebGLShadowMap( _this, objects, capabilities );\n\t\t\tuniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );\n\n\t\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );\n\t\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );\n\n\t\t\tinfo.programs = programCache.programs;\n\n\t\t\t_this.capabilities = capabilities;\n\t\t\t_this.extensions = extensions;\n\t\t\t_this.properties = properties;\n\t\t\t_this.renderLists = renderLists;\n\t\t\t_this.shadowMap = shadowMap;\n\t\t\t_this.state = state;\n\t\t\t_this.info = info;\n\n\t\t}\n\n\t\tinitGLContext();\n\n\t\t// xr\n\n\t\tconst xr = new WebXRManager( _this, _gl );\n\n\t\tthis.xr = xr;\n\n\t\t// API\n\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\n\t\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.loseContext();\n\n\t\t};\n\n\t\tthis.forceContextRestore = function () {\n\n\t\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.restoreContext();\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _width, _height, false );\n\n\t\t};\n\n\t\tthis.getSize = function ( target ) {\n\n\t\t\treturn target.set( _width, _height );\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle = true ) {\n\n\t\t\tif ( xr.isPresenting ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\tcanvas.width = Math.floor( width * _pixelRatio );\n\t\t\tcanvas.height = Math.floor( height * _pixelRatio );\n\n\t\t\tif ( updateStyle === true ) {\n\n\t\t\t\tcanvas.style.width = width + 'px';\n\t\t\t\tcanvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.getDrawingBufferSize = function ( target ) {\n\n\t\t\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\n\n\t\t};\n\n\t\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_pixelRatio = pixelRatio;\n\n\t\t\tcanvas.width = Math.floor( width * pixelRatio );\n\t\t\tcanvas.height = Math.floor( height * pixelRatio );\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.getCurrentViewport = function ( target ) {\n\n\t\t\treturn target.copy( _currentViewport );\n\n\t\t};\n\n\t\tthis.getViewport = function ( target ) {\n\n\t\t\treturn target.copy( _viewport );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\t_viewport.set( x.x, x.y, x.z, x.w );\n\n\t\t\t} else {\n\n\t\t\t\t_viewport.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).round() );\n\n\t\t};\n\n\t\tthis.getScissor = function ( target ) {\n\n\t\t\treturn target.copy( _scissor );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\t_scissor.set( x.x, x.y, x.z, x.w );\n\n\t\t\t} else {\n\n\t\t\t\t_scissor.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).round() );\n\n\t\t};\n\n\t\tthis.getScissorTest = function () {\n\n\t\t\treturn _scissorTest;\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\tthis.setOpaqueSort = function ( method ) {\n\n\t\t\t_opaqueSort = method;\n\n\t\t};\n\n\t\tthis.setTransparentSort = function ( method ) {\n\n\t\t\t_transparentSort = method;\n\n\t\t};\n\n\t\t// Clearing\n\n\t\tthis.getClearColor = function ( target ) {\n\n\t\t\treturn target.copy( background.getClearColor() );\n\n\t\t};\n\n\t\tthis.setClearColor = function () {\n\n\t\t\tbackground.setClearColor.apply( background, arguments );\n\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn background.getClearAlpha();\n\n\t\t};\n\n\t\tthis.setClearAlpha = function () {\n\n\t\t\tbackground.setClearAlpha.apply( background, arguments );\n\n\t\t};\n\n\t\tthis.clear = function ( color = true, depth = true, stencil = true ) {\n\n\t\t\tlet bits = 0;\n\n\t\t\tif ( color ) {\n\n\t\t\t\t// check if we're trying to clear an integer target\n\t\t\t\tlet isIntegerFormat = false;\n\t\t\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t\t\tconst targetFormat = _currentRenderTarget.texture.format;\n\t\t\t\t\tisIntegerFormat = targetFormat === RGBAIntegerFormat ||\n\t\t\t\t\t\ttargetFormat === RGIntegerFormat ||\n\t\t\t\t\t\ttargetFormat === RedIntegerFormat;\n\n\t\t\t\t}\n\n\t\t\t\t// use the appropriate clear functions to clear the target if it's a signed\n\t\t\t\t// or unsigned integer target\n\t\t\t\tif ( isIntegerFormat ) {\n\n\t\t\t\t\tconst targetType = _currentRenderTarget.texture.type;\n\t\t\t\t\tconst isUnsignedType = targetType === UnsignedByteType ||\n\t\t\t\t\t\ttargetType === UnsignedIntType ||\n\t\t\t\t\t\ttargetType === UnsignedShortType ||\n\t\t\t\t\t\ttargetType === UnsignedInt248Type ||\n\t\t\t\t\t\ttargetType === UnsignedShort4444Type ||\n\t\t\t\t\t\ttargetType === UnsignedShort5551Type;\n\n\t\t\t\t\tconst clearColor = background.getClearColor();\n\t\t\t\t\tconst a = background.getClearAlpha();\n\t\t\t\t\tconst r = clearColor.r;\n\t\t\t\t\tconst g = clearColor.g;\n\t\t\t\t\tconst b = clearColor.b;\n\n\t\t\t\t\tif ( isUnsignedType ) {\n\n\t\t\t\t\t\tuintClearColor[ 0 ] = r;\n\t\t\t\t\t\tuintClearColor[ 1 ] = g;\n\t\t\t\t\t\tuintClearColor[ 2 ] = b;\n\t\t\t\t\t\tuintClearColor[ 3 ] = a;\n\t\t\t\t\t\t_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tintClearColor[ 0 ] = r;\n\t\t\t\t\t\tintClearColor[ 1 ] = g;\n\t\t\t\t\t\tintClearColor[ 2 ] = b;\n\t\t\t\t\t\tintClearColor[ 3 ] = a;\n\t\t\t\t\t\t_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbits |= _gl.COLOR_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil ) {\n\n\t\t\t\tbits |= _gl.STENCIL_BUFFER_BIT;\n\t\t\t\tthis.state.buffers.stencil.setMask( 0xffffffff );\n\n\t\t\t}\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\t//\n\n\t\tthis.dispose = function () {\n\n\t\t\tcanvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\tcanvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t\tcanvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\t\trenderLists.dispose();\n\t\t\trenderStates.dispose();\n\t\t\tproperties.dispose();\n\t\t\tcubemaps.dispose();\n\t\t\tcubeuvmaps.dispose();\n\t\t\tobjects.dispose();\n\t\t\tbindingStates.dispose();\n\t\t\tuniformsGroups.dispose();\n\t\t\tprogramCache.dispose();\n\n\t\t\txr.dispose();\n\n\t\t\txr.removeEventListener( 'sessionstart', onXRSessionStart );\n\t\t\txr.removeEventListener( 'sessionend', onXRSessionEnd );\n\n\t\t\tanimation.stop();\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t\t_isContextLost = true;\n\n\t\t}\n\n\t\tfunction onContextRestore( /* event */ ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t\t_isContextLost = false;\n\n\t\t\tconst infoAutoReset = info.autoReset;\n\t\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\t\tconst shadowMapType = shadowMap.type;\n\n\t\t\tinitGLContext();\n\n\t\t\tinfo.autoReset = infoAutoReset;\n\t\t\tshadowMap.enabled = shadowMapEnabled;\n\t\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\t\tshadowMap.type = shadowMapType;\n\n\t\t}\n\n\t\tfunction onContextCreationError( event ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tconst material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReferences( material );\n\n\t\t\tproperties.remove( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReferences( material ) {\n\n\t\t\tconst programs = properties.get( material ).programs;\n\n\t\t\tif ( programs !== undefined ) {\n\n\t\t\t\tprograms.forEach( function ( program ) {\n\n\t\t\t\t\tprogramCache.releaseProgram( program );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\t\tprogramCache.releaseShaderCache( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {\n\n\t\t\tif ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\t\tconst program = setProgram( camera, scene, geometry, material, object );\n\n\t\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\t\t//\n\n\t\t\tlet index = geometry.index;\n\t\t\tlet rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\n\t\t\t\tif ( index === undefined ) return;\n\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst drawRange = geometry.drawRange;\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tlet drawStart = drawRange.start * rangeFactor;\n\t\t\tlet drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\t\tif ( group !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, group.start * rangeFactor );\n\t\t\t\tdrawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );\n\n\t\t\t}\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\t\tdrawEnd = Math.min( drawEnd, index.count );\n\n\t\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\t\tdrawEnd = Math.min( drawEnd, position.count );\n\n\t\t\t}\n\n\t\t\tconst drawCount = drawEnd - drawStart;\n\n\t\t\tif ( drawCount < 0 || drawCount === Infinity ) return;\n\n\t\t\t//\n\n\t\t\tbindingStates.setup( object, material, program, geometry, index );\n\n\t\t\tlet attribute;\n\t\t\tlet renderer = bufferRenderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tattribute = attributes.get( index );\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( attribute );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tlet lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_LOOP );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t}\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tif ( object._multiDrawInstances !== null ) {\n\n\t\t\t\t\trenderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isInstancedMesh ) {\n\n\t\t\t\trenderer.renderInstances( drawStart, drawCount, object.count );\n\n\t\t\t} else if ( geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tconst maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;\n\t\t\t\tconst instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );\n\n\t\t\t\trenderer.renderInstances( drawStart, drawCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Compile\n\n\t\tfunction prepareMaterial( material, scene, object ) {\n\n\t\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\tmaterial.side = FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.compile = function ( scene, camera, targetScene = null ) {\n\n\t\t\tif ( targetScene === null ) targetScene = scene;\n\n\t\t\tcurrentRenderState = renderStates.get( targetScene );\n\t\t\tcurrentRenderState.init( camera );\n\n\t\t\trenderStateStack.push( currentRenderState );\n\n\t\t\t// gather lights from both the target scene and the new object that will be added to the scene.\n\n\t\t\ttargetScene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( scene !== targetScene ) {\n\n\t\t\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tcurrentRenderState.setupLights();\n\n\t\t\t// Only initialize materials in the new scene, not the targetScene.\n\n\t\t\tconst materials = new Set();\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( material ) {\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\t\tconst material2 = material[ i ];\n\n\t\t\t\t\t\t\tprepareMaterial( material2, targetScene, object );\n\t\t\t\t\t\t\tmaterials.add( material2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tprepareMaterial( material, targetScene, object );\n\t\t\t\t\t\tmaterials.add( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\trenderStateStack.pop();\n\t\t\tcurrentRenderState = null;\n\n\t\t\treturn materials;\n\n\t\t};\n\n\t\t// compileAsync\n\n\t\tthis.compileAsync = function ( scene, camera, targetScene = null ) {\n\n\t\t\tconst materials = this.compile( scene, camera, targetScene );\n\n\t\t\t// Wait for all the materials in the new object to indicate that they're\n\t\t\t// ready to be used before resolving the promise.\n\n\t\t\treturn new Promise( ( resolve ) => {\n\n\t\t\t\tfunction checkMaterialsReady() {\n\n\t\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\t\tconst materialProperties = properties.get( material );\n\t\t\t\t\t\tconst program = materialProperties.currentProgram;\n\n\t\t\t\t\t\tif ( program.isReady() ) {\n\n\t\t\t\t\t\t\t// remove any programs that report they're ready to use from the list\n\t\t\t\t\t\t\tmaterials.delete( material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// once the list of compiling materials is empty, call the callback\n\n\t\t\t\t\tif ( materials.size === 0 ) {\n\n\t\t\t\t\t\tresolve( scene );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if some materials are still not ready, wait a bit and check again\n\n\t\t\t\t\tsetTimeout( checkMaterialsReady, 10 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( extensions.get( 'KHR_parallel_shader_compile' ) !== null ) {\n\n\t\t\t\t\t// If we can check the compilation status of the materials without\n\t\t\t\t\t// blocking then do so right away.\n\n\t\t\t\t\tcheckMaterialsReady();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise start by waiting a bit to give the materials we just\n\t\t\t\t\t// initialized a chance to finish.\n\n\t\t\t\t\tsetTimeout( checkMaterialsReady, 10 );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time ) {\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t\t}\n\n\t\tfunction onXRSessionStart() {\n\n\t\t\tanimation.stop();\n\n\t\t}\n\n\t\tfunction onXRSessionEnd() {\n\n\t\t\tanimation.start();\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tif ( typeof self !== 'undefined' ) animation.setContext( self );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\t\t\txr.setAnimationLoop( callback );\n\n\t\t\t( callback === null ) ? animation.stop() : animation.start();\n\n\t\t};\n\n\t\txr.addEventListener( 'sessionstart', onXRSessionStart );\n\t\txr.addEventListener( 'sessionend', onXRSessionEnd );\n\n\t\t// Rendering\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( _isContextLost === true ) return;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\n\n\t\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );\n\n\t\t\tcurrentRenderState = renderStates.get( scene, renderStateStack.length );\n\t\t\tcurrentRenderState.init( camera );\n\n\t\t\trenderStateStack.push( currentRenderState );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );\n\n\t\t\tcurrentRenderList = renderLists.get( scene, renderListStack.length );\n\t\t\tcurrentRenderList.init();\n\n\t\t\trenderListStack.push( currentRenderList );\n\n\t\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\t\tconst depthSensingMesh = _this.xr.getDepthSensingMesh();\n\n\t\t\t\tif ( depthSensingMesh !== null ) {\n\n\t\t\t\t\tprojectObject( depthSensingMesh, camera, - Infinity, _this.sortObjects );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprojectObject( scene, camera, 0, _this.sortObjects );\n\n\t\t\tcurrentRenderList.finish();\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\tcurrentRenderList.sort( _opaqueSort, _transparentSort );\n\n\t\t\t}\n\n\t\t\t_renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;\n\t\t\tif ( _renderBackground ) {\n\n\t\t\t\tbackground.addToRenderList( currentRenderList, scene );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tthis.info.render.frame ++;\n\n\t\t\tif ( _clippingEnabled === true ) clipping.beginShadows();\n\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.endShadows();\n\n\t\t\t//\n\n\t\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t\t// render scene\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\n\t\t\tcurrentRenderState.setupLights();\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tif ( transmissiveObjects.length > 0 ) {\n\n\t\t\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst camera2 = cameras[ i ];\n\n\t\t\t\t\t\trenderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( _renderBackground ) background.render( scene );\n\n\t\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ i ];\n\n\t\t\t\t\trenderScene( currentRenderList, scene, camera2, camera2.viewport );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );\n\n\t\t\t\tif ( _renderBackground ) background.render( scene );\n\n\t\t\t\trenderScene( currentRenderList, scene, camera );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\t\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\n\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\t\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );\n\n\t\t\t// _gl.finish();\n\n\t\t\tbindingStates.resetDefaultState();\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\trenderStateStack.pop();\n\n\t\t\tif ( renderStateStack.length > 0 ) {\n\n\t\t\t\tcurrentRenderState = renderStateStack[ renderStateStack.length - 1 ];\n\n\t\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, currentRenderState.state.camera );\n\n\t\t\t} else {\n\n\t\t\t\tcurrentRenderState = null;\n\n\t\t\t}\n\n\t\t\trenderListStack.pop();\n\n\t\t\tif ( renderListStack.length > 0 ) {\n\n\t\t\t\tcurrentRenderList = renderListStack[ renderListStack.length - 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tcurrentRenderList = null;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tconst visible = object.layers.test( camera.layers );\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isGroup ) {\n\n\t\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\t\t\t\t\t\t\t\t_vector3.copy( object.boundingSphere.center );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\t\t\t\t\t\t\t_vector3.copy( geometry.boundingSphere.center );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_vector3\n\t\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderScene( currentRenderList, scene, camera, viewport ) {\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\t\t\tconst transparentObjects = currentRenderList.transparent;\n\n\t\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );\n\n\t\t\tif ( viewport ) state.viewport( _currentViewport.copy( viewport ) );\n\n\t\t\tif ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );\n\t\t\tif ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );\n\t\t\tif ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.buffers.depth.setTest( true );\n\t\t\tstate.buffers.depth.setMask( true );\n\t\t\tstate.buffers.color.setMask( true );\n\n\t\t\tstate.setPolygonOffset( false );\n\n\t\t}\n\n\t\tfunction renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {\n\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tif ( overrideMaterial !== null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( currentRenderState.state.transmissionRenderTarget[ camera.id ] === undefined ) {\n\n\t\t\t\tcurrentRenderState.state.transmissionRenderTarget[ camera.id ] = new WebGLRenderTarget( 1, 1, {\n\t\t\t\t\tgenerateMipmaps: true,\n\t\t\t\t\ttype: ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) ) ? HalfFloatType : UnsignedByteType,\n\t\t\t\t\tminFilter: LinearMipmapLinearFilter,\n\t\t\t\t\tsamples: 4,\n\t\t\t\t\tstencilBuffer: stencil,\n\t\t\t\t\tresolveDepthBuffer: false,\n\t\t\t\t\tresolveStencilBuffer: false,\n\t\t\t\t\tcolorSpace: ColorManagement.workingColorSpace,\n\t\t\t\t} );\n\n\t\t\t\t// debug\n\n\t\t\t\t/*\n\t\t\t\tconst geometry = new PlaneGeometry();\n\t\t\t\tconst material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );\n\n\t\t\t\tconst mesh = new Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\t\t\t\t*/\n\n\t\t\t}\n\n\t\t\tconst transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[ camera.id ];\n\n\t\t\tconst activeViewport = camera.viewport || _currentViewport;\n\t\t\ttransmissionRenderTarget.setSize( activeViewport.z, activeViewport.w );\n\n\t\t\t//\n\n\t\t\tconst currentRenderTarget = _this.getRenderTarget();\n\t\t\t_this.setRenderTarget( transmissionRenderTarget );\n\n\t\t\t_this.getClearColor( _currentClearColor );\n\t\t\t_currentClearAlpha = _this.getClearAlpha();\n\t\t\tif ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );\n\n\t\t\tif ( _renderBackground ) {\n\n\t\t\t\tbackground.render( scene );\n\n\t\t\t} else {\n\n\t\t\t\t_this.clear();\n\n\t\t\t}\n\n\t\t\t// Turn off the features which can affect the frag color for opaque objects pass.\n\t\t\t// Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n\t\t\tconst currentToneMapping = _this.toneMapping;\n\t\t\t_this.toneMapping = NoToneMapping;\n\n\t\t\t// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).\n\t\t\t// Transmission render pass requires viewport to match the transmissionRenderTarget.\n\t\t\tconst currentCameraViewport = camera.viewport;\n\t\t\tif ( camera.viewport !== undefined ) camera.viewport = undefined;\n\n\t\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );\n\n\t\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t\ttextures.updateMultisampleRenderTarget( transmissionRenderTarget );\n\t\t\ttextures.updateRenderTargetMipmap( transmissionRenderTarget );\n\n\t\t\tif ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === false ) { // see #28131\n\n\t\t\t\tlet renderTargetNeedsUpdate = false;\n\n\t\t\t\tfor ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst renderItem = transmissiveObjects[ i ];\n\n\t\t\t\t\tconst object = renderItem.object;\n\t\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\t\tconst material = renderItem.material;\n\t\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\t\tif ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\t\tconst currentSide = material.side;\n\n\t\t\t\t\t\tmaterial.side = BackSide;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t\t\tmaterial.side = currentSide;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t\trenderTargetNeedsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTargetNeedsUpdate === true ) {\n\n\t\t\t\t\ttextures.updateMultisampleRenderTarget( transmissionRenderTarget );\n\t\t\t\t\ttextures.updateRenderTargetMipmap( transmissionRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_this.setRenderTarget( currentRenderTarget );\n\n\t\t\t_this.setClearColor( _currentClearColor, _currentClearAlpha );\n\n\t\t\tif ( currentCameraViewport !== undefined ) camera.viewport = currentCameraViewport;\n\n\t\t\t_this.toneMapping = currentToneMapping;\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera ) {\n\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tfor ( let i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\t\tconst object = renderItem.object;\n\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tmaterial.onBeforeRender( _this, scene, camera, geometry, object, group );\n\n\t\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\t\t}\n\n\t\tfunction getProgram( material, scene, object ) {\n\n\t\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\tconst materialProperties = properties.get( material );\n\n\t\t\tconst lights = currentRenderState.state.lights;\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tconst lightsStateVersion = lights.state.version;\n\n\t\t\tconst parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );\n\t\t\tconst programCacheKey = programCache.getProgramCacheKey( parameters );\n\n\t\t\tlet programs = materialProperties.programs;\n\n\t\t\t// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tmaterialProperties.fog = scene.fog;\n\t\t\tmaterialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );\n\t\t\tmaterialProperties.envMapRotation = ( materialProperties.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;\n\n\t\t\tif ( programs === undefined ) {\n\n\t\t\t\t// new material\n\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t\tprograms = new Map();\n\t\t\t\tmaterialProperties.programs = programs;\n\n\t\t\t}\n\n\t\t\tlet program = programs.get( programCacheKey );\n\n\t\t\tif ( program !== undefined ) {\n\n\t\t\t\t// early out if program and light state is identical\n\n\t\t\t\tif ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {\n\n\t\t\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t\t\treturn program;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tparameters.uniforms = programCache.getUniforms( material );\n\n\t\t\t\tmaterial.onBuild( object, parameters, _this );\n\n\t\t\t\tmaterial.onBeforeCompile( parameters, _this );\n\n\t\t\t\tprogram = programCache.acquireProgram( parameters, programCacheKey );\n\t\t\t\tprograms.set( programCacheKey, program );\n\n\t\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\n\t\t\t}\n\n\t\t\tconst uniforms = materialProperties.uniforms;\n\n\t\t\tif ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {\n\n\t\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\n\t\t\t}\n\n\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.needsLights = materialNeedsLights( material );\n\t\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\t\tuniforms.spotLightMatrix.value = lights.state.spotLightMatrix;\n\t\t\t\tuniforms.spotLightMap.value = lights.state.spotLightMap;\n\t\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t\t}\n\n\t\t\tmaterialProperties.currentProgram = program;\n\t\t\tmaterialProperties.uniformsList = null;\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction getUniformList( materialProperties ) {\n\n\t\t\tif ( materialProperties.uniformsList === null ) {\n\n\t\t\t\tconst progUniforms = materialProperties.currentProgram.getUniforms();\n\t\t\t\tmaterialProperties.uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, materialProperties.uniforms );\n\n\t\t\t}\n\n\t\t\treturn materialProperties.uniformsList;\n\n\t\t}\n\n\t\tfunction updateCommonMaterialProperties( material, parameters ) {\n\n\t\t\tconst materialProperties = properties.get( material );\n\n\t\t\tmaterialProperties.outputColorSpace = parameters.outputColorSpace;\n\t\t\tmaterialProperties.batching = parameters.batching;\n\t\t\tmaterialProperties.batchingColor = parameters.batchingColor;\n\t\t\tmaterialProperties.instancing = parameters.instancing;\n\t\t\tmaterialProperties.instancingColor = parameters.instancingColor;\n\t\t\tmaterialProperties.instancingMorph = parameters.instancingMorph;\n\t\t\tmaterialProperties.skinning = parameters.skinning;\n\t\t\tmaterialProperties.morphTargets = parameters.morphTargets;\n\t\t\tmaterialProperties.morphNormals = parameters.morphNormals;\n\t\t\tmaterialProperties.morphColors = parameters.morphColors;\n\t\t\tmaterialProperties.morphTargetsCount = parameters.morphTargetsCount;\n\t\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\t\t\tmaterialProperties.vertexTangents = parameters.vertexTangents;\n\t\t\tmaterialProperties.toneMapping = parameters.toneMapping;\n\n\t\t}\n\n\t\tfunction setProgram( camera, scene, geometry, material, object ) {\n\n\t\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\ttextures.resetTextureUnits();\n\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );\n\t\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\n\t\t\tconst vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;\n\t\t\tconst vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );\n\t\t\tconst morphTargets = !! geometry.morphAttributes.position;\n\t\t\tconst morphNormals = !! geometry.morphAttributes.normal;\n\t\t\tconst morphColors = !! geometry.morphAttributes.color;\n\n\t\t\tlet toneMapping = NoToneMapping;\n\n\t\t\tif ( material.toneMapped ) {\n\n\t\t\t\tif ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\t\t\t\ttoneMapping = _this.toneMapping;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t\tconst materialProperties = properties.get( material );\n\t\t\tconst lights = currentRenderState.state.lights;\n\n\t\t\tif ( _clippingEnabled === true ) {\n\n\t\t\t\tif ( _localClippingEnabled === true || camera !== _currentCamera ) {\n\n\t\t\t\t\tconst useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\tclipping.setState( material, camera, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet needsProgramChange = false;\n\n\t\t\tif ( material.version === materialProperties.__version ) {\n\n\t\t\t\tif ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.outputColorSpace !== colorSpace ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isBatchedMesh && materialProperties.batching === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isBatchedMesh && materialProperties.batching === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.envMap !== envMap ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( material.fog === true && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== clipping.numPlanes ||\n\t\t\t\t\tmaterialProperties.numIntersection !== clipping.numIntersection ) ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.vertexTangents !== vertexTangents ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphTargets !== morphTargets ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphNormals !== morphNormals ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphColors !== morphColors ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.toneMapping !== toneMapping ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphTargetsCount !== morphTargetsCount ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tneedsProgramChange = true;\n\t\t\t\tmaterialProperties.__version = material.version;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet program = materialProperties.currentProgram;\n\n\t\t\tif ( needsProgramChange === true ) {\n\n\t\t\t\tprogram = getProgram( material, scene, object );\n\n\t\t\t}\n\n\t\t\tlet refreshProgram = false;\n\t\t\tlet refreshMaterial = false;\n\t\t\tlet refreshLights = false;\n\n\t\t\tconst p_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || _currentCamera !== camera ) {\n\n\t\t\t\t// common camera uniforms\n\n\t\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\t\t\t\t// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\tmaterial.isShaderMaterial ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( _currentCamera !== camera ) {\n\n\t\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skinning and morph target uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone and morph texture must go before other textures\n\t\t\t// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\n\n\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tconst skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tif ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'batchingTexture' );\n\t\t\t\tp_uniforms.setValue( _gl, 'batchingTexture', object._matricesTexture, textures );\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'batchingColorTexture' );\n\t\t\t\tif ( object._colorsTexture !== null ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'batchingColorTexture', object._colorsTexture, textures );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\t\tif ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined ) ) {\n\n\t\t\t\tmorphtargets.update( object, geometry, program );\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {\n\n\t\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\t\tp_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );\n\n\t\t\t}\n\n\t\t\t// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512\n\n\t\t\tif ( material.isMeshGouraudMaterial && material.envMap !== null ) {\n\n\t\t\t\tm_uniforms.envMap.value = envMap;\n\n\t\t\t\tm_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null ) {\n\n\t\t\t\tm_uniforms.envMapIntensity.value = scene.environmentIntensity;\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\n\t\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog === true ) {\n\n\t\t\t\t\tmaterials.refreshFogUniforms( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[ camera.id ] );\n\n\t\t\t\tWebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );\n\n\t\t\t}\n\n\t\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\t\tWebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );\n\t\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( material.isSpriteMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\n\n\t\t\t}\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\t// UBOs\n\n\t\t\tif ( material.isShaderMaterial || material.isRawShaderMaterial ) {\n\n\t\t\t\tconst groups = material.uniformsGroups;\n\n\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\t\tuniformsGroups.update( group, program );\n\t\t\t\t\tuniformsGroups.bind( group, program );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\t\tuniforms.lightProbe.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\tfunction materialNeedsLights( material ) {\n\n\t\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial || material.isShadowMaterial ||\n\t\t\t\t( material.isShaderMaterial && material.lights === true );\n\n\t\t}\n\n\t\tthis.getActiveCubeFace = function () {\n\n\t\t\treturn _currentActiveCubeFace;\n\n\t\t};\n\n\t\tthis.getActiveMipmapLevel = function () {\n\n\t\t\treturn _currentActiveMipmapLevel;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {\n\n\t\t\tproperties.get( renderTarget.texture ).__webglTexture = colorTexture;\n\t\t\tproperties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\trenderTargetProperties.__hasExternalTextures = true;\n\n\t\t\trenderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;\n\n\t\t\tif ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {\n\n\t\t\t\t// The multisample_render_to_texture extension doesn't work properly if there\n\t\t\t\t// are midframe flushes and an external depth buffer. Disable use of the extension.\n\t\t\t\tif ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );\n\t\t\t\t\trenderTargetProperties.__useRenderToTexture = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\trenderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n\t\t\trenderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\t\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\t\tlet useDefaultFramebuffer = true;\n\t\t\tlet framebuffer = null;\n\t\t\tlet isCube = false;\n\t\t\tlet isRenderTarget3D = false;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tif ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {\n\n\t\t\t\t\t// We need to make sure to rebind the framebuffer.\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\t\t\t\tuseDefaultFramebuffer = false;\n\n\t\t\t\t} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {\n\n\t\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t\t} else if ( renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\t\t\t// Color and depth texture must be rebound in order for the swapchain to update.\n\t\t\t\t\ttextures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tisRenderTarget3D = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\t\t\tif ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tisCube = true;\n\n\t\t\t\t} else if ( ( renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( Array.isArray( __webglFramebuffer ) ) {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeMipmapLevel ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t} else {\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t}\n\n\t\t\tconst framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( framebufferBound && useDefaultFramebuffer ) {\n\n\t\t\t\tstate.drawBuffers( renderTarget, framebuffer );\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport );\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );\n\n\t\t\t} else if ( isRenderTarget3D ) {\n\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\tconst layer = activeCubeFace || 0;\n\t\t\t\t_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );\n\n\t\t\t}\n\n\t\t\t_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings\n\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\n\n\t\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t\t}\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\ttry {\n\n\t\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\t\tif ( ! capabilities.textureFormatReadable( textureFormat ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! capabilities.textureTypeReadable( textureType ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\t// restore framebuffer of current render target if necessary\n\n\t\t\t\t\tconst framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.readRenderTargetPixelsAsync = async function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\n\n\t\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t\t}\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\ttry {\n\n\t\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\t\tif ( ! capabilities.textureFormatReadable( textureFormat ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! capabilities.textureTypeReadable( textureType ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\tconst glBuffer = _gl.createBuffer();\n\t\t\t\t\t\t_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );\n\t\t\t\t\t\t_gl.bufferData( _gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ );\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), 0 );\n\t\t\t\t\t\t_gl.flush();\n\n\t\t\t\t\t\t// check if the commands have finished every 8 ms\n\t\t\t\t\t\tconst sync = _gl.fenceSync( _gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );\n\t\t\t\t\t\tawait probeAsync( _gl, sync, 4 );\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );\n\t\t\t\t\t\t\t_gl.getBufferSubData( _gl.PIXEL_PACK_BUFFER, 0, buffer );\n\n\t\t\t\t\t\t} finally {\n\n\t\t\t\t\t\t\t_gl.deleteBuffer( glBuffer );\n\t\t\t\t\t\t\t_gl.deleteSync( sync );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn buffer;\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\t// restore framebuffer of current render target if necessary\n\n\t\t\t\t\tconst framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.copyFramebufferToTexture = function ( texture, position = null, level = 0 ) {\n\n\t\t\t// support previous signature with position first\n\t\t\tif ( texture.isTexture !== true ) {\n\n\t\t\t\t// @deprecated, r165\n\t\t\t\tconsole.warn( 'WebGLRenderer: copyFramebufferToTexture function signature has changed.' );\n\n\t\t\t\tposition = arguments[ 0 ] || null;\n\t\t\t\ttexture = arguments[ 1 ];\n\n\t\t\t}\n\n\t\t\tconst levelScale = Math.pow( 2, - level );\n\t\t\tconst width = Math.floor( texture.image.width * levelScale );\n\t\t\tconst height = Math.floor( texture.image.height * levelScale );\n\n\t\t\tconst x = position !== null ? position.x : 0;\n\t\t\tconst y = position !== null ? position.y : 0;\n\n\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t\t_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, x, y, width, height );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.copyTextureToTexture = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\t\t// support previous signature with dstPosition first\n\t\t\tif ( srcTexture.isTexture !== true ) {\n\n\t\t\t\t// @deprecated, r165\n\t\t\t\tconsole.warn( 'WebGLRenderer: copyTextureToTexture function signature has changed.' );\n\n\t\t\t\tdstPosition = arguments[ 0 ] || null;\n\t\t\t\tsrcTexture = arguments[ 1 ];\n\t\t\t\tdstTexture = arguments[ 2 ];\n\t\t\t\tlevel = arguments[ 3 ] || 0;\n\t\t\t\tsrcRegion = null;\n\n\t\t\t}\n\n\t\t\tlet width, height, minX, minY;\n\t\t\tlet dstX, dstY;\n\t\t\tif ( srcRegion !== null ) {\n\n\t\t\t\twidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\t\theight = srcRegion.max.y - srcRegion.min.y;\n\t\t\t\tminX = srcRegion.min.x;\n\t\t\t\tminY = srcRegion.min.y;\n\n\t\t\t} else {\n\n\t\t\t\twidth = srcTexture.image.width;\n\t\t\t\theight = srcTexture.image.height;\n\t\t\t\tminX = 0;\n\t\t\t\tminY = 0;\n\n\t\t\t}\n\n\t\t\tif ( dstPosition !== null ) {\n\n\t\t\t\tdstX = dstPosition.x;\n\t\t\t\tdstY = dstPosition.y;\n\n\t\t\t} else {\n\n\t\t\t\tdstX = 0;\n\t\t\t\tdstY = 0;\n\n\t\t\t}\n\n\t\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\t\tconst glType = utils.convert( dstTexture.type );\n\n\t\t\ttextures.setTexture2D( dstTexture, 0 );\n\n\t\t\t// As another texture upload may have changed pixelStorei\n\t\t\t// parameters, make sure they are correct for the dstTexture\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\t\tconst currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );\n\t\t\tconst currentUnpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );\n\t\t\tconst currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );\n\t\t\tconst currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );\n\t\t\tconst currentUnpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );\n\n\t\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, minX );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, minY );\n\n\t\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data );\n\n\t\t\t} else {\n\n\t\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t\t_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level, dstX, dstY, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );\n\n\t\t\t// Generate mipmaps only when copying level 0\n\t\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.copyTextureToTexture3D = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\t\t// support previous signature with source box first\n\t\t\tif ( srcTexture.isTexture !== true ) {\n\n\t\t\t\t// @deprecated, r165\n\t\t\t\tconsole.warn( 'WebGLRenderer: copyTextureToTexture3D function signature has changed.' );\n\n\t\t\t\tsrcRegion = arguments[ 0 ] || null;\n\t\t\t\tdstPosition = arguments[ 1 ] || null;\n\t\t\t\tsrcTexture = arguments[ 2 ];\n\t\t\t\tdstTexture = arguments[ 3 ];\n\t\t\t\tlevel = arguments[ 4 ] || 0;\n\n\t\t\t}\n\n\t\t\tlet width, height, depth, minX, minY, minZ;\n\t\t\tlet dstX, dstY, dstZ;\n\t\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;\n\t\t\tif ( srcRegion !== null ) {\n\n\t\t\t\twidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\t\theight = srcRegion.max.y - srcRegion.min.y;\n\t\t\t\tdepth = srcRegion.max.z - srcRegion.min.z;\n\t\t\t\tminX = srcRegion.min.x;\n\t\t\t\tminY = srcRegion.min.y;\n\t\t\t\tminZ = srcRegion.min.z;\n\n\t\t\t} else {\n\n\t\t\t\twidth = image.width;\n\t\t\t\theight = image.height;\n\t\t\t\tdepth = image.depth;\n\t\t\t\tminX = 0;\n\t\t\t\tminY = 0;\n\t\t\t\tminZ = 0;\n\n\t\t\t}\n\n\t\t\tif ( dstPosition !== null ) {\n\n\t\t\t\tdstX = dstPosition.x;\n\t\t\t\tdstY = dstPosition.y;\n\t\t\t\tdstZ = dstPosition.z;\n\n\t\t\t} else {\n\n\t\t\t\tdstX = 0;\n\t\t\t\tdstY = 0;\n\t\t\t\tdstZ = 0;\n\n\t\t\t}\n\n\t\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\t\tconst glType = utils.convert( dstTexture.type );\n\t\t\tlet glTarget;\n\n\t\t\tif ( dstTexture.isData3DTexture ) {\n\n\t\t\t\ttextures.setTexture3D( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_3D;\n\n\t\t\t} else if ( dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture ) {\n\n\t\t\t\ttextures.setTexture2DArray( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_2D_ARRAY;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\t\tconst currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );\n\t\t\tconst currentUnpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );\n\t\t\tconst currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );\n\t\t\tconst currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );\n\t\t\tconst currentUnpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, minX );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, minY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, minZ );\n\n\t\t\tif ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {\n\n\t\t\t\t_gl.texSubImage3D( glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data );\n\n\t\t\t} else {\n\n\t\t\t\tif ( dstTexture.isCompressedArrayTexture ) {\n\n\t\t\t\t\t_gl.compressedTexSubImage3D( glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texSubImage3D( glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );\n\n\t\t\t// Generate mipmaps only when copying level 0\n\t\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.initRenderTarget = function ( target ) {\n\n\t\t\tif ( properties.get( target ).__webglFramebuffer === undefined ) {\n\n\t\t\t\ttextures.setupRenderTarget( target );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.initTexture = function ( texture ) {\n\n\t\t\tif ( texture.isCubeTexture ) {\n\n\t\t\t\ttextures.setTextureCube( texture, 0 );\n\n\t\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\t\ttextures.setTexture3D( texture, 0 );\n\n\t\t\t} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\ttextures.setTexture2DArray( texture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.resetState = function () {\n\n\t\t\t_currentActiveCubeFace = 0;\n\t\t\t_currentActiveMipmapLevel = 0;\n\t\t\t_currentRenderTarget = null;\n\n\t\t\tstate.reset();\n\t\t\tbindingStates.reset();\n\n\t\t};\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn WebGLCoordinateSystem;\n\n\t}\n\n\tget outputColorSpace() {\n\n\t\treturn this._outputColorSpace;\n\n\t}\n\n\tset outputColorSpace( colorSpace ) {\n\n\t\tthis._outputColorSpace = colorSpace;\n\n\t\tconst gl = this.getContext();\n\t\tgl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? 'display-p3' : 'srgb';\n\t\tgl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? 'display-p3' : 'srgb';\n\n\t}\n\n}\n\nclass FogExp2 {\n\n\tconstructor( color, density = 0.00025 ) {\n\n\t\tthis.isFogExp2 = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = density;\n\n\t}\n\n\tclone() {\n\n\t\treturn new FogExp2( this.color, this.density );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tname: this.name,\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t}\n\n}\n\nclass Fog {\n\n\tconstructor( color, near = 1, far = 1000 ) {\n\n\t\tthis.isFog = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Fog( this.color, this.near, this.far );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tname: this.name,\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t}\n\n}\n\nclass Scene extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isScene = true;\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.environment = null;\n\t\tthis.fog = null;\n\n\t\tthis.backgroundBlurriness = 0;\n\t\tthis.backgroundIntensity = 1;\n\t\tthis.backgroundRotation = new Euler();\n\n\t\tthis.environmentIntensity = 1;\n\t\tthis.environmentRotation = new Euler();\n\n\t\tthis.overrideMaterial = null;\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.environment !== null ) this.environment = source.environment.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\n\t\tthis.backgroundBlurriness = source.backgroundBlurriness;\n\t\tthis.backgroundIntensity = source.backgroundIntensity;\n\t\tthis.backgroundRotation.copy( source.backgroundRotation );\n\n\t\tthis.environmentIntensity = source.environmentIntensity;\n\t\tthis.environmentRotation.copy( source.environmentRotation );\n\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\tif ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;\n\t\tif ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;\n\t\tdata.object.backgroundRotation = this.backgroundRotation.toArray();\n\n\t\tif ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;\n\t\tdata.object.environmentRotation = this.environmentRotation.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InterleavedBuffer {\n\n\tconstructor( array, stride ) {\n\n\t\tthis.isInterleavedBuffer = true;\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis._updateRange = { offset: 0, count: - 1 };\n\t\tthis.updateRanges = [];\n\n\t\tthis.version = 0;\n\n\t\tthis.uuid = generateUUID();\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tget updateRange() {\n\n\t\twarnOnce( 'THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.' ); // @deprecated, r159\n\t\treturn this._updateRange;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( let i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;\n\n\t\t}\n\n\t\tconst array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );\n\n\t\tconst ib = new this.constructor( array, this.stride );\n\t\tib.setUsage( this.usage );\n\n\t\treturn ib;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\t// generate UUID for array buffer if necessary\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );\n\n\t\t}\n\n\t\t//\n\n\t\treturn {\n\t\t\tuuid: this.uuid,\n\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tstride: this.stride\n\t\t};\n\n\t}\n\n}\n\nconst _vector$6 = /*@__PURE__*/ new Vector3();\n\nclass InterleavedBufferAttribute {\n\n\tconstructor( interleavedBuffer, itemSize, offset, normalized = false ) {\n\n\t\tthis.isInterleavedBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized;\n\n\t}\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t}\n\n\tget array() {\n\n\t\treturn this.data.array;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tthis.data.needsUpdate = value;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.data.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.fromBufferAttribute( this, i );\n\n\t\t\t_vector$6.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.fromBufferAttribute( this, i );\n\n\t\t\t_vector$6.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.fromBufferAttribute( this, i );\n\n\t\t\t_vector$6.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.data.stride + this.offset + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.data.array[ index * this.data.stride + this.offset ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );\n\n\t\t} else {\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );\n\n\t\t\t}\n\n\t\t\treturn new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );\n\n\t\t}\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// de-interleave data and save it as an ordinary buffer attribute for now\n\n\t\t\treturn {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t} else {\n\n\t\t\t// save as true interleaved attribute\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\tdata: this.data.uuid,\n\t\t\t\toffset: this.offset,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n\nclass SpriteMaterial extends (/* unused pure expression or super */ null && (Material)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isSpriteMaterial = true;\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/ new Vector3();\nconst _worldScale = /*@__PURE__*/ new Vector3();\nconst _mvPosition = /*@__PURE__*/ new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/ new Vector2();\nconst _rotatedPosition = /*@__PURE__*/ new Vector2();\nconst _viewWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _uvA = /*@__PURE__*/ new Vector2();\nconst _uvB = /*@__PURE__*/ new Vector2();\nconst _uvC = /*@__PURE__*/ new Vector2();\n\nclass Sprite extends (/* unused pure expression or super */ null && (Object3D)) {\n\n\tconstructor( material = new SpriteMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isSprite = true;\n\n\t\tthis.type = 'Sprite';\n\n\t\tif ( _geometry === undefined ) {\n\n\t\t\t_geometry = new BufferGeometry();\n\n\t\t\tconst float32Array = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5, 0, 0, 0,\n\t\t\t\t0.5, - 0.5, 0, 1, 0,\n\t\t\t\t0.5, 0.5, 0, 1, 1,\n\t\t\t\t- 0.5, 0.5, 0, 0, 1\n\t\t\t] );\n\n\t\t\tconst interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\t\t\t_geometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\t\t_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\t\t_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\t}\n\n\t\tthis.geometry = _geometry;\n\t\tthis.material = material;\n\n\t\tthis.center = new Vector2( 0.5, 0.5 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.' );\n\n\t\t}\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\n\t\t_viewWorldMatrix.copy( raycaster.camera.matrixWorld );\n\t\tthis.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );\n\n\t\t_mvPosition.setFromMatrixPosition( this.modelViewMatrix );\n\n\t\tif ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {\n\n\t\t\t_worldScale.multiplyScalar( - _mvPosition.z );\n\n\t\t}\n\n\t\tconst rotation = this.material.rotation;\n\t\tlet sin, cos;\n\n\t\tif ( rotation !== 0 ) {\n\n\t\t\tcos = Math.cos( rotation );\n\t\t\tsin = Math.sin( rotation );\n\n\t\t}\n\n\t\tconst center = this.center;\n\n\t\ttransformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\n\t\t_uvA.set( 0, 0 );\n\t\t_uvB.set( 1, 0 );\n\t\t_uvC.set( 1, 1 );\n\n\t\t// check first triangle\n\t\tlet intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );\n\n\t\tif ( intersect === null ) {\n\n\t\t\t// check second triangle\n\t\t\ttransformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\t\t_uvB.set( 0, 1 );\n\n\t\t\tintersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );\n\t\t\tif ( intersect === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( _intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectPoint.clone(),\n\t\t\tuv: Triangle.getInterpolation( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),\n\t\t\tface: null,\n\t\t\tobject: this\n\n\t\t} );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\tthis.material = source.material;\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\n\n\t// compute position in camera space\n\t_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\n\n\t// to check if rotation is not zero\n\tif ( sin !== undefined ) {\n\n\t\t_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );\n\t\t_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );\n\n\t} else {\n\n\t\t_rotatedPosition.copy( _alignedPosition );\n\n\t}\n\n\n\tvertexPosition.copy( mvPosition );\n\tvertexPosition.x += _rotatedPosition.x;\n\tvertexPosition.y += _rotatedPosition.y;\n\n\t// transform to world space\n\tvertexPosition.applyMatrix4( _viewWorldMatrix );\n\n}\n\nconst _v1$2 = /*@__PURE__*/ new Vector3();\nconst _v2$1 = /*@__PURE__*/ new Vector3();\n\nclass LOD extends (/* unused pure expression or super */ null && (Object3D)) {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis._currentLevel = 0;\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tisLOD: {\n\t\t\t\tvalue: true,\n\t\t\t}\n\t\t} );\n\n\t\tthis.autoUpdate = true;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tconst levels = source.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance, level.hysteresis );\n\n\t\t}\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\taddLevel( object, distance = 0, hysteresis = 0 ) {\n\n\t\tdistance = Math.abs( distance );\n\n\t\tconst levels = this.levels;\n\n\t\tlet l;\n\n\t\tfor ( l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );\n\n\t\tthis.add( object );\n\n\t\treturn this;\n\n\t}\n\n\tgetCurrentLevel() {\n\n\t\treturn this._currentLevel;\n\n\t}\n\n\n\n\tgetObjectForDistance( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance < levelDistance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo( _v1$2 );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 1 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t_v2$1.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;\n\n\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance >= levelDistance ) {\n\n\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._currentLevel = i - 1;\n\n\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.autoUpdate === false ) data.object.autoUpdate = false;\n\n\t\tdata.object.levels = [];\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance,\n\t\t\t\thysteresis: level.hysteresis\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _basePosition = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\n\nconst _vector3 = /*@__PURE__*/ new Vector3();\nconst _matrix4 = /*@__PURE__*/ new Matrix4();\nconst _vertex = /*@__PURE__*/ new Vector3();\n\nconst _sphere$4 = /*@__PURE__*/ new Sphere();\nconst _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();\nconst _ray$2 = /*@__PURE__*/ new Ray();\n\nclass SkinnedMesh extends (/* unused pure expression or super */ null && (Mesh)) {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkinnedMesh = true;\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = AttachedBindMode;\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingBox.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingSphere.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.bindMode = source.bindMode;\n\t\tthis.bindMatrix.copy( source.bindMatrix );\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\n\n\t\tthis.skeleton = source.skeleton;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$4.copy( this.boundingSphere );\n\t\t_sphere$4.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;\n\n\t\t// convert ray to local space of skinned mesh\n\n\t\t_inverseMatrix$2.copy( matrixWorld ).invert();\n\t\t_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tif ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$2 );\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tsuper.getVertexPosition( index, target );\n\n\t\tthis.applyBoneTransform( index, target );\n\n\t\treturn target;\n\n\t}\n\n\tbind( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.copy( bindMatrix ).invert();\n\n\t}\n\n\tpose() {\n\n\t\tthis.skeleton.pose();\n\n\t}\n\n\tnormalizeSkinWeights() {\n\n\t\tconst vector = new Vector4();\n\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.fromBufferAttribute( skinWeight, i );\n\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.bindMode === AttachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.matrixWorld ).invert();\n\n\t\t} else if ( this.bindMode === DetachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.bindMatrix ).invert();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t}\n\n\tapplyBoneTransform( index, vector ) {\n\n\t\tconst skeleton = this.skeleton;\n\t\tconst geometry = this.geometry;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_basePosition.copy( vector ).applyMatrix4( this.bindMatrix );\n\n\t\tvector.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\n\t\t\t\t_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\tvector.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn vector.applyMatrix4( this.bindMatrixInverse );\n\n\t}\n\n}\n\nclass Bone extends (/* unused pure expression or super */ null && (Object3D)) {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBone = true;\n\n\t\tthis.type = 'Bone';\n\n\t}\n\n}\n\nclass DataTexture extends (/* unused pure expression or super */ null && (Texture)) {\n\n\tconstructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isDataTexture = true;\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix$1 = /*@__PURE__*/ new Matrix4();\n\nclass Skeleton {\n\n\tconstructor( bones = [], boneInverses = [] ) {\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.bones = bones.slice( 0 );\n\t\tthis.boneInverses = boneInverses;\n\t\tthis.boneMatrices = null;\n\n\t\tthis.boneTexture = null;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\n\n\t\t// calculate inverse bone matrices if necessary\n\n\t\tif ( boneInverses.length === 0 ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\t// handle special case\n\n\t\t\tif ( bones.length !== boneInverses.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcalculateInverses() {\n\n\t\tthis.boneInverses.length = 0;\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\tpose() {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix$1;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== null ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t}\n\n\tcomputeBoneTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tboneMatrices.set( this.boneMatrices ); // copy current values\n\n\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\tboneTexture.needsUpdate = true;\n\n\t\tthis.boneMatrices = boneMatrices;\n\t\tthis.boneTexture = boneTexture;\n\n\t\treturn this;\n\n\t}\n\n\tgetBoneByName( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tdispose( ) {\n\n\t\tif ( this.boneTexture !== null ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = null;\n\n\t\t}\n\n\t}\n\n\tfromJSON( json, bones ) {\n\n\t\tthis.uuid = json.uuid;\n\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\n\n\t\t\tconst uuid = json.bones[ i ];\n\t\t\tlet bone = bones[ uuid ];\n\n\t\t\tif ( bone === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\n\t\t\t\tbone = new Bone();\n\n\t\t\t}\n\n\t\t\tthis.bones.push( bone );\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\n\n\t\t}\n\n\t\tthis.init();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Skeleton',\n\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t},\n\t\t\tbones: [],\n\t\t\tboneInverses: []\n\t\t};\n\n\t\tdata.uuid = this.uuid;\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\t\t\tdata.bones.push( bone.uuid );\n\n\t\t\tconst boneInverse = boneInverses[ i ];\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InstancedBufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)) {\n\n\tconstructor( array, itemSize, normalized, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, itemSize, normalized );\n\n\t\tthis.isInstancedBufferAttribute = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\n\t\tdata.isInstancedBufferAttribute = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _instanceIntersects = (/* unused pure expression or super */ null && ([]));\n\nconst _box3 = /*@__PURE__*/ new Box3();\nconst _identity = /*@__PURE__*/ new Matrix4();\nconst _mesh$1 = /*@__PURE__*/ new Mesh();\nconst _sphere$3 = /*@__PURE__*/ new Sphere();\n\nclass InstancedMesh extends (/* unused pure expression or super */ null && (Mesh)) {\n\n\tconstructor( geometry, material, count ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isInstancedMesh = true;\n\n\t\tthis.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );\n\t\tthis.instanceColor = null;\n\t\tthis.morphTexture = null;\n\n\t\tthis.count = count;\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.setMatrixAt( i, _identity );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingBox.union( _box3 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingSphere.union( _sphere$3 );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\n\t\tif ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\n\n\t\tthis.count = source.count;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( index, color ) {\n\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tgetMatrixAt( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tgetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tconst len = objectInfluences.length + 1; // All influences + the baseInfluenceSum\n\n\t\tconst dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tobjectInfluences[ i ] = array[ dataIndex + i ];\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh$1.geometry = this.geometry;\n\t\t_mesh$1.material = this.material;\n\n\t\tif ( _mesh$1.material === undefined ) return;\n\n\t\t// test with bounding sphere first\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$3.copy( this.boundingSphere );\n\t\t_sphere$3.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;\n\n\t\t// now test each instance\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh$1.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh$1.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t}\n\n\tsetColorAt( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tsetMatrixAt( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tsetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst len = objectInfluences.length + 1; // morphBaseInfluence + all influences\n\n\t\tif ( this.morphTexture === null ) {\n\n\t\t\tthis.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );\n\n\t\t}\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tlet morphInfluencesSum = 0;\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t}\n\n\t\tconst morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\tconst dataIndex = len * index;\n\n\t\tarray[ dataIndex ] = morphBaseInfluence;\n\n\t\tarray.set( objectInfluences, dataIndex + 1 );\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\tif ( this.morphTexture !== null ) {\n\n\t\t\tthis.morphTexture.dispose();\n\t\t\tthis.morphTexture = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction sortOpaque( a, b ) {\n\n\treturn a.z - b.z;\n\n}\n\nfunction sortTransparent( a, b ) {\n\n\treturn b.z - a.z;\n\n}\n\nclass MultiDrawRenderList {\n\n\tconstructor() {\n\n\t\tthis.index = 0;\n\t\tthis.pool = [];\n\t\tthis.list = [];\n\n\t}\n\n\tpush( drawRange, z ) {\n\n\t\tconst pool = this.pool;\n\t\tconst list = this.list;\n\t\tif ( this.index >= pool.length ) {\n\n\t\t\tpool.push( {\n\n\t\t\t\tstart: - 1,\n\t\t\t\tcount: - 1,\n\t\t\t\tz: - 1,\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst item = pool[ this.index ];\n\t\tlist.push( item );\n\t\tthis.index ++;\n\n\t\titem.start = drawRange.start;\n\t\titem.count = drawRange.count;\n\t\titem.z = z;\n\n\t}\n\n\treset() {\n\n\t\tthis.list.length = 0;\n\t\tthis.index = 0;\n\n\t}\n\n}\n\nconst ID_ATTR_NAME = 'batchId';\nconst _matrix$1 = /*@__PURE__*/ new Matrix4();\nconst _invMatrixWorld = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\nconst _whiteColor = /*@__PURE__*/ new Color( 1, 1, 1 );\nconst _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4();\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _box$1 = /*@__PURE__*/ new Box3();\nconst _sphere$2 = /*@__PURE__*/ new Sphere();\nconst _vector$5 = /*@__PURE__*/ new Vector3();\nconst _forward = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\nconst _renderList = /*@__PURE__*/ new MultiDrawRenderList();\nconst _mesh = /*@__PURE__*/ new Mesh();\nconst _batchIntersects = (/* unused pure expression or super */ null && ([]));\n\n// @TODO: SkinnedMesh support?\n// @TODO: geometry.groups support?\n// @TODO: geometry.drawRange support?\n// @TODO: geometry.morphAttributes support?\n// @TODO: Support uniform parameter per geometry\n// @TODO: Add an \"optimize\" function to pack geometry and remove data gaps\n\n// copies data from attribute \"src\" into \"target\" starting at \"targetOffset\"\nfunction copyAttributeData( src, target, targetOffset = 0 ) {\n\n\tconst itemSize = target.itemSize;\n\tif ( src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor ) {\n\n\t\t// use the component getters and setters if the array data cannot\n\t\t// be copied directly\n\t\tconst vertexCount = src.count;\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\ttarget.setComponent( i + targetOffset, c, src.getComponent( i, c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// faster copy approach using typed array set function\n\t\ttarget.array.set( src.array, targetOffset * itemSize );\n\n\t}\n\n\ttarget.needsUpdate = true;\n\n}\n\nclass BatchedMesh extends (/* unused pure expression or super */ null && (Mesh)) {\n\n\tget maxGeometryCount() {\n\n\t\treturn this._maxGeometryCount;\n\n\t}\n\n\tconstructor( maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material ) {\n\n\t\tsuper( new BufferGeometry(), material );\n\n\t\tthis.isBatchedMesh = true;\n\t\tthis.perObjectFrustumCulled = true;\n\t\tthis.sortObjects = true;\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\tthis.customSort = null;\n\n\t\tthis._drawRanges = [];\n\t\tthis._reservedRanges = [];\n\n\t\tthis._visibility = [];\n\t\tthis._active = [];\n\t\tthis._bounds = [];\n\n\t\tthis._maxGeometryCount = maxGeometryCount;\n\t\tthis._maxVertexCount = maxVertexCount;\n\t\tthis._maxIndexCount = maxIndexCount;\n\n\t\tthis._geometryInitialized = false;\n\t\tthis._geometryCount = 0;\n\t\tthis._multiDrawCounts = new Int32Array( maxGeometryCount );\n\t\tthis._multiDrawStarts = new Int32Array( maxGeometryCount );\n\t\tthis._multiDrawCount = 0;\n\t\tthis._multiDrawInstances = null;\n\t\tthis._visibilityChanged = true;\n\n\t\t// Local matrix per geometry by using data texture\n\t\tthis._matricesTexture = null;\n\n\t\tthis._initMatricesTexture();\n\n\t\t// Local color per geometry by using data texture\n\t\tthis._colorsTexture = null;\n\n\t}\n\n\t_initMatricesTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this._maxGeometryCount * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst matricesArray = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tconst matricesTexture = new DataTexture( matricesArray, size, size, RGBAFormat, FloatType );\n\n\t\tthis._matricesTexture = matricesTexture;\n\n\t}\n\n\t_initColorsTexture() {\n\n\t\tlet size = Math.sqrt( this._maxGeometryCount );\n\t\tsize = Math.ceil( size );\n\n\t\t// 4 floats per RGBA pixel initialized to white\n\t\tconst colorsArray = new Float32Array( size * size * 4 ).fill( 1 );\n\t\tconst colorsTexture = new DataTexture( colorsArray, size, size, RGBAFormat, FloatType );\n\t\tcolorsTexture.colorSpace = ColorManagement.workingColorSpace;\n\n\t\tthis._colorsTexture = colorsTexture;\n\n\t}\n\n\t_initializeGeometry( reference ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst maxVertexCount = this._maxVertexCount;\n\t\tconst maxGeometryCount = this._maxGeometryCount;\n\t\tconst maxIndexCount = this._maxIndexCount;\n\t\tif ( this._geometryInitialized === false ) {\n\n\t\t\tfor ( const attributeName in reference.attributes ) {\n\n\t\t\t\tconst srcAttribute = reference.getAttribute( attributeName );\n\t\t\t\tconst { array, itemSize, normalized } = srcAttribute;\n\n\t\t\t\tconst dstArray = new array.constructor( maxVertexCount * itemSize );\n\t\t\t\tconst dstAttribute = new BufferAttribute( dstArray, itemSize, normalized );\n\n\t\t\t\tgeometry.setAttribute( attributeName, dstAttribute );\n\n\t\t\t}\n\n\t\t\tif ( reference.getIndex() !== null ) {\n\n\t\t\t\tconst indexArray = maxVertexCount > 65536\n\t\t\t\t\t? new Uint32Array( maxIndexCount )\n\t\t\t\t\t: new Uint16Array( maxIndexCount );\n\n\t\t\t\tgeometry.setIndex( new BufferAttribute( indexArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tconst idArray = maxGeometryCount > 65536\n\t\t\t\t? new Uint32Array( maxVertexCount )\n\t\t\t\t: new Uint16Array( maxVertexCount );\n\t\t\tgeometry.setAttribute( ID_ATTR_NAME, new BufferAttribute( idArray, 1 ) );\n\n\t\t\tthis._geometryInitialized = true;\n\n\t\t}\n\n\t}\n\n\t// Make sure the geometry is compatible with the existing combined geometry attributes\n\t_validateGeometry( geometry ) {\n\n\t\t// check that the geometry doesn't have a version of our reserved id attribute\n\t\tif ( geometry.getAttribute( ID_ATTR_NAME ) ) {\n\n\t\t\tthrow new Error( `BatchedMesh: Geometry cannot use attribute \"${ ID_ATTR_NAME }\"` );\n\n\t\t}\n\n\t\t// check to ensure the geometries are using consistent attributes and indices\n\t\tconst batchGeometry = this.geometry;\n\t\tif ( Boolean( geometry.getIndex() ) !== Boolean( batchGeometry.getIndex() ) ) {\n\n\t\t\tthrow new Error( 'BatchedMesh: All geometries must consistently have \"index\".' );\n\n\t\t}\n\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\tif ( attributeName === ID_ATTR_NAME ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! geometry.hasAttribute( attributeName ) ) {\n\n\t\t\t\tthrow new Error( `BatchedMesh: Added geometry missing \"${ attributeName }\". All geometries must have consistent attributes.` );\n\n\t\t\t}\n\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tif ( srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized ) {\n\n\t\t\t\tthrow new Error( 'BatchedMesh: All attributes must have a consistent itemSize and normalized value.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetCustomSort( func ) {\n\n\t\tthis.customSort = func;\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst geometryCount = this._geometryCount;\n\t\tconst boundingBox = this.boundingBox;\n\t\tconst active = this._active;\n\n\t\tboundingBox.makeEmpty();\n\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\tif ( active[ i ] === false ) continue;\n\n\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\tthis.getBoundingBoxAt( i, _box$1 ).applyMatrix4( _matrix$1 );\n\t\t\tboundingBox.union( _box$1 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst geometryCount = this._geometryCount;\n\t\tconst boundingSphere = this.boundingSphere;\n\t\tconst active = this._active;\n\n\t\tboundingSphere.makeEmpty();\n\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\tif ( active[ i ] === false ) continue;\n\n\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\tthis.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );\n\t\t\tboundingSphere.union( _sphere$2 );\n\n\t\t}\n\n\t}\n\n\taddGeometry( geometry, vertexCount = - 1, indexCount = - 1 ) {\n\n\t\tthis._initializeGeometry( geometry );\n\n\t\tthis._validateGeometry( geometry );\n\n\t\t// ensure we're not over geometry\n\t\tif ( this._geometryCount >= this._maxGeometryCount ) {\n\n\t\t\tthrow new Error( 'BatchedMesh: Maximum geometry count reached.' );\n\n\t\t}\n\n\t\t// get the necessary range fo the geometry\n\t\tconst reservedRange = {\n\t\t\tvertexStart: - 1,\n\t\t\tvertexCount: - 1,\n\t\t\tindexStart: - 1,\n\t\t\tindexCount: - 1,\n\t\t};\n\n\t\tlet lastRange = null;\n\t\tconst reservedRanges = this._reservedRanges;\n\t\tconst drawRanges = this._drawRanges;\n\t\tconst bounds = this._bounds;\n\t\tif ( this._geometryCount !== 0 ) {\n\n\t\t\tlastRange = reservedRanges[ reservedRanges.length - 1 ];\n\n\t\t}\n\n\t\tif ( vertexCount === - 1 ) {\n\n\t\t\treservedRange.vertexCount = geometry.getAttribute( 'position' ).count;\n\n\t\t} else {\n\n\t\t\treservedRange.vertexCount = vertexCount;\n\n\t\t}\n\n\t\tif ( lastRange === null ) {\n\n\t\t\treservedRange.vertexStart = 0;\n\n\t\t} else {\n\n\t\t\treservedRange.vertexStart = lastRange.vertexStart + lastRange.vertexCount;\n\n\t\t}\n\n\t\tconst index = geometry.getIndex();\n\t\tconst hasIndex = index !== null;\n\t\tif ( hasIndex ) {\n\n\t\t\tif ( indexCount\t=== - 1 ) {\n\n\t\t\t\treservedRange.indexCount = index.count;\n\n\t\t\t} else {\n\n\t\t\t\treservedRange.indexCount = indexCount;\n\n\t\t\t}\n\n\t\t\tif ( lastRange === null ) {\n\n\t\t\t\treservedRange.indexStart = 0;\n\n\t\t\t} else {\n\n\t\t\t\treservedRange.indexStart = lastRange.indexStart + lastRange.indexCount;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (\n\t\t\treservedRange.indexStart !== - 1 &&\n\t\t\treservedRange.indexStart + reservedRange.indexCount > this._maxIndexCount ||\n\t\t\treservedRange.vertexStart + reservedRange.vertexCount > this._maxVertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'BatchedMesh: Reserved space request exceeds the maximum buffer size.' );\n\n\t\t}\n\n\t\tconst visibility = this._visibility;\n\t\tconst active = this._active;\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst matricesArray = this._matricesTexture.image.data;\n\t\tconst colorsTexture = this._colorsTexture;\n\n\t\t// push new visibility states\n\t\tvisibility.push( true );\n\t\tactive.push( true );\n\n\t\t// update id\n\t\tconst geometryId = this._geometryCount;\n\t\tthis._geometryCount ++;\n\n\t\t// initialize matrix information\n\t\t_identityMatrix.toArray( matricesArray, geometryId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\t// initialize the color to white\n\t\tif ( colorsTexture !== null ) {\n\n\t\t\t_whiteColor.toArray( colorsTexture.image.data, geometryId * 4 );\n\t\t\tcolorsTexture.needsUpdate = true;\n\n\t\t}\n\n\t\t// add the reserved range and draw range objects\n\t\treservedRanges.push( reservedRange );\n\t\tdrawRanges.push( {\n\t\t\tstart: hasIndex ? reservedRange.indexStart : reservedRange.vertexStart,\n\t\t\tcount: - 1\n\t\t} );\n\t\tbounds.push( {\n\t\t\tboxInitialized: false,\n\t\t\tbox: new Box3(),\n\n\t\t\tsphereInitialized: false,\n\t\t\tsphere: new Sphere()\n\t\t} );\n\n\t\t// set the id for the geometry\n\t\tconst idAttribute = this.geometry.getAttribute( ID_ATTR_NAME );\n\t\tfor ( let i = 0; i < reservedRange.vertexCount; i ++ ) {\n\n\t\t\tidAttribute.setX( reservedRange.vertexStart + i, geometryId );\n\n\t\t}\n\n\t\tidAttribute.needsUpdate = true;\n\n\t\t// update the geometry\n\t\tthis.setGeometryAt( geometryId, geometry );\n\n\t\treturn geometryId;\n\n\t}\n\n\tsetGeometryAt( id, geometry ) {\n\n\t\tif ( id >= this._geometryCount ) {\n\n\t\t\tthrow new Error( 'BatchedMesh: Maximum geometry count reached.' );\n\n\t\t}\n\n\t\tthis._validateGeometry( geometry );\n\n\t\tconst batchGeometry = this.geometry;\n\t\tconst hasIndex = batchGeometry.getIndex() !== null;\n\t\tconst dstIndex = batchGeometry.getIndex();\n\t\tconst srcIndex = geometry.getIndex();\n\t\tconst reservedRange = this._reservedRanges[ id ];\n\t\tif (\n\t\t\thasIndex &&\n\t\t\tsrcIndex.count > reservedRange.indexCount ||\n\t\t\tgeometry.attributes.position.count > reservedRange.vertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'BatchedMesh: Reserved space not large enough for provided geometry.' );\n\n\t\t}\n\n\t\t// copy geometry over\n\t\tconst vertexStart = reservedRange.vertexStart;\n\t\tconst vertexCount = reservedRange.vertexCount;\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\tif ( attributeName === ID_ATTR_NAME ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// copy attribute data\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tcopyAttributeData( srcAttribute, dstAttribute, vertexStart );\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tconst itemSize = srcAttribute.itemSize;\n\t\t\tfor ( let i = srcAttribute.count, l = vertexCount; i < l; i ++ ) {\n\n\t\t\t\tconst index = vertexStart + i;\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tdstAttribute.setComponent( index, c, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdstAttribute.needsUpdate = true;\n\t\t\tdstAttribute.addUpdateRange( vertexStart * itemSize, vertexCount * itemSize );\n\n\t\t}\n\n\t\t// copy index\n\t\tif ( hasIndex ) {\n\n\t\t\tconst indexStart = reservedRange.indexStart;\n\n\t\t\t// copy index data over\n\t\t\tfor ( let i = 0; i < srcIndex.count; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart + srcIndex.getX( i ) );\n\n\t\t\t}\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tfor ( let i = srcIndex.count, l = reservedRange.indexCount; i < l; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart );\n\n\t\t\t}\n\n\t\t\tdstIndex.needsUpdate = true;\n\t\t\tdstIndex.addUpdateRange( indexStart, reservedRange.indexCount );\n\n\t\t}\n\n\t\t// store the bounding boxes\n\t\tconst bound = this._bounds[ id ];\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tbound.box.copy( geometry.boundingBox );\n\t\t\tbound.boxInitialized = true;\n\n\t\t} else {\n\n\t\t\tbound.boxInitialized = false;\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tbound.sphere.copy( geometry.boundingSphere );\n\t\t\tbound.sphereInitialized = true;\n\n\t\t} else {\n\n\t\t\tbound.sphereInitialized = false;\n\n\t\t}\n\n\t\t// set drawRange count\n\t\tconst drawRange = this._drawRanges[ id ];\n\t\tconst posAttr = geometry.getAttribute( 'position' );\n\t\tdrawRange.count = hasIndex ? srcIndex.count : posAttr.count;\n\t\tthis._visibilityChanged = true;\n\n\t\treturn id;\n\n\t}\n\n\tdeleteGeometry( geometryId ) {\n\n\t\t// Note: User needs to call optimize() afterward to pack the data.\n\n\t\tconst active = this._active;\n\t\tif ( geometryId >= active.length || active[ geometryId ] === false ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tactive[ geometryId ] = false;\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetInstanceCountAt( id ) {\n\n\t\tif ( this._multiDrawInstances === null ) return null;\n\n\t\treturn this._multiDrawInstances[ id ];\n\n\t}\n\n\tsetInstanceCountAt( id, instanceCount ) {\n\n\t\tif ( this._multiDrawInstances === null ) {\n\n\t\t\tthis._multiDrawInstances = new Int32Array( this._maxGeometryCount ).fill( 1 );\n\n\t\t}\n\n\t\tthis._multiDrawInstances[ id ] = instanceCount;\n\n\t\treturn id;\n\n\t}\n\n\t// get bounding box and compute it if it doesn't exist\n\tgetBoundingBoxAt( id, target ) {\n\n\t\tconst active = this._active;\n\t\tif ( active[ id ] === false ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding box\n\t\tconst bound = this._bounds[ id ];\n\t\tconst box = bound.box;\n\t\tconst geometry = this.geometry;\n\t\tif ( bound.boxInitialized === false ) {\n\n\t\t\tbox.makeEmpty();\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tconst drawRange = this._drawRanges[ id ];\n\t\t\tfor ( let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\tbox.expandByPoint( _vector$5.fromBufferAttribute( position, iv ) );\n\n\t\t\t}\n\n\t\t\tbound.boxInitialized = true;\n\n\t\t}\n\n\t\ttarget.copy( box );\n\t\treturn target;\n\n\t}\n\n\t// get bounding sphere and compute it if it doesn't exist\n\tgetBoundingSphereAt( id, target ) {\n\n\t\tconst active = this._active;\n\t\tif ( active[ id ] === false ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding sphere\n\t\tconst bound = this._bounds[ id ];\n\t\tconst sphere = bound.sphere;\n\t\tconst geometry = this.geometry;\n\t\tif ( bound.sphereInitialized === false ) {\n\n\t\t\tsphere.makeEmpty();\n\n\t\t\tthis.getBoundingBoxAt( id, _box$1 );\n\t\t\t_box$1.getCenter( sphere.center );\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tconst drawRange = this._drawRanges[ id ];\n\n\t\t\tlet maxRadiusSq = 0;\n\t\t\tfor ( let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\t_vector$5.fromBufferAttribute( position, iv );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, sphere.center.distanceToSquared( _vector$5 ) );\n\n\t\t\t}\n\n\t\t\tsphere.radius = Math.sqrt( maxRadiusSq );\n\t\t\tbound.sphereInitialized = true;\n\n\t\t}\n\n\t\ttarget.copy( sphere );\n\t\treturn target;\n\n\t}\n\n\tsetMatrixAt( geometryId, matrix ) {\n\n\t\t// @TODO: Map geometryId to index of the arrays because\n\t\t//        optimize() can make geometryId mismatch the index\n\n\t\tconst active = this._active;\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst matricesArray = this._matricesTexture.image.data;\n\t\tconst geometryCount = this._geometryCount;\n\t\tif ( geometryId >= geometryCount || active[ geometryId ] === false ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tmatrix.toArray( matricesArray, geometryId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetMatrixAt( geometryId, matrix ) {\n\n\t\tconst active = this._active;\n\t\tconst matricesArray = this._matricesTexture.image.data;\n\t\tconst geometryCount = this._geometryCount;\n\t\tif ( geometryId >= geometryCount || active[ geometryId ] === false ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn matrix.fromArray( matricesArray, geometryId * 16 );\n\n\t}\n\n\tsetColorAt( geometryId, color ) {\n\n\t\tif ( this._colorsTexture === null ) {\n\n\t\t\tthis._initColorsTexture();\n\n\t\t}\n\n\t\t// @TODO: Map geometryId to index of the arrays because\n\t\t//        optimize() can make geometryId mismatch the index\n\n\t\tconst active = this._active;\n\t\tconst colorsTexture = this._colorsTexture;\n\t\tconst colorsArray = this._colorsTexture.image.data;\n\t\tconst geometryCount = this._geometryCount;\n\t\tif ( geometryId >= geometryCount || active[ geometryId ] === false ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tcolor.toArray( colorsArray, geometryId * 4 );\n\t\tcolorsTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( geometryId, color ) {\n\n\t\tconst active = this._active;\n\t\tconst colorsArray = this._colorsTexture.image.data;\n\t\tconst geometryCount = this._geometryCount;\n\t\tif ( geometryId >= geometryCount || active[ geometryId ] === false ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn color.fromArray( colorsArray, geometryId * 4 );\n\n\t}\n\n\tsetVisibleAt( geometryId, value ) {\n\n\t\tconst visibility = this._visibility;\n\t\tconst active = this._active;\n\t\tconst geometryCount = this._geometryCount;\n\n\t\t// if the geometry is out of range, not active, or visibility state\n\t\t// does not change then return early\n\t\tif (\n\t\t\tgeometryId >= geometryCount ||\n\t\t\tactive[ geometryId ] === false ||\n\t\t\tvisibility[ geometryId ] === value\n\t\t) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvisibility[ geometryId ] = value;\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetVisibleAt( geometryId ) {\n\n\t\tconst visibility = this._visibility;\n\t\tconst active = this._active;\n\t\tconst geometryCount = this._geometryCount;\n\n\t\t// return early if the geometry is out of range or not active\n\t\tif ( geometryId >= geometryCount || active[ geometryId ] === false ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn visibility[ geometryId ];\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst visibility = this._visibility;\n\t\tconst active = this._active;\n\t\tconst drawRanges = this._drawRanges;\n\t\tconst geometryCount = this._geometryCount;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst batchGeometry = this.geometry;\n\n\t\t// iterate over each geometry\n\t\t_mesh.material = this.material;\n\t\t_mesh.geometry.index = batchGeometry.index;\n\t\t_mesh.geometry.attributes = batchGeometry.attributes;\n\t\tif ( _mesh.geometry.boundingBox === null ) {\n\n\t\t\t_mesh.geometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t_mesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\tif ( ! visibility[ i ] || ! active[ i ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst drawRange = drawRanges[ i ];\n\t\t\t_mesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\n\t\t\t// ge the intersects\n\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\t\t\tthis.getBoundingBoxAt( i, _mesh.geometry.boundingBox );\n\t\t\tthis.getBoundingSphereAt( i, _mesh.geometry.boundingSphere );\n\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\t// add batch id to the intersects\n\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersect.batchId = i;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_batchIntersects.length = 0;\n\n\t\t}\n\n\t\t_mesh.material = null;\n\t\t_mesh.geometry.index = null;\n\t\t_mesh.geometry.attributes = {};\n\t\t_mesh.geometry.setDrawRange( 0, Infinity );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.geometry = source.geometry.clone();\n\t\tthis.perObjectFrustumCulled = source.perObjectFrustumCulled;\n\t\tthis.sortObjects = source.sortObjects;\n\t\tthis.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;\n\t\tthis.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;\n\n\t\tthis._drawRanges = source._drawRanges.map( range => ( { ...range } ) );\n\t\tthis._reservedRanges = source._reservedRanges.map( range => ( { ...range } ) );\n\n\t\tthis._visibility = source._visibility.slice();\n\t\tthis._active = source._active.slice();\n\t\tthis._bounds = source._bounds.map( bound => ( {\n\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\tbox: bound.box.clone(),\n\n\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\tsphere: bound.sphere.clone()\n\t\t} ) );\n\n\t\tthis._maxGeometryCount = source._maxGeometryCount;\n\t\tthis._maxVertexCount = source._maxVertexCount;\n\t\tthis._maxIndexCount = source._maxIndexCount;\n\n\t\tthis._geometryInitialized = source._geometryInitialized;\n\t\tthis._geometryCount = source._geometryCount;\n\t\tthis._multiDrawCounts = source._multiDrawCounts.slice();\n\t\tthis._multiDrawStarts = source._multiDrawStarts.slice();\n\n\t\tthis._matricesTexture = source._matricesTexture.clone();\n\t\tthis._matricesTexture.image.data = this._matricesTexture.image.slice();\n\n\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\tthis._colorsTexture = source._colorsTexture.clone();\n\t\t\tthis._colorsTexture.image.data = this._colorsTexture.image.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\t// Assuming the geometry is not shared with other meshes\n\t\tthis.geometry.dispose();\n\n\t\tthis._matricesTexture.dispose();\n\t\tthis._matricesTexture = null;\n\n\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\tthis._colorsTexture.dispose();\n\t\t\tthis._colorsTexture = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tonBeforeRender( renderer, scene, camera, geometry, material/*, _group*/ ) {\n\n\t\t// if visibility has not changed and frustum culling and object sorting is not required\n\t\t// then skip iterating over all items\n\t\tif ( ! this._visibilityChanged && ! this.perObjectFrustumCulled && ! this.sortObjects ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// the indexed version of the multi draw function requires specifying the start\n\t\t// offset in bytes.\n\t\tconst index = geometry.getIndex();\n\t\tconst bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;\n\n\t\tconst active = this._active;\n\t\tconst visibility = this._visibility;\n\t\tconst multiDrawStarts = this._multiDrawStarts;\n\t\tconst multiDrawCounts = this._multiDrawCounts;\n\t\tconst drawRanges = this._drawRanges;\n\t\tconst perObjectFrustumCulled = this.perObjectFrustumCulled;\n\n\t\t// prepare the frustum in the local frame\n\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t_projScreenMatrix$2\n\t\t\t\t.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse )\n\t\t\t\t.multiply( this.matrixWorld );\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_projScreenMatrix$2,\n\t\t\t\trenderer.coordinateSystem\n\t\t\t);\n\n\t\t}\n\n\t\tlet count = 0;\n\t\tif ( this.sortObjects ) {\n\n\t\t\t// get the camera position in the local frame\n\t\t\t_invMatrixWorld.copy( this.matrixWorld ).invert();\n\t\t\t_vector$5.setFromMatrixPosition( camera.matrixWorld ).applyMatrix4( _invMatrixWorld );\n\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).transformDirection( _invMatrixWorld );\n\n\t\t\tfor ( let i = 0, l = visibility.length; i < l; i ++ ) {\n\n\t\t\t\tif ( visibility[ i ] && active[ i ] ) {\n\n\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\t\t\tthis.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\tculled = ! _frustum.intersectsSphere( _sphere$2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\t// get the distance from camera used for sorting\n\t\t\t\t\t\tconst z = _temp.subVectors( _sphere$2.center, _vector$5 ).dot( _forward );\n\t\t\t\t\t\t_renderList.push( drawRanges[ i ], z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Sort the draw ranges and prep for rendering\n\t\t\tconst list = _renderList.list;\n\t\t\tconst customSort = this.customSort;\n\t\t\tif ( customSort === null ) {\n\n\t\t\t\tlist.sort( material.transparent ? sortTransparent : sortOpaque );\n\n\t\t\t} else {\n\n\t\t\t\tcustomSort.call( this, list, camera );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = list.length; i < l; i ++ ) {\n\n\t\t\t\tconst item = list[ i ];\n\t\t\t\tmultiDrawStarts[ count ] = item.start * bytesPerElement;\n\t\t\t\tmultiDrawCounts[ count ] = item.count;\n\t\t\t\tcount ++;\n\n\t\t\t}\n\n\t\t\t_renderList.reset();\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = visibility.length; i < l; i ++ ) {\n\n\t\t\t\tif ( visibility[ i ] && active[ i ] ) {\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\t\t\t\tthis.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );\n\t\t\t\t\t\tculled = ! _frustum.intersectsSphere( _sphere$2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\tconst range = drawRanges[ i ];\n\t\t\t\t\t\tmultiDrawStarts[ count ] = range.start * bytesPerElement;\n\t\t\t\t\t\tmultiDrawCounts[ count ] = range.count;\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._multiDrawCount = count;\n\t\tthis._visibilityChanged = false;\n\n\t}\n\n\tonBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {\n\n\t\tthis.onBeforeRender( renderer, null, shadowCamera, geometry, depthMaterial );\n\n\t}\n\n}\n\nclass LineBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineBasicMaterial = true;\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vStart = /*@__PURE__*/ new Vector3();\nconst _vEnd = /*@__PURE__*/ new Vector3();\n\nconst _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _ray$1 = /*@__PURE__*/ new Ray();\nconst _sphere$1 = /*@__PURE__*/ new Sphere();\n\nconst _intersectPointOnRay = /*@__PURE__*/ new Vector3();\nconst _intersectPointOnSegment = /*@__PURE__*/ new Vector3();\n\nclass Line extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isLine = true;\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t_vStart.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t_vEnd.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i ] += _vStart.distanceTo( _vEnd );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$1.copy( geometry.boundingSphere );\n\t\t_sphere$1.applyMatrix4( matrixWorld );\n\t\t_sphere$1.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix$1.copy( matrixWorld ).invert();\n\t\t_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst a = index.getX( end - 1 );\n\t\t\t\tconst b = index.getX( start );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1 );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection( object, raycaster, ray, thresholdSq, a, b ) {\n\n\tconst positionAttribute = object.geometry.attributes.position;\n\n\t_vStart.fromBufferAttribute( positionAttribute, a );\n\t_vEnd.fromBufferAttribute( positionAttribute, b );\n\n\tconst distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );\n\n\tif ( distSq > thresholdSq ) return;\n\n\t_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t// point: raycaster.ray.at( distance ),\n\t\tpoint: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),\n\t\tindex: a,\n\t\tface: null,\n\t\tfaceIndex: null,\n\t\tobject: object\n\n\t};\n\n}\n\nconst _start = /*@__PURE__*/ new Vector3();\nconst _end = /*@__PURE__*/ new Vector3();\n\nclass LineSegments extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments = true;\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [];\n\n\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t_start.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t_end.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineLoop extends (/* unused pure expression or super */ null && (Line)) {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineLoop = true;\n\n\t\tthis.type = 'LineLoop';\n\n\t}\n\n}\n\nclass PointsMaterial extends (/* unused pure expression or super */ null && (Material)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isPointsMaterial = true;\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _position$2 = /*@__PURE__*/ new Vector3();\n\nclass Points extends (/* unused pure expression or super */ null && (Object3D)) {\n\n\tconstructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isPoints = true;\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\n\n\t\t\t\tconst a = index.getX( i );\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\ttestPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\ttestPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nclass VideoTexture extends (/* unused pure expression or super */ null && (Texture)) {\n\n\tconstructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isVideoTexture = true;\n\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tconst scope = this;\n\n\t\tfunction updateVideo() {\n\n\t\t\tscope.needsUpdate = true;\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t\tif ( 'requestVideoFrameCallback' in video ) {\n\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.image ).copy( this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst video = this.image;\n\t\tconst hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n\t\tif ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass FramebufferTexture extends (/* unused pure expression or super */ null && (Texture)) {\n\n\tconstructor( width, height ) {\n\n\t\tsuper( { width, height } );\n\n\t\tthis.isFramebufferTexture = true;\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nclass CompressedTexture extends (/* unused pure expression or super */ null && (Texture)) {\n\n\tconstructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCompressedTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n}\n\nclass CompressedArrayTexture extends (/* unused pure expression or super */ null && (CompressedTexture)) {\n\n\tconstructor( mipmaps, width, height, depth, format, type ) {\n\n\t\tsuper( mipmaps, width, height, format, type );\n\n\t\tthis.isCompressedArrayTexture = true;\n\t\tthis.image.depth = depth;\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.layerUpdates = new Set();\n\n\t}\n\n\taddLayerUpdates( layerIndex ) {\n\n\t\tthis.layerUpdates.add( layerIndex );\n\n\t}\n\n\tclearLayerUpdates() {\n\n\t\tthis.layerUpdates.clear();\n\n\t}\n\n}\n\nclass CompressedCubeTexture extends (/* unused pure expression or super */ null && (CompressedTexture)) {\n\n\tconstructor( images, format, type ) {\n\n\t\tsuper( undefined, images[ 0 ].width, images[ 0 ].height, format, type, CubeReflectionMapping );\n\n\t\tthis.isCompressedCubeTexture = true;\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.image = images;\n\n\t}\n\n}\n\nclass CanvasTexture extends Texture {\n\n\tconstructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isCanvasTexture = true;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n\n\tconstructor() {\n\n\t\tthis.type = 'Curve';\n\n\t\tthis.arcLengthDivisions = 200;\n\n\t}\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t}\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t}\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get total curve arc length\n\n\tgetLength() {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t}\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths( divisions = this.arcLengthDivisions ) {\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t}\n\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t}\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t}\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t}\n\n\tcomputeFrenetFrames( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass EllipseCurve extends Curve {\n\n\tconstructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.isEllipseCurve = true;\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst twoPi = Math.PI * 2;\n\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tconst samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\tlet x = this.aX + this.xRadius * Math.cos( angle );\n\t\tlet y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tconst cos = Math.cos( this.aRotation );\n\t\t\tconst sin = Math.sin( this.aRotation );\n\n\t\t\tconst tx = x - this.aX;\n\t\t\tconst ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass ArcCurve extends EllipseCurve {\n\n\tconstructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tsuper( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\tthis.isArcCurve = true;\n\n\t\tthis.type = 'ArcCurve';\n\n\t}\n\n}\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tlet c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tlet t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tlet t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nconst tmp = /*@__PURE__*/ new Vector3();\nconst px = /*@__PURE__*/ new CubicPoly();\nconst py = /*@__PURE__*/ new CubicPoly();\nconst pz = /*@__PURE__*/ new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n\n\tconstructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {\n\n\t\tsuper();\n\n\t\tthis.isCatmullRomCurve3 = true;\n\n\t\tthis.type = 'CatmullRomCurve3';\n\n\t\tthis.points = points;\n\t\tthis.closed = closed;\n\t\tthis.curveType = curveType;\n\t\tthis.tension = tension;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst l = points.length;\n\n\t\tconst p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\tlet intPoint = Math.floor( p );\n\t\tlet weight = p - intPoint;\n\n\t\tif ( this.closed ) {\n\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1;\n\n\t\t}\n\n\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\tp0 = tmp;\n\n\t\t}\n\n\t\tconst p1 = points[ intPoint % l ];\n\t\tconst p2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = tmp;\n\n\t\t}\n\n\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\tlet dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\tlet dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\tlet dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t// safety check for repeated points\n\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t\t}\n\n\t\tpoint.set(\n\t\t\tpx.calc( weight ),\n\t\t\tpy.calc( weight ),\n\t\t\tpz.calc( weight )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\tthis.closed = source.closed;\n\t\tthis.curveType = source.curveType;\n\t\tthis.tension = source.tension;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\tdata.closed = this.closed;\n\t\tdata.curveType = this.curveType;\n\t\tdata.tension = this.tension;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t\t}\n\n\t\tthis.closed = json.closed;\n\t\tthis.curveType = json.curveType;\n\t\tthis.tension = json.tension;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Bezier Curves formulas obtained from\n * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tconst v0 = ( p2 - p0 ) * 0.5;\n\tconst v1 = ( p3 - p1 ) * 0.5;\n\tconst t2 = t * t;\n\tconst t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tconst k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nclass CubicBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve = true;\n\n\t\tthis.type = 'CubicBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass CubicBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve3 = true;\n\n\t\tthis.type = 'CubicBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve extends Curve {\n\n\tconstructor( v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve = true;\n\n\t\tthis.type = 'LineCurve';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector2() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve3 extends Curve {\n\n\tconstructor( v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve3 = true;\n\n\t\tthis.type = 'LineCurve3';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve = true;\n\n\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve3 = true;\n\n\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SplineCurve extends Curve {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isSplineCurve = true;\n\n\t\tthis.type = 'SplineCurve';\n\n\t\tthis.points = points;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst p = ( points.length - 1 ) * t;\n\n\t\tconst intPoint = Math.floor( p );\n\t\tconst weight = p - intPoint;\n\n\t\tconst p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tconst p1 = points[ intPoint ];\n\t\tconst p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tconst p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tpoint.set(\n\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nvar Curves = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tArcCurve: ArcCurve,\n\tCatmullRomCurve3: CatmullRomCurve3,\n\tCubicBezierCurve: CubicBezierCurve,\n\tCubicBezierCurve3: CubicBezierCurve3,\n\tEllipseCurve: EllipseCurve,\n\tLineCurve: LineCurve,\n\tLineCurve3: LineCurve3,\n\tQuadraticBezierCurve: QuadraticBezierCurve,\n\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\tSplineCurve: SplineCurve\n});\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tconst lineType = ( startPoint.isVector2 === true ) ? 'LineCurve' : 'LineCurve3';\n\t\t\tthis.curves.push( new Curves[ lineType ]( endPoint, startPoint ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u, optionalTarget );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength() {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths() {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = curve.isEllipseCurve ? divisions * 2\n\t\t\t\t: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1\n\t\t\t\t\t: curve.isSplineCurve ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Path extends CurvePath {\n\n\tconstructor( points ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Path';\n\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( let i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tconst curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tconst curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tconst curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts /*Array of Vector*/ ) {\n\n\t\tconst npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tconst curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t}\n\n\tarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tabsarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t}\n\n\tabsellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tconst firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tconst lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LatheGeometry extends BufferGeometry {\n\n\tconstructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\t\tconst initNormals = [];\n\t\tconst normals = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tconst normal = new Vector3();\n\t\tconst curNormal = new Vector3();\n\t\tconst prevNormal = new Vector3();\n\t\tlet dx = 0;\n\t\tlet dy = 0;\n\n\t\t// pre-compute normals for initial \"meridian\"\n\n\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\tswitch ( j ) {\n\n\t\t\t\tcase 0:\t\t\t\t// special handling for 1st vertex on path\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tprevNormal.copy( normal );\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ( points.length - 1 ):\t// special handling for last Vertex on path\n\n\t\t\t\t\tinitNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t\t\t// default handling for all vertices in between\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tcurNormal.copy( normal );\n\n\t\t\t\t\tnormal.x += prevNormal.x;\n\t\t\t\t\tnormal.y += prevNormal.y;\n\t\t\t\t\tnormal.z += prevNormal.z;\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tprevNormal.copy( curNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices, uvs and normals\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// normal\n\n\t\t\t\tconst x = initNormals[ 3 * j + 0 ] * sin;\n\t\t\t\tconst y = initNormals[ 3 * j + 1 ];\n\t\t\t\tconst z = initNormals[ 3 * j + 0 ] * cos;\n\n\t\t\t\tnormals.push( x, y, z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( c, d, b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\n\n\t}\n\n}\n\nclass CapsuleGeometry extends LatheGeometry {\n\n\tconstructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {\n\n\t\tconst path = new Path();\n\t\tpath.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );\n\t\tpath.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );\n\n\t\tsuper( path.getPoints( capSegments ), radialSegments );\n\n\t\tthis.type = 'CapsuleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tlength: length,\n\t\t\tcapSegments: capSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );\n\n\t}\n\n}\n\nclass CircleGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tsegments = Math.max( 3, segments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass CylinderGeometry extends BufferGeometry {\n\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// update group counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ConeGeometry extends CylinderGeometry {\n\n\tconstructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass PolyhedronGeometry extends BufferGeometry {\n\n\tconstructor( vertices = [], indices = [], radius = 1, detail = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivision with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );\n\n\t}\n\n}\n\nclass DodecahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tconst r = 1 / t;\n\n\t\tconst vertices = [\n\n\t\t\t// (1, 1, 1)\n\t\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t\t// (0, 1/, )\n\t\t\t0, - r, - t, 0, - r, t,\n\t\t\t0, r, - t, 0, r, t,\n\n\t\t\t// (1/, , 0)\n\t\t\t- r, - t, 0, - r, t, 0,\n\t\t\tr, - t, 0, r, t, 0,\n\n\t\t\t// (, 0, 1/)\n\t\t\t- t, 0, - r, t, 0, - r,\n\t\t\t- t, 0, r, t, 0, r\n\t\t];\n\n\t\tconst indices = [\n\t\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new DodecahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1$1 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\nconst _triangle = /*@__PURE__*/ new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null, thresholdAngle = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry,\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\t\tconst thresholdDot = Math.cos( DEG2RAD * thresholdAngle );\n\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\t\tconst indexArr = [ 0, 0, 0 ];\n\t\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\t\tconst hashes = new Array( 3 );\n\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\t\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst { a, b, c } = _triangle;\n\t\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t\t// create hashes for the edge from the vertices\n\t\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t\t// skip degenerate triangles\n\t\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over every edge\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\t\tfor ( const key in edgeData ) {\n\n\t\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t\t_v1$1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\t\tvertices.push( _v1$1.x, _v1$1.y, _v1$1.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Shape extends Path {\n\n\tconstructor( points ) {\n\n\t\tsuper( points );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.type = 'Shape';\n\n\t\tthis.holes = [];\n\n\t}\n\n\tgetPointsHoles( divisions ) {\n\n\t\tconst holesPts = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t}\n\n\t// get points of shape and holes (keypoints based on segments parameter)\n\n\textractPoints( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = source.holes[ i ];\n\n\t\t\tthis.holes.push( hole.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.holes = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = this.holes[ i ];\n\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.uuid = json.uuid;\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = json.holes[ i ];\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.4)\n */\n\nconst Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim = 2 ) {\n\n\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\tconst outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;\n\t\tlet outerNode = linkedList( data, 0, outerLen, dim, true );\n\t\tconst triangles = [];\n\n\t\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\n\n\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( let i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 32767 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tlet i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tlet p = start,\n\t\tagain;\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tlet stop = ear,\n\t\tprev, next;\n\n\t// iterate through ears, slicing them one by one\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim | 0 );\n\t\t\ttriangles.push( ear.i / dim | 0 );\n\t\t\ttriangles.push( next.i / dim | 0 );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertex leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( filterPoints( ear ), triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar( ear ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\tlet p = c.next;\n\twhile ( p !== a ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\t// z-order range for the current triangle bbox;\n\tconst minZ = zOrder( x0, y0, minX, minY, invSize ),\n\t\tmaxZ = zOrder( x1, y1, minX, minY, invSize );\n\n\tlet p = ear.prevZ,\n\t\tn = ear.nextZ;\n\n\t// look for points inside the triangle in both directions\n\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\t// look for remaining points in decreasing z-order\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t}\n\n\t// look for remaining points in increasing z-order\n\twhile ( n && n.z <= maxZ ) {\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tconst a = p.prev,\n\t\t\tb = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim | 0 );\n\t\t\ttriangles.push( p.i / dim | 0 );\n\t\t\ttriangles.push( b.i / dim | 0 );\n\n\t\t\t// remove two nodes involved\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn filterPoints( p );\n\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\tlet a = start;\n\tdo {\n\n\t\tlet b = a.next.next;\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\tlet c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tconst queue = [];\n\tlet i, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\touterNode = eliminateHole( queue[ i ], outerNode );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole( hole, outerNode ) {\n\n\tconst bridge = findHoleBridge( hole, outerNode );\n\tif ( ! bridge ) {\n\n\t\treturn outerNode;\n\n\t}\n\n\tconst bridgeReverse = splitPolygon( bridge, hole );\n\n\t// filter collinear points around the cuts\n\tfilterPoints( bridgeReverse, bridgeReverse.next );\n\treturn filterPoints( bridge, bridge.next );\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge( hole, outerNode ) {\n\n\tlet p = outerNode,\n\t\tqx = - Infinity,\n\t\tm;\n\n\tconst hx = hole.x, hy = hole.y;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tconst x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\tif ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tconst stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y;\n\tlet tanMin = Infinity, tan;\n\n\tp = m;\n\n\tdo {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== stop );\n\n\treturn m;\n\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector( m, p ) {\n\n\treturn area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;\n\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tif ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked( list ) {\n\n\tlet i, p, q, e, tail, numMerges, pSize, qSize,\n\t\tinSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\tx = ( x - minX ) * invSize | 0;\n\ty = ( y - minY ) * invSize | 0;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost( start ) {\n\n\tlet p = start,\n\t\tleftmost = start;\n\tdo {\n\n\t\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&\n           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&\n           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges\n           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible\n            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors\n            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case\n\n}\n\n// signed area of a triangle\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tconst o1 = sign( area( p1, q1, p2 ) );\n\tconst o2 = sign( area( p1, q1, q2 ) );\n\tconst o3 = sign( area( p2, q2, p1 ) );\n\tconst o4 = sign( area( p2, q2, q1 ) );\n\n\tif ( o1 !== o2 && o3 !== o4 ) return true; // general case\n\n\tif ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\tif ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\tif ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\tif ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\treturn false;\n\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment( p, q, r ) {\n\n\treturn q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );\n\n}\n\nfunction sign( num ) {\n\n\treturn num > 0 ? 1 : num < 0 ? - 1 : 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon( a, b ) {\n\n\tlet p = a;\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\tintersects( p, p.next, a, b ) ) return true;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside( a, b ) {\n\n\tlet p = a,\n\t\tinside = false;\n\tconst px = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\n\t\t\tinside = ! inside;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon( a, b ) {\n\n\tconst a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode( i, x, y, last ) {\n\n\tconst p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertex index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertex nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = 0;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tlet sum = 0;\n\tfor ( let i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\nclass ShapeUtils {\n\n\t// calculate area of the contour polygon\n\n\tstatic area( contour ) {\n\n\t\tconst n = contour.length;\n\t\tlet a = 0.0;\n\n\t\tfor ( let p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t}\n\n\tstatic isClockWise( pts ) {\n\n\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t}\n\n\tstatic triangulateShape( contour, holes ) {\n\n\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\tconst holeIndices = []; // array of hole indices\n\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\tremoveDupEndPts( contour );\n\t\taddContour( vertices, contour );\n\n\t\t//\n\n\t\tlet holeIndex = contour.length;\n\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfor ( let i = 0; i < holes.length; i ++ ) {\n\n\t\t\tholeIndices.push( holeIndex );\n\t\t\tholeIndex += holes[ i ].length;\n\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t}\n\n\t\treturn faces;\n\n\t}\n\n}\n\nfunction removeDupEndPts( points ) {\n\n\tconst l = points.length;\n\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\tpoints.pop();\n\n\t}\n\n}\n\nfunction addContour( vertices, contour ) {\n\n\tfor ( let i = 0; i < contour.length; i ++ ) {\n\n\t\tvertices.push( contour[ i ].x );\n\t\tvertices.push( contour[ i ].y );\n\n\t}\n\n}\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\n\nclass ExtrudeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tconst depth = options.depth !== undefined ? options.depth : 1;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\n\n\t\t\t\treturn pt.clone().addScaledVector( vec, size );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length, flen = faces.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON$1( shapes, options, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\tconst extrudePath = data.options.extrudePath;\n\n\t\tif ( extrudePath !== undefined ) {\n\n\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t}\n\n\t\treturn new ExtrudeGeometry( geometryShapes, data.options );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON$1( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tdata.options = Object.assign( {}, options );\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\nclass IcosahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tconst vertices = [\n\t\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t\t0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t\tt, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t\t1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t\t3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t\t4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new IcosahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass OctahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t\t1, 3, 4,\t1, 4, 2\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new OctahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass RingGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthetaSegments = Math.max( 3, thetaSegments );\n\t\tphiSegments = Math.max( 1, phiSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ShapeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet groupStart = 0;\n\t\tlet groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\tconst points = shape.extractPoints( curveSegments );\n\n\t\t\tlet shapeVertices = points.shape;\n\t\t\tconst shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\treturn new ShapeGeometry( geometryShapes, data.curveSegments );\n\n\t}\n\n}\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\nclass SphereGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy === 0 && thetaStart === 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy === heightSegments && thetaEnd === Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass TetrahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TetrahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass TorusGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\ttubularSegments = Math.floor( tubularSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst center = new Vector3();\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tconst b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tconst c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tconst d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );\n\n\t}\n\n}\n\nclass TorusKnotGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\ttubularSegments = Math.floor( tubularSegments );\n\t\tradialSegments = Math.floor( radialSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segment\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );\n\n\t}\n\n}\n\nclass TubeGeometry extends BufferGeometry {\n\n\tconstructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\treturn new TubeGeometry(\n\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\tdata.tubularSegments,\n\t\t\tdata.radius,\n\t\t\tdata.radialSegments,\n\t\t\tdata.closed\n\t\t);\n\n\t}\n\n}\n\nclass WireframeGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'WireframeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\t// buffer\n\n\t\t\tconst vertices = [];\n\t\t\tconst edges = new Set();\n\n\t\t\t// helper variables\n\n\t\t\tconst start = new Vector3();\n\t\t\tconst end = new Vector3();\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// create a data structure that contains all edges without duplicates\n\n\t\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tconst group = groups[ o ];\n\n\t\t\t\t\tconst groupStart = group.start;\n\t\t\t\t\tconst groupCount = group.count;\n\n\t\t\t\t\tfor ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index1 = indices.getX( i + j );\n\t\t\t\t\t\t\tconst index2 = indices.getX( i + ( j + 1 ) % 3 );\n\n\t\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\n\n\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction isUniqueEdge( start, end, edges ) {\n\n\tconst hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n\tconst hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n\tif ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {\n\n\t\treturn false;\n\n\t} else {\n\n\t\tedges.add( hash1 );\n\t\tedges.add( hash2 );\n\t\treturn true;\n\n\t}\n\n}\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBoxGeometry: BoxGeometry,\n\tCapsuleGeometry: CapsuleGeometry,\n\tCircleGeometry: CircleGeometry,\n\tConeGeometry: ConeGeometry,\n\tCylinderGeometry: CylinderGeometry,\n\tDodecahedronGeometry: DodecahedronGeometry,\n\tEdgesGeometry: EdgesGeometry,\n\tExtrudeGeometry: ExtrudeGeometry,\n\tIcosahedronGeometry: IcosahedronGeometry,\n\tLatheGeometry: LatheGeometry,\n\tOctahedronGeometry: OctahedronGeometry,\n\tPlaneGeometry: PlaneGeometry,\n\tPolyhedronGeometry: PolyhedronGeometry,\n\tRingGeometry: RingGeometry,\n\tShapeGeometry: ShapeGeometry,\n\tSphereGeometry: SphereGeometry,\n\tTetrahedronGeometry: TetrahedronGeometry,\n\tTorusGeometry: TorusGeometry,\n\tTorusKnotGeometry: TorusKnotGeometry,\n\tTubeGeometry: TubeGeometry,\n\tWireframeGeometry: WireframeGeometry\n});\n\nclass ShadowMaterial extends (/* unused pure expression or super */ null && (Material)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShadowMaterial = true;\n\n\t\tthis.type = 'ShadowMaterial';\n\n\t\tthis.color = new Color( 0x000000 );\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass RawShaderMaterial extends (/* unused pure expression or super */ null && (ShaderMaterial)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.isRawShaderMaterial = true;\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n}\n\nclass MeshStandardMaterial extends (/* unused pure expression or super */ null && (Material)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshStandardMaterial = true;\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 1.0;\n\t\tthis.metalness = 0.0;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhysicalMaterial extends (/* unused pure expression or super */ null && (MeshStandardMaterial)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhysicalMaterial = true;\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.anisotropyRotation = 0;\n\t\tthis.anisotropyMap = null;\n\n\t\tthis.clearcoatMap = null;\n\t\tthis.clearcoatRoughness = 0.0;\n\t\tthis.clearcoatRoughnessMap = null;\n\t\tthis.clearcoatNormalScale = new Vector2( 1, 1 );\n\t\tthis.clearcoatNormalMap = null;\n\n\t\tthis.ior = 1.5;\n\n\t\tObject.defineProperty( this, 'reflectivity', {\n\t\t\tget: function () {\n\n\t\t\t\treturn ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );\n\n\t\t\t},\n\t\t\tset: function ( reflectivity ) {\n\n\t\t\t\tthis.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );\n\n\t\t\t}\n\t\t} );\n\n\t\tthis.iridescenceMap = null;\n\t\tthis.iridescenceIOR = 1.3;\n\t\tthis.iridescenceThicknessRange = [ 100, 400 ];\n\t\tthis.iridescenceThicknessMap = null;\n\n\t\tthis.sheenColor = new Color( 0x000000 );\n\t\tthis.sheenColorMap = null;\n\t\tthis.sheenRoughness = 1.0;\n\t\tthis.sheenRoughnessMap = null;\n\n\t\tthis.transmissionMap = null;\n\n\t\tthis.thickness = 0;\n\t\tthis.thicknessMap = null;\n\t\tthis.attenuationDistance = Infinity;\n\t\tthis.attenuationColor = new Color( 1, 1, 1 );\n\n\t\tthis.specularIntensity = 1.0;\n\t\tthis.specularIntensityMap = null;\n\t\tthis.specularColor = new Color( 1, 1, 1 );\n\t\tthis.specularColorMap = null;\n\n\t\tthis._anisotropy = 0;\n\t\tthis._clearcoat = 0;\n\t\tthis._dispersion = 0;\n\t\tthis._iridescence = 0;\n\t\tthis._sheen = 0.0;\n\t\tthis._transmission = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget anisotropy() {\n\n\t\treturn this._anisotropy;\n\n\t}\n\n\tset anisotropy( value ) {\n\n\t\tif ( this._anisotropy > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._anisotropy = value;\n\n\t}\n\n\tget clearcoat() {\n\n\t\treturn this._clearcoat;\n\n\t}\n\n\tset clearcoat( value ) {\n\n\t\tif ( this._clearcoat > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._clearcoat = value;\n\n\t}\n\n\tget iridescence() {\n\n\t\treturn this._iridescence;\n\n\t}\n\n\tset iridescence( value ) {\n\n\t\tif ( this._iridescence > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._iridescence = value;\n\n\t}\n\n\tget dispersion() {\n\n\t\treturn this._dispersion;\n\n\t}\n\n\tset dispersion( value ) {\n\n\t\tif ( this._dispersion > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._dispersion = value;\n\n\t}\n\n\tget sheen() {\n\n\t\treturn this._sheen;\n\n\t}\n\n\tset sheen( value ) {\n\n\t\tif ( this._sheen > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._sheen = value;\n\n\t}\n\n\tget transmission() {\n\n\t\treturn this._transmission;\n\n\t}\n\n\tset transmission( value ) {\n\n\t\tif ( this._transmission > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._transmission = value;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.anisotropy = source.anisotropy;\n\t\tthis.anisotropyRotation = source.anisotropyRotation;\n\t\tthis.anisotropyMap = source.anisotropyMap;\n\n\t\tthis.clearcoat = source.clearcoat;\n\t\tthis.clearcoatMap = source.clearcoatMap;\n\t\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\t\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\t\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\t\tthis.clearcoatNormalScale.copy( source.clearcoatNormalScale );\n\n\t\tthis.dispersion = source.dispersion;\n\t\tthis.ior = source.ior;\n\n\t\tthis.iridescence = source.iridescence;\n\t\tthis.iridescenceMap = source.iridescenceMap;\n\t\tthis.iridescenceIOR = source.iridescenceIOR;\n\t\tthis.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];\n\t\tthis.iridescenceThicknessMap = source.iridescenceThicknessMap;\n\n\t\tthis.sheen = source.sheen;\n\t\tthis.sheenColor.copy( source.sheenColor );\n\t\tthis.sheenColorMap = source.sheenColorMap;\n\t\tthis.sheenRoughness = source.sheenRoughness;\n\t\tthis.sheenRoughnessMap = source.sheenRoughnessMap;\n\n\t\tthis.transmission = source.transmission;\n\t\tthis.transmissionMap = source.transmissionMap;\n\n\t\tthis.thickness = source.thickness;\n\t\tthis.thicknessMap = source.thicknessMap;\n\t\tthis.attenuationDistance = source.attenuationDistance;\n\t\tthis.attenuationColor.copy( source.attenuationColor );\n\n\t\tthis.specularIntensity = source.specularIntensity;\n\t\tthis.specularIntensityMap = source.specularIntensityMap;\n\t\tthis.specularColor.copy( source.specularColor );\n\t\tthis.specularColorMap = source.specularColorMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhongMaterial extends (/* unused pure expression or super */ null && (Material)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhongMaterial = true;\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshToonMaterial extends (/* unused pure expression or super */ null && (Material)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshToonMaterial = true;\n\n\t\tthis.defines = { 'TOON': '' };\n\n\t\tthis.type = 'MeshToonMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\t\tthis.gradientMap = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\t\tthis.gradientMap = source.gradientMap;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshNormalMaterial extends (/* unused pure expression or super */ null && (Material)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshNormalMaterial = true;\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshLambertMaterial extends (/* unused pure expression or super */ null && (Material)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshLambertMaterial = true;\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshMatcapMaterial extends (/* unused pure expression or super */ null && (Material)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshMatcapMaterial = true;\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.type = 'MeshMatcapMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.matcap = null;\n\n\t\tthis.map = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.matcap = source.matcap;\n\n\t\tthis.map = source.map;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineDashedMaterial extends (/* unused pure expression or super */ null && (LineBasicMaterial)) {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineDashedMaterial = true;\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// converts an array to a specific type\nfunction convertArray( array, type, forceClone ) {\n\n\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t! forceClone && array.constructor === type ) return array;\n\n\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\treturn new type( array ); // create typed array\n\n\t}\n\n\treturn Array.prototype.slice.call( array ); // create Array\n\n}\n\nfunction isTypedArray( object ) {\n\n\treturn ArrayBuffer.isView( object ) &&\n\t\t! ( object instanceof DataView );\n\n}\n\n// returns an array by which times and values can be sorted\nfunction getKeyframeOrder( times ) {\n\n\tfunction compareTime( i, j ) {\n\n\t\treturn times[ i ] - times[ j ];\n\n\t}\n\n\tconst n = times.length;\n\tconst result = new Array( n );\n\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\tresult.sort( compareTime );\n\n\treturn result;\n\n}\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nfunction sortedArray( values, stride, order ) {\n\n\tconst nValues = values.length;\n\tconst result = new values.constructor( nValues );\n\n\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\tconst srcOffset = order[ i ] * stride;\n\n\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n// function for parsing AOS keyframe formats\nfunction flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\tlet i = 1, key = jsonKeys[ 0 ];\n\n\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\tkey = jsonKeys[ i ++ ];\n\n\t}\n\n\tif ( key === undefined ) return; // no data\n\n\tlet value = key[ valuePropertyName ];\n\tif ( value === undefined ) return; // no data\n\n\tif ( Array.isArray( value ) ) {\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else if ( value.toArray !== undefined ) {\n\n\t\t// ...assume THREE.Math-ish\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else {\n\n\t\t// otherwise push as-is\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( value );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t}\n\n}\n\nfunction subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\tconst clip = sourceClip.clone();\n\n\tclip.name = name;\n\n\tconst tracks = [];\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tconst track = clip.tracks[ i ];\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( times.length === 0 ) continue;\n\n\t\ttrack.times = convertArray( times, track.times.constructor );\n\t\ttrack.values = convertArray( values, track.values.constructor );\n\n\t\ttracks.push( track );\n\n\t}\n\n\tclip.tracks = tracks;\n\n\t// find minimum .times value across all tracks in the trimmed clip\n\n\tlet minStartTime = Infinity;\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t}\n\n\t}\n\n\t// shift all tracks such that clip begins at t=0\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t}\n\n\tclip.resetDuration();\n\n\treturn clip;\n\n}\n\nfunction makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\tif ( fps <= 0 ) fps = 30;\n\n\tconst numTracks = referenceClip.tracks.length;\n\tconst referenceTime = referenceFrame / fps;\n\n\t// Make each track's values relative to the values at the reference frame\n\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t// Skip this track if it's non-numeric\n\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t} );\n\n\t\tif ( targetTrack === undefined ) continue;\n\n\t\tlet referenceOffset = 0;\n\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t}\n\n\t\tlet targetOffset = 0;\n\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t}\n\n\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\tlet referenceValue;\n\n\t\t// Find the value to subtract out of the track\n\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else {\n\n\t\t\t// Interpolate to the reference value\n\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\treferenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );\n\n\t\t}\n\n\t\t// Conjugate the quaternion\n\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t}\n\n\t\t// Subtract the reference value from all of the track values\n\n\t\tconst numTimes = targetTrack.times.length;\n\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart,\n\t\t\t\t\treferenceValue,\n\t\t\t\t\t0,\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\treturn targetClip;\n\n}\n\nconst AnimationUtils = {\n\tconvertArray: convertArray,\n\tisTypedArray: isTypedArray,\n\tgetKeyframeOrder: getKeyframeOrder,\n\tsortedArray: sortedArray,\n\tflattenJSON: flattenJSON,\n\tsubclip: subclip,\n\tmakeClipAdditive: makeClipAdditive\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t\tthis.settings = null;\n\t\tthis.DefaultSettings_ = {};\n\n\t}\n\n\tevaluate( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t}\n\n\tgetSettings_() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t// Template methods for derived classes:\n\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t}\n\n\tintervalChanged_( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n}\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = - 0;\n\t\tthis._offsetPrev = - 0;\n\t\tthis._weightNext = - 0;\n\t\tthis._offsetNext = - 0;\n\n\t\tthis.DefaultSettings_ = {\n\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\n\t\t};\n\n\t}\n\n\tintervalChanged_( i1, t0, t1 ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet iPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nclass LinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceding\n * the parameter.\n */\n\nclass DiscreteInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n}\n\nclass KeyframeTrack {\n\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = convertArray( times, this.TimeBufferType );\n\t\tthis.values = convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': convertArray( track.times, Array ),\n\t\t\t\t'values': convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t// move all keyframes either forwards or backwards in time\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = times.slice( from, to );\n\t\t\tthis.values = this.values.slice( from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --\x3e (0,0,1,1,0,0)\n\toptimize() {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = this.times.slice(),\n\t\t\tvalues = this.values.slice(),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = times.slice( 0, writeIndex );\n\t\t\tthis.values = values.slice( 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst times = this.times.slice();\n\t\tconst values = this.values.slice();\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {\n\n\t// No interpolation parameter because only InterpolateDiscrete is valid.\n\tconstructor( name, times, values ) {\n\n\t\tsuper( name, times, values );\n\n\t}\n\n}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tlet offset = i1 * stride;\n\n\t\tfor ( let end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\n// DefaultInterpolation is inherited;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {\n\n\t// No interpolation parameter because only InterpolateDiscrete is valid.\n\tconstructor( name, times, values ) {\n\n\t\tsuper( name, times, values );\n\n\t}\n\n}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n\nclass AnimationClip {\n\n\tconstructor( name = '', duration = - 1, tracks = [], blendMode = NormalAnimationBlendMode ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = duration;\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = getKeyframeOrder( times );\n\t\t\ttimes = sortedArray( times, 1, order );\n\t\t\tvalues = sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t// parse the animation.hierarchy format\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tflattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * fps;\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tflattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nconst Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\nclass LoadingManager {\n\n\tconstructor( onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet isLoading = false;\n\t\tlet itemsLoaded = 0;\n\t\tlet itemsTotal = 0;\n\t\tlet urlModifier = undefined;\n\t\tconst handlers = [];\n\n\t\t// Refer to #5689 for the reason why we don't set .onStart\n\t\t// in the constructor\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.resolveURL = function ( url ) {\n\n\t\t\tif ( urlModifier ) {\n\n\t\t\t\treturn urlModifier( url );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t};\n\n\t\tthis.setURLModifier = function ( transform ) {\n\n\t\t\turlModifier = transform;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.addHandler = function ( regex, loader ) {\n\n\t\t\thandlers.push( regex, loader );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.removeHandler = function ( regex ) {\n\n\t\t\tconst index = handlers.indexOf( regex );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\thandlers.splice( index, 2 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.getHandler = function ( file ) {\n\n\t\t\tfor ( let i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tconst regex = handlers[ i ];\n\t\t\t\tconst loader = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t}\n\n}\n\nconst DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();\n\nclass Loader {\n\n\tconstructor( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.crossOrigin = 'anonymous';\n\t\tthis.withCredentials = false;\n\t\tthis.path = '';\n\t\tthis.resourcePath = '';\n\t\tthis.requestHeader = {};\n\n\t}\n\n\tload( /* url, onLoad, onProgress, onError */ ) {}\n\n\tloadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.load( url, resolve, onProgress, reject );\n\n\t\t} );\n\n\t}\n\n\tparse( /* data */ ) {}\n\n\tsetCrossOrigin( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t}\n\n\tsetWithCredentials( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t}\n\n\tsetResourcePath( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n\tsetRequestHeader( requestHeader ) {\n\n\t\tthis.requestHeader = requestHeader;\n\t\treturn this;\n\n\t}\n\n}\n\nLoader.DEFAULT_MATERIAL_NAME = '__DEFAULT';\n\nconst loading = {};\n\nclass HttpError extends (/* unused pure expression or super */ null && (Error)) {\n\n\tconstructor( message, response ) {\n\n\t\tsuper( message );\n\t\tthis.response = response;\n\n\t}\n\n}\n\nclass FileLoader extends (/* unused pure expression or super */ null && (Loader)) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tsetTimeout( () => {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Initialise array for duplicate requests\n\t\tloading[ url ] = [];\n\n\t\tloading[ url ].push( {\n\t\t\tonLoad: onLoad,\n\t\t\tonProgress: onProgress,\n\t\t\tonError: onError,\n\t\t} );\n\n\t\t// create request\n\t\tconst req = new Request( url, {\n\t\t\theaders: new Headers( this.requestHeader ),\n\t\t\tcredentials: this.withCredentials ? 'include' : 'same-origin',\n\t\t\t// An abort controller could be added within a future PR\n\t\t} );\n\n\t\t// record states ( avoid data race )\n\t\tconst mimeType = this.mimeType;\n\t\tconst responseType = this.responseType;\n\n\t\t// start the fetch\n\t\tfetch( req )\n\t\t\t.then( response => {\n\n\t\t\t\tif ( response.status === 200 || response.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( response.status === 0 ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n\t\t\t\t\tif ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {\n\n\t\t\t\t\t\treturn response;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\t// Nginx needs X-File-Size check\n\t\t\t\t\t// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n\t\t\t\t\tconst contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );\n\t\t\t\t\tconst total = contentLength ? parseInt( contentLength ) : 0;\n\t\t\t\t\tconst lengthComputable = total !== 0;\n\t\t\t\t\tlet loaded = 0;\n\n\t\t\t\t\t// periodically read data into the new stream tracking while download progress\n\t\t\t\t\tconst stream = new ReadableStream( {\n\t\t\t\t\t\tstart( controller ) {\n\n\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\tfunction readData() {\n\n\t\t\t\t\t\t\t\treader.read().then( ( { done, value } ) => {\n\n\t\t\t\t\t\t\t\t\tif ( done ) {\n\n\t\t\t\t\t\t\t\t\t\tcontroller.close();\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\n\n\t\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tcontroller.enqueue( value );\n\t\t\t\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}, ( e ) => {\n\n\t\t\t\t\t\t\t\t\tcontroller.error( e );\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn new Response( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new HttpError( `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( response => {\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\n\t\t\t\t\t\treturn response.arrayBuffer();\n\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\treturn response.blob();\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\treturn response.text()\n\t\t\t\t\t\t\t.then( text => {\n\n\t\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\t\treturn parser.parseFromString( text, mimeType );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\treturn response.json();\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( mimeType === undefined ) {\n\n\t\t\t\t\t\t\treturn response.text();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// sniff encoding\n\t\t\t\t\t\t\tconst re = /charset=\"?([^;\"\\s]*)\"?/i;\n\t\t\t\t\t\t\tconst exec = re.exec( mimeType );\n\t\t\t\t\t\t\tconst label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;\n\t\t\t\t\t\t\tconst decoder = new TextDecoder( label );\n\t\t\t\t\t\t\treturn response.arrayBuffer().then( ab => decoder.decode( ab ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( data => {\n\n\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\tCache.add( url, data );\n\n\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( data );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( err => {\n\n\t\t\t\t// Abort errors and other errors are handled the same\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tif ( callbacks === undefined ) {\n\n\t\t\t\t\t// When onLoad was called and url was deleted in `loading`\n\t\t\t\t\tthis.manager.itemError( url );\n\t\t\t\t\tthrow err;\n\n\t\t\t\t}\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( err );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t} )\n\t\t\t.finally( () => {\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\tthis.manager.itemStart( url );\n\n\t}\n\n\tsetResponseType( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t}\n\n\tsetMimeType( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n}\n\nclass AnimationLoader extends (/* unused pure expression or super */ null && (Loader)) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst animations = [];\n\n\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\tconst clip = AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass CompressedTextureLoader extends (/* unused pure expression or super */ null && (Loader)) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.image = images;\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.image = images;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass ImageLoader extends (/* runtime-dependent pure expression or super */ 577 == __webpack_require__.j ? (Loader) : null) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst image = createElementNS( 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction removeEventListeners() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.slice( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n}\n\nclass CubeTextureLoader extends (/* unused pure expression or super */ null && (Loader)) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( urls, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new CubeTexture();\n\t\ttexture.colorSpace = SRGBColorSpace;\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass DataTextureLoader extends (/* unused pure expression or super */ null && (Loader)) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst texture = new DataTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tlet texData;\n\n\t\t\ttry {\n\n\t\t\t\ttexData = scope.parse( buffer );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) {\n\n\t\t\t\t\tonError( error );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = texData.colorSpace;\n\n\t\t\t}\n\n\t\t\tif ( texData.flipY !== undefined ) {\n\n\t\t\t\ttexture.flipY = texData.flipY;\n\n\t\t\t}\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\tif ( texData.generateMipmaps !== undefined ) {\n\n\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass TextureLoader extends (/* runtime-dependent pure expression or super */ 577 == __webpack_require__.j ? (Loader) : null) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass Light extends Object3D {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.isLight = true;\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity;\n\n\t}\n\n\tdispose() {\n\n\t\t// Empty here in base class; some subclasses override.\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass HemisphereLight extends (/* unused pure expression or super */ null && (Light)) {\n\n\tconstructor( skyColor, groundColor, intensity ) {\n\n\t\tsuper( skyColor, intensity );\n\n\t\tthis.isHemisphereLight = true;\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();\nconst _lookTarget$1 = /*@__PURE__*/ new Vector3();\n\nclass LightShadow {\n\n\tconstructor( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.normalBias = 0;\n\t\tthis.radius = 1;\n\t\tthis.blurSamples = 8;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.mapPass = null;\n\t\tthis.matrix = new Matrix4();\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis._frustum = new Frustum();\n\t\tthis._frameExtents = new Vector2( 1, 1 );\n\n\t\tthis._viewportCount = 1;\n\n\t\tthis._viewports = [\n\n\t\t\tnew Vector4( 0, 0, 1, 1 )\n\n\t\t];\n\n\t}\n\n\tgetViewportCount() {\n\n\t\treturn this._viewportCount;\n\n\t}\n\n\tgetFrustum() {\n\n\t\treturn this._frustum;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst shadowCamera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\t_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );\n\t\tshadowCamera.position.copy( _lightPositionWorld$1 );\n\n\t\t_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );\n\t\tshadowCamera.lookAt( _lookTarget$1 );\n\t\tshadowCamera.updateMatrixWorld();\n\n\t\t_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );\n\n\t\tshadowMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\n\t\tshadowMatrix.multiply( _projScreenMatrix$1 );\n\n\t}\n\n\tgetViewport( viewportIndex ) {\n\n\t\treturn this._viewports[ viewportIndex ];\n\n\t}\n\n\tgetFrameExtents() {\n\n\t\treturn this._frameExtents;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.map ) {\n\n\t\t\tthis.map.dispose();\n\n\t\t}\n\n\t\tif ( this.mapPass ) {\n\n\t\t\tthis.mapPass.dispose();\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst object = {};\n\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.normalBias !== 0 ) object.normalBias = this.normalBias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n}\n\nclass SpotLightShadow extends (/* unused pure expression or super */ null && (LightShadow)) {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t\tthis.isSpotLightShadow = true;\n\n\t\tthis.focus = 1;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst camera = this.camera;\n\n\t\tconst fov = RAD2DEG * 2 * light.angle * this.focus;\n\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\tsuper.updateMatrices( light );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.focus = source.focus;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SpotLight extends (/* unused pure expression or super */ null && (Light)) {\n\n\tconstructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isSpotLight = true;\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.distance = distance;\n\t\tthis.angle = angle;\n\t\tthis.penumbra = penumbra;\n\t\tthis.decay = decay;\n\n\t\tthis.map = null;\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)\n\t\treturn this.intensity * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / Math.PI;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nclass PointLightShadow extends (/* unused pure expression or super */ null && (LightShadow)) {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t\tthis.isPointLightShadow = true;\n\n\t\tthis._frameExtents = new Vector2( 4, 2 );\n\n\t\tthis._viewportCount = 6;\n\n\t\tthis._viewports = [\n\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//  xzXZ\n\t\t\t//   y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\n\t\t\t// positive X\n\t\t\tnew Vector4( 2, 1, 1, 1 ),\n\t\t\t// negative X\n\t\t\tnew Vector4( 0, 1, 1, 1 ),\n\t\t\t// positive Z\n\t\t\tnew Vector4( 3, 1, 1, 1 ),\n\t\t\t// negative Z\n\t\t\tnew Vector4( 1, 1, 1, 1 ),\n\t\t\t// positive Y\n\t\t\tnew Vector4( 3, 0, 1, 1 ),\n\t\t\t// negative Y\n\t\t\tnew Vector4( 1, 0, 1, 1 )\n\t\t];\n\n\t\tthis._cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tthis._cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t}\n\n\tupdateMatrices( light, viewportIndex = 0 ) {\n\n\t\tconst camera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( far !== camera.far ) {\n\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\tcamera.position.copy( _lightPositionWorld );\n\n\t\t_lookTarget.copy( camera.position );\n\t\t_lookTarget.add( this._cubeDirections[ viewportIndex ] );\n\t\tcamera.up.copy( this._cubeUps[ viewportIndex ] );\n\t\tcamera.lookAt( _lookTarget );\n\t\tcamera.updateMatrixWorld();\n\n\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t}\n\n}\n\nclass PointLight extends (/* unused pure expression or super */ null && (Light)) {\n\n\tconstructor( color, intensity, distance = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isPointLight = true;\n\n\t\tthis.type = 'PointLight';\n\n\t\tthis.distance = distance;\n\t\tthis.decay = decay;\n\n\t\tthis.shadow = new PointLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)\n\t\treturn this.intensity * 4 * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass DirectionalLightShadow extends (/* unused pure expression or super */ null && (LightShadow)) {\n\n\tconstructor() {\n\n\t\tsuper( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t\tthis.isDirectionalLightShadow = true;\n\n\t}\n\n}\n\nclass DirectionalLight extends (/* unused pure expression or super */ null && (Light)) {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isDirectionalLight = true;\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.target = source.target.clone();\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass AmbientLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isAmbientLight = true;\n\n\t\tthis.type = 'AmbientLight';\n\n\t}\n\n}\n\nclass RectAreaLight extends (/* unused pure expression or super */ null && (Light)) {\n\n\tconstructor( color, intensity, width = 10, height = 10 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isRectAreaLight = true;\n\n\t\tthis.type = 'RectAreaLight';\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in nits)\n\t\treturn this.intensity * this.width * this.height * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in nits) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( this.width * this.height * Math.PI );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.width = this.width;\n\t\tdata.object.height = this.height;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n\n\tconstructor() {\n\n\t\tthis.isSphericalHarmonics3 = true;\n\n\t\tthis.coefficients = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients.push( new Vector3() );\n\n\t\t}\n\n\t}\n\n\tset( coefficients ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].copy( coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tzero() {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get the radiance in the direction of the normal\n\t// target is a Vector3\n\tgetAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 0.488603 * y );\n\t\ttarget.addScaledVector( coeff[ 2 ], 0.488603 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 0.488603 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );\n\t\ttarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\n\t\ttarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\n\n\t\treturn target;\n\n\t}\n\n\t// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t// target is a Vector3\n\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\tgetIrradianceAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603\n\t\ttarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548\n\t\ttarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3\n\t\ttarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274\n\n\t\treturn target;\n\n\t}\n\n\tadd( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\taddScaledSH( sh, s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tscale( s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].multiplyScalar( s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tlerp( sh, alpha ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcopy( sh ) {\n\n\t\treturn this.set( sh.coefficients );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].fromArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].toArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n\t// evaluate the basis functions\n\t// shBasis is an Array[ 9 ]\n\tstatic getBasisAt( normal, shBasis ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\t// band 0\n\t\tshBasis[ 0 ] = 0.282095;\n\n\t\t// band 1\n\t\tshBasis[ 1 ] = 0.488603 * y;\n\t\tshBasis[ 2 ] = 0.488603 * z;\n\t\tshBasis[ 3 ] = 0.488603 * x;\n\n\t\t// band 2\n\t\tshBasis[ 4 ] = 1.092548 * x * y;\n\t\tshBasis[ 5 ] = 1.092548 * y * z;\n\t\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\n\t\tshBasis[ 7 ] = 1.092548 * x * z;\n\t\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\n\n\t}\n\n}\n\nclass LightProbe extends (/* unused pure expression or super */ null && (Light)) {\n\n\tconstructor( sh = new SphericalHarmonics3(), intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tthis.isLightProbe = true;\n\n\t\tthis.sh = sh;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.sh.copy( source.sh );\n\n\t\treturn this;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\t\tthis.sh.fromArray( json.sh );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.sh = this.sh.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass MaterialLoader extends (/* unused pure expression or super */ null && (Loader)) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\t\tthis.textures = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst textures = this.textures;\n\n\t\tfunction getTexture( name ) {\n\n\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t}\n\n\t\t\treturn textures[ name ];\n\n\t\t}\n\n\t\tconst material = MaterialLoader.createMaterialFromType( json.type );\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.sheen !== undefined ) material.sheen = json.sheen;\n\t\tif ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );\n\t\tif ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;\n\t\tif ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;\n\t\tif ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;\n\t\tif ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\tif ( json.dispersion !== undefined ) material.dispersion = json.dispersion;\n\t\tif ( json.iridescence !== undefined ) material.iridescence = json.iridescence;\n\t\tif ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;\n\t\tif ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;\n\t\tif ( json.transmission !== undefined ) material.transmission = json.transmission;\n\t\tif ( json.thickness !== undefined ) material.thickness = json.thickness;\n\t\tif ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;\n\t\tif ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );\n\t\tif ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;\n\t\tif ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;\n\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.combine !== undefined ) material.combine = json.combine;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.alphaHash !== undefined ) material.alphaHash = json.alphaHash;\n\t\tif ( json.depthFunc !== undefined ) material.depthFunc = json.depthFunc;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.blendSrc !== undefined ) material.blendSrc = json.blendSrc;\n\t\tif ( json.blendDst !== undefined ) material.blendDst = json.blendDst;\n\t\tif ( json.blendEquation !== undefined ) material.blendEquation = json.blendEquation;\n\t\tif ( json.blendSrcAlpha !== undefined ) material.blendSrcAlpha = json.blendSrcAlpha;\n\t\tif ( json.blendDstAlpha !== undefined ) material.blendDstAlpha = json.blendDstAlpha;\n\t\tif ( json.blendEquationAlpha !== undefined ) material.blendEquationAlpha = json.blendEquationAlpha;\n\t\tif ( json.blendColor !== undefined && material.blendColor !== undefined ) material.blendColor.setHex( json.blendColor );\n\t\tif ( json.blendAlpha !== undefined ) material.blendAlpha = json.blendAlpha;\n\t\tif ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;\n\t\tif ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;\n\t\tif ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;\n\t\tif ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;\n\t\tif ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;\n\t\tif ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;\n\t\tif ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;\n\t\tif ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;\n\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\tif ( json.linewidth !== undefined ) material.linewidth = json.linewidth;\n\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\n\t\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\n\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\tif ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;\n\t\tif ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;\n\t\tif ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;\n\n\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\n\t\tif ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;\n\n\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\tif ( json.vertexColors !== undefined ) {\n\n\t\t\tif ( typeof json.vertexColors === 'number' ) {\n\n\t\t\t\tmaterial.vertexColors = ( json.vertexColors > 0 ) ? true : false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Shader Material\n\n\t\tif ( json.uniforms !== undefined ) {\n\n\t\t\tfor ( const name in json.uniforms ) {\n\n\t\t\t\tconst uniform = json.uniforms[ name ];\n\n\t\t\t\tmaterial.uniforms[ name ] = {};\n\n\t\t\t\tswitch ( uniform.type ) {\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.defines !== undefined ) material.defines = json.defines;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;\n\n\t\tif ( json.extensions !== undefined ) {\n\n\t\t\tfor ( const key in json.extensions ) {\n\n\t\t\t\tmaterial.extensions[ key ] = json.extensions[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.lights !== undefined ) material.lights = json.lights;\n\t\tif ( json.clipping !== undefined ) material.clipping = json.clipping;\n\n\t\t// for PointsMaterial\n\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\tif ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );\n\n\t\tif ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tlet normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\t\tif ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );\n\t\tif ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );\n\n\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\tif ( json.envMapRotation !== undefined ) material.envMapRotation.fromArray( json.envMapRotation );\n\t\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\tif ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\tif ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );\n\t\tif ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );\n\t\tif ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );\n\t\tif ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );\n\n\t\tif ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );\n\t\tif ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );\n\n\t\tif ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );\n\t\tif ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );\n\n\t\tif ( json.anisotropyMap !== undefined ) material.anisotropyMap = getTexture( json.anisotropyMap );\n\n\t\tif ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );\n\t\tif ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );\n\n\t\treturn material;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\tstatic createMaterialFromType( type ) {\n\n\t\tconst materialLib = {\n\t\t\tShadowMaterial,\n\t\t\tSpriteMaterial,\n\t\t\tRawShaderMaterial,\n\t\t\tShaderMaterial,\n\t\t\tPointsMaterial,\n\t\t\tMeshPhysicalMaterial,\n\t\t\tMeshStandardMaterial,\n\t\t\tMeshPhongMaterial,\n\t\t\tMeshToonMaterial,\n\t\t\tMeshNormalMaterial,\n\t\t\tMeshLambertMaterial,\n\t\t\tMeshDepthMaterial,\n\t\t\tMeshDistanceMaterial,\n\t\t\tMeshBasicMaterial,\n\t\t\tMeshMatcapMaterial,\n\t\t\tLineDashedMaterial,\n\t\t\tLineBasicMaterial,\n\t\t\tMaterial\n\t\t};\n\n\t\treturn new materialLib[ type ]();\n\n\t}\n\n}\n\nclass LoaderUtils {\n\n\tstatic decodeText( array ) { // @deprecated, r165\n\n\t\tconsole.warn( 'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.' );\n\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\treturn new TextDecoder().decode( array );\n\n\t\t}\n\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\tlet s = '';\n\n\t\tfor ( let i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t// Implicitly assumes little-endian.\n\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// merges multi-byte utf-8 characters.\n\n\t\t\treturn decodeURIComponent( escape( s ) );\n\n\t\t} catch ( e ) { // see #16358\n\n\t\t\treturn s;\n\n\t\t}\n\n\t}\n\n\tstatic extractUrlBase( url ) {\n\n\t\tconst index = url.lastIndexOf( '/' );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.slice( 0, index + 1 );\n\n\t}\n\n\tstatic resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Host Relative URL\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t}\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n}\n\nclass InstancedBufferGeometry extends (/* unused pure expression or super */ null && (BufferGeometry)) {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isInstancedBufferGeometry = true;\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.instanceCount = Infinity;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.instanceCount = source.instanceCount;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.instanceCount = this.instanceCount;\n\n\t\tdata.isInstancedBufferGeometry = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass BufferGeometryLoader extends (/* unused pure expression or super */ null && (Loader)) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst interleavedBufferMap = {};\n\t\tconst arrayBufferMap = {};\n\n\t\tfunction getInterleavedBuffer( json, uuid ) {\n\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\n\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\n\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\n\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\n\t\t\tib.uuid = interleavedBuffer.uuid;\n\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\n\n\t\t\treturn ib;\n\n\t\t}\n\n\t\tfunction getArrayBuffer( json, uuid ) {\n\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\n\n\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\n\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\n\n\t\t\tarrayBufferMap[ uuid ] = ab;\n\n\t\t\treturn ab;\n\n\t\t}\n\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tconst index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tconst attributes = json.data.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\t\t\tlet bufferAttribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t} else {\n\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\n\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( const key in morphAttributes ) {\n\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attribute = attributeArray[ i ];\n\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t}\n\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tconst center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nclass ObjectLoader extends (/* unused pure expression or super */ null && (Loader)) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\\'t load ' + url ) );\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tasync loadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await loader.loadAsync( url, onProgress );\n\n\t\tconst json = JSON.parse( text );\n\n\t\tconst metadata = json.metadata;\n\n\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\tthrow new Error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\n\t\t}\n\n\t\treturn await scope.parseAsync( json );\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\t//\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\tlet hasImages = false;\n\n\t\t\tfor ( const uuid in images ) {\n\n\t\t\t\tif ( images[ uuid ].data instanceof HTMLImageElement ) {\n\n\t\t\t\t\thasImages = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasImages === false ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tasync parseAsync( json ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = await this.parseImagesAsync( json.images );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\treturn object;\n\n\t}\n\n\tparseShapes( json ) {\n\n\t\tconst shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n\tparseSkeletons( json, object ) {\n\n\t\tconst skeletons = {};\n\t\tconst bones = {};\n\n\t\t// generate bone lookup table\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isBone ) bones[ child.uuid ] = child;\n\n\t\t} );\n\n\t\t// create skeletons\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst skeleton = new Skeleton().fromJSON( json[ i ], bones );\n\n\t\t\t\tskeletons[ skeleton.uuid ] = skeleton;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skeletons;\n\n\t}\n\n\tparseGeometries( json, shapes ) {\n\n\t\tconst geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tlet geometry;\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\tcase 'InstancedBufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( data.type in Geometries ) {\n\n\t\t\t\t\t\t\tgeometry = Geometries[ data.type ].fromJSON( data, shapes );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( `THREE.ObjectLoader: Unsupported geometry type \"${ data.type }\"` );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst cache = {}; // MultiMaterial\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseAnimations( json ) {\n\n\t\tconst animations = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tconst clip = AnimationClip.parse( data );\n\n\t\t\t\tanimations[ clip.uuid ] = clip;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n\tparseImages( json, onLoad ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn loadImage( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tconst manager = new LoadingManager( onLoad );\n\n\t\t\tloader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tasync parseImagesAsync( json ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tasync function deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn await loader.loadAsync( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tloader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = await deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = await deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tparseTextures( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tconst textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tconst source = images[ data.image ];\n\t\t\t\tconst image = source.data;\n\n\t\t\t\tlet texture;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture();\n\n\t\t\t\t\tif ( image.length === 6 ) texture.needsUpdate = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( image && image.data ) {\n\n\t\t\t\t\t\ttexture = new DataTexture();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new Texture();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( image ) texture.needsUpdate = true; // textures can have undefined image data\n\n\t\t\t\t}\n\n\t\t\t\ttexture.source = source;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\t\t\t\tif ( data.channel !== undefined ) texture.channel = data.channel;\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.colorSpace !== undefined ) texture.colorSpace = data.colorSpace;\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\t\t\t\tif ( data.compareFunction !== undefined ) texture.compareFunction = data.compareFunction;\n\n\t\t\t\tif ( data.userData !== undefined ) texture.userData = data.userData;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t}\n\n\tparseObject( data, geometries, materials, textures, animations ) {\n\n\t\tlet object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tfunction getTexture( uuid ) {\n\n\t\t\tif ( textures[ uuid ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined texture', uuid );\n\n\t\t\t}\n\n\t\t\treturn textures[ uuid ];\n\n\t\t}\n\n\t\tlet geometry, material;\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.background = getTexture( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.environment !== undefined ) {\n\n\t\t\t\t\tobject.environment = getTexture( data.environment );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.fog.name !== '' ) {\n\n\t\t\t\t\t\tobject.fog.name = data.fog.name;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;\n\t\t\t\tif ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;\n\t\t\t\tif ( data.backgroundRotation !== undefined ) object.backgroundRotation.fromArray( data.backgroundRotation );\n\n\t\t\t\tif ( data.environmentIntensity !== undefined ) object.environmentIntensity = data.environmentIntensity;\n\t\t\t\tif ( data.environmentRotation !== undefined ) object.environmentRotation.fromArray( data.environmentRotation );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LightProbe':\n\n\t\t\t\tobject = new LightProbe().fromJSON( data );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t \tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\tif ( data.bindMode !== undefined ) object.bindMode = data.bindMode;\n\t\t\t\tif ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );\n\t\t\t\tif ( data.skeleton !== undefined ) object.skeleton = data.skeleton;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'InstancedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\t\t\t\tconst count = data.count;\n\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\tconst instanceColor = data.instanceColor;\n\n\t\t\t\tobject = new InstancedMesh( geometry, material, count );\n\t\t\t\tobject.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\n\t\t\t\tif ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'BatchedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new BatchedMesh( data.maxGeometryCount, data.maxVertexCount, data.maxIndexCount, material );\n\t\t\t\tobject.geometry = geometry;\n\t\t\t\tobject.perObjectFrustumCulled = data.perObjectFrustumCulled;\n\t\t\t\tobject.sortObjects = data.sortObjects;\n\n\t\t\t\tobject._drawRanges = data.drawRanges;\n\t\t\t\tobject._reservedRanges = data.reservedRanges;\n\n\t\t\t\tobject._visibility = data.visibility;\n\t\t\t\tobject._active = data.active;\n\t\t\t\tobject._bounds = data.bounds.map( bound => {\n\n\t\t\t\t\tconst box = new Box3();\n\t\t\t\t\tbox.min.fromArray( bound.boxMin );\n\t\t\t\t\tbox.max.fromArray( bound.boxMax );\n\n\t\t\t\t\tconst sphere = new Sphere();\n\t\t\t\t\tsphere.radius = bound.sphereRadius;\n\t\t\t\t\tsphere.center.fromArray( bound.sphereCenter );\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\t\t\t\tbox: box,\n\n\t\t\t\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\t\t\t\tsphere: sphere\n\t\t\t\t\t};\n\n\t\t\t\t} );\n\n\t\t\t\tobject._maxGeometryCount = data.maxGeometryCount;\n\t\t\t\tobject._maxVertexCount = data.maxVertexCount;\n\t\t\t\tobject._maxIndexCount = data.maxIndexCount;\n\n\t\t\t\tobject._geometryInitialized = data.geometryInitialized;\n\t\t\t\tobject._geometryCount = data.geometryCount;\n\n\t\t\t\tobject._matricesTexture = getTexture( data.matricesTexture.uuid );\n\t\t\t\tif ( data.colorsTexture !== undefined ) object._colorsTexture = getTexture( data.colorsTexture.uuid );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Bone':\n\n\t\t\t\tobject = new Bone();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.up !== undefined ) object.up.fromArray( data.up );\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.animations !== undefined ) {\n\n\t\t\tconst objectAnimations = data.animations;\n\n\t\t\tfor ( let i = 0; i < objectAnimations.length; i ++ ) {\n\n\t\t\t\tconst uuid = objectAnimations[ i ];\n\n\t\t\t\tobject.animations.push( animations[ uuid ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\n\n\t\t\tconst levels = data.levels;\n\n\t\t\tfor ( let l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tconst level = levels[ l ];\n\t\t\t\tconst child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance, level.hysteresis );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tbindSkeletons( object, skeletons ) {\n\n\t\tif ( Object.keys( skeletons ).length === 0 ) return;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {\n\n\t\t\t\tconst skeleton = skeletons[ child.skeleton ];\n\n\t\t\t\tif ( skeleton === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.bind( skeleton, child.bindMatrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\nconst TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping\n};\n\nconst TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nconst TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\n\nclass ImageBitmapLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.isImageBitmapLoader = true;\n\n\t\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t\t}\n\n\t\tif ( typeof fetch === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t\t}\n\n\t\tthis.options = { premultiplyAlpha: 'none' };\n\n\t}\n\n\tsetOptions( options ) {\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\t// If cached is a promise, wait for it to resolve\n\t\t\tif ( cached.then ) {\n\n\t\t\t\tcached.then( imageBitmap => {\n\n\t\t\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t} ).catch( e => {\n\n\t\t\t\t\tif ( onError ) onError( e );\n\n\t\t\t\t} );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// If cached is not a promise (i.e., it's already an imageBitmap)\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst fetchOptions = {};\n\t\tfetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';\n\t\tfetchOptions.headers = this.requestHeader;\n\n\t\tconst promise = fetch( url, fetchOptions ).then( function ( res ) {\n\n\t\t\treturn res.blob();\n\n\t\t} ).then( function ( blob ) {\n\n\t\t\treturn createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );\n\n\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\tCache.add( url, imageBitmap );\n\n\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t\treturn imageBitmap;\n\n\t\t} ).catch( function ( e ) {\n\n\t\t\tif ( onError ) onError( e );\n\n\t\t\tCache.remove( url );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} );\n\n\t\tCache.add( url, promise );\n\t\tscope.manager.itemStart( url );\n\n\t}\n\n}\n\nlet _context;\n\nclass AudioContext {\n\n\tstatic getContext() {\n\n\t\tif ( _context === undefined ) {\n\n\t\t\t_context = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn _context;\n\n\t}\n\n\tstatic setContext( value ) {\n\n\t\t_context = value;\n\n\t}\n\n}\n\nclass AudioLoader extends (/* unused pure expression or super */ null && (Loader)) {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\tconst bufferCopy = buffer.slice( 0 );\n\n\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} ).catch( handleError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\thandleError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\tfunction handleError( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}\n\n\t}\n\n}\n\nconst _eyeRight = /*@__PURE__*/ new Matrix4();\nconst _eyeLeft = /*@__PURE__*/ new Matrix4();\nconst _projectionMatrix = /*@__PURE__*/ new Matrix4();\n\nclass StereoCamera {\n\n\tconstructor() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t\tthis._cache = {\n\t\t\tfocus: null,\n\t\t\tfov: null,\n\t\t\taspect: null,\n\t\t\tnear: null,\n\t\t\tfar: null,\n\t\t\tzoom: null,\n\t\t\teyeSep: null\n\t\t};\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst cache = this._cache;\n\n\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\n\t\t\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\n\t\t\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tcache.focus = camera.focus;\n\t\t\tcache.fov = camera.fov;\n\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\tcache.near = camera.near;\n\t\t\tcache.far = camera.far;\n\t\t\tcache.zoom = camera.zoom;\n\t\t\tcache.eyeSep = this.eyeSep;\n\n\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t_projectionMatrix.copy( camera.projectionMatrix );\n\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\tconst ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\n\t\t\tlet xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\n\t\t\t_eyeRight.elements[ 12 ] = eyeSepHalf;\n\n\t\t\t// for left eye\n\n\t\t\txmin = - ymax * cache.aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraL.projectionMatrix.copy( _projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = - ymax * cache.aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraR.projectionMatrix.copy( _projectionMatrix );\n\n\t\t}\n\n\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\n\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\n\n\t}\n\n}\n\nclass Clock {\n\n\tconstructor( autoStart = true ) {\n\n\t\tthis.autoStart = autoStart;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tstart() {\n\n\t\tthis.startTime = now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.elapsedTime = 0;\n\t\tthis.running = true;\n\n\t}\n\n\tstop() {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\t\tthis.autoStart = false;\n\n\t}\n\n\tgetElapsedTime() {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t}\n\n\tgetDelta() {\n\n\t\tlet diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tconst newTime = now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n}\n\nfunction now() {\n\n\treturn ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\n\n}\n\nconst _position$1 = /*@__PURE__*/ new Vector3();\nconst _quaternion$1 = /*@__PURE__*/ new Quaternion();\nconst _scale$1 = /*@__PURE__*/ new Vector3();\nconst _orientation$1 = /*@__PURE__*/ new Vector3();\n\nclass AudioListener extends (/* unused pure expression or super */ null && (Object3D)) {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = AudioContext.getContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t\tthis.timeDelta = 0;\n\n\t\t// private\n\n\t\tthis._clock = new Clock();\n\n\t}\n\n\tgetInput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tremoveFilter() {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.filter;\n\n\t}\n\n\tsetFilter( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t\treturn this;\n\n\t}\n\n\tgetMasterVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetMasterVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tconst listener = this.context.listener;\n\t\tconst up = this.up;\n\n\t\tthis.timeDelta = this._clock.getDelta();\n\n\t\tthis.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );\n\n\t\t_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );\n\n\t\tif ( listener.positionX ) {\n\n\t\t\t// code path for Chrome (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\tlistener.positionX.linearRampToValueAtTime( _position$1.x, endTime );\n\t\t\tlistener.positionY.linearRampToValueAtTime( _position$1.y, endTime );\n\t\t\tlistener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );\n\t\t\tlistener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );\n\t\t\tlistener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );\n\t\t\tlistener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );\n\t\t\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\n\t\t\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\n\t\t\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\n\n\t\t} else {\n\n\t\t\tlistener.setPosition( _position$1.x, _position$1.y, _position$1.z );\n\t\t\tlistener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass Audio extends (/* unused pure expression or super */ null && (Object3D)) {\n\n\tconstructor( listener ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.listener = listener;\n\t\tthis.context = listener.context;\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.buffer = null;\n\t\tthis.detune = 0;\n\t\tthis.loop = false;\n\t\tthis.loopStart = 0;\n\t\tthis.loopEnd = 0;\n\t\tthis.offset = 0;\n\t\tthis.duration = undefined;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.source = null;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis._startedAt = 0;\n\t\tthis._progress = 0;\n\t\tthis._connected = false;\n\n\t\tthis.filters = [];\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tsetNodeSource( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaElementSource( mediaElement ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaNode';\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaStreamSource( mediaStream ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaStreamNode';\n\t\tthis.source = this.context.createMediaStreamSource( mediaStream );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetBuffer( audioBuffer ) {\n\n\t\tthis.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t}\n\n\tplay( delay = 0 ) {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._startedAt = this.context.currentTime + delay;\n\n\t\tconst source = this.context.createBufferSource();\n\t\tsource.buffer = this.buffer;\n\t\tsource.loop = this.loop;\n\t\tsource.loopStart = this.loopStart;\n\t\tsource.loopEnd = this.loopEnd;\n\t\tsource.onended = this.onEnded.bind( this );\n\t\tsource.start( this._startedAt, this._progress + this.offset, this.duration );\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\tthis.setDetune( this.detune );\n\t\tthis.setPlaybackRate( this.playbackRate );\n\n\t\treturn this.connect();\n\n\t}\n\n\tpause() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\t// update current progress\n\n\t\t\tthis._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;\n\n\t\t\tif ( this.loop === true ) {\n\n\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\n\t\t\t\tthis._progress = this._progress % ( this.duration || this.buffer.duration );\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t\tthis.isPlaying = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._progress = 0;\n\n\t\tif ( this.source !== null ) {\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t}\n\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t}\n\n\tconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = true;\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect() {\n\n\t\tif ( this._connected === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = false;\n\n\t\treturn this;\n\n\t}\n\n\tgetFilters() {\n\n\t\treturn this.filters;\n\n\t}\n\n\tsetFilters( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this._connected === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value.slice();\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetDetune( value ) {\n\n\t\tthis.detune = value;\n\n\t\tif ( this.isPlaying === true && this.source.detune !== undefined ) {\n\n\t\t\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetDetune() {\n\n\t\treturn this.detune;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t}\n\n\tsetFilter( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t}\n\n\tsetPlaybackRate( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetPlaybackRate() {\n\n\t\treturn this.playbackRate;\n\n\t}\n\n\tonEnded() {\n\n\t\tthis.isPlaying = false;\n\n\t}\n\n\tgetLoop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.loop;\n\n\t}\n\n\tsetLoop( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.loop = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.loop = this.loop;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopStart( value ) {\n\n\t\tthis.loopStart = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopEnd( value ) {\n\n\t\tthis.loopEnd = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _position = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\nconst _scale = /*@__PURE__*/ new Vector3();\nconst _orientation = /*@__PURE__*/ new Vector3();\n\nclass PositionalAudio extends (/* unused pure expression or super */ null && (Audio)) {\n\n\tconstructor( listener ) {\n\n\t\tsuper( listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.panningModel = 'HRTF';\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tconnect() {\n\n\t\tsuper.connect();\n\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tdisconnect() {\n\n\t\tsuper.disconnect();\n\n\t\tthis.panner.disconnect( this.gain );\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.panner;\n\n\t}\n\n\tgetRefDistance() {\n\n\t\treturn this.panner.refDistance;\n\n\t}\n\n\tsetRefDistance( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetRolloffFactor() {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t}\n\n\tsetRolloffFactor( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetDistanceModel() {\n\n\t\treturn this.panner.distanceModel;\n\n\t}\n\n\tsetDistanceModel( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxDistance() {\n\n\t\treturn this.panner.maxDistance;\n\n\t}\n\n\tsetMaxDistance( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\n\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\tthis.panner.coneOuterGain = coneOuterGain;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.hasPlaybackControl === true && this.isPlaying === false ) return;\n\n\t\tthis.matrixWorld.decompose( _position, _quaternion, _scale );\n\n\t\t_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );\n\n\t\tconst panner = this.panner;\n\n\t\tif ( panner.positionX ) {\n\n\t\t\t// code path for Chrome and Firefox (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\n\t\t\tpanner.positionX.linearRampToValueAtTime( _position.x, endTime );\n\t\t\tpanner.positionY.linearRampToValueAtTime( _position.y, endTime );\n\t\t\tpanner.positionZ.linearRampToValueAtTime( _position.z, endTime );\n\t\t\tpanner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );\n\t\t\tpanner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );\n\t\t\tpanner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );\n\n\t\t} else {\n\n\t\t\tpanner.setPosition( _position.x, _position.y, _position.z );\n\t\t\tpanner.setOrientation( _orientation.x, _orientation.y, _orientation.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass AudioAnalyser {\n\n\tconstructor( audio, fftSize = 2048 ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\n\tgetFrequencyData() {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t}\n\n\tgetAverageFrequency() {\n\n\t\tlet value = 0;\n\t\tconst data = this.getFrequencyData();\n\n\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n}\n\nclass PropertyMixer {\n\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*/ /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*/ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*/ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];\n\nclass Composite {\n\n\tconstructor( targetGroup, path, optionalParsedPath ) {\n\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tgetValue( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t}\n\n\tsetValue( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t}\n\n\tbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t}\n\n\tunbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n\n\tconstructor( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );\n\n\t\tthis.rootNode = rootNode;\n\n\t\t// initial state of these methods that calls 'bind'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n\n\tstatic create( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tstatic sanitizeNodeName( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t}\n\n\tstatic parseTrackName( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( matches === null ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n\tstatic findNode( root, nodeName ) {\n\n\t\tif ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable() {}\n\t_setValue_unavailable() {}\n\n\t// Getters\n\n\t_getValue_direct( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.targetObject[ this.propertyName ];\n\n\t}\n\n\t_getValue_array( buffer, offset ) {\n\n\t\tconst source = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t}\n\n\t}\n\n\t_getValue_arrayElement( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t}\n\n\t_getValue_toArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t}\n\n\t// Direct\n\n\t_setValue_direct( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// EntireArray\n\n\t_setValue_array( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t}\n\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// ArrayElement\n\n\t_setValue_arrayElement( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// HasToFromArray\n\n\t_setValue_fromArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t}\n\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t_getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t}\n\n\t_setValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t}\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind() {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map':\n\n\t\t\t\t\tif ( 'map' in targetObject ) {\n\n\t\t\t\t\t\ttargetObject = targetObject.map;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.map ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.map;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t}\n\n\tunbind() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n\tDirect: 0,\n\tEntireArray: 1,\n\tArrayElement: 2,\n\tHasFromToArray: 3\n};\n\nPropertyBinding.prototype.Versioning = {\n\tNone: 0,\n\tNeedsUpdate: 1,\n\tMatrixWorldNeedsUpdate: 2\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n\n\tPropertyBinding.prototype._getValue_direct,\n\tPropertyBinding.prototype._getValue_array,\n\tPropertyBinding.prototype._getValue_arrayElement,\n\tPropertyBinding.prototype._getValue_toArray,\n\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n\n\t[\n\t\t// Direct\n\t\tPropertyBinding.prototype._setValue_direct,\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// EntireArray\n\n\t\tPropertyBinding.prototype._setValue_array,\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// ArrayElement\n\t\tPropertyBinding.prototype._setValue_arrayElement,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// HasToFromArray\n\t\tPropertyBinding.prototype._setValue_fromArray,\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n\n\t]\n\n];\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n\n\tconstructor() {\n\n\t\tthis.isAnimationObjectGroup = true;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tconst indices = {};\n\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = []; // inside: string\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tadd() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\tremove() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// remove & forget\n\tuncache() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t}\n\n\tunsubscribe_( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n}\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot;\n\t\tthis.blendMode = blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\tdeltaTime = 0;\n\n\t\t\t} else {\n\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _controlInterpolantsResultBuffer = new Float32Array( 1 );\n\n\nclass AnimationMixer extends (/* unused pure expression or super */ null && (EventDispatcher)) {\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\tthis.time = 0;\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, _controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t// get an existing action\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// advance the time and update apply the animation\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t// return this mixer's root target object\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t// free all resources specific to a particular clip\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remove a targeted clip from the cache\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nclass Uniform {\n\n\tconstructor( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n\t}\n\n}\n\nlet _id = 0;\n\nclass UniformsGroup extends (/* unused pure expression or super */ null && (EventDispatcher)) {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isUniformsGroup = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\tthis.name = '';\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.uniforms = [];\n\n\t}\n\n\tadd( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\tremove( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) this.uniforms.splice( index, 1 );\n\n\t\treturn this;\n\n\t}\n\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.usage = source.usage;\n\n\t\tconst uniformsSource = source.uniforms;\n\n\t\tthis.uniforms.length = 0;\n\n\t\tfor ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {\n\n\t\t\tconst uniforms = Array.isArray( uniformsSource[ i ] ) ? uniformsSource[ i ] : [ uniformsSource[ i ] ];\n\n\t\t\tfor ( let j = 0; j < uniforms.length; j ++ ) {\n\n\t\t\t\tthis.uniforms.push( uniforms[ j ].clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass InstancedInterleavedBuffer extends (/* unused pure expression or super */ null && (InterleavedBuffer)) {\n\n\tconstructor( array, stride, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, stride );\n\n\t\tthis.isInstancedInterleavedBuffer = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tconst ib = super.clone( data );\n\n\t\tib.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn ib;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tconst json = super.toJSON( data );\n\n\t\tjson.isInstancedInterleavedBuffer = true;\n\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn json;\n\n\t}\n\n}\n\nclass GLBufferAttribute {\n\n\tconstructor( buffer, type, itemSize, elementSize, count ) {\n\n\t\tthis.isGLBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.buffer = buffer;\n\t\tthis.type = type;\n\t\tthis.itemSize = itemSize;\n\t\tthis.elementSize = elementSize;\n\t\tthis.count = count;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetBuffer( buffer ) {\n\n\t\tthis.buffer = buffer;\n\n\t\treturn this;\n\n\t}\n\n\tsetType( type, elementSize ) {\n\n\t\tthis.type = type;\n\t\tthis.elementSize = elementSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetItemSize( itemSize ) {\n\n\t\tthis.itemSize = itemSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetCount( count ) {\n\n\t\tthis.count = count;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\n\nclass Raycaster {\n\n\tconstructor( origin, direction, near = 0, far = Infinity ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.camera = null;\n\t\tthis.layers = new Layers();\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: { threshold: 1 },\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t}\n\n\tsetFromCamera( coords, camera ) {\n\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( camera.isOrthographicCamera ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\n\n\t\t}\n\n\t}\n\n\tsetFromXRController( controller ) {\n\n\t\t_matrix.identity().extractRotation( controller.matrixWorld );\n\n\t\tthis.ray.origin.setFromMatrixPosition( controller.matrixWorld );\n\t\tthis.ray.direction.set( 0, 0, - 1 ).applyMatrix4( _matrix );\n\n\t\treturn this;\n\n\t}\n\n\tintersectObject( object, recursive = true, intersects = [] ) {\n\n\t\tintersect( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n\tintersectObjects( objects, recursive = true, intersects = [] ) {\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersect( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersect( object, raycaster, intersects, recursive ) {\n\n\tlet propagate = true;\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tconst result = object.raycast( raycaster, intersects );\n\n\t\tif ( result === false ) propagate = false;\n\n\t}\n\n\tif ( propagate === true && recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersect( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.\n * theta (the azimuthal angle) is measured from the positive z-axis.\n */\nclass Spherical {\n\n\tconstructor( radius = 1, phi = 0, theta = 0 ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi; // polar angle\n\t\tthis.theta = theta; // azimuthal angle\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.phi = other.phi;\n\t\tthis.theta = other.theta;\n\n\t\treturn this;\n\n\t}\n\n\t// restrict phi to be between EPS and PI-EPS\n\tmakeSafe() {\n\n\t\tconst EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\tthis.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n */\n\nclass Cylindrical {\n\n\tconstructor( radius = 1, theta = 0, y = 0 ) {\n\n\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\t\tthis.y = y; // height above the x-z plane\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, theta, y ) {\n\n\t\tthis.radius = radius;\n\t\tthis.theta = theta;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.theta = other.theta;\n\t\tthis.y = other.y;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + z * z );\n\t\tthis.theta = Math.atan2( x, z );\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$4 = /*@__PURE__*/ new Vector2();\n\nclass Box2 {\n\n\tconstructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox2 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 4 splitting planes to rule out intersections\n\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$4 ).distanceTo( point );\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _startP = /*@__PURE__*/ new Vector3();\nconst _startEnd = /*@__PURE__*/ new Vector3();\n\nclass Line3 {\n\n\tconstructor( start = new Vector3(), end = new Vector3() ) {\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\n\t}\n\n\tset( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t}\n\n\tdelta( target ) {\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t}\n\n\tdistanceSq() {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t}\n\n\tdistance() {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tclosestPointToPointParameter( point, clampToLine ) {\n\n\t\t_startP.subVectors( point, this.start );\n\t\t_startEnd.subVectors( this.end, this.start );\n\n\t\tconst startEnd2 = _startEnd.dot( _startEnd );\n\t\tconst startEnd_startP = _startEnd.dot( _startP );\n\n\t\tlet t = startEnd_startP / startEnd2;\n\n\t\tif ( clampToLine ) {\n\n\t\t\tt = clamp( t, 0, 1 );\n\n\t\t}\n\n\t\treturn t;\n\n\t}\n\n\tclosestPointToPoint( point, clampToLine, target ) {\n\n\t\tconst t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t}\n\n\tequals( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$3 = /*@__PURE__*/ new Vector3();\n\nclass SpotLightHelper extends (/* unused pure expression or super */ null && (Object3D)) {\n\n\tconstructor( light, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'SpotLightHelper';\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions = [\n\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t];\n\n\t\tfor ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tconst p1 = ( i / l ) * Math.PI * 2;\n\t\t\tconst p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t// update the local matrix based on the parent and light target transforms\n\t\tif ( this.parent ) {\n\n\t\t\tthis.parent.updateWorldMatrix( true );\n\n\t\t\tthis.matrix\n\t\t\t\t.copy( this.parent.matrixWorld )\n\t\t\t\t.invert()\n\t\t\t\t.multiply( this.light.matrixWorld );\n\n\t\t} else {\n\n\t\t\tthis.matrix.copy( this.light.matrixWorld );\n\n\t\t}\n\n\t\tthis.matrixWorld.copy( this.light.matrixWorld );\n\n\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tconst coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( _vector$3 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t}\n\n}\n\nconst _vector$2 = /*@__PURE__*/ new Vector3();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\nconst _matrixWorldInv = /*@__PURE__*/ new Matrix4();\n\n\nclass SkeletonHelper extends (/* unused pure expression or super */ null && (LineSegments)) {\n\n\tconstructor( object ) {\n\n\t\tconst bones = getBoneList( object );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst color1 = new Color( 0, 0, 1 );\n\t\tconst color2 = new Color( 0, 1, 0 );\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkeletonHelper = true;\n\n\t\tthis.type = 'SkeletonHelper';\n\n\t\tthis.root = object;\n\t\tthis.bones = bones;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst bones = this.bones;\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t_matrixWorldInv.copy( this.root.matrixWorld ).invert();\n\n\t\tfor ( let i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction getBoneList( object ) {\n\n\tconst boneList = [];\n\n\tif ( object.isBone === true ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( let i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n}\n\nclass PointLightHelper extends (/* unused pure expression or super */ null && (Mesh)) {\n\n\tconstructor( light, sphereSize, color ) {\n\n\t\tconst geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tconst material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.light = light;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'PointLightHelper';\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\n\t\t/*\n\t// TODO: delete this comment?\n\tconst distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tconst d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\t/*\n\t\tconst d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t}\n\n}\n\nconst _vector$1 = /*@__PURE__*/ new Vector3();\nconst _color1 = /*@__PURE__*/ new Color();\nconst _color2 = /*@__PURE__*/ new Color();\n\nclass HemisphereLightHelper extends (/* unused pure expression or super */ null && (Object3D)) {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'HemisphereLightHelper';\n\n\t\tconst geometry = new OctahedronGeometry( size );\n\t\tgeometry.rotateY( Math.PI * 0.5 );\n\n\t\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\t\tif ( this.color === undefined ) this.material.vertexColors = true;\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tconst colors = new Float32Array( position.count * 3 );\n\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tthis.add( new Mesh( geometry, this.material ) );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.children[ 0 ];\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tconst colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\t_color1.copy( this.light.color );\n\t\t\t_color2.copy( this.light.groundColor );\n\n\t\t\tfor ( let i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\tconst color = ( i < ( l / 2 ) ) ? _color1 : _color2;\n\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tcolors.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tmesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t}\n\n}\n\nclass GridHelper extends (/* unused pure expression or super */ null && (LineSegments)) {\n\n\tconstructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst center = divisions / 2;\n\t\tconst step = size / divisions;\n\t\tconst halfSize = size / 2;\n\n\t\tconst vertices = [], colors = [];\n\n\t\tfor ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\t\tconst color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'GridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PolarGridHelper extends (/* unused pure expression or super */ null && (LineSegments)) {\n\n\tconstructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\t// create the sectors\n\n\t\tif ( sectors > 1 ) {\n\n\t\t\tfor ( let i = 0; i < sectors; i ++ ) {\n\n\t\t\t\tconst v = ( i / sectors ) * ( Math.PI * 2 );\n\n\t\t\t\tconst x = Math.sin( v ) * radius;\n\t\t\t\tconst z = Math.cos( v ) * radius;\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( x, 0, z );\n\n\t\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create the rings\n\n\t\tfor ( let i = 0; i < rings; i ++ ) {\n\n\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\tconst r = radius - ( radius / rings * i );\n\n\t\t\tfor ( let j = 0; j < divisions; j ++ ) {\n\n\t\t\t\t// first vertex\n\n\t\t\t\tlet v = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tlet x = Math.sin( v ) * r;\n\t\t\t\tlet z = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t// second vertex\n\n\t\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\tz = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'PolarGridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\nconst _v3 = /*@__PURE__*/ new Vector3();\n\nclass DirectionalLightHelper extends (/* unused pure expression or super */ null && (Object3D)) {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'DirectionalLightHelper';\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tlet geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t- size, size, 0,\n\t\t\tsize, size, 0,\n\t\t\tsize, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size, size, 0\n\t\t], 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.lightPlane = new Line( geometry, material );\n\t\tthis.add( this.lightPlane );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.targetLine = new Line( geometry, material );\n\t\tthis.add( this.targetLine );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lightPlane.geometry.dispose();\n\t\tthis.lightPlane.material.dispose();\n\t\tthis.targetLine.geometry.dispose();\n\t\tthis.targetLine.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t_v1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t_v2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t_v3.subVectors( _v2, _v1 );\n\n\t\tthis.lightPlane.lookAt( _v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( _v2 );\n\t\tthis.targetLine.scale.z = _v3.length();\n\n\t}\n\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _camera = /*@__PURE__*/ new Camera();\n\n/**\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttps://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html\n */\n\nclass CameraHelper extends (/* unused pure expression or super */ null && (LineSegments)) {\n\n\tconstructor( camera ) {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst pointMap = {};\n\n\t\t// near\n\n\t\taddLine( 'n1', 'n2' );\n\t\taddLine( 'n2', 'n4' );\n\t\taddLine( 'n4', 'n3' );\n\t\taddLine( 'n3', 'n1' );\n\n\t\t// far\n\n\t\taddLine( 'f1', 'f2' );\n\t\taddLine( 'f2', 'f4' );\n\t\taddLine( 'f4', 'f3' );\n\t\taddLine( 'f3', 'f1' );\n\n\t\t// sides\n\n\t\taddLine( 'n1', 'f1' );\n\t\taddLine( 'n2', 'f2' );\n\t\taddLine( 'n3', 'f3' );\n\t\taddLine( 'n4', 'f4' );\n\n\t\t// cone\n\n\t\taddLine( 'p', 'n1' );\n\t\taddLine( 'p', 'n2' );\n\t\taddLine( 'p', 'n3' );\n\t\taddLine( 'p', 'n4' );\n\n\t\t// up\n\n\t\taddLine( 'u1', 'u2' );\n\t\taddLine( 'u2', 'u3' );\n\t\taddLine( 'u3', 'u1' );\n\n\t\t// target\n\n\t\taddLine( 'c', 't' );\n\t\taddLine( 'p', 'c' );\n\n\t\t// cross\n\n\t\taddLine( 'cn1', 'cn2' );\n\t\taddLine( 'cn3', 'cn4' );\n\n\t\taddLine( 'cf1', 'cf2' );\n\t\taddLine( 'cf3', 'cf4' );\n\n\t\tfunction addLine( a, b ) {\n\n\t\t\taddPoint( a );\n\t\t\taddPoint( b );\n\n\t\t}\n\n\t\tfunction addPoint( id ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( 0, 0, 0 );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'CameraHelper';\n\n\t\tthis.camera = camera;\n\t\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t\t// colors\n\n\t\tconst colorFrustum = new Color( 0xffaa00 );\n\t\tconst colorCone = new Color( 0xff0000 );\n\t\tconst colorUp = new Color( 0x00aaff );\n\t\tconst colorTarget = new Color( 0xffffff );\n\t\tconst colorCross = new Color( 0x333333 );\n\n\t\tthis.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );\n\n\t}\n\n\tsetColors( frustum, cone, up, target, cross ) {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst colorAttribute = geometry.getAttribute( 'color' );\n\n\t\t// near\n\n\t\tcolorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2\n\t\tcolorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4\n\t\tcolorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3\n\t\tcolorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1\n\n\t\t// far\n\n\t\tcolorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2\n\t\tcolorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4\n\t\tcolorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3\n\t\tcolorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1\n\n\t\t// sides\n\n\t\tcolorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1\n\t\tcolorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2\n\t\tcolorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3\n\t\tcolorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4\n\n\t\t// cone\n\n\t\tcolorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1\n\t\tcolorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2\n\t\tcolorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3\n\t\tcolorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4\n\n\t\t// up\n\n\t\tcolorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2\n\t\tcolorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3\n\t\tcolorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1\n\n\t\t// target\n\n\t\tcolorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t\n\t\tcolorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c\n\n\t\t// cross\n\n\t\tcolorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2\n\t\tcolorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4\n\n\t\tcolorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2\n\t\tcolorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4\n\n\t\tcolorAttribute.needsUpdate = true;\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst pointMap = this.pointMap;\n\n\t\tconst w = 1, h = 1;\n\n\t\t// we need just camera projection matrix inverse\n\t\t// world matrix must be identity\n\n\t\t_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );\n\n\t\t// center / target\n\n\t\tsetPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );\n\t\tsetPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );\n\n\t\t// near\n\n\t\tsetPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );\n\t\tsetPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );\n\t\tsetPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );\n\t\tsetPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );\n\t\tsetPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );\n\t\tsetPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );\n\t\tsetPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );\n\t\tsetPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );\n\t\tsetPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );\n\t\tsetPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );\n\n\t\tsetPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );\n\t\tsetPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );\n\t\tsetPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );\n\t\tsetPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {\n\n\t_vector.set( x, y, z ).unproject( camera );\n\n\tconst points = pointMap[ point ];\n\n\tif ( points !== undefined ) {\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tposition.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n}\n\nconst _box = /*@__PURE__*/ new Box3();\n\nclass BoxHelper extends (/* unused pure expression or super */ null && (LineSegments)) {\n\n\tconstructor( object, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tconst positions = new Float32Array( 8 * 3 );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.object = object;\n\t\tthis.type = 'BoxHelper';\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate( object ) {\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t}\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\t_box.setFromObject( this.object );\n\n\t\t}\n\n\t\tif ( _box.isEmpty() ) return;\n\n\t\tconst min = _box.min;\n\t\tconst max = _box.max;\n\n\t\t/*\n\t\t\t5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tconst position = this.geometry.attributes.position;\n\t\tconst array = position.array;\n\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tthis.object = object;\n\t\tthis.update();\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.object = source.object;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass Box3Helper extends (/* unused pure expression or super */ null && (LineSegments)) {\n\n\tconstructor( box, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\t\tconst positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.box = box;\n\n\t\tthis.type = 'Box3Helper';\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst box = this.box;\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tbox.getCenter( this.position );\n\n\t\tbox.getSize( this.scale );\n\n\t\tthis.scale.multiplyScalar( 0.5 );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PlaneHelper extends (/* unused pure expression or super */ null && (Line)) {\n\n\tconstructor( plane, size = 1, hex = 0xffff00 ) {\n\n\t\tconst color = hex;\n\n\t\tconst positions = [ 1, - 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.type = 'PlaneHelper';\n\n\t\tthis.plane = plane;\n\n\t\tthis.size = size;\n\n\t\tconst positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\n\t\tconst geometry2 = new BufferGeometry();\n\t\tgeometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\t\tgeometry2.computeBoundingSphere();\n\n\t\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tthis.position.set( 0, 0, 0 );\n\n\t\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );\n\n\t\tthis.lookAt( this.plane.normal );\n\n\t\tthis.translateZ( - this.plane.constant );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n}\n\nconst _axis = /*@__PURE__*/ new Vector3();\nlet _lineGeometry, _coneGeometry;\n\nclass ArrowHelper extends (/* unused pure expression or super */ null && (Object3D)) {\n\n\t// dir is assumed to be normalized\n\n\tconstructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ArrowHelper';\n\n\t\tif ( _lineGeometry === undefined ) {\n\n\t\t\t_lineGeometry = new BufferGeometry();\n\t\t\t_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\t\t_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );\n\t\t\t_coneGeometry.translate( 0, - 0.5, 0 );\n\n\t\t}\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tsetDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\t_axis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tconst radians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( _axis, radians );\n\n\t\t}\n\n\t}\n\n\tsetLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tthis.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t}\n\n\tsetColor( color ) {\n\n\t\tthis.line.material.color.set( color );\n\t\tthis.cone.material.color.set( color );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tthis.line.copy( source.line );\n\t\tthis.cone.copy( source.cone );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.line.geometry.dispose();\n\t\tthis.line.material.dispose();\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n}\n\nclass AxesHelper extends LineSegments {\n\n\tconstructor( size = 1 ) {\n\n\t\tconst vertices = [\n\t\t\t0, 0, 0,\tsize, 0, 0,\n\t\t\t0, 0, 0,\t0, size, 0,\n\t\t\t0, 0, 0,\t0, 0, size\n\t\t];\n\n\t\tconst colors = [\n\t\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t\t0, 0, 1,\t0, 0.6, 1\n\t\t];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'AxesHelper';\n\n\t}\n\n\tsetColors( xAxisColor, yAxisColor, zAxisColor ) {\n\n\t\tconst color = new Color();\n\t\tconst array = this.geometry.attributes.color.array;\n\n\t\tcolor.set( xAxisColor );\n\t\tcolor.toArray( array, 0 );\n\t\tcolor.toArray( array, 3 );\n\n\t\tcolor.set( yAxisColor );\n\t\tcolor.toArray( array, 6 );\n\t\tcolor.toArray( array, 9 );\n\n\t\tcolor.set( zAxisColor );\n\t\tcolor.toArray( array, 12 );\n\t\tcolor.toArray( array, 15 );\n\n\t\tthis.geometry.attributes.color.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass ShapePath {\n\n\tconstructor() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\tthis.color = new Color();\n\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t}\n\n\ttoShapes( isCCW ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tconst shapes = [];\n\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\n\n\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tconst polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tlet inside = false;\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tconst isClockWise = ShapeUtils.isClockWise;\n\n\t\tconst subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tlet solid, tmpPath, tmpShape;\n\t\tconst shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tconst betterShapeHoles = [];\n\t\tconst newShapes = [];\n\t\tlet newShapeHoles = [];\n\t\tlet mainIdx = 0;\n\t\tlet tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tlet ambiguous = false;\n\t\t\tlet toChange = 0;\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tconst ho = sho[ hIdx ];\n\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange ++;\n\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( toChange > 0 && ambiguous === false ) {\n\n\t\t\t\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet tmpHoles;\n\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nclass WebGLMultipleRenderTargets extends (/* unused pure expression or super */ null && (WebGLRenderTarget)) { // @deprecated, r162\n\n\tconstructor( width = 1, height = 1, count = 1, options = {} ) {\n\n\t\tconsole.warn( 'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the \"count\" parameter to enable MRT.' );\n\n\t\tsuper( width, height, { ...options, count } );\n\n\t\tthis.isWebGLMultipleRenderTargets = true;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this.textures;\n\n\t}\n\n}\n\nif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {\n\t\trevision: REVISION,\n\t} } ) );\n\n}\n\nif ( typeof window !== 'undefined' ) {\n\n\tif ( window.__THREE__ ) {\n\n\t\tconsole.warn( 'WARNING: Multiple instances of Three.js being imported.' );\n\n\t} else {\n\n\t\twindow.__THREE__ = REVISION;\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLGVBQWU7QUFDaEMsaUJBQWlCLGVBQWU7QUFDaEMsaUJBQWlCLGVBQWU7O0FBRWhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUI7QUFDeEMscUJBQXFCLG1CQUFtQjtBQUN4QyxxQkFBcUIsbUJBQW1COztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsaUJBQWlCOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlDQUFpQyxRQUFROztBQUV6QywwQ0FBMEM7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsMERBQTBELFlBQVk7O0FBRXRFOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsb0JBQW9CLGlCQUFpQjs7QUFFckM7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsc0JBQXNCOztBQUU3RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUJBQXVCOztBQUU5RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEMseUJBQXlCOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QixrQkFBa0I7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQjs7QUFFakI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsV0FBVzs7QUFFOUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxRQUFROztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnREFBZ0QsUUFBUTs7QUFFeEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QixrQkFBa0I7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsaUVBQWlCOztBQUV0RCw2REFBNkQ7O0FBRTdEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLGlFQUFpQjs7QUFFbkQsNkRBQTZEOztBQUU3RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtEQUFrRCxPQUFPOztBQUV6RDs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0EsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjs7QUFFakY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQixlQUFlLGVBQWU7QUFDL0MsaUJBQWlCLGVBQWUsZUFBZTtBQUMvQyxpQkFBaUIsZUFBZSxnQkFBZ0I7QUFDaEQsaUJBQWlCLGVBQWUsZ0JBQWdCOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUIsbUJBQW1CO0FBQzNELHFCQUFxQixtQkFBbUIsbUJBQW1CO0FBQzNELHFCQUFxQixtQkFBbUIscUJBQXFCO0FBQzdELHVCQUF1QixxQkFBcUIscUJBQXFCOztBQUVqRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEMsa0JBQWtCLGdCQUFnQjtBQUNsQyxrQkFBa0IsZ0JBQWdCOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCLGNBQWMsY0FBYztBQUM1QyxnQkFBZ0IsY0FBYyxjQUFjO0FBQzVDLGdCQUFnQixjQUFjLGVBQWU7QUFDN0MsZ0JBQWdCLGNBQWMsZUFBZTs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDLGlCQUFpQixtQkFBbUI7QUFDcEMsaUJBQWlCLG1CQUFtQjs7QUFFcEMsaUJBQWlCLG9CQUFvQjtBQUNyQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLGtCQUFrQixxQkFBcUI7O0FBRXZDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxlQUFlLGFBQWEsY0FBYztBQUMxQyxlQUFlLGFBQWEsY0FBYztBQUMxQyxlQUFlLGFBQWEsZUFBZTtBQUMzQyxlQUFlLGFBQWEsZ0JBQWdCOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsbUJBQW1CLGNBQWMsZUFBZTtBQUNoRCxpQkFBaUIsaUJBQWlCLGVBQWU7QUFDakQsaUJBQWlCLGNBQWMsaUJBQWlCO0FBQ2hELGlCQUFpQixjQUFjLGVBQWU7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixRQUFROztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsd0JBQXdCOztBQUV4QiwyQkFBMkI7QUFDM0IsNkJBQTZCOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsd0JBQXdCOztBQUUvRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHNCQUFzQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHNCQUFzQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMsT0FBTzs7QUFFcEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxPQUFPOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxPQUFPOztBQUV0RDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiwwQkFBMEI7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiw0QkFBNEI7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLDRCQUE0Qjs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdURBQXVEOztBQUV2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEseURBQXlEO0FBQ3pELHlDQUF5QztBQUN6Qyx5Q0FBeUM7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsYUFBYSxHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQjs7QUFFNUY7O0FBRUEsaUJBQWlCLHVCQUF1QixJQUFJLHVCQUF1QixJQUFJLHVCQUF1Qjs7QUFFOUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx3QkFBd0I7O0FBRS9EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELEtBQUs7QUFDdEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLEtBQUssZ0NBQWdDLFdBQVc7QUFDdkY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUzs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QixrQkFBa0I7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQzs7QUFFdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixVQUFVOztBQUU1QixtQkFBbUI7QUFDbkIsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjs7QUFFQSxxQkFBcUI7QUFDckIsbUJBQW1COztBQUVuQjs7QUFFQTs7QUFFQSxxQkFBcUIsVUFBVTs7QUFFL0I7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixRQUFROztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrSEFBK0g7QUFDL0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNEJBQTRCLGVBQWU7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0MsT0FBTzs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLG9DQUFvQyxPQUFPOztBQUUzQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxPQUFPOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsT0FBTzs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLE9BQU87O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLCtEQUFlOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsK0RBQWU7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQywrREFBZTs7QUFFekQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLCtEQUFlOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsK0RBQWU7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQywrREFBZTs7QUFFcEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsa0JBQWtCOztBQUV6RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMERBQTBELFFBQVE7O0FBRWxFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMERBQTBELFFBQVE7O0FBRWxFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwREFBMEQsUUFBUTs7QUFFbEU7QUFDQTs7QUFFQSxpREFBaUQsUUFBUTs7QUFFekQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLDZCQUE2Qjs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTtBQUNBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxtREFBbUQsUUFBUTs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxxQkFBcUIsY0FBYzs7QUFFbkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRCxnREFBZ0QsUUFBUTs7QUFFeEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCOztBQUVoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdEQUFnRCxRQUFROztBQUV4RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRCwrQ0FBK0MsT0FBTzs7QUFFdEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0Isa0JBQWtCOztBQUUxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpREFBaUQ7O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxRQUFROztBQUV6RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxRQUFROztBQUV2RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DLFFBQVE7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsbUNBQW1DLFFBQVE7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFROztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLG1DQUFtQyxRQUFROztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0RBQW9EO0FBQ3BEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlHQUFpRztBQUNqRyxpR0FBaUc7QUFDakcsNEZBQTRGO0FBQzVGLGdHQUFnRztBQUNoRywrRkFBK0Y7QUFDL0YsbUdBQW1HOztBQUVuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDOztBQUVBLHNCQUFzQixhQUFhOztBQUVuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZOztBQUVqQyxzQkFBc0IsWUFBWTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixxQkFBcUI7O0FBRXZDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixnQkFBZ0I7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0I7O0FBRXhCLG1DQUFtQyw2RUFBNkUsR0FBRzs7QUFFbkgscUNBQXFDLDhDQUE4QyxHQUFHOztBQUV0Rjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLHlFQUF5RTtBQUNwRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0VBQWdFOztBQUVoRTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQjtBQUNsQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVUsa0NBQWtDOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMsT0FBTzs7QUFFcEQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsYUFBYTs7QUFFakM7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLFlBQVk7O0FBRWhDLHFCQUFxQixZQUFZOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUhBQXFIOztBQUVySCwyRkFBMkYsZ0NBQWdDLHVIQUF1SCxLQUFLLGdDQUFnQywyREFBMkQsS0FBSyxrREFBa0QsZ0hBQWdILDZEQUE2RCxzSEFBc0gsMklBQTJJLG1EQUFtRCxzRUFBc0Usb0RBQW9ELHVMQUF1TCx3R0FBd0csOENBQThDLEtBQUs7O0FBRXR6Qyx1R0FBdUc7O0FBRXZHLGdGQUFnRjs7QUFFaEYsNktBQTZLLHlDQUF5Qyx1REFBdUQ7O0FBRTdRLCtFQUErRTs7QUFFL0UsbUlBQW1JLHVEQUF1RCxxRkFBcUYsdUZBQXVGLHFJQUFxSSxpSEFBaUg7O0FBRTVsQix1RUFBdUUsaUNBQWlDOztBQUV4RywyRUFBMkUsNENBQTRDLGdEQUFnRCxxREFBcUQsMkJBQTJCLHVCQUF1Qix1QkFBdUIsZ0VBQWdFLG9FQUFvRSxvRUFBb0Usb0VBQW9FLG9DQUFvQyxLQUFLLDhFQUE4RSwrQ0FBK0MsMERBQTBELHVCQUF1Qix1QkFBdUIsdUJBQXVCLHNFQUFzRSxLQUFLOztBQUVqNkIsaUdBQWlHOztBQUVqRyx3REFBd0QsdURBQXVEOztBQUUvRyw2REFBNkQsaUVBQWlFOztBQUU5SCw2Q0FBNkMsZ0JBQWdCLEdBQUcsd0VBQXdFLCtFQUErRSxHQUFHLHNKQUFzSixtREFBbUQscURBQXFELHNEQUFzRCxvREFBb0QsdUNBQXVDLCtDQUErQyx5QkFBeUIsSUFBSTs7QUFFcnJCLHNOQUFzTix5Q0FBeUMscUNBQXFDLGlFQUFpRSxLQUFLLGtFQUFrRSx5R0FBeUcsS0FBSyxvRUFBb0Usd0ZBQXdGLEtBQUssbURBQW1ELDRDQUE0Qyw0REFBNEQsNERBQTRELDREQUE0RCwwR0FBMEcseUlBQXlJLHVCQUF1QixxQ0FBcUMsaUJBQWlCLEtBQUssaUhBQWlILGFBQWEsaUdBQWlHLDRGQUE0Riw0Q0FBNEMsZ0NBQWdDLDJCQUEyQixPQUFPLDRDQUE0Qyw2REFBNkQsa0RBQWtELDZCQUE2Qix3QkFBd0Isb0RBQW9ELCtCQUErQixtRUFBbUUsdURBQXVELGlEQUFpRCwrQkFBK0IsMkRBQTJELDJEQUEyRCwyREFBMkQsdUVBQXVFLHVDQUF1QyxtREFBbUQsK0JBQStCLDREQUE0RCx5QkFBeUIsYUFBYSwwQkFBMEIsdUJBQXVCLFFBQVEsUUFBUSxtQkFBbUIsOEVBQThFLHFCQUFxQixPQUFPLG1DQUFtQyxLQUFLOztBQUVsMkYsNkVBQTZFLDRCQUE0QixzQkFBc0Isc0NBQXNDLHNDQUFzQyxpRUFBaUUsK0VBQStFLCtFQUErRSw4QkFBOEIsS0FBSyw2RkFBNkYsdURBQXVELHVEQUF1RCwwQkFBMEIscUNBQXFDLHFDQUFxQyxzREFBc0Qsa0VBQWtFLDBEQUEwRCxLQUFLOztBQUVuN0IsMEVBQTBFLDBFQUEwRSw4QkFBOEIsc0RBQXNELDJCQUEyQixRQUFRLG9DQUFvQyxzRUFBc0UsMkRBQTJELDJGQUEyRiwwQ0FBMEMsT0FBTyx1SEFBdUgsOEVBQThFLHlCQUF5QixRQUFRLHNDQUFzQyx3RUFBd0UsNkRBQTZELHdHQUF3RyxTQUFTLDZFQUE2RSxnREFBZ0QsMkNBQTJDLCtEQUErRCwyQkFBMkIsUUFBUSxvQ0FBb0MsaUVBQWlFLE9BQU8sOEdBQThHLDhFQUE4RSx5QkFBeUIsUUFBUSxzQ0FBc0MsNkVBQTZFLFNBQVMsOERBQThEOztBQUUzMEQsK0ZBQStGLHVEQUF1RDs7QUFFdEosNkZBQTZGOztBQUU3Riw4RkFBOEY7O0FBRTlGLCtFQUErRSwyREFBMkQ7O0FBRTFJLGlGQUFpRixvREFBb0Q7O0FBRXJJLCtFQUErRSx3SEFBd0g7O0FBRXZNLDJFQUEyRSx5SEFBeUgsOENBQThDLHlFQUF5RSx3RkFBd0Ysb0NBQW9DOztBQUV2Yix3WEFBd1gsYUFBYSxpQ0FBaUMsYUFBYSxtQ0FBbUMsZUFBZSxtQ0FBbUMsZ0JBQWdCLGVBQWUsa0NBQWtDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLHdDQUF3Qyw4REFBOEQsbUVBQW1FLGtDQUFrQyxHQUFHLGlFQUFpRSxxQkFBcUIsZ0RBQWdELDRDQUE0Qyx1REFBdUQsS0FBSyxnQ0FBZ0MsZUFBZSxtQkFBbUIsaUJBQWlCLElBQUkseUJBQXlCLHVCQUF1Qix3QkFBd0IseUJBQXlCLDBCQUEwQixJQUFJLGlEQUFpRCxrRUFBa0UsMERBQTBELEdBQUcsaUVBQWlFLDBEQUEwRCxHQUFHLHlDQUF5QyxhQUFhLG9EQUFvRCxvREFBb0Qsb0RBQW9ELGVBQWUsR0FBRyx3Q0FBd0MsaUVBQWlFLCtCQUErQixHQUFHLHNDQUFzQyxnQ0FBZ0MsR0FBRyxrQ0FBa0MsMERBQTBELHVFQUF1RSx3QkFBd0IsR0FBRyxtREFBbUQsd0NBQXdDLEdBQUcsZ0ZBQWdGLG9FQUFvRSxzREFBc0QsR0FBRyxrRkFBa0Ysb0VBQW9FLHNEQUFzRCxJQUFJOztBQUV6dUYsdUtBQXVLLDJDQUEyQyx5QkFBeUIsOENBQThDLDZGQUE2RiwyREFBMkQsUUFBUSxNQUFNLDZGQUE2RiwyREFBMkQsT0FBTyxrQkFBa0IsS0FBSyw4Q0FBOEMsY0FBYywwQkFBMEIsbUVBQW1FLFFBQVEseUJBQXlCLHVFQUF1RSxRQUFRLHlCQUF5QixxRUFBcUUsUUFBUSx5QkFBeUIscUVBQXFFLFFBQVEseUJBQXlCLHFFQUFxRSxRQUFRLE1BQU0sbUVBQW1FLE9BQU8sZ0NBQWdDLEtBQUssMkVBQTJFLHdDQUF3QyxnRUFBZ0UsaURBQWlELHNDQUFzQywwRUFBMEUseUJBQXlCLHlCQUF5QixvQkFBb0IsT0FBTyw4QkFBOEIsbURBQW1ELDBEQUEwRCxpQ0FBaUMsa0NBQWtDLHlHQUF5RyxzREFBc0QsaUJBQWlCLDhTQUE4UyxzQkFBc0IscUNBQXFDLDRHQUE0RyxRQUFRLG9DQUFvQyw0R0FBNEcsUUFBUSxvQ0FBb0MsNEdBQTRHLFFBQVEsb0NBQW9DLDRHQUE0RyxRQUFRLE1BQU0sK0NBQStDLEtBQUssaUJBQWlCLEtBQUssNkVBQTZFLGtGQUFrRixnQ0FBZ0Msa0NBQWtDLGdFQUFnRSwwQkFBMEIsbUNBQW1DLFFBQVEsTUFBTSx3RUFBd0Usd0RBQXdELE9BQU8sS0FBSzs7QUFFampILGtFQUFrRSxnRUFBZ0Usa0VBQWtFLDJHQUEyRywrQ0FBK0MseUVBQXlFLDhFQUE4RSwyR0FBMkcsK0NBQStDLHlFQUF5RSx5RUFBeUUsK0RBQStELCtHQUErRyxxRUFBcUU7O0FBRXBoQyxtR0FBbUcsb0NBQW9DLG1DQUFtQzs7QUFFMUsscU1BQXFNOztBQUVyTSxvSEFBb0gsK0NBQStDOztBQUVuSyx5RkFBeUY7O0FBRXpGLDhFQUE4RTs7QUFFOUUsK01BQStNLHdMQUF3TCxxREFBcUQseUVBQXlFLEdBQUcscURBQXFELHlFQUF5RSxHQUFHLDRDQUE0QyxpQkFBaUIsR0FBRywwQ0FBMEMsdUtBQXVLLEdBQUcsd0NBQXdDLGlCQUFpQixHQUFHLHNDQUFzQyxxQ0FBcUMsR0FBRzs7QUFFdmlDLHVGQUF1Riw2QkFBNkIsbUhBQW1ILFFBQVEsTUFBTSxvRUFBb0UsT0FBTyx5RUFBeUUsa0dBQWtHLDJGQUEyRixzREFBc0Qsb0pBQW9KLDJDQUEyQyx1SkFBdUosa0lBQWtJLDhHQUE4Rzs7QUFFbHNDLHNGQUFzRiw2QkFBNkIsZ0NBQWdDLDREQUE0RCx3Q0FBd0M7O0FBRXZQLDRFQUE0RSxpTUFBaU0sb0NBQW9DLHFDQUFxQzs7QUFFdFYsa1BBQWtQLHFDQUFxQyxvQ0FBb0M7O0FBRTNULHNHQUFzRyxtQ0FBbUMsNkJBQTZCLHFIQUFxSCxRQUFRLE1BQU0seUVBQXlFLE9BQU8sb0ZBQW9GLDZGQUE2RixzRkFBc0Y7O0FBRWhvQiwrREFBK0Q7O0FBRS9ELGlFQUFpRTs7QUFFakUsNElBQTRJLDBFQUEwRSw4RUFBOEU7O0FBRXBTLGlFQUFpRSw0QkFBNEIsa0RBQWtELHFDQUFxQywyQkFBMkI7O0FBRS9NLHlGQUF5RiwwRUFBMEUsZ0RBQWdELGdEQUFnRCxpRkFBaUYsK0NBQStDLDRGQUE0RixhQUFhOztBQUU1ZSxnRkFBZ0Ysb0NBQW9DOztBQUVwSCx3REFBd0QsMkNBQTJDLCtDQUErQzs7QUFFbEosK0RBQStELDBCQUEwQixzQkFBc0IsMkJBQTJCLElBQUksNFFBQTRRLDJFQUEyRSxnREFBZ0QsdUZBQXVGLEdBQUcsMlFBQTJRLHlGQUF5RixHQUFHOztBQUV0OUIsb0RBQW9ELGlDQUFpQyxrRUFBa0UsaUZBQWlGLG1EQUFtRCxpREFBaUQsdURBQXVELHVEQUF1RCx1REFBdUQsMkRBQTJELDJEQUEyRCxvRUFBb0UsMkRBQTJELGlFQUFpRSxrQkFBa0IsR0FBRyx1RkFBdUYsdUVBQXVFLG1FQUFtRSxzQkFBc0IsR0FBRyxxRUFBcUUsd0NBQXdDLHNCQUFzQixHQUFHLDZIQUE2SCxtRkFBbUYsaUNBQWlDLDBGQUEwRixLQUFLLDJCQUEyQixHQUFHLG9IQUFvSCxpRUFBaUUsR0FBRyxxREFBcUQscUJBQXFCLGlCQUFpQixNQUFNLGlFQUFpRSx5R0FBeUcsMkNBQTJDLG1EQUFtRCwyQkFBMkIsS0FBSyx5REFBeUQsb0JBQW9CLGlCQUFpQixxQkFBcUIsa0JBQWtCLE1BQU0sdURBQXVELHVIQUF1SCw0REFBNEQsNkNBQTZDLDhDQUE4QyxxQ0FBcUMsb0dBQW9HLHFEQUFxRCxLQUFLLHVEQUF1RCxvQkFBb0IscUJBQXFCLGlCQUFpQixxQkFBcUIsa0JBQWtCLG9CQUFvQix3QkFBd0IsTUFBTSxvREFBb0Qsb0hBQW9ILDJEQUEyRCw2Q0FBNkMsbUVBQW1FLHVHQUF1RyxvQ0FBb0MsZ0RBQWdELHdEQUF3RCxvR0FBb0csdURBQXVELFFBQVEsTUFBTSxrQ0FBa0MsOEJBQThCLE9BQU8sS0FBSyxnRUFBZ0UsaUJBQWlCLG9CQUFvQixxQkFBcUIsc0JBQXNCLE1BQU0sNEJBQTRCLDBCQUEwQixpRUFBaUUsNkRBQTZELHFCQUFxQixvQkFBb0IsdUJBQXVCLE1BQU0sZ0VBQWdFLG1HQUFtRyx1REFBdUQsa0RBQWtELDRGQUE0Rix3QkFBd0IsS0FBSzs7QUFFeGhKLHlHQUF5RywyR0FBMkcsc0ZBQXNGLHNEQUFzRCxzQ0FBc0MsaUJBQWlCLGtHQUFrRyx1RkFBdUYsa0ZBQWtGLHlFQUF5RSwyRkFBMkYsaURBQWlELHNDQUFzQyxpQkFBaUIsMkxBQTJMLDBGQUEwRixtRUFBbUUsc0hBQXNILGtFQUFrRSwwQ0FBMEMscUJBQXFCOztBQUU3L0Msa0RBQWtELDJDQUEyQzs7QUFFN0YsNERBQTRELHVCQUF1QixzQkFBc0IsSUFBSSxzUUFBc1EseUdBQXlHLHVGQUF1RixHQUFHLHFRQUFxUSx5RkFBeUYsR0FBRzs7QUFFdjVCLHlEQUF5RCwyQ0FBMkMsb0NBQW9DLHlDQUF5QywrQ0FBK0M7O0FBRWhPLDZEQUE2RCw2QkFBNkIsc0JBQXNCLHVCQUF1Qiw0QkFBNEIsMkJBQTJCLElBQUksa1JBQWtSLDJFQUEyRSxnREFBZ0QsdUZBQXVGLDRNQUE0TSxHQUFHLGlSQUFpUix5RkFBeUYsR0FBRzs7QUFFbHVDLDBEQUEwRCx1RUFBdUUseUZBQXlGLDhEQUE4RCxzREFBc0Qsd0NBQXdDLHNEQUFzRCxtQ0FBbUMsK0VBQStFLCtDQUErQyx3SEFBd0gsa0pBQWtKLDhGQUE4RixtREFBbUQsNkNBQTZDLGlDQUFpQyw2TUFBNk0sMkZBQTJGLCtCQUErQixpRUFBaUUscURBQXFELHdDQUF3QyxnQ0FBZ0Msb0dBQW9HLG1KQUFtSixrRUFBa0UsMkVBQTJFLHFEQUFxRCwwRUFBMEUsb0VBQW9FLHVFQUF1RSw2Q0FBNkMsNEdBQTRHLHNQQUFzUCwyRUFBMkUseUVBQXlFLDJHQUEyRywyRUFBMkUseUhBQXlILHlMQUF5TCw4RUFBOEUsaUhBQWlILG1EQUFtRCwwREFBMEQsc0NBQXNDLHFDQUFxQyxNQUFNLE1BQU0seUNBQXlDLDREQUE0RCxLQUFLLDBGQUEwRiwrRUFBK0UsK0VBQStFOztBQUV6N0gsOERBQThELHNCQUFzQixvQkFBb0IsdUJBQXVCLHNCQUFzQixxQkFBcUIsOENBQThDLCtCQUErQix1QkFBdUIseUJBQXlCLDREQUE0RCwyQkFBMkIsaUNBQWlDLDhCQUE4Qix5QkFBeUIsb0RBQW9ELDJCQUEyQix3Q0FBd0MsOERBQThELDhCQUE4QixzQkFBc0IsZ0NBQWdDLDRCQUE0QiwwREFBMEQsbUJBQW1CLHVCQUF1Qix1QkFBdUIsY0FBYyw2Q0FBNkMsK0NBQStDLHlDQUF5QywwQ0FBMEMsbUZBQW1GLCtDQUErQyx1QkFBdUIsbURBQW1ELHFEQUFxRCxHQUFHLG1HQUFtRyw2QkFBNkIsaUVBQWlFLGlFQUFpRSx5Q0FBeUMsR0FBRyw2REFBNkQsNkJBQTZCLHFEQUFxRCw4Q0FBOEMsR0FBRyx3UEFBd1AsaUZBQWlGLGlGQUFpRixrQ0FBa0MseUJBQXlCLEtBQUssK0lBQStJLGlDQUFpQyx3RUFBd0UsbUNBQW1DLHlCQUF5Qiw4Q0FBOEMsS0FBSyxxS0FBcUsscUNBQXFDLHdDQUF3QyxvREFBb0Qsc0NBQXNDLHFEQUFxRCx3REFBd0QsdURBQXVELHVEQUF1RCx3REFBd0QsMkNBQTJDLDZEQUE2RCxzQ0FBc0MsMkJBQTJCLEtBQUssb0lBQW9JLHFDQUFxQyxxQ0FBcUMseUNBQXlDLG9DQUFvQyxtREFBbUQsc0RBQXNELHFEQUFxRCxxREFBcUQsc0RBQXNELHlDQUF5QyxnR0FBZ0csNkZBQTZGLHlEQUF5RCx5REFBeUQsMERBQTBELHlEQUF5RCx5REFBeUQsc0hBQXNILGlGQUFpRixzRUFBc0Usc0NBQXNDLG1DQUFtQyxHQUFHLDZFQUE2RSxnQ0FBZ0MsMERBQTBELDBDQUEwQywwQ0FBMEMscURBQXFELG1DQUFtQyxjQUFjLEdBQUcsd0RBQXdELDBCQUEwQixxREFBcUQsR0FBRyx1RUFBdUUsNEJBQTRCLHVCQUF1Qiw0REFBNEQsZ0RBQWdELG9CQUFvQiwrRkFBK0YsNENBQTRDLEdBQUcsNkhBQTZILGdEQUFnRCxnREFBZ0QsdUNBQXVDLDJFQUEyRSxnQkFBZ0IsMENBQTBDLDBCQUEwQix5REFBeUQscUJBQXFCLGdEQUFnRCxnREFBZ0QsZ0RBQWdELGdEQUFnRCwyQ0FBMkMsMkNBQTJDLDJDQUEyQywyQ0FBMkMsd0NBQXdDLDZFQUE2RSw2RUFBNkUsNkVBQTZFLDZFQUE2RSxtRUFBbUUsMEJBQTBCLEdBQUcsNkVBQTZFLG9DQUFvQyxpQ0FBaUMsZ0NBQWdDLGdEQUFnRCw0RUFBNEUsR0FBRywrQ0FBK0MseUVBQXlFLEdBQUcsMElBQTBJLG1EQUFtRCxzREFBc0QscURBQXFELHFEQUFxRCxpREFBaUQsd0NBQXdDLGtDQUFrQyxHQUFHLHVHQUF1RyxxREFBcUQscUNBQXFDLCtHQUErRywyR0FBMkcsOEZBQThGLDBDQUEwQyxHQUFHLDJGQUEyRixxREFBcUQsMERBQTBELG9EQUFvRCxpQ0FBaUMsc0VBQXNFLGtEQUFrRCxlQUFlLEdBQUcsMEpBQTBKLHVEQUF1RCx1REFBdUQsR0FBRyxnVEFBZ1QsMk5BQTJOLCtEQUErRCwyRkFBMkYsdUNBQXVDLDZEQUE2RCw4QkFBOEIsMEJBQTBCLDZDQUE2QyxrREFBa0QsNEJBQTRCLDhCQUE4QixHQUFHLHlUQUF5VCxtQ0FBbUMscUNBQXFDLHVDQUF1Qyw2Q0FBNkMsK0NBQStDLGlEQUFpRCw0Q0FBNEMsMkNBQTJDLDJCQUEyQiwwREFBMEQsd0RBQXdELDBEQUEwRCwwREFBMEQscURBQXFELHVDQUF1Qyx1Q0FBdUMsd0hBQXdILHlHQUF5RywwSEFBMEgsOElBQThJLEtBQUssc1JBQXNSLDJFQUEyRSxnREFBZ0QsZ0hBQWdILHNEQUFzRCxnSkFBZ0osMkxBQTJMLHlJQUF5SSx1RkFBdUYsR0FBRyw2UUFBNlEseUZBQXlGLEdBQUcsc1VBQXNVLHFOQUFxTix5S0FBeUssa0RBQWtELHVDQUF1QywrREFBK0QsNlBBQTZQLDhLQUE4Syx3RUFBd0UsMkhBQTJILG1FQUFtRSxrRkFBa0YseUVBQXlFLEdBQUcscVZBQXFWLGtIQUFrSCxHQUFHOztBQUVsZ2UsdUVBQXVFLCtCQUErQiwyRkFBMkYsNkNBQTZDLG9FQUFvRSw4RkFBOEYsaURBQWlELGlDQUFpQyxNQUFNLE1BQU0sOERBQThELEtBQUssdUNBQXVDLG1KQUFtSix5RkFBeUYsS0FBSyxvQ0FBb0MsZ0ZBQWdGLHFHQUFxRyw0REFBNEQsc0JBQXNCLFFBQVEsb0NBQW9DLHFFQUFxRSx1SUFBdUksMlNBQTJTLGlKQUFpSixLQUFLLGdIQUFnSCxtQkFBbUIsd0JBQXdCLHdCQUF3QixrR0FBa0csNERBQTRELHFCQUFxQixRQUFRLGtDQUFrQyxtRUFBbUUsNGZBQTRmLHlGQUF5Rix5RkFBeUYsbUdBQW1HLGlMQUFpTCwyTkFBMk4saUpBQWlKLEtBQUssNkhBQTZILCtHQUErRyw0REFBNEQsb0JBQW9CLFFBQVEsZ0RBQWdELCtEQUErRCxpSkFBaUosK1BBQStQLGlKQUFpSixLQUFLLHNJQUFzSSxrREFBa0QsMEJBQTBCLFFBQVEsMENBQTBDLGdKQUFnSixLQUFLLDJHQUEyRyxxRUFBcUUsNkdBQTZHLCtGQUErRixxQkFBcUIsUUFBUSw0RkFBNEYsT0FBTyxtSEFBbUgseUNBQXlDOztBQUU3akwsa0pBQWtKLHNFQUFzRSx1Q0FBdUMsMEpBQTBKLHFQQUFxUCxpR0FBaUcscUpBQXFKOztBQUVwNEIsdU1BQXVNLHdOQUF3Tjs7QUFFL1osK0pBQStKOztBQUUvSiwrRkFBK0YsNkJBQTZCLGlDQUFpQzs7QUFFN0osa0ZBQWtGLGlDQUFpQzs7QUFFbkgscUZBQXFGLHNFQUFzRTs7QUFFM0osMEZBQTBGLDhSQUE4UixzREFBc0Q7O0FBRTlhLGlFQUFpRTs7QUFFakUsa0lBQWtJLGdHQUFnRywyRUFBMkUsK0VBQStFOztBQUU1WCxtRkFBbUYsMkZBQTJGLDREQUE0RCw0REFBNEQ7O0FBRXRTLCtEQUErRCw4RkFBOEYsd0NBQXdDOztBQUVyTSw0RkFBNEY7O0FBRTVGLDZHQUE2RyxnR0FBZ0cscUJBQXFCLHdCQUF3QixRQUFRLGlHQUFpRyxLQUFLOztBQUV4Vyw4RkFBOEYscUJBQXFCLHdCQUF3QixRQUFRLDBKQUEwSiwwSkFBMEosaUJBQWlCOztBQUV4ZCw4RkFBOEYscUJBQXFCLHdCQUF3QixRQUFRLDhIQUE4SCxLQUFLOztBQUV0UixtSUFBbUksZ0VBQWdFLHlEQUF5RCwwQ0FBMEMsbUdBQW1HLDBFQUEwRSxxREFBcUQseURBQXlELHNEQUFzRCwyREFBMkQsS0FBSzs7QUFFdnJCLDZGQUE2RixxQkFBcUIsd0JBQXdCLFFBQVEsNkhBQTZILEtBQUs7O0FBRXBSLGdGQUFnRix5REFBeUQscUNBQXFDLGlEQUFpRCw4Q0FBOEMscURBQXFELHNPQUFzTyw4T0FBOE8sbUdBQW1HLDhCQUE4Qix5SkFBeUosNkZBQTZGLG9HQUFvRywrQkFBK0IscURBQXFEOztBQUVyMEMsOEhBQThILDZDQUE2Qyx1RUFBdUUsMERBQTBELGtIQUFrSCwyQkFBMkIscUNBQXFDLG1IQUFtSDs7QUFFamxCLHdFQUF3RSxrREFBa0QsOEJBQThCOztBQUV4SixzRUFBc0Usa0RBQWtELDhCQUE4Qjs7QUFFdEoscUZBQXFGLHVFQUF1RSx1RUFBdUU7O0FBRW5PLG1GQUFtRiw2QkFBNkIsd0VBQXdFLDROQUE0TixvQ0FBb0Msb0NBQW9DLCtCQUErQiwrQkFBK0IseUJBQXlCLG1DQUFtQyxtQ0FBbUMsK0NBQStDLCtDQUErQyxrREFBa0QsOERBQThELDZDQUE2QyxLQUFLOztBQUV6M0IseUdBQXlHOztBQUV6RyxvS0FBb0ssNkNBQTZDLHdEQUF3RDs7QUFFelEseUZBQXlGLGlGQUFpRixzQ0FBc0MsdUZBQXVGOztBQUV2UywrRkFBK0YsMkZBQTJGOztBQUUxTCwyREFBMkQsZ0ZBQWdGLCtEQUErRDs7QUFFMU0sNkRBQTZELDJDQUEyQyxHQUFHLCtDQUErQywrQkFBK0IsR0FBRyx3Q0FBd0MsMENBQTBDLHlFQUF5RSx1RUFBdUUsc0NBQXNDLDRDQUE0QyxpREFBaUQsaUNBQWlDLHlCQUF5QixHQUFHLDhDQUE4QyxtQ0FBbUMsR0FBRywwQ0FBMEMsbUNBQW1DLEdBQUcsa0RBQWtELHVEQUF1RCxHQUFHLGtDQUFrQywwRUFBMEUsa0VBQWtFLEdBQUcsb0NBQW9DLGdFQUFnRSxHQUFHLG1HQUFtRyw2Q0FBNkMsR0FBRyxtR0FBbUcseUNBQXlDLEdBQUcsa0dBQWtHLG1FQUFtRSxHQUFHLGtHQUFrRyw2REFBNkQsR0FBRzs7QUFFbHZELHFHQUFxRzs7QUFFckcsaUVBQWlFLGtFQUFrRSw0RUFBNEUsb0RBQW9ELDhDQUE4Qzs7QUFFalQsK0ZBQStGOztBQUUvRixpRkFBaUYsb0RBQW9ELGdGQUFnRiwrRkFBK0Ysc0NBQXNDLEtBQUs7O0FBRS9WLCtEQUErRCw4RkFBOEYsd0NBQXdDOztBQUVyTSw0RkFBNEY7O0FBRTVGLHNIQUFzSCwrRkFBK0YscUlBQXFJLG9FQUFvRSxxQ0FBcUMseUJBQXlCLCtCQUErQiwyQkFBMkIsMkJBQTJCLFFBQVEsc0ZBQXNGLDRHQUE0Ryw4QkFBOEIseUJBQXlCLCtCQUErQiwyQkFBMkIsMkJBQTJCLFFBQVEseUVBQXlFLCtHQUErRyxnRUFBZ0UsK0JBQStCLHlCQUF5QiwrQkFBK0IsMkJBQTJCLDJCQUEyQiwrQkFBK0IsOEJBQThCLFFBQVEsNEVBQTRFLGtGQUFrRiwyRUFBMkUsS0FBSyw2REFBNkQsMERBQTBELEtBQUssZ0VBQWdFLDRCQUE0Qiw4REFBOEQsMkRBQTJELGdDQUFnQyxtREFBbUQseUVBQXlFLGtGQUFrRixnR0FBZ0csOEVBQThFLE9BQU8sdUJBQXVCLEtBQUssd0hBQXdILHlCQUF5Qix1Q0FBdUMsa0NBQWtDLG9IQUFvSCwyREFBMkQsMEJBQTBCLDRGQUE0RixpREFBaUQsaURBQWlELGlEQUFpRCxpREFBaUQsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLG1pREFBbWlELG1HQUFtRywrQkFBK0IsK0JBQStCLGlDQUFpQyxtREFBbUQsNEJBQTRCLG8rQ0FBbytDLGdIQUFnSCx5RkFBeUYsbUJBQW1CLG9CQUFvQixLQUFLLCtDQUErQywyQkFBMkIscUVBQXFFLDBCQUEwQixvREFBb0QseUJBQXlCLDRDQUE0QywyQ0FBMkMsa0NBQWtDLHVEQUF1RCxRQUFRLGlDQUFpQyxrQ0FBa0MsNkNBQTZDLFFBQVEsaUNBQWlDLGtDQUFrQywyQ0FBMkMscUNBQXFDLE9BQU8sZ0VBQWdFLEtBQUssNEtBQTRLLHlCQUF5Qiw2Q0FBNkMsb0VBQW9FLGdIQUFnSCx5R0FBeUcsdUJBQXVCLGlEQUFpRCw0RUFBNEUsb0xBQW9MLG8xQkFBbzFCLGlHQUFpRyxxQkFBcUIsb0JBQW9CLEtBQUs7O0FBRTl0UyxvSEFBb0gsMERBQTBELG1JQUFtSSxvRUFBb0UscUNBQXFDLHlCQUF5QiwrQkFBK0IsMkJBQTJCLDJCQUEyQixRQUFRLHNGQUFzRiwwRUFBMEUseUJBQXlCLCtCQUErQiwyQkFBMkIsMkJBQTJCLFFBQVEseUVBQXlFLDZHQUE2RyxnRUFBZ0UsK0JBQStCLHlCQUF5QiwrQkFBK0IsMkJBQTJCLDJCQUEyQiwrQkFBK0IsOEJBQThCLFFBQVEsNEVBQTRFOztBQUUxekMsaVBBQWlQLDZCQUE2Qiw2SEFBNkgsMkJBQTJCLFFBQVEsMkhBQTJILDBGQUEwRixPQUFPLGdJQUFnSSw2QkFBNkIsUUFBUSxxSEFBcUgsOEVBQThFLE9BQU8sZ0lBQWdJLDJCQUEyQixRQUFRLDBDQUEwQyxvTEFBb0wsb0ZBQW9GLEtBQUs7O0FBRW45Qyx1REFBdUQsdUJBQXVCLHFHQUFxRyxrREFBa0QsMkJBQTJCLFFBQVEsc0RBQXNELHVNQUF1TSxLQUFLLHFHQUFxRyxrREFBa0QsNEJBQTRCLFFBQVEsd0NBQXdDLG1LQUFtSyxLQUFLLHdHQUF3RyxrREFBa0QsNkJBQTZCLFFBQVEsMENBQTBDLHVPQUF1TyxLQUFLLGlFQUFpRSxHQUFHOztBQUU5NkMsMkZBQTJGLGlEQUFpRCxpREFBaUQsaURBQWlEOztBQUU5TywyRUFBMkUsbUNBQW1DLHdDQUF3Qyw0Q0FBNEMsaURBQWlELDJCQUEyQix1QkFBdUIsdUJBQXVCLDREQUE0RCxnRUFBZ0UsZ0VBQWdFLGdFQUFnRSxvQ0FBb0MsS0FBSzs7QUFFam1CLHNHQUFzRywrQkFBK0Isb0RBQW9ELG9EQUFvRCxvREFBb0Qsb0RBQW9ELHNEQUFzRDs7QUFFM1ksOEVBQThFLDBDQUEwQywwQ0FBMEMsMENBQTBDLDBDQUEwQyw2REFBNkQsc0VBQXNFLGdHQUFnRzs7QUFFemQsbURBQW1ELDBGQUEwRix1Q0FBdUMsa0NBQWtDOztBQUV0Tix5RkFBeUY7O0FBRXpGLDhHQUE4Rzs7QUFFOUcseUlBQXlJLHdDQUF3QyxtREFBbUQsR0FBRywwQ0FBMEMsaUNBQWlDLHVEQUF1RCxHQUFHLGlEQUFpRCxpQ0FBaUMsOENBQThDLDRHQUE0RyxHQUFHLCtCQUErQixpREFBaUQseURBQXlELGlCQUFpQixHQUFHLDRDQUE0Qyw4SkFBOEosd0tBQXdLLHVDQUF1QyxpQ0FBaUMsa0NBQWtDLGtDQUFrQyw2QkFBNkIsR0FBRywwS0FBMEssOEpBQThKLDJDQUEyQyxvQkFBb0Isc0JBQXNCLDhJQUE4SSxHQUFHLHFDQUFxQyw4UEFBOFAsd1JBQXdSLHNDQUFzQyxrQ0FBa0MsaUNBQWlDLGtEQUFrRCxtQ0FBbUMsZ0NBQWdDLHdCQUF3QiwyREFBMkQscUNBQXFDLDhDQUE4QyxvQ0FBb0MsMERBQTBELGtEQUFrRCxxQ0FBcUMsaUJBQWlCLEdBQUcseUNBQXlDLDhDQUE4QyxvQ0FBb0MsaUNBQWlDLHNEQUFzRCxzREFBc0Qsb0JBQW9CLHlEQUF5RCxnREFBZ0Qsb0NBQW9DLGlFQUFpRSw0QkFBNEIsbUVBQW1FLDRDQUE0QyxHQUFHLHlDQUF5QyxlQUFlOztBQUU1bkgsNkZBQTZGLHFDQUFxQyxtQ0FBbUMsdURBQXVELGlEQUFpRCxnSEFBZ0gsOEdBQThHLHdDQUF3QywrQ0FBK0MsNkRBQTZELDhUQUE4VCx5R0FBeUcsK0VBQStFOztBQUVybkMsd0ZBQXdGLDRCQUE0QixzQ0FBc0Msa0NBQWtDLHNFQUFzRSwwRUFBMEUsbURBQW1ELDZDQUE2Qyw2QkFBNkIsa0NBQWtDLGdDQUFnQyx5QkFBeUIsdUVBQXVFLEtBQUsseUJBQXlCLGtFQUFrRSxLQUFLLHdCQUF3Qiw2RUFBNkUsS0FBSyx5QkFBeUIsMkNBQTJDLEtBQUsseUJBQXlCLCtCQUErQixLQUFLLHlCQUF5QiwrQkFBK0IsS0FBSyx5QkFBeUIscURBQXFELEtBQUsseUJBQXlCLG1EQUFtRCxLQUFLLHVFQUF1RSxtQ0FBbUMsNkJBQTZCLDZCQUE2Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4QiwwRUFBMEUsMEVBQTBFLDBFQUEwRSwwRUFBMEUsa01BQWtNLEtBQUssa0VBQWtFLGlFQUFpRSx1RUFBdUUsd0NBQXdDLHdDQUF3Qyx5RkFBeUYsd0ZBQXdGLG1EQUFtRCxLQUFLLGdKQUFnSix3RUFBd0Usc0JBQXNCLDREQUE0RCw0REFBNEQsNERBQTRELG9FQUFvRSxLQUFLLCtFQUErRSw0REFBNEQsS0FBSyx5R0FBeUcsNEZBQTRGLHlFQUF5RSxLQUFLLHVJQUF1SSwyQ0FBMkMsMkJBQTJCLFFBQVEsTUFBTSxxRkFBcUYsb0ZBQW9GLDJCQUEyQixPQUFPLEtBQUssdWJBQXViLDRCQUE0Qix5QkFBeUIseUZBQXlGLG9FQUFvRSx5QkFBeUIsT0FBTyxRQUFRLHFHQUFxRyw2REFBNkQsc0ZBQXNGLHVEQUF1RCxrQ0FBa0Msa0NBQWtDLDBHQUEwRywwREFBMEQscURBQXFELDhJQUE4SSxTQUFTLGtDQUFrQyxvSEFBb0gsMkRBQTJELDhFQUE4RSxxREFBcUQsZ0NBQWdDLGdDQUFnQyxxRkFBcUYsNkhBQTZILG9GQUFvRiw4RUFBOEUsZ0dBQWdHLDZHQUE2RyxLQUFLOztBQUVscE0sK0ZBQStGLGdEQUFnRCwwREFBMEQsMERBQTBELG9EQUFvRCx3REFBd0QsNERBQTRELGdFQUFnRSxrRUFBa0Usa0VBQWtFLG9FQUFvRSxrRUFBa0UsK0VBQStFLHFGQUFxRixzRUFBc0UseUZBQXlGLHFFQUFxRSw2RUFBNkUsZ0VBQWdFLDJFQUEyRSxtRkFBbUYsOEVBQThFLG9DQUFvQyx3RUFBd0UsaUNBQWlDOztBQUVub0QsNkZBQTZGLHNEQUFzRCx3QkFBd0IsZ0VBQWdFLDZCQUE2QixnRUFBZ0UsNkJBQTZCLDBEQUEwRCwwQkFBMEIsOERBQThELDRCQUE0QixrRUFBa0UsOEJBQThCLDhFQUE4RSxvQ0FBb0Msc0VBQXNFLGdDQUFnQyx3RUFBd0UsaUNBQWlDLHdFQUF3RSxpQ0FBaUMsMEVBQTBFLGtDQUFrQyx3RUFBd0UsaUNBQWlDLHFGQUFxRix1Q0FBdUMsMkZBQTJGLDBDQUEwQywyRUFBMkUsa0NBQWtDLG1GQUFtRixzQ0FBc0MsNEVBQTRFLG1DQUFtQywrRkFBK0YsNENBQTRDLHNFQUFzRSxnQ0FBZ0MsaUZBQWlGLHFDQUFxQyx5RkFBeUYseUNBQXlDLDhFQUE4RSxvQ0FBb0Msd0VBQXdFLGlDQUFpQzs7QUFFNWdGLDhGQUE4Riw2RUFBNkUsaUdBQWlHLGlHQUFpRyxxRkFBcUYsNkZBQTZGLHFHQUFxRyw2SEFBNkgsNkdBQTZHLGlIQUFpSCxpSEFBaUgscUhBQXFILGlIQUFpSCwySUFBMkksdUpBQXVKLHlIQUF5SCwrSkFBK0osdUhBQXVILHVJQUF1SSw2R0FBNkcsbUlBQW1JLG1KQUFtSiw2SEFBNkgsaUhBQWlIOztBQUUvdEYsbU5BQW1OLDRFQUE0RSx3RkFBd0YsMERBQTBEOztBQUVqYixtQ0FBbUMsMkJBQTJCLGVBQWUsNkNBQTZDLGdEQUFnRCxHQUFHOztBQUU3SywwQ0FBMEMsb0NBQW9DLG1CQUFtQixlQUFlLDBDQUEwQyx1T0FBdU8sa0RBQWtELDRCQUE0Qix3RUFBd0U7O0FBRXZoQiwrQ0FBK0Msa0NBQWtDLGtFQUFrRSwwRkFBMEYsR0FBRzs7QUFFaFAsMEVBQTBFLG1FQUFtRSxtQ0FBbUMscUNBQXFDLG9DQUFvQyxrQ0FBa0MsK0JBQStCLHVEQUF1RCx3SkFBd0osa0pBQWtKLDBEQUEwRCxrREFBa0QsNEJBQTRCLHdFQUF3RTs7QUFFMzJCLCtDQUErQyxrQ0FBa0Msa0VBQWtFLDBGQUEwRixHQUFHOztBQUVoUCw4Q0FBOEMsc0JBQXNCLHdCQUF3QiwrQkFBK0IsZUFBZSxnR0FBZ0csNEJBQTRCLDhCQUE4Qix3RUFBd0U7O0FBRTVXLHdUQUF3VCxlQUFlLCtnQkFBK2dCLEdBQUc7O0FBRXoxQix1RUFBdUUscVVBQXFVLGVBQWUsb0NBQW9DLG1HQUFtRyx1UEFBdVAsNEZBQTRGLGtGQUFrRixhQUFhOztBQUVwOUIsZ0VBQWdFLG1QQUFtUCw2Z0JBQTZnQixHQUFHOztBQUVuMEIscUVBQXFFLDZCQUE2Qiw0QkFBNEIsOEJBQThCLHVRQUF1USxvQ0FBb0Msa09BQWtPLG9FQUFvRSw0QkFBNEIsMkNBQTJDLEdBQUc7O0FBRXZ6QiwrQ0FBK0Msa0NBQWtDLGtFQUFrRSwyREFBMkQ7O0FBRTlNLGdEQUFnRCwrQkFBK0Isa0NBQWtDLGtEQUFrRCw0Q0FBNEMsb0RBQW9ELHdFQUF3RTs7QUFFM1Usc0NBQXNDLCtCQUErQiw4QkFBOEIsdU9BQXVPLHlDQUF5QyxpVEFBaVQ7O0FBRXBxQix5Q0FBeUMsd0JBQXdCLHlCQUF5QiwwQkFBMEIsOEJBQThCLDJPQUEyTyxpREFBaUQsOEZBQThGLGNBQWMsS0FBSyxxQ0FBcUMsZ0lBQWdJLDRLQUE0Szs7QUFFaDNCLHdWQUF3Vix3cEJBQXdwQjs7QUFFaC9CLHlDQUF5Qyx3QkFBd0IsOENBQThDLG9qQkFBb2pCLGlEQUFpRCxnWEFBZ1gscUZBQXFGLDhGQUE4Riw2REFBNkQsOEZBQThGLHdEQUF3RCwyT0FBMk87O0FBRXJyRCw4REFBOEQsaWJBQWliLDBsQkFBMGxCLHFIQUFxSDs7QUFFOXJDLDBEQUEwRCx3QkFBd0Isd0JBQXdCLDAwQkFBMDBCLGlEQUFpRCxnSkFBZ0osMENBQTBDLHFtQkFBcW1CLDJPQUEyTzs7QUFFLytELDZEQUE2RCxnWEFBZ1gsbW5CQUFtbkIsR0FBRzs7QUFFbmlDLHlEQUF5RCx3QkFBd0IsMkJBQTJCLDZCQUE2QixpZUFBaWUsaURBQWlELHlWQUF5Viw4REFBOEQsaUNBQWlDLHVFQUF1RSxzRUFBc0UsNkVBQTZFLHNFQUFzRSw2TUFBNk07O0FBRWhrRCw4SkFBOEosOFRBQThULDhuQkFBOG5CLFdBQVc7O0FBRXJtQywwREFBMEQsOEhBQThILCtQQUErUCx1REFBdUQsc05BQXNOLDRDQUE0QyxhQUFhOztBQUU3dkIsNERBQTRELGliQUFpYiwwbEJBQTBsQixxSEFBcUg7O0FBRTVyQyx3REFBd0Qsd0JBQXdCLHdCQUF3QiwwQkFBMEIsd0JBQXdCLHcwQkFBdzBCLGlEQUFpRCxnSkFBZ0osMENBQTBDLHFxQkFBcXFCLDJPQUEyTzs7QUFFN2xFLCtEQUErRCx5REFBeUQsMFpBQTBaLDBsQkFBMGxCLHNKQUFzSixXQUFXOztBQUU3d0MsMkhBQTJILHdCQUF3QiwwQkFBMEIsMEJBQTBCLHdCQUF3QixrQ0FBa0MsaUVBQWlFLCtCQUErQix5RUFBeUUsMkZBQTJGLG9FQUFvRSxxQ0FBcUMsNERBQTRELDhEQUE4RCxpQ0FBaUMsOENBQThDLDhDQUE4QyxzREFBc0QsaUNBQWlDLG1FQUFtRSxxRkFBcUYsMkVBQTJFLGtFQUFrRSwrQ0FBK0Msb2lDQUFvaUMsaURBQWlELGdKQUFnSiwwQ0FBMEMsNnNCQUE2c0IseUZBQXlGLGtIQUFrSCw0RkFBNEYsb0dBQW9HLG9IQUFvSCxtRkFBbUYsd0pBQXdKLHVOQUF1Tjs7QUFFN3FJLDJEQUEyRCxrWkFBa1osMGxCQUEwbEIseUZBQXlGOztBQUVob0MsdURBQXVELHdCQUF3Qix3QkFBd0IsOHZCQUE4dkIsaURBQWlELGdKQUFnSiwwQ0FBMEMsK2pCQUErakIsNk1BQTZNOztBQUU1MUQscUNBQXFDLHNCQUFzQix3T0FBd08sNkJBQTZCLHVCQUF1Qix1RUFBdUUseU5BQXlOLGlHQUFpRyxzRUFBc0UsMElBQTBJOztBQUV4NkIseUNBQXlDLHdCQUF3QiwrUkFBK1IsaURBQWlELDRFQUE0RSwyTUFBMk0sNEtBQTRLOztBQUVwMUIsMFBBQTBQLHFkQUFxZDs7QUFFL3NCLHVDQUF1Qyx3QkFBd0IsbVBBQW1QLHlHQUF5RyxtR0FBbUc7O0FBRTlmLHlDQUF5QyxzQkFBc0IscUtBQXFLLDJGQUEyRixlQUFlLDJGQUEyRiwyRkFBMkYsa0dBQWtHLG1EQUFtRCx3RkFBd0YseUJBQXlCLGtHQUFrRyxrR0FBa0cscUNBQXFDLGdEQUFnRCxrR0FBa0c7O0FBRXJvQyx5Q0FBeUMsd0JBQXdCLHNUQUFzVCxpREFBaUQsNEVBQTRFLHFNQUFxTSxpSUFBaUk7O0FBRTF6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYSw0Q0FBNEM7QUFDekQsYUFBYSxZQUFZOztBQUV6QixTQUFTLGFBQWE7QUFDdEIsa0JBQWtCLG9DQUFvQzs7QUFFdEQsY0FBYyxhQUFhO0FBQzNCLHVCQUF1QixvQ0FBb0M7O0FBRTNELGVBQWU7O0FBRWYsRUFBRTs7QUFFRjs7QUFFQSxpQkFBaUIsYUFBYTtBQUM5QiwwQkFBMEI7O0FBRTFCLEVBQUU7O0FBRUY7O0FBRUEsWUFBWSxhQUFhO0FBQ3pCLG9CQUFvQixvQ0FBb0M7QUFDeEQsZ0JBQWdCLFlBQVk7QUFDNUIsa0JBQWtCLFlBQVk7QUFDOUIsU0FBUyxZQUFZO0FBQ3JCLHFCQUFxQixhQUFhOztBQUVsQyxFQUFFOztBQUVGOztBQUVBLFdBQVcsYUFBYTtBQUN4QixvQkFBb0IsVUFBVTtBQUM5QixvQkFBb0I7O0FBRXBCLEVBQUU7O0FBRUY7O0FBRUEsY0FBYyxhQUFhO0FBQzNCLHVCQUF1QixVQUFVO0FBQ2pDLHVCQUF1Qjs7QUFFdkIsRUFBRTs7QUFFRjs7QUFFQSxhQUFhLGFBQWE7QUFDMUIsc0JBQXNCLG9DQUFvQztBQUMxRCxlQUFlOztBQUVmLEVBQUU7O0FBRUY7O0FBRUEsZUFBZSxhQUFhO0FBQzVCLHdCQUF3QixvQ0FBb0M7QUFDNUQsaUJBQWlCOztBQUVqQixFQUFFOztBQUVGOztBQUVBLHFCQUFxQixhQUFhO0FBQ2xDLDhCQUE4QixvQ0FBb0M7QUFDbEUsdUJBQXVCLFVBQVU7QUFDakMsc0JBQXNCOztBQUV0QixFQUFFOztBQUVGOztBQUVBLGlCQUFpQixhQUFhO0FBQzlCLDBCQUEwQjs7QUFFMUIsRUFBRTs7QUFFRjs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQiwyQkFBMkI7O0FBRTNCLEVBQUU7O0FBRUY7O0FBRUEsa0JBQWtCLGFBQWE7QUFDL0IsMkJBQTJCOztBQUUzQixFQUFFOztBQUVGOztBQUVBLGlCQUFpQjs7QUFFakIsRUFBRTs7QUFFRjs7QUFFQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGFBQWEsVUFBVTtBQUN2QixZQUFZLGFBQWE7QUFDekIsY0FBYzs7QUFFZCxFQUFFOztBQUVGOztBQUVBLHVCQUF1QixXQUFXOztBQUVsQyxnQkFBZ0IsV0FBVzs7QUFFM0IsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7O0FBRUwsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CO0FBQ0EsS0FBSzs7QUFFTCwwQkFBMEIsV0FBVztBQUNyQyw2QkFBNkIsV0FBVzs7QUFFeEMsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCO0FBQ0EsS0FBSzs7QUFFTCxzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkI7QUFDQSxLQUFLOztBQUVMLGtCQUFrQixXQUFXO0FBQzdCLG1CQUFtQixXQUFXO0FBQzlCLHFCQUFxQixXQUFXOztBQUVoQyxpQkFBaUI7QUFDakIsWUFBWTtBQUNaLGVBQWU7QUFDZixZQUFZO0FBQ1o7QUFDQSxLQUFLOztBQUVMLHVCQUF1QjtBQUN2QixpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCO0FBQ0EsS0FBSzs7QUFFTCxvQkFBb0IsV0FBVztBQUMvQix1QkFBdUIsV0FBVzs7QUFFbEMsc0JBQXNCO0FBQ3RCLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2Y7QUFDQSxLQUFLOztBQUVMO0FBQ0Esb0JBQW9CO0FBQ3BCLFlBQVk7QUFDWixlQUFlO0FBQ2YsWUFBWTtBQUNaO0FBQ0EsS0FBSzs7QUFFTCxXQUFXLGFBQWE7QUFDeEIsV0FBVzs7QUFFWCxFQUFFOztBQUVGOztBQUVBLGFBQWEsNENBQTRDO0FBQ3pELGFBQWEsWUFBWTtBQUN6QixVQUFVLFlBQVk7QUFDdEIsV0FBVyxZQUFZO0FBQ3ZCLFNBQVMsYUFBYTtBQUN0QixjQUFjLGFBQWE7QUFDM0IsdUJBQXVCLG9DQUFvQztBQUMzRCxlQUFlLFVBQVU7QUFDekIsaUJBQWlCOztBQUVqQixFQUFFOztBQUVGOztBQUVBLGFBQWEsNENBQTRDO0FBQ3pELGFBQWEsWUFBWTtBQUN6QixZQUFZLDhDQUE4QztBQUMxRCxjQUFjLFlBQVk7QUFDMUIsU0FBUyxhQUFhO0FBQ3RCLGtCQUFrQixvQ0FBb0M7QUFDdEQsY0FBYyxhQUFhO0FBQzNCLHVCQUF1QixvQ0FBb0M7QUFDM0QsZUFBZTs7QUFFZjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBNEM7QUFDNUQsZ0JBQWdCLDRDQUE0QztBQUM1RCxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBNEM7QUFDNUQsaUJBQWlCLFlBQVk7QUFDN0IsaUJBQWlCLFlBQVk7QUFDN0IsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsZ0JBQWdCLFVBQVU7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0Esa0JBQWtCLG9DQUFvQztBQUN0RCxVQUFVLGFBQWE7QUFDdkIsMEJBQTBCO0FBQzFCLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGlCQUFpQixZQUFZO0FBQzdCLDJCQUEyQixVQUFVO0FBQ3JDLDBCQUEwQixVQUFVO0FBQ3BDLHlCQUF5QjtBQUN6QixHQUFHOztBQUVIO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLFlBQVk7QUFDeEIsY0FBYztBQUNkLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0NBQW9DO0FBQzdELG9CQUFvQixVQUFVO0FBQzlCLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkNBQTJDO0FBQ3hELGVBQWU7QUFDZixJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixtQkFBbUIsYUFBYTtBQUNoQyw0QkFBNEIsb0NBQW9DO0FBQ2hFLHlCQUF5QixhQUFhO0FBQ3RDLGtDQUFrQyxvQ0FBb0M7QUFDdEUsMkJBQTJCLDBDQUEwQztBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQyw0QkFBNEIsYUFBYTtBQUN6QyxxQ0FBcUMsb0NBQW9DO0FBQ3pFLGlCQUFpQixVQUFVO0FBQzNCLGtCQUFrQixVQUFVO0FBQzVCLHFCQUFxQixhQUFhO0FBQ2xDLDhCQUE4QixvQ0FBb0M7QUFDbEUscUJBQXFCLFlBQVk7QUFDakMsa0NBQWtDLFlBQVk7QUFDOUMsa0NBQWtDLFlBQVk7QUFDOUMsOEJBQThCLGFBQWE7QUFDM0MsdUNBQXVDLG9DQUFvQztBQUMzRSxZQUFZLFVBQVU7QUFDdEIsaUJBQWlCLDRDQUE0QztBQUM3RCxvQkFBb0IsYUFBYTtBQUNqQyw2QkFBNkIsb0NBQW9DO0FBQ2pFLHFCQUFxQixVQUFVO0FBQy9CLHdCQUF3QixhQUFhO0FBQ3JDLGlDQUFpQyxvQ0FBb0M7QUFDckUsbUJBQW1CLFVBQVU7QUFDN0Isc0JBQXNCLGFBQWE7QUFDbkMsK0JBQStCLG9DQUFvQztBQUNuRSw4QkFBOEIsb0NBQW9DO0FBQ2xFLDZCQUE2QixhQUFhO0FBQzFDLGdCQUFnQixVQUFVO0FBQzFCLG1CQUFtQixhQUFhO0FBQ2hDLDRCQUE0QixvQ0FBb0M7QUFDaEUsMEJBQTBCLFVBQVU7QUFDcEMsdUJBQXVCLDRDQUE0QztBQUNuRSxvQkFBb0IsMkNBQTJDO0FBQy9ELHVCQUF1QixhQUFhO0FBQ3BDLGdDQUFnQyxvQ0FBb0M7QUFDcEUsd0JBQXdCLFVBQVU7QUFDbEMsMkJBQTJCLGFBQWE7QUFDeEMsb0NBQW9DLG9DQUFvQztBQUN4RSx1QkFBdUIsb0NBQW9DO0FBQzNELG9CQUFvQixhQUFhO0FBQ2pDLDZCQUE2QixvQ0FBb0M7QUFDakU7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0RBQW9EO0FBQ3BEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsZ0JBQWdCOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix5QkFBeUI7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLFFBQVE7O0FBRXREOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0QsUUFBUTs7QUFFMUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixtQ0FBbUM7O0FBRTNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVIsd0JBQXdCLG1DQUFtQzs7QUFFM0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLG1DQUFtQzs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUEsd0JBQXdCLG1DQUFtQzs7QUFFM0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUix3QkFBd0IsbUNBQW1DOztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsbUNBQW1DOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsZUFBZTs7QUFFbkM7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBLG9CQUFvQixlQUFlOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsbUJBQW1COztBQUV2Qzs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7O0FBRW5DOztBQUVBOztBQUVBLG9CQUFvQixzQkFBc0I7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkI7O0FBRTdCOztBQUVBLG9CQUFvQixlQUFlOztBQUVuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLGVBQWU7O0FBRXBEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDs7QUFFN0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFOztBQUVoRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLDRCQUE0Qjs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUksT0FBTzs7QUFFWDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFXLFVBQVU7QUFDckIsT0FBTyw2RUFBNkU7O0FBRXBGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWEscUNBQXFDLFlBQVk7O0FBRTlEOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjs7QUFFcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLG9CQUFvQjs7QUFFdkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsZUFBZTs7QUFFakM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLEdBQUc7O0FBRUg7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLGdCQUFnQjtBQUNoQyxvQkFBb0IsY0FBYztBQUNsQyxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQixHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLGFBQWE7QUFDNUIsbUJBQW1CO0FBQ25CLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCO0FBQzNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtCQUErQjs7QUFFL0IsS0FBSzs7QUFFTDtBQUNBLDBCQUEwQjs7QUFFMUIsS0FBSzs7QUFFTCx5QkFBeUI7O0FBRXpCLEtBQUs7O0FBRUw7QUFDQSwwQkFBMEI7O0FBRTFCLEtBQUs7O0FBRUw7QUFDQSwwQkFBMEI7O0FBRTFCLEtBQUs7O0FBRUwseUJBQXlCOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsWUFBWTs7QUFFL0I7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLGtEQUFrRCxPQUFPOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixlQUFlOztBQUVuQzs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixtQkFBbUI7O0FBRXZDOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTs7QUFFbkM7O0FBRUE7O0FBRUEsb0JBQW9CLHNCQUFzQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHVCQUF1Qjs7QUFFM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQix1QkFBdUI7O0FBRTVDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLG9CQUFvQiw2QkFBNkI7O0FBRWpEOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0IsZUFBZTs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsT0FBTzs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLE9BQU87O0FBRXZDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7O0FBRW5DLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDOztBQUVsQyxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7O0FBRWhELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixTQUFTOztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsU0FBUzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixTQUFTOztBQUUzQjs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDOztBQUV4Qyx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDLHVDQUF1Qzs7QUFFdkMscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQscURBQXFEOztBQUVyRCx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLFNBQVM7O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxTQUFTOztBQUU1QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLFNBQVM7O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsUUFBUTs7QUFFN0I7QUFDQSxrQkFBa0IsZ0NBQWdDLEVBQUUsS0FBSyxJQUFJLFdBQVc7O0FBRXhFOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhLGlCQUFpQixTQUFTLGdCQUFnQixJQUFJLGdCQUFnQixjQUFjOztBQUV6Rzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1EQUFtRCxxREFBcUQ7O0FBRXhHOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixPQUFPOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUZBQXlGLG9CQUFvQixvQkFBb0IsV0FBVzs7QUFFNUk7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLHFCQUFxQjs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9DQUFvQyxzQkFBc0I7QUFDMUQsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkM7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVOztBQUVWOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsZ0NBQWdDO0FBQ2hDLGdDQUFnQzs7QUFFaEM7O0FBRUEsbUNBQW1DOztBQUVuQzs7QUFFQTs7QUFFQSxrQ0FBa0M7O0FBRWxDOztBQUVBOztBQUVBLG9DQUFvQzs7QUFFcEM7O0FBRUEsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQixzQkFBc0I7O0FBRXRCOztBQUVBLHdCQUF3Qjs7QUFFeEI7O0FBRUE7O0FBRUEsd0JBQXdCOztBQUV4Qjs7QUFFQTs7QUFFQSx3QkFBd0I7O0FBRXhCOztBQUVBOztBQUVBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7O0FBRUEsMEJBQTBCOztBQUUxQjs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QiwrQkFBK0I7O0FBRS9COztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQyxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxPQUFPOztBQUV0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJEQUEyRCxRQUFROztBQUVuRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTCxxQkFBcUIsT0FBTzs7QUFFNUI7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkJBQTZCLHdDQUF3QyxHQUFHOztBQUV4RSxnREFBZ0QsMEJBQTBCLHVCQUF1QixtQ0FBbUMsK0NBQStDLHFCQUFxQiw2QkFBNkIsb0VBQW9FLGlEQUFpRCx5QkFBeUIsYUFBYSxRQUFRLDhDQUE4Qyx5S0FBeUssK0JBQStCLDBGQUEwRixrSkFBa0osc0JBQXNCLHNDQUFzQyxpQkFBaUIsMEJBQTBCLDBDQUEwQyx1REFBdUQsNERBQTRELEdBQUc7O0FBRWpuQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRDQUE0QyxpQ0FBaUM7QUFDN0U7O0FBRUEscUJBQXFCOztBQUVyQjs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQixhQUFhO0FBQy9CLGlCQUFpQixzQkFBc0I7QUFDdkMsYUFBYTtBQUNiLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBb0QscURBQXFEOztBQUV6Rzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLG9CQUFvQjs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxhQUFhLFFBQVE7O0FBRXJCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixXQUFXOztBQUU5Qjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCOztBQUVBLDBCQUEwQiwrREFBK0Q7O0FBRXpGLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSx5QkFBeUIsMERBQTBEOztBQUVuRixLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLDREQUE0RDs7QUFFakY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVHQUF1Rzs7QUFFdkc7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsWUFBWTs7QUFFWjs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVOztBQUVWOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZELFNBQVM7O0FBRXRFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQsT0FBTzs7QUFFaEU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUEsdUJBQXVCLFlBQVk7O0FBRW5DOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCOztBQUVBLHNCQUFzQixvQkFBb0I7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUEsdUJBQXVCLG9CQUFvQjs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQSx1QkFBdUIsb0JBQW9COztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSSwySkFBMko7O0FBRS9KOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCOztBQUVBOztBQUVBLDBCQUEwQixnQ0FBZ0M7O0FBRTFEOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSx5QkFBeUIsZ0NBQWdDOztBQUV6RDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixxQkFBcUI7O0FBRTFDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCOztBQUVBLDBCQUEwQixnQ0FBZ0M7O0FBRTFEOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSiwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QixnQ0FBZ0M7O0FBRXpEOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IscUJBQXFCOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIscUJBQXFCOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHFCQUFxQjs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVOztBQUVWOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0IsdUNBQXVDOztBQUUvRDs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0IsMENBQTBDOztBQUVsRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekMsb0JBQW9CLG1CQUFtQjtBQUN2QyxxQkFBcUI7QUFDckI7QUFDQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDLDRDQUE0Qzs7QUFFNUU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isd0JBQXdCOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIscUJBQXFCOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLHlCQUF5Qjs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0MsMEJBQTBCOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSOztBQUVBLDZDQUE2Qzs7QUFFN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQix1QkFBdUI7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiwwQkFBMEI7O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0Isd0JBQXdCOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0Isd0JBQXdCOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0Isb0JBQW9COztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLGtCQUFrQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQix3QkFBd0I7O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCLHNDQUFzQzs7QUFFakU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSix3Q0FBd0M7O0FBRXhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtRUFBbUU7O0FBRW5FOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2RUFBNkU7O0FBRTdFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7O0FBRXpDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQSw4Q0FBOEMsUUFBUTs7QUFFdEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLG1CQUFtQjs7QUFFekM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7QUFDbEIsd0JBQXdCOztBQUV4Qix3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUEsOENBQThDLFFBQVE7O0FBRXREOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCOztBQUV4Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9GQUFvRixTQUFTOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsa0RBQWtEOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLHFCQUFxQjs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkJBQTZCOztBQUU3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLE9BQU87O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBLDhDQUE4Qyx5Q0FBeUM7O0FBRXZGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwrRUFBK0U7O0FBRS9FOztBQUVBLHFEQUFxRCxPQUFPOztBQUU1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0RBQXNEOztBQUV0RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0RBQXNEOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLDRCQUE0Qjs7QUFFNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZCQUE2Qjs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGVBQWU7O0FBRWxGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUUsZUFBZTs7QUFFbEY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpSUFBaUk7QUFDakk7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNEJBQTRCLGVBQWU7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DLE9BQU87O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLE9BQU87O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxPQUFPOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsZ0JBQWdCOztBQUVwQzs7QUFFQSxxQkFBcUIsbUJBQW1COztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixnQkFBZ0I7O0FBRXBDOztBQUVBLHFCQUFxQixtQkFBbUI7O0FBRXhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZCQUE2Qix3REFBUTs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix3REFBUTs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isd0RBQVE7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsbUJBQW1COztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIsNkRBQTZEOztBQUV0Rjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxPQUFPOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxPQUFPOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxPQUFPOztBQUVsQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsb0RBQUk7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQiw2QkFBNkI7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLDZCQUE2Qjs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxPQUFPOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLDhCQUE4Qjs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHdEQUFROztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBMEIsdURBQU87O0FBRWpDOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMsUUFBUTs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQseUNBQXlDOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLCtEQUFlOztBQUV0RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixrREFBRTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLG9EQUFJOztBQUVoQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsV0FBVzs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsV0FBVzs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsV0FBVzs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQzs7QUFFM0MscUNBQXFDOztBQUVyQyxtQkFBbUIsNkJBQTZCOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0QkFBNEIsMkJBQTJCOztBQUV2RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBb0QsT0FBTzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsNkJBQTZCOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0Isa0JBQWtCOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0RBQUU7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjs7QUFFcEMsb0JBQW9CLGNBQWM7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBMEIsb0RBQUk7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSw4QkFBOEI7O0FBRTFDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvRUFBb0UsY0FBYzs7QUFFbEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhEQUE4RCxlQUFlOztBQUU3RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQW1COztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTzs7QUFFN0Q7QUFDQSxxQkFBcUIsY0FBYzs7QUFFbkM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjs7QUFFeEM7O0FBRUE7O0FBRUE7QUFDQSwrREFBK0QsT0FBTzs7QUFFdEU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsT0FBTzs7QUFFaEY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLE9BQU87O0FBRWhGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLG1CQUFtQjs7QUFFdEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELE9BQU87O0FBRXhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBELFdBQVc7QUFDckUsa0VBQWtFLFdBQVc7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSiwyQ0FBMkMsT0FBTzs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsT0FBTzs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxRQUFROztBQUV6RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMERBQTBEOztBQUUxRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsT0FBTzs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLG9EQUFJOztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2QkFBNkIsd0RBQVE7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsd0RBQVE7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFROztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsaUNBQWlDLE9BQU87O0FBRXhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsUUFBUTs7QUFFekQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLDJCQUEyQix1REFBTzs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUNBQWlDLHVEQUFPOztBQUV4Qzs7QUFFQSxXQUFXLGdCQUFnQjs7QUFFM0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsdURBQU87O0FBRXZDOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLGlFQUFpQjs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9DQUFvQyxpRUFBaUI7O0FBRXJEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsZ0JBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsS0FBSyx5QkFBeUI7O0FBRTlDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0NBQStDOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsZUFBZTs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3RkFBd0Y7O0FBRXhGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLGVBQWU7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYzs7QUFFZDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLG1CQUFtQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsZ0JBQWdCOztBQUVwQzs7QUFFQSxrREFBa0Q7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUNBQWlDOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLDRCQUE0Qjs7QUFFL0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQiw0QkFBNEI7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsY0FBYzs7QUFFakMsb0JBQW9CLDJCQUEyQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixlQUFlOztBQUV6Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGVBQWU7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIscUJBQXFCOztBQUUxQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLG9CQUFvQjs7QUFFeEMscUJBQXFCLG9CQUFvQjs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixvQkFBb0I7O0FBRXhDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDOztBQUVoQyxJQUFJOztBQUVKLDRCQUE0Qjs7QUFFNUI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixvQkFBb0I7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsV0FBVzs7QUFFL0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsV0FBVzs7QUFFaEM7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsVUFBVTs7QUFFOUIscUJBQXFCLDBCQUEwQjs7QUFFL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQix5QkFBeUI7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHlCQUF5Qjs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHlCQUF5Qjs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiwrQkFBK0IsSUFBSSwrQkFBK0IsSUFBSSwrQkFBK0I7QUFDM0gsc0JBQXNCLCtCQUErQixJQUFJLCtCQUErQixJQUFJLCtCQUErQjtBQUMzSCxzQkFBc0IsK0JBQStCLElBQUksK0JBQStCLElBQUksK0JBQStCOztBQUUzSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVSxJQUFJLFVBQVU7QUFDOUMsNkJBQTZCLFVBQVUsSUFBSSxVQUFVOztBQUVyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLE9BQU87O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLE9BQU87O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGNBQWM7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsU0FBUzs7QUFFNUIsR0FBRzs7QUFFSCx1QkFBdUIsWUFBWTs7QUFFbkM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsa0JBQWtCOztBQUVoQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCOztBQUU3RDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTs7QUFFNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRzs7QUFFaEc7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDOztBQUU1Qyx5REFBeUQ7QUFDekQseURBQXlEO0FBQ3pELHlEQUF5RDtBQUN6RCx5REFBeUQ7O0FBRXpEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EscUNBQXFDLFNBQVM7O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsT0FBTzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGtCQUFrQjs7QUFFckM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixvQkFBb0I7O0FBRXRDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxpS0FBaUs7O0FBRWpLOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLDZCQUE2Qjs7QUFFN0IsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsK0JBQStCOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUEsZ0VBQWdFLFFBQVE7O0FBRXhFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTs7QUFFQSwrREFBK0QsUUFBUTs7QUFFdkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLG9CQUFvQixtQkFBbUI7O0FBRXZDLCtCQUErQixPQUFPOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDtBQUNBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsVUFBVTs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7O0FBRWhDLHFCQUFxQixVQUFVOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEMsb0NBQW9DLFFBQVE7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsUUFBUTs7QUFFaEQ7QUFDQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBOztBQUVBLHNCQUFzQixVQUFVOztBQUVoQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLFVBQVU7O0FBRWhDO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxzQkFBc0IsVUFBVTs7QUFFaEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0IsVUFBVTs7QUFFaEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBEQUEwRCxRQUFROztBQUVsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsaUNBQWlDOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsa0JBQWtCOztBQUVyQyxvQkFBb0Isb0JBQW9COztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGlCQUFpQjs7QUFFcEM7O0FBRUEsb0JBQW9CLG1CQUFtQjs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixvQkFBb0IsbUJBQW1COztBQUV2Qzs7QUFFQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHNCQUFzQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxxQkFBcUIscUJBQXFCOztBQUUxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6QyxxQkFBcUIsb0JBQW9COztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIscUJBQXFCOztBQUV4QyxvQkFBb0Isc0JBQXNCOztBQUUxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIscUJBQXFCOztBQUV4QyxvQkFBb0Isc0JBQXNCOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjs7QUFFekM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsc0JBQXNCOztBQUV6QyxvQkFBb0IscUJBQXFCOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHFCQUFxQjs7QUFFekM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHNCQUFzQjs7QUFFMUMscUJBQXFCLHFCQUFxQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0Isc0JBQXNCOztBQUUxQyxxQkFBcUIscUJBQXFCOztBQUUxQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixtREFBbUQ7O0FBRXJFOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTtBQUNBOztBQUVBLGdFQUFnRSxPQUFPOztBQUV2RSx1QkFBdUIsT0FBTzs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxpREFBaUQsT0FBTzs7QUFFeEQsc0JBQXNCLE9BQU87O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsUUFBUSxHQUFHLFFBQVEsR0FBRyxRQUFRLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNO0FBQzNFLGtCQUFrQixNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxRQUFRLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRzs7QUFFOUU7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsNkJBQTZCLHdEQUFROztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdDQUFnQyw4REFBYzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLHdEQUFROztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUI7O0FBRW5COztBQUVBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLG9FQUFvQjs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0Msd0RBQVE7O0FBRXhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0JBQStCLHdEQUFROztBQUV2Qzs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUI7O0FBRW5COztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUMsd0RBQVE7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQyx3REFBUTs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDOztBQUV0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUNBQWlDLHdEQUFROztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUI7O0FBRW5COztBQUVBLHNDQUFzQzs7QUFFdEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQSxtQkFBbUI7O0FBRW5COztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUMsaUVBQWlCOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7O0FBRTVCOztBQUVBLDZDQUE2Qzs7QUFFN0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQyx1QkFBdUI7O0FBRXhEOztBQUVBLG1CQUFtQixjQUFjOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQSxvQ0FBb0M7O0FBRXBDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4Qzs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQix3QkFBd0I7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsZUFBZTs7QUFFbkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0Isd0JBQXdCOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0Isd0JBQXdCOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGVBQWU7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7O0FBRWpDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EscUJBQXFCLGNBQWM7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTtBQUNmOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixjQUFjOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUM7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOLGlDQUFpQzs7QUFFakM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxTQUFTOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxTQUFTOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGFBQWE7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLFNBQVM7O0FBRWpEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGVBQWU7O0FBRWxDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixjQUFjOztBQUVwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixjQUFjOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3RkFBd0YsY0FBYzs7QUFFdEc7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxnQkFBZ0I7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7O0FBRW5EOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQyxTQUFTOztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixxQkFBcUI7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsc0JBQXNCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxRQUFROztBQUVyRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsNEJBQTRCOztBQUUvQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsMEJBQTBCOztBQUUzQzs7QUFFQSx1QkFBdUIsNENBQTRDOztBQUVuRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQiw4Q0FBOEM7O0FBRXBFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxTQUFTOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsd0JBQXdCOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsd0JBQXdCOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsd0JBQXdCOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsd0JBQXdCOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVOztBQUVWOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7QUFDQTs7QUFFQSw2Q0FBNkM7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLHFEQUFLOztBQUU3Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHlCQUF5QixzREFBTTs7QUFFL0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdDQUFnQyxjQUFjOztBQUU5Qzs7QUFFQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBLHlEQUF5RCxrQ0FBa0M7QUFDM0Ysa0RBQWtELFFBQVE7O0FBRTFEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSxNQUFNOztBQUVOLHdDQUF3QyxhQUFhLG1CQUFtQixnQkFBZ0IsSUFBSSxvQkFBb0I7O0FBRWhIOztBQUVBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsUUFBUTs7QUFFcEQ7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBOEIsc0RBQU07O0FBRXBDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGlCQUFpQjs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0Msc0RBQU07O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLHFDQUFxQyxRQUFROztBQUU3Qzs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQixXQUFXOztBQUVqQyxzQkFBc0I7O0FBRXRCLHVCQUF1QiwwQkFBMEI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBMEIsd0ZBQU07O0FBRWhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLHNEQUFNOztBQUV0Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLG1CQUFtQixpQkFBaUI7O0FBRXBDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLHNEQUFNOztBQUV0Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0RBQWtEOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOzs7QUFHSDs7QUFFQTs7QUFFQTs7QUFFQSw0QkFBNEIsd0ZBQU07O0FBRWxDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0I7O0FBRS9COztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBOEIscURBQUs7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOEJBQThCLDJEQUFXOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLHFEQUFLOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsMkRBQVc7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIscURBQUs7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsMkRBQVc7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtCQUErQixxREFBSzs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QixxREFBSzs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLHNFQUFzRTs7QUFFdEU7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIscURBQUs7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQztBQUNuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2QkFBNkIsc0RBQU07O0FBRW5DOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBOEI7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSSxjQUFjOztBQUVsQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsOERBQWM7O0FBRXBEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLHNEQUFNOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRCxRQUFROztBQUV6RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFNBQVM7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCLHNEQUFNOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSLHdFQUF3RSxXQUFXOztBQUVuRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsaUJBQWlCOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQSw4Q0FBOEM7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTs7QUFFbEU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxrRUFBa0U7O0FBRWxFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixxQkFBcUI7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiw2QkFBNkI7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixtQkFBbUI7O0FBRXZDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQjs7QUFFbkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUosbUVBQW1FLCtCQUErQjs7QUFFbEcsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBCQUEwQixzREFBTTs7QUFFaEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU4sS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkVBQTJFOztBQUUzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsd0RBQVE7O0FBRXBDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHdEQUFROztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLHFEQUFLOztBQUVuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixjQUFjOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QyxTQUFTOztBQUV0RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlEQUFpRCxTQUFTOztBQUUxRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLGNBQWM7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsb0JBQW9COztBQUV2Qzs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLGNBQWM7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsY0FBYzs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGNBQWM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxHQUFHO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3RUFBd0UsU0FBUzs7QUFFakY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0VBQXdFLFNBQVM7O0FBRWpGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdFQUF3RSxTQUFTOztBQUVqRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixxQkFBcUI7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsU0FBUzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9DQUFvQyxTQUFTOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0MsU0FBUzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW9DLFNBQVM7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IseUJBQXlCOztBQUUvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtEQUFrRDs7QUFFbEQ7O0FBRUEsSUFBSSxnRUFBZ0U7O0FBRXBFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQSxpQ0FBaUM7O0FBRWpDLHlDQUF5QyxTQUFTOztBQUVsRDs7QUFFQTs7QUFFQSxvQkFBb0I7QUFDcEIsMEJBQTBCLGFBQWE7QUFDdkMsdUJBQXVCO0FBQ3ZCLG9DQUFvQzs7QUFFcEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsU0FBUzs7QUFFN0M7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsU0FBUzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUwsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxTQUFTOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUMsU0FBUzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUMsU0FBUzs7QUFFOUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOLEtBQUs7O0FBRUwsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxTQUFTOztBQUU3RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBOztBQUVBLDJCQUEyQjtBQUMzQixpQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCLGlDQUFpQzs7QUFFakMsK0JBQStCO0FBQy9CLDZCQUE2Qjs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsd0JBQXdCO0FBQ3hCLHlCQUF5Qjs7QUFFekI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOzs7QUFHTCw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsK0NBQStDLFNBQVM7O0FBRXhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsU0FBUzs7QUFFeEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUEsSUFBSSxPQUFPOztBQUVYOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFEQUFxRDtBQUNyRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQSw2QkFBNkIsK0RBQWU7O0FBRTVDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsZUFBZTs7QUFFbEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QyxTQUFTOztBQUVsRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUF1QjtBQUN2Qjs7QUFFQSxvQ0FBb0M7OztBQUdwQyxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsU0FBUzs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsUUFBUTs7QUFFdEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGdCQUFnQjs7QUFFbkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQixtQkFBbUIsMEJBQTBCOztBQUU3QyxnQ0FBZ0M7O0FBRWhDOztBQUVBLHVDQUF1Qzs7QUFFdkM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnREFBZ0QsU0FBUzs7QUFFekQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0QkFBNEIsK0RBQWU7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxnQkFBZ0I7O0FBRXZEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLGtCQUFrQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUEsb0JBQW9CLHFCQUFxQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLGlFQUFpQjs7QUFFMUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxXQUFXLGNBQWM7QUFDekIsVUFBVTtBQUNWLGFBQWEsY0FBYztBQUMzQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKLCtIQUErSDtBQUMvSDtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLHNCQUFzQjs7QUFFdEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsY0FBYzs7QUFFZDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhCQUE4Qix3REFBUTs7QUFFdEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLE9BQU87O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLGdDQUFnQzs7QUFFNUU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLDZCQUE2Qiw0REFBWTs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7O0FBRXJDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLGdHQUFnRzs7QUFFNUk7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLGtCQUFrQjs7QUFFNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsNEJBQTRCOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0Isb0RBQUk7O0FBRW5DOztBQUVBO0FBQ0EsNENBQTRDLGlEQUFpRDs7QUFFN0Y7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdGQUFnRjs7QUFFekk7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyx3REFBUTs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxpREFBaUQ7QUFDNUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUJBQXlCLDREQUFZOztBQUVyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsZ0JBQWdCOztBQUUxRDtBQUNBOztBQUVBOztBQUVBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0Qyx3Q0FBd0M7O0FBRXBGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsOEJBQThCLDREQUFZOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLGFBQWE7O0FBRWpDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixXQUFXOztBQUU5Qjs7QUFFQTs7QUFFQSxvQkFBb0IsZUFBZTs7QUFFbkM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLHdDQUF3Qzs7QUFFcEY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLHdEQUFROztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGdDQUFnQzs7QUFFNUU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsNERBQVk7O0FBRXZDOztBQUVBO0FBQ0EsNENBQTRDLHlEQUF5RDs7QUFFckc7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0RBQStELDZEQUE2RDtBQUM1SCwrREFBK0QsNkRBQTZEO0FBQzVILCtEQUErRCw2REFBNkQ7QUFDNUgsK0RBQStELDZEQUE2RDs7QUFFNUg7O0FBRUEsK0RBQStELDZEQUE2RDtBQUM1SCxnRUFBZ0UsOERBQThEO0FBQzlILGdFQUFnRSw4REFBOEQ7QUFDOUgsZ0VBQWdFLDhEQUE4RDs7QUFFOUg7O0FBRUEsZ0VBQWdFLDhEQUE4RDtBQUM5SCxnRUFBZ0UsOERBQThEO0FBQzlILGdFQUFnRSw4REFBOEQ7QUFDOUgsZ0VBQWdFLDhEQUE4RDs7QUFFOUg7O0FBRUEsdURBQXVELHFEQUFxRDtBQUM1Ryx1REFBdUQscURBQXFEO0FBQzVHLHVEQUF1RCxxREFBcUQ7QUFDNUcsdURBQXVELHFEQUFxRDs7QUFFNUc7O0FBRUEsaURBQWlELCtDQUErQztBQUNoRyxpREFBaUQsK0NBQStDO0FBQ2hHLGlEQUFpRCwrQ0FBK0M7O0FBRWhHOztBQUVBLDZEQUE2RCwyREFBMkQ7QUFDeEgsMERBQTBELHdEQUF3RDs7QUFFbEg7O0FBRUEsMERBQTBELHdEQUF3RDtBQUNsSCwwREFBMEQsd0RBQXdEOztBQUVsSCwwREFBMEQsd0RBQXdEO0FBQ2xILDBEQUEwRCx3REFBd0Q7O0FBRWxIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLDREQUFZOztBQUVwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsa0NBQWtDOztBQUU5RTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDLHNCQUFzQixvQkFBb0I7QUFDMUMsc0JBQXNCLG9CQUFvQjtBQUMxQyxzQkFBc0IscUJBQXFCO0FBQzNDLHVCQUF1QixxQkFBcUI7QUFDNUMsdUJBQXVCLHFCQUFxQjtBQUM1Qyx1QkFBdUIscUJBQXFCO0FBQzVDLHVCQUF1QixxQkFBcUI7O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIsNERBQVk7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxrQ0FBa0M7O0FBRTlFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLG9EQUFJOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGtDQUFrQzs7QUFFOUU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCxzRkFBc0Y7O0FBRWhKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLHdEQUFROztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0VBQWdFLGtDQUFrQztBQUNsRztBQUNBOztBQUVBLGdFQUFnRSxrQ0FBa0M7QUFDbEc7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3RUFBd0U7QUFDeEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0Qyx3Q0FBd0M7O0FBRXBGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQyxtQ0FBbUM7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBLG1EQUFtRDtBQUNuRCxzQkFBc0I7O0FBRXRCLE9BQU87O0FBRVA7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBLE1BQU07O0FBRU47QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCxxQ0FBcUMsZ0NBQWdDOztBQUVyRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxhQUFhOztBQUU3RDs7QUFFQTs7QUFFQSxnREFBZ0QsYUFBYTs7QUFFN0Q7O0FBRUEsd0JBQXdCLG1CQUFtQjs7QUFFM0M7QUFDQTs7QUFFQSwwQkFBMEIsMEJBQTBCOztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLGlFQUFpQixLQUFHOztBQUU3RCw2REFBNkQ7O0FBRTdEOztBQUVBLDBCQUEwQixvQkFBb0I7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtFQUFrRTtBQUNsRTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFczROIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLXRleHR1cmUtc3dpdGNoaW5nLWxvYWRlci8uL25vZGVfbW9kdWxlcy90aHJlZS9idWlsZC90aHJlZS5tb2R1bGUuanM/MTM3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMC0yMDI0IFRocmVlLmpzIEF1dGhvcnNcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbiAqL1xuY29uc3QgUkVWSVNJT04gPSAnMTY1JztcblxuY29uc3QgTU9VU0UgPSB7IExFRlQ6IDAsIE1JRERMRTogMSwgUklHSFQ6IDIsIFJPVEFURTogMCwgRE9MTFk6IDEsIFBBTjogMiB9O1xuY29uc3QgVE9VQ0ggPSB7IFJPVEFURTogMCwgUEFOOiAxLCBET0xMWV9QQU46IDIsIERPTExZX1JPVEFURTogMyB9O1xuY29uc3QgQ3VsbEZhY2VOb25lID0gMDtcbmNvbnN0IEN1bGxGYWNlQmFjayA9IDE7XG5jb25zdCBDdWxsRmFjZUZyb250ID0gMjtcbmNvbnN0IEN1bGxGYWNlRnJvbnRCYWNrID0gMztcbmNvbnN0IEJhc2ljU2hhZG93TWFwID0gMDtcbmNvbnN0IFBDRlNoYWRvd01hcCA9IDE7XG5jb25zdCBQQ0ZTb2Z0U2hhZG93TWFwID0gMjtcbmNvbnN0IFZTTVNoYWRvd01hcCA9IDM7XG5jb25zdCBGcm9udFNpZGUgPSAwO1xuY29uc3QgQmFja1NpZGUgPSAxO1xuY29uc3QgRG91YmxlU2lkZSA9IDI7XG5jb25zdCBOb0JsZW5kaW5nID0gMDtcbmNvbnN0IE5vcm1hbEJsZW5kaW5nID0gMTtcbmNvbnN0IEFkZGl0aXZlQmxlbmRpbmcgPSAyO1xuY29uc3QgU3VidHJhY3RpdmVCbGVuZGluZyA9IDM7XG5jb25zdCBNdWx0aXBseUJsZW5kaW5nID0gNDtcbmNvbnN0IEN1c3RvbUJsZW5kaW5nID0gNTtcbmNvbnN0IEFkZEVxdWF0aW9uID0gMTAwO1xuY29uc3QgU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcbmNvbnN0IFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xuY29uc3QgTWluRXF1YXRpb24gPSAxMDM7XG5jb25zdCBNYXhFcXVhdGlvbiA9IDEwNDtcbmNvbnN0IFplcm9GYWN0b3IgPSAyMDA7XG5jb25zdCBPbmVGYWN0b3IgPSAyMDE7XG5jb25zdCBTcmNDb2xvckZhY3RvciA9IDIwMjtcbmNvbnN0IE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XG5jb25zdCBTcmNBbHBoYUZhY3RvciA9IDIwNDtcbmNvbnN0IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG5jb25zdCBEc3RBbHBoYUZhY3RvciA9IDIwNjtcbmNvbnN0IE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG5jb25zdCBEc3RDb2xvckZhY3RvciA9IDIwODtcbmNvbnN0IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XG5jb25zdCBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gMjEwO1xuY29uc3QgQ29uc3RhbnRDb2xvckZhY3RvciA9IDIxMTtcbmNvbnN0IE9uZU1pbnVzQ29uc3RhbnRDb2xvckZhY3RvciA9IDIxMjtcbmNvbnN0IENvbnN0YW50QWxwaGFGYWN0b3IgPSAyMTM7XG5jb25zdCBPbmVNaW51c0NvbnN0YW50QWxwaGFGYWN0b3IgPSAyMTQ7XG5jb25zdCBOZXZlckRlcHRoID0gMDtcbmNvbnN0IEFsd2F5c0RlcHRoID0gMTtcbmNvbnN0IExlc3NEZXB0aCA9IDI7XG5jb25zdCBMZXNzRXF1YWxEZXB0aCA9IDM7XG5jb25zdCBFcXVhbERlcHRoID0gNDtcbmNvbnN0IEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcbmNvbnN0IEdyZWF0ZXJEZXB0aCA9IDY7XG5jb25zdCBOb3RFcXVhbERlcHRoID0gNztcbmNvbnN0IE11bHRpcGx5T3BlcmF0aW9uID0gMDtcbmNvbnN0IE1peE9wZXJhdGlvbiA9IDE7XG5jb25zdCBBZGRPcGVyYXRpb24gPSAyO1xuY29uc3QgTm9Ub25lTWFwcGluZyA9IDA7XG5jb25zdCBMaW5lYXJUb25lTWFwcGluZyA9IDE7XG5jb25zdCBSZWluaGFyZFRvbmVNYXBwaW5nID0gMjtcbmNvbnN0IENpbmVvblRvbmVNYXBwaW5nID0gMztcbmNvbnN0IEFDRVNGaWxtaWNUb25lTWFwcGluZyA9IDQ7XG5jb25zdCBDdXN0b21Ub25lTWFwcGluZyA9IDU7XG5jb25zdCBBZ1hUb25lTWFwcGluZyA9IDY7XG5jb25zdCBOZXV0cmFsVG9uZU1hcHBpbmcgPSA3O1xuY29uc3QgQXR0YWNoZWRCaW5kTW9kZSA9ICdhdHRhY2hlZCc7XG5jb25zdCBEZXRhY2hlZEJpbmRNb2RlID0gJ2RldGFjaGVkJztcblxuY29uc3QgVVZNYXBwaW5nID0gMzAwO1xuY29uc3QgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xuY29uc3QgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xuY29uc3QgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDM7XG5jb25zdCBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IDMwNDtcbmNvbnN0IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gMzA2O1xuY29uc3QgUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xuY29uc3QgQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XG5jb25zdCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcbmNvbnN0IE5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xuY29uc3QgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuY29uc3QgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuY29uc3QgTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciA9IDEwMDU7XG5jb25zdCBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcbmNvbnN0IExpbmVhckZpbHRlciA9IDEwMDY7XG5jb25zdCBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcbmNvbnN0IExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xuY29uc3QgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyID0gMTAwODtcbmNvbnN0IExpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XG5jb25zdCBVbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcbmNvbnN0IEJ5dGVUeXBlID0gMTAxMDtcbmNvbnN0IFNob3J0VHlwZSA9IDEwMTE7XG5jb25zdCBVbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XG5jb25zdCBJbnRUeXBlID0gMTAxMztcbmNvbnN0IFVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XG5jb25zdCBGbG9hdFR5cGUgPSAxMDE1O1xuY29uc3QgSGFsZkZsb2F0VHlwZSA9IDEwMTY7XG5jb25zdCBVbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE3O1xuY29uc3QgVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxODtcbmNvbnN0IFVuc2lnbmVkSW50MjQ4VHlwZSA9IDEwMjA7XG5jb25zdCBVbnNpZ25lZEludDU5OTlUeXBlID0gMzU5MDI7XG5jb25zdCBBbHBoYUZvcm1hdCA9IDEwMjE7XG5jb25zdCBSR0JGb3JtYXQgPSAxMDIyO1xuY29uc3QgUkdCQUZvcm1hdCA9IDEwMjM7XG5jb25zdCBMdW1pbmFuY2VGb3JtYXQgPSAxMDI0O1xuY29uc3QgTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDI1O1xuY29uc3QgRGVwdGhGb3JtYXQgPSAxMDI2O1xuY29uc3QgRGVwdGhTdGVuY2lsRm9ybWF0ID0gMTAyNztcbmNvbnN0IFJlZEZvcm1hdCA9IDEwMjg7XG5jb25zdCBSZWRJbnRlZ2VyRm9ybWF0ID0gMTAyOTtcbmNvbnN0IFJHRm9ybWF0ID0gMTAzMDtcbmNvbnN0IFJHSW50ZWdlckZvcm1hdCA9IDEwMzE7XG5jb25zdCBSR0JBSW50ZWdlckZvcm1hdCA9IDEwMzM7XG5cbmNvbnN0IFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3NzY7XG5jb25zdCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3NztcbmNvbnN0IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDMzNzc4O1xuY29uc3QgUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMzM3Nzk7XG5jb25zdCBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQwO1xuY29uc3QgUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAzNTg0MTtcbmNvbnN0IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQyO1xuY29uc3QgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDM7XG5jb25zdCBSR0JfRVRDMV9Gb3JtYXQgPSAzNjE5NjtcbmNvbnN0IFJHQl9FVEMyX0Zvcm1hdCA9IDM3NDkyO1xuY29uc3QgUkdCQV9FVEMyX0VBQ19Gb3JtYXQgPSAzNzQ5NjtcbmNvbnN0IFJHQkFfQVNUQ180eDRfRm9ybWF0ID0gMzc4MDg7XG5jb25zdCBSR0JBX0FTVENfNXg0X0Zvcm1hdCA9IDM3ODA5O1xuY29uc3QgUkdCQV9BU1RDXzV4NV9Gb3JtYXQgPSAzNzgxMDtcbmNvbnN0IFJHQkFfQVNUQ182eDVfRm9ybWF0ID0gMzc4MTE7XG5jb25zdCBSR0JBX0FTVENfNng2X0Zvcm1hdCA9IDM3ODEyO1xuY29uc3QgUkdCQV9BU1RDXzh4NV9Gb3JtYXQgPSAzNzgxMztcbmNvbnN0IFJHQkFfQVNUQ184eDZfRm9ybWF0ID0gMzc4MTQ7XG5jb25zdCBSR0JBX0FTVENfOHg4X0Zvcm1hdCA9IDM3ODE1O1xuY29uc3QgUkdCQV9BU1RDXzEweDVfRm9ybWF0ID0gMzc4MTY7XG5jb25zdCBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgPSAzNzgxNztcbmNvbnN0IFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCA9IDM3ODE4O1xuY29uc3QgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCA9IDM3ODE5O1xuY29uc3QgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCA9IDM3ODIwO1xuY29uc3QgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCA9IDM3ODIxO1xuY29uc3QgUkdCQV9CUFRDX0Zvcm1hdCA9IDM2NDkyO1xuY29uc3QgUkdCX0JQVENfU0lHTkVEX0Zvcm1hdCA9IDM2NDk0O1xuY29uc3QgUkdCX0JQVENfVU5TSUdORURfRm9ybWF0ID0gMzY0OTU7XG5jb25zdCBSRURfUkdUQzFfRm9ybWF0ID0gMzYyODM7XG5jb25zdCBTSUdORURfUkVEX1JHVEMxX0Zvcm1hdCA9IDM2Mjg0O1xuY29uc3QgUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCA9IDM2Mjg1O1xuY29uc3QgU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgPSAzNjI4NjtcbmNvbnN0IExvb3BPbmNlID0gMjIwMDtcbmNvbnN0IExvb3BSZXBlYXQgPSAyMjAxO1xuY29uc3QgTG9vcFBpbmdQb25nID0gMjIwMjtcbmNvbnN0IEludGVycG9sYXRlRGlzY3JldGUgPSAyMzAwO1xuY29uc3QgSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xuY29uc3QgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xuY29uc3QgWmVyb0N1cnZhdHVyZUVuZGluZyA9IDI0MDA7XG5jb25zdCBaZXJvU2xvcGVFbmRpbmcgPSAyNDAxO1xuY29uc3QgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XG5jb25zdCBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUgPSAyNTAwO1xuY29uc3QgQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGUgPSAyNTAxO1xuY29uc3QgVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xuY29uc3QgVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcbmNvbnN0IFRyaWFuZ2xlRmFuRHJhd01vZGUgPSAyO1xuY29uc3QgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xuY29uc3QgUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XG5jb25zdCBUYW5nZW50U3BhY2VOb3JtYWxNYXAgPSAwO1xuY29uc3QgT2JqZWN0U3BhY2VOb3JtYWxNYXAgPSAxO1xuXG4vLyBDb2xvciBzcGFjZSBzdHJpbmcgaWRlbnRpZmllcnMsIG1hdGNoaW5nIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgNCBhbmQgV2ViR1BVIG5hbWVzIHdoZXJlIGF2YWlsYWJsZS5cbmNvbnN0IE5vQ29sb3JTcGFjZSA9ICcnO1xuY29uc3QgU1JHQkNvbG9yU3BhY2UgPSAnc3JnYic7XG5jb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9ICdzcmdiLWxpbmVhcic7XG5jb25zdCBEaXNwbGF5UDNDb2xvclNwYWNlID0gJ2Rpc3BsYXktcDMnO1xuY29uc3QgTGluZWFyRGlzcGxheVAzQ29sb3JTcGFjZSA9ICdkaXNwbGF5LXAzLWxpbmVhcic7XG5cbmNvbnN0IExpbmVhclRyYW5zZmVyID0gJ2xpbmVhcic7XG5jb25zdCBTUkdCVHJhbnNmZXIgPSAnc3JnYic7XG5cbmNvbnN0IFJlYzcwOVByaW1hcmllcyA9ICdyZWM3MDknO1xuY29uc3QgUDNQcmltYXJpZXMgPSAncDMnO1xuXG5jb25zdCBaZXJvU3RlbmNpbE9wID0gMDtcbmNvbnN0IEtlZXBTdGVuY2lsT3AgPSA3NjgwO1xuY29uc3QgUmVwbGFjZVN0ZW5jaWxPcCA9IDc2ODE7XG5jb25zdCBJbmNyZW1lbnRTdGVuY2lsT3AgPSA3NjgyO1xuY29uc3QgRGVjcmVtZW50U3RlbmNpbE9wID0gNzY4MztcbmNvbnN0IEluY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1NTtcbmNvbnN0IERlY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1NjtcbmNvbnN0IEludmVydFN0ZW5jaWxPcCA9IDUzODY7XG5cbmNvbnN0IE5ldmVyU3RlbmNpbEZ1bmMgPSA1MTI7XG5jb25zdCBMZXNzU3RlbmNpbEZ1bmMgPSA1MTM7XG5jb25zdCBFcXVhbFN0ZW5jaWxGdW5jID0gNTE0O1xuY29uc3QgTGVzc0VxdWFsU3RlbmNpbEZ1bmMgPSA1MTU7XG5jb25zdCBHcmVhdGVyU3RlbmNpbEZ1bmMgPSA1MTY7XG5jb25zdCBOb3RFcXVhbFN0ZW5jaWxGdW5jID0gNTE3O1xuY29uc3QgR3JlYXRlckVxdWFsU3RlbmNpbEZ1bmMgPSA1MTg7XG5jb25zdCBBbHdheXNTdGVuY2lsRnVuYyA9IDUxOTtcblxuY29uc3QgTmV2ZXJDb21wYXJlID0gNTEyO1xuY29uc3QgTGVzc0NvbXBhcmUgPSA1MTM7XG5jb25zdCBFcXVhbENvbXBhcmUgPSA1MTQ7XG5jb25zdCBMZXNzRXF1YWxDb21wYXJlID0gNTE1O1xuY29uc3QgR3JlYXRlckNvbXBhcmUgPSA1MTY7XG5jb25zdCBOb3RFcXVhbENvbXBhcmUgPSA1MTc7XG5jb25zdCBHcmVhdGVyRXF1YWxDb21wYXJlID0gNTE4O1xuY29uc3QgQWx3YXlzQ29tcGFyZSA9IDUxOTtcblxuY29uc3QgU3RhdGljRHJhd1VzYWdlID0gMzUwNDQ7XG5jb25zdCBEeW5hbWljRHJhd1VzYWdlID0gMzUwNDg7XG5jb25zdCBTdHJlYW1EcmF3VXNhZ2UgPSAzNTA0MDtcbmNvbnN0IFN0YXRpY1JlYWRVc2FnZSA9IDM1MDQ1O1xuY29uc3QgRHluYW1pY1JlYWRVc2FnZSA9IDM1MDQ5O1xuY29uc3QgU3RyZWFtUmVhZFVzYWdlID0gMzUwNDE7XG5jb25zdCBTdGF0aWNDb3B5VXNhZ2UgPSAzNTA0NjtcbmNvbnN0IER5bmFtaWNDb3B5VXNhZ2UgPSAzNTA1MDtcbmNvbnN0IFN0cmVhbUNvcHlVc2FnZSA9IDM1MDQyO1xuXG5jb25zdCBHTFNMMSA9ICcxMDAnO1xuY29uc3QgR0xTTDMgPSAnMzAwIGVzJztcblxuY29uc3QgV2ViR0xDb29yZGluYXRlU3lzdGVtID0gMjAwMDtcbmNvbnN0IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gPSAyMDAxO1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xuICovXG5cbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0YWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cblx0XHR9XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0aGFzRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0cmV0dXJuIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxO1xuXG5cdH1cblxuXHRyZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZGlzcGF0Y2hFdmVudCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGNvbnN0IGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcblxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXG5cdFx0XHQvLyBNYWtlIGEgY29weSwgaW4gY2FzZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgd2hpbGUgaXRlcmF0aW5nLlxuXHRcdFx0Y29uc3QgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKCAwICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmNvbnN0IF9sdXQgPSBbICcwMCcsICcwMScsICcwMicsICcwMycsICcwNCcsICcwNScsICcwNicsICcwNycsICcwOCcsICcwOScsICcwYScsICcwYicsICcwYycsICcwZCcsICcwZScsICcwZicsICcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOScsICcxYScsICcxYicsICcxYycsICcxZCcsICcxZScsICcxZicsICcyMCcsICcyMScsICcyMicsICcyMycsICcyNCcsICcyNScsICcyNicsICcyNycsICcyOCcsICcyOScsICcyYScsICcyYicsICcyYycsICcyZCcsICcyZScsICcyZicsICczMCcsICczMScsICczMicsICczMycsICczNCcsICczNScsICczNicsICczNycsICczOCcsICczOScsICczYScsICczYicsICczYycsICczZCcsICczZScsICczZicsICc0MCcsICc0MScsICc0MicsICc0MycsICc0NCcsICc0NScsICc0NicsICc0NycsICc0OCcsICc0OScsICc0YScsICc0YicsICc0YycsICc0ZCcsICc0ZScsICc0ZicsICc1MCcsICc1MScsICc1MicsICc1MycsICc1NCcsICc1NScsICc1NicsICc1NycsICc1OCcsICc1OScsICc1YScsICc1YicsICc1YycsICc1ZCcsICc1ZScsICc1ZicsICc2MCcsICc2MScsICc2MicsICc2MycsICc2NCcsICc2NScsICc2NicsICc2NycsICc2OCcsICc2OScsICc2YScsICc2YicsICc2YycsICc2ZCcsICc2ZScsICc2ZicsICc3MCcsICc3MScsICc3MicsICc3MycsICc3NCcsICc3NScsICc3NicsICc3NycsICc3OCcsICc3OScsICc3YScsICc3YicsICc3YycsICc3ZCcsICc3ZScsICc3ZicsICc4MCcsICc4MScsICc4MicsICc4MycsICc4NCcsICc4NScsICc4NicsICc4NycsICc4OCcsICc4OScsICc4YScsICc4YicsICc4YycsICc4ZCcsICc4ZScsICc4ZicsICc5MCcsICc5MScsICc5MicsICc5MycsICc5NCcsICc5NScsICc5NicsICc5NycsICc5OCcsICc5OScsICc5YScsICc5YicsICc5YycsICc5ZCcsICc5ZScsICc5ZicsICdhMCcsICdhMScsICdhMicsICdhMycsICdhNCcsICdhNScsICdhNicsICdhNycsICdhOCcsICdhOScsICdhYScsICdhYicsICdhYycsICdhZCcsICdhZScsICdhZicsICdiMCcsICdiMScsICdiMicsICdiMycsICdiNCcsICdiNScsICdiNicsICdiNycsICdiOCcsICdiOScsICdiYScsICdiYicsICdiYycsICdiZCcsICdiZScsICdiZicsICdjMCcsICdjMScsICdjMicsICdjMycsICdjNCcsICdjNScsICdjNicsICdjNycsICdjOCcsICdjOScsICdjYScsICdjYicsICdjYycsICdjZCcsICdjZScsICdjZicsICdkMCcsICdkMScsICdkMicsICdkMycsICdkNCcsICdkNScsICdkNicsICdkNycsICdkOCcsICdkOScsICdkYScsICdkYicsICdkYycsICdkZCcsICdkZScsICdkZicsICdlMCcsICdlMScsICdlMicsICdlMycsICdlNCcsICdlNScsICdlNicsICdlNycsICdlOCcsICdlOScsICdlYScsICdlYicsICdlYycsICdlZCcsICdlZScsICdlZicsICdmMCcsICdmMScsICdmMicsICdmMycsICdmNCcsICdmNScsICdmNicsICdmNycsICdmOCcsICdmOScsICdmYScsICdmYicsICdmYycsICdmZCcsICdmZScsICdmZicgXTtcblxubGV0IF9zZWVkID0gMTIzNDU2NztcblxuXG5jb25zdCBERUcyUkFEID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IFJBRDJERUcgPSAxODAgLyBNYXRoLlBJO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblxuXHRjb25zdCBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgdXVpZCA9IF9sdXRbIGQwICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDEgJiAweGZmIF0gKyBfbHV0WyBkMSA+PiA4ICYgMHhmZiBdICsgJy0nICsgX2x1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgX2x1dFsgZDEgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDIgJiAweDNmIHwgMHg4MCBdICsgX2x1dFsgZDIgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQyID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDIgPj4gMjQgJiAweGZmIF0gK1xuXHRcdFx0X2x1dFsgZDMgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiA4ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiAyNCAmIDB4ZmYgXTtcblxuXHQvLyAudG9Mb3dlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cdHJldHVybiB1dWlkLnRvTG93ZXJDYXNlKCk7XG5cbn1cblxuZnVuY3Rpb24gY2xhbXAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuXHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xuXG59XG5cbi8vIGNvbXB1dGUgZXVjbGlkZWFuIG1vZHVsbyBvZiBtICUgblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuZnVuY3Rpb24gZXVjbGlkZWFuTW9kdWxvKCBuLCBtICkge1xuXG5cdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cbn1cblxuLy8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuZnVuY3Rpb24gbWFwTGluZWFyKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcblxuXHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxufVxuXG4vLyBodHRwczovL3d3dy5nYW1lZGV2Lm5ldC90dXRvcmlhbHMvcHJvZ3JhbW1pbmcvZ2VuZXJhbC1hbmQtZ2FtZXBsYXktcHJvZ3JhbW1pbmcvaW52ZXJzZS1sZXJwLWEtc3VwZXItdXNlZnVsLXlldC1vZnRlbi1vdmVybG9va2VkLWZ1bmN0aW9uLXI1MjMwL1xuZnVuY3Rpb24gaW52ZXJzZUxlcnAoIHgsIHksIHZhbHVlICkge1xuXG5cdGlmICggeCAhPT0geSApIHtcblxuXHRcdHJldHVybiAoIHZhbHVlIC0geCApIC8gKCB5IC0geCApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gMDtcblxuXHR9XG5cbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cbmZ1bmN0aW9uIGxlcnAoIHgsIHksIHQgKSB7XG5cblx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxufVxuXG4vLyBodHRwOi8vd3d3LnJvcnlkcmlzY29sbC5jb20vMjAxNi8wMy8wNy9mcmFtZS1yYXRlLWluZGVwZW5kZW50LWRhbXBpbmctdXNpbmctbGVycC9cbmZ1bmN0aW9uIGRhbXAoIHgsIHksIGxhbWJkYSwgZHQgKSB7XG5cblx0cmV0dXJuIGxlcnAoIHgsIHksIDEgLSBNYXRoLmV4cCggLSBsYW1iZGEgKiBkdCApICk7XG5cbn1cblxuLy8gaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3Zjc2pueXo3eDRcbmZ1bmN0aW9uIHBpbmdwb25nKCB4LCBsZW5ndGggPSAxICkge1xuXG5cdHJldHVybiBsZW5ndGggLSBNYXRoLmFicyggZXVjbGlkZWFuTW9kdWxvKCB4LCBsZW5ndGggKiAyICkgLSBsZW5ndGggKTtcblxufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcbmZ1bmN0aW9uIHNtb290aHN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcblxufVxuXG5mdW5jdGlvbiBzbW9vdGhlcnN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcblxufVxuXG4vLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5mdW5jdGlvbiByYW5kSW50KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEZsb2F0KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXG5mdW5jdGlvbiByYW5kRmxvYXRTcHJlYWQoIHJhbmdlICkge1xuXG5cdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG59XG5cbi8vIERldGVybWluaXN0aWMgcHNldWRvLXJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgWyAwLCAxIF1cbmZ1bmN0aW9uIHNlZWRlZFJhbmRvbSggcyApIHtcblxuXHRpZiAoIHMgIT09IHVuZGVmaW5lZCApIF9zZWVkID0gcztcblxuXHQvLyBNdWxiZXJyeTMyIGdlbmVyYXRvclxuXG5cdGxldCB0ID0gX3NlZWQgKz0gMHg2RDJCNzlGNTtcblxuXHR0ID0gTWF0aC5pbXVsKCB0IF4gdCA+Pj4gMTUsIHQgfCAxICk7XG5cblx0dCBePSB0ICsgTWF0aC5pbXVsKCB0IF4gdCA+Pj4gNywgdCB8IDYxICk7XG5cblx0cmV0dXJuICggKCB0IF4gdCA+Pj4gMTQgKSA+Pj4gMCApIC8gNDI5NDk2NzI5NjtcblxufVxuXG5mdW5jdGlvbiBkZWdUb1JhZCggZGVncmVlcyApIHtcblxuXHRyZXR1cm4gZGVncmVlcyAqIERFRzJSQUQ7XG5cbn1cblxuZnVuY3Rpb24gcmFkVG9EZWcoIHJhZGlhbnMgKSB7XG5cblx0cmV0dXJuIHJhZGlhbnMgKiBSQUQyREVHO1xuXG59XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cbn1cblxuZnVuY3Rpb24gY2VpbFBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxufVxuXG5mdW5jdGlvbiBmbG9vclBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlciggcSwgYSwgYiwgYywgb3JkZXIgKSB7XG5cblx0Ly8gSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXMgLSBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXG5cblx0Ly8gcm90YXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBheGVzIGluIHRoZSBvcmRlciBzcGVjaWZpZWQgYnkgJ29yZGVyJ1xuXHQvLyByb3RhdGlvbiBieSBhbmdsZSAnYScgaXMgYXBwbGllZCBmaXJzdCwgdGhlbiBieSBhbmdsZSAnYicsIHRoZW4gYnkgYW5nbGUgJ2MnXG5cdC8vIGFuZ2xlcyBhcmUgaW4gcmFkaWFuc1xuXG5cdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRjb25zdCBjMiA9IGNvcyggYiAvIDIgKTtcblx0Y29uc3QgczIgPSBzaW4oIGIgLyAyICk7XG5cblx0Y29uc3QgYzEzID0gY29zKCAoIGEgKyBjICkgLyAyICk7XG5cdGNvbnN0IHMxMyA9IHNpbiggKCBhICsgYyApIC8gMiApO1xuXG5cdGNvbnN0IGMxXzMgPSBjb3MoICggYSAtIGMgKSAvIDIgKTtcblx0Y29uc3QgczFfMyA9IHNpbiggKCBhIC0gYyApIC8gMiApO1xuXG5cdGNvbnN0IGMzXzEgPSBjb3MoICggYyAtIGEgKSAvIDIgKTtcblx0Y29uc3QgczNfMSA9IHNpbiggKCBjIC0gYSApIC8gMiApO1xuXG5cdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0Y2FzZSAnWFlYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1laWSc6XG5cdFx0XHRxLnNldCggczIgKiBzMV8zLCBjMiAqIHMxMywgczIgKiBjMV8zLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWFonOlxuXHRcdFx0cS5zZXQoIHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWFpYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1lYWSc6XG5cdFx0XHRxLnNldCggczIgKiBjM18xLCBjMiAqIHMxMywgczIgKiBzM18xLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWVonOlxuXHRcdFx0cS5zZXQoIHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gZGVub3JtYWxpemUoIHZhbHVlLCBhcnJheSApIHtcblxuXHRzd2l0Y2ggKCBhcnJheS5jb25zdHJ1Y3RvciApIHtcblxuXHRcdGNhc2UgRmxvYXQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRjYXNlIFVpbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA0Mjk0OTY3Mjk1LjA7XG5cblx0XHRjYXNlIFVpbnQxNkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA2NTUzNS4wO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyAyNTUuMDtcblxuXHRcdGNhc2UgSW50MzJBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDIxNDc0ODM2NDcuMCwgLSAxLjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDMyNzY3LjAsIC0gMS4wICk7XG5cblx0XHRjYXNlIEludDhBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDEyNy4wLCAtIDEuMCApO1xuXG5cdFx0ZGVmYXVsdDpcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wb25lbnQgdHlwZS4nICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSggdmFsdWUsIGFycmF5ICkge1xuXG5cdHN3aXRjaCAoIGFycmF5LmNvbnN0cnVjdG9yICkge1xuXG5cdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdGNhc2UgVWludDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDQyOTQ5NjcyOTUuMCApO1xuXG5cdFx0Y2FzZSBVaW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogNjU1MzUuMCApO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyNTUuMCApO1xuXG5cdFx0Y2FzZSBJbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyMTQ3NDgzNjQ3LjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogMzI3NjcuMCApO1xuXG5cdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDEyNy4wICk7XG5cblx0XHRkZWZhdWx0OlxuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXBvbmVudCB0eXBlLicgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgTWF0aFV0aWxzID0ge1xuXHRERUcyUkFEOiBERUcyUkFELFxuXHRSQUQyREVHOiBSQUQyREVHLFxuXHRnZW5lcmF0ZVVVSUQ6IGdlbmVyYXRlVVVJRCxcblx0Y2xhbXA6IGNsYW1wLFxuXHRldWNsaWRlYW5Nb2R1bG86IGV1Y2xpZGVhbk1vZHVsbyxcblx0bWFwTGluZWFyOiBtYXBMaW5lYXIsXG5cdGludmVyc2VMZXJwOiBpbnZlcnNlTGVycCxcblx0bGVycDogbGVycCxcblx0ZGFtcDogZGFtcCxcblx0cGluZ3Bvbmc6IHBpbmdwb25nLFxuXHRzbW9vdGhzdGVwOiBzbW9vdGhzdGVwLFxuXHRzbW9vdGhlcnN0ZXA6IHNtb290aGVyc3RlcCxcblx0cmFuZEludDogcmFuZEludCxcblx0cmFuZEZsb2F0OiByYW5kRmxvYXQsXG5cdHJhbmRGbG9hdFNwcmVhZDogcmFuZEZsb2F0U3ByZWFkLFxuXHRzZWVkZWRSYW5kb206IHNlZWRlZFJhbmRvbSxcblx0ZGVnVG9SYWQ6IGRlZ1RvUmFkLFxuXHRyYWRUb0RlZzogcmFkVG9EZWcsXG5cdGlzUG93ZXJPZlR3bzogaXNQb3dlck9mVHdvLFxuXHRjZWlsUG93ZXJPZlR3bzogY2VpbFBvd2VyT2ZUd28sXG5cdGZsb29yUG93ZXJPZlR3bzogZmxvb3JQb3dlck9mVHdvLFxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyOiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxuXHRub3JtYWxpemU6IG5vcm1hbGl6ZSxcblx0ZGVub3JtYWxpemU6IGRlbm9ybWFsaXplXG59O1xuXG5jbGFzcyBWZWN0b3IyIHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwICkge1xuXG5cdFx0VmVjdG9yMi5wcm90b3R5cGUuaXNWZWN0b3IyID0gdHJ1ZTtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHR9XG5cblx0Z2V0IHdpZHRoKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueDtcblxuXHR9XG5cblx0c2V0IHdpZHRoKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMueCA9IHZhbHVlO1xuXG5cdH1cblxuXHRnZXQgaGVpZ2h0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueTtcblxuXHR9XG5cblx0c2V0IGhlaWdodCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnkgPSB2YWx1ZTtcblxuXHR9XG5cblx0c2V0KCB4LCB5ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRZKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRDb21wb25lbnQoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDb21wb25lbnQoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xuXG5cdH1cblxuXHRjb3B5KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGQoIHYgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGVkVmVjdG9yKCB2LCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViKCB2ICkge1xuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCB2ICkge1xuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpdmlkZVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXgzKCBtICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdO1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1pbiggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1heCggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xuXG5cdH1cblxuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmQoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZFRvWmVybygpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgudHJ1bmMoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgudHJ1bmMoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG5lZ2F0ZSgpIHtcblxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRvdCggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG5cblx0fVxuXG5cdGNyb3NzKCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcblxuXHR9XG5cblx0bGVuZ3RoU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcblxuXHR9XG5cblx0bWFuaGF0dGFuTGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKTtcblxuXHR9XG5cblx0bm9ybWFsaXplKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcblxuXHR9XG5cblx0YW5nbGUoKSB7XG5cblx0XHQvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xuXG5cdFx0Y29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKCAtIHRoaXMueSwgLSB0aGlzLnggKSArIE1hdGguUEk7XG5cblx0XHRyZXR1cm4gYW5nbGU7XG5cblx0fVxuXG5cdGFuZ2xlVG8oIHYgKSB7XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIE1hdGguUEkgLyAyO1xuXG5cdFx0Y29uc3QgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gZGVub21pbmF0b3I7XG5cblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG5cdFx0cmV0dXJuIE1hdGguYWNvcyggY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9TcXVhcmVkKCB2ICkge1xuXG5cdFx0Y29uc3QgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblxuXHR9XG5cblx0bWFuaGF0dGFuRGlzdGFuY2VUbyggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICk7XG5cblx0fVxuXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xuXG5cdH1cblxuXHRsZXJwKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwVmVjdG9ycyggdjEsIHYyLCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCA9IHYxLnggKyAoIHYyLnggLSB2MS54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgPSB2MS55ICsgKCB2Mi55IC0gdjEueSApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4ICkge1xuXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlQXJvdW5kKCBjZW50ZXIsIGFuZ2xlICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCBhbmdsZSApLCBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54IC0gY2VudGVyLng7XG5cdFx0Y29uc3QgeSA9IHRoaXMueSAtIGNlbnRlci55O1xuXG5cdFx0dGhpcy54ID0geCAqIGMgLSB5ICogcyArIGNlbnRlci54O1xuXHRcdHRoaXMueSA9IHggKiBzICsgeSAqIGMgKyBjZW50ZXIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyYW5kb20oKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueSA9IE1hdGgucmFuZG9tKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLng7XG5cdFx0eWllbGQgdGhpcy55O1xuXG5cdH1cblxufVxuXG5jbGFzcyBNYXRyaXgzIHtcblxuXHRjb25zdHJ1Y3RvciggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuXHRcdE1hdHJpeDMucHJvdG90eXBlLmlzTWF0cml4MyA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNldCggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMSBdID0gbjIxOyB0ZVsgMiBdID0gbjMxO1xuXHRcdHRlWyAzIF0gPSBuMTI7IHRlWyA0IF0gPSBuMjI7IHRlWyA1IF0gPSBuMzI7XG5cdFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdO1xuXHRcdHRlWyAzIF0gPSBtZVsgMyBdOyB0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdOyB0ZVsgOCBdID0gbWVbIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHRyYWN0QmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbiggdGhpcywgMCApO1xuXHRcdHlBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4NCggbSApIHtcblxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtZVsgMCBdLCBtZVsgNCBdLCBtZVsgOCBdLFxuXHRcdFx0bWVbIDEgXSwgbWVbIDUgXSwgbWVbIDkgXSxcblx0XHRcdG1lWyAyIF0sIG1lWyA2IF0sIG1lWyAxMCBdXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH1cblxuXHRwcmVtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9XG5cblx0bXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIHtcblxuXHRcdGNvbnN0IGFlID0gYS5lbGVtZW50cztcblx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDMgXSwgYTEzID0gYWVbIDYgXTtcblx0XHRjb25zdCBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNCBdLCBhMjMgPSBhZVsgNyBdO1xuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA1IF0sIGEzMyA9IGFlWyA4IF07XG5cblx0XHRjb25zdCBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgMyBdLCBiMTMgPSBiZVsgNiBdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA0IF0sIGIyMyA9IGJlWyA3IF07XG5cdFx0Y29uc3QgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDUgXSwgYjMzID0gYmVbIDggXTtcblxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XG5cdFx0dGVbIDMgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcblx0XHR0ZVsgNiBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xuXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcblx0XHR0ZVsgNCBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuXHRcdHRlWyA3IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XG5cblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxO1xuXHRcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG5cdFx0dGVbIDggXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRldGVybWluYW50KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcblx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXG5cdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSB0ZVsgMCBdLCBuMjEgPSB0ZVsgMSBdLCBuMzEgPSB0ZVsgMiBdLFxuXHRcdFx0bjEyID0gdGVbIDMgXSwgbjIyID0gdGVbIDQgXSwgbjMyID0gdGVbIDUgXSxcblx0XHRcdG4xMyA9IHRlWyA2IF0sIG4yMyA9IHRlWyA3IF0sIG4zMyA9IHRlWyA4IF0sXG5cblx0XHRcdHQxMSA9IG4zMyAqIG4yMiAtIG4zMiAqIG4yMyxcblx0XHRcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcblx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcblxuXHRcdFx0ZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzO1xuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgKTtcblxuXHRcdGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdHRlWyAxIF0gPSAoIG4zMSAqIG4yMyAtIG4zMyAqIG4yMSApICogZGV0SW52O1xuXHRcdHRlWyAyIF0gPSAoIG4zMiAqIG4yMSAtIG4zMSAqIG4yMiApICogZGV0SW52O1xuXG5cdFx0dGVbIDMgXSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVsgNCBdID0gKCBuMzMgKiBuMTEgLSBuMzEgKiBuMTMgKSAqIGRldEludjtcblx0XHR0ZVsgNSBdID0gKCBuMzEgKiBuMTIgLSBuMzIgKiBuMTEgKSAqIGRldEludjtcblxuXHRcdHRlWyA2IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0dGVbIDcgXSA9ICggbjIxICogbjEzIC0gbjIzICogbjExICkgKiBkZXRJbnY7XG5cdFx0dGVbIDggXSA9ICggbjIyICogbjExIC0gbjIxICogbjEyICkgKiBkZXRJbnY7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNwb3NlKCkge1xuXG5cdFx0bGV0IHRtcDtcblx0XHRjb25zdCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE5vcm1hbE1hdHJpeCggbWF0cml4NCApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuaW52ZXJ0KCkudHJhbnNwb3NlKCk7XG5cblx0fVxuXG5cdHRyYW5zcG9zZUludG9BcnJheSggciApIHtcblxuXHRcdGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0clsgMCBdID0gbVsgMCBdO1xuXHRcdHJbIDEgXSA9IG1bIDMgXTtcblx0XHRyWyAyIF0gPSBtWyA2IF07XG5cdFx0clsgMyBdID0gbVsgMSBdO1xuXHRcdHJbIDQgXSA9IG1bIDQgXTtcblx0XHRyWyA1IF0gPSBtWyA3IF07XG5cdFx0clsgNiBdID0gbVsgMiBdO1xuXHRcdHJbIDcgXSA9IG1bIDUgXTtcblx0XHRyWyA4IF0gPSBtWyA4IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0VXZUcmFuc2Zvcm0oIHR4LCB0eSwgc3gsIHN5LCByb3RhdGlvbiwgY3gsIGN5ICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggcm90YXRpb24gKTtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0c3ggKiBjLCBzeCAqIHMsIC0gc3ggKiAoIGMgKiBjeCArIHMgKiBjeSApICsgY3ggKyB0eCxcblx0XHRcdC0gc3kgKiBzLCBzeSAqIGMsIC0gc3kgKiAoIC0gcyAqIGN4ICsgYyAqIGN5ICkgKyBjeSArIHR5LFxuXHRcdFx0MCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly9cblxuXHRzY2FsZSggc3gsIHN5ICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VTY2FsZSggc3gsIHN5ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGUoIHRoZXRhICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VSb3RhdGlvbiggLSB0aGV0YSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCB0eCwgdHkgKSB7XG5cblx0XHR0aGlzLnByZW11bHRpcGx5KCBfbTMubWFrZVRyYW5zbGF0aW9uKCB0eCwgdHkgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIGZvciAyRCBUcmFuc2Zvcm1zXG5cblx0bWFrZVRyYW5zbGF0aW9uKCB4LCB5ICkge1xuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMiApIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgeC54LFxuXHRcdFx0XHQwLCAxLCB4LnksXG5cdFx0XHRcdDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIHgsXG5cdFx0XHRcdDAsIDEsIHksXG5cdFx0XHRcdDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb24oIHRoZXRhICkge1xuXG5cdFx0Ly8gY291bnRlcmNsb2Nrd2lzZVxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRjLCAtIHMsIDAsXG5cdFx0XHRzLCBjLCAwLFxuXHRcdFx0MCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2NhbGUoIHgsIHkgKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCxcblx0XHRcdDAsIHksIDAsXG5cdFx0XHQwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vXG5cblx0ZXF1YWxzKCBtYXRyaXggKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfbTMgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCk7XG5cbmZ1bmN0aW9uIGFycmF5TmVlZHNVaW50MzIoIGFycmF5ICkge1xuXG5cdC8vIGFzc3VtZXMgbGFyZ2VyIHZhbHVlcyB1c3VhbGx5IG9uIGxhc3RcblxuXHRmb3IgKCBsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS0gaSApIHtcblxuXHRcdGlmICggYXJyYXlbIGkgXSA+PSA2NTUzNSApIHJldHVybiB0cnVlOyAvLyBhY2NvdW50IGZvciBQUklNSVRJVkVfUkVTVEFSVF9GSVhFRF9JTkRFWCwgIzI0NTY1XG5cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcblxufVxuXG5jb25zdCBUWVBFRF9BUlJBWVMgPSB7XG5cdEludDhBcnJheTogSW50OEFycmF5LFxuXHRVaW50OEFycmF5OiBVaW50OEFycmF5LFxuXHRVaW50OENsYW1wZWRBcnJheTogVWludDhDbGFtcGVkQXJyYXksXG5cdEludDE2QXJyYXk6IEludDE2QXJyYXksXG5cdFVpbnQxNkFycmF5OiBVaW50MTZBcnJheSxcblx0SW50MzJBcnJheTogSW50MzJBcnJheSxcblx0VWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxuXHRGbG9hdDMyQXJyYXk6IEZsb2F0MzJBcnJheSxcblx0RmxvYXQ2NEFycmF5OiBGbG9hdDY0QXJyYXlcbn07XG5cbmZ1bmN0aW9uIGdldFR5cGVkQXJyYXkoIHR5cGUsIGJ1ZmZlciApIHtcblxuXHRyZXR1cm4gbmV3IFRZUEVEX0FSUkFZU1sgdHlwZSBdKCBidWZmZXIgKTtcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMoIG5hbWUgKSB7XG5cblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCBuYW1lICk7XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FudmFzRWxlbWVudCgpIHtcblxuXHRjb25zdCBjYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoICdjYW52YXMnICk7XG5cdGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0cmV0dXJuIGNhbnZhcztcblxufVxuXG5jb25zdCBfY2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk9uY2UoIG1lc3NhZ2UgKSB7XG5cblx0aWYgKCBtZXNzYWdlIGluIF9jYWNoZSApIHJldHVybjtcblxuXHRfY2FjaGVbIG1lc3NhZ2UgXSA9IHRydWU7XG5cblx0Y29uc29sZS53YXJuKCBtZXNzYWdlICk7XG5cbn1cblxuZnVuY3Rpb24gcHJvYmVBc3luYyggZ2wsIHN5bmMsIGludGVydmFsICkge1xuXG5cdHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlLCByZWplY3QgKSB7XG5cblx0XHRmdW5jdGlvbiBwcm9iZSgpIHtcblxuXHRcdFx0c3dpdGNoICggZ2wuY2xpZW50V2FpdFN5bmMoIHN5bmMsIGdsLlNZTkNfRkxVU0hfQ09NTUFORFNfQklULCAwICkgKSB7XG5cblx0XHRcdFx0Y2FzZSBnbC5XQUlUX0ZBSUxFRDpcblx0XHRcdFx0XHRyZWplY3QoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIGdsLlRJTUVPVVRfRVhQSVJFRDpcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCBwcm9iZSwgaW50ZXJ2YWwgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJlc29sdmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c2V0VGltZW91dCggcHJvYmUsIGludGVydmFsICk7XG5cblx0fSApO1xuXG59XG5cbi8qKlxuICogTWF0cmljZXMgY29udmVydGluZyBQMyA8LT4gUmVjLiA3MDkgcHJpbWFyaWVzLCB3aXRob3V0IGdhbXV0IG1hcHBpbmdcbiAqIG9yIGNsaXBwaW5nLiBCYXNlZCBvbiBXM0Mgc3BlY2lmaWNhdGlvbnMgZm9yIHNSR0IgYW5kIERpc3BsYXkgUDMsXG4gKiBhbmQgSUNDIHNwZWNpZmljYXRpb25zIGZvciB0aGUgRDUwIGNvbm5lY3Rpb24gc3BhY2UuIFZhbHVlcyBpbi9vdXRcbiAqIGFyZSBfbGluZWFyXyBzUkdCIGFuZCBfbGluZWFyXyBEaXNwbGF5IFAzLlxuICpcbiAqIE5vdGUgdGhhdCBib3RoIHNSR0IgYW5kIERpc3BsYXkgUDMgdXNlIHRoZSBzUkdCIHRyYW5zZmVyIGZ1bmN0aW9ucy5cbiAqXG4gKiBSZWZlcmVuY2U6XG4gKiAtIGh0dHA6Ly93d3cucnVzc2VsbGNvdHRyZWxsLmNvbS9waG90by9tYXRyaXhDYWxjdWxhdG9yLmh0bVxuICovXG5cbmNvbnN0IExJTkVBUl9TUkdCX1RPX0xJTkVBUl9ESVNQTEFZX1AzID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpLnNldChcblx0MC44MjI0NjIxLCAwLjE3NzUzOCwgMC4wLFxuXHQwLjAzMzE5NDEsIDAuOTY2ODA1OCwgMC4wLFxuXHQwLjAxNzA4MjcsIDAuMDcyMzk3NCwgMC45MTA1MTk5LFxuKTtcblxuY29uc3QgTElORUFSX0RJU1BMQVlfUDNfVE9fTElORUFSX1NSR0IgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkuc2V0KFxuXHQxLjIyNDk0MDEsIC0gMC4yMjQ5NDA0LCAwLjAsXG5cdC0gMC4wNDIwNTY5LCAxLjA0MjA1NzEsIDAuMCxcblx0LSAwLjAxOTYzNzYsIC0gMC4wNzg2MzYxLCAxLjA5ODI3MzVcbik7XG5cbi8qKlxuICogRGVmaW5lcyBzdXBwb3J0ZWQgY29sb3Igc3BhY2VzIGJ5IHRyYW5zZmVyIGZ1bmN0aW9uIGFuZCBwcmltYXJpZXMsXG4gKiBhbmQgcHJvdmlkZXMgY29udmVyc2lvbnMgdG8vZnJvbSB0aGUgTGluZWFyLXNSR0IgcmVmZXJlbmNlIHNwYWNlLlxuICovXG5jb25zdCBDT0xPUl9TUEFDRVMgPSB7XG5cdFsgTGluZWFyU1JHQkNvbG9yU3BhY2UgXToge1xuXHRcdHRyYW5zZmVyOiBMaW5lYXJUcmFuc2Zlcixcblx0XHRwcmltYXJpZXM6IFJlYzcwOVByaW1hcmllcyxcblx0XHR0b1JlZmVyZW5jZTogKCBjb2xvciApID0+IGNvbG9yLFxuXHRcdGZyb21SZWZlcmVuY2U6ICggY29sb3IgKSA9PiBjb2xvcixcblx0fSxcblx0WyBTUkdCQ29sb3JTcGFjZSBdOiB7XG5cdFx0dHJhbnNmZXI6IFNSR0JUcmFuc2Zlcixcblx0XHRwcmltYXJpZXM6IFJlYzcwOVByaW1hcmllcyxcblx0XHR0b1JlZmVyZW5jZTogKCBjb2xvciApID0+IGNvbG9yLmNvbnZlcnRTUkdCVG9MaW5lYXIoKSxcblx0XHRmcm9tUmVmZXJlbmNlOiAoIGNvbG9yICkgPT4gY29sb3IuY29udmVydExpbmVhclRvU1JHQigpLFxuXHR9LFxuXHRbIExpbmVhckRpc3BsYXlQM0NvbG9yU3BhY2UgXToge1xuXHRcdHRyYW5zZmVyOiBMaW5lYXJUcmFuc2Zlcixcblx0XHRwcmltYXJpZXM6IFAzUHJpbWFyaWVzLFxuXHRcdHRvUmVmZXJlbmNlOiAoIGNvbG9yICkgPT4gY29sb3IuYXBwbHlNYXRyaXgzKCBMSU5FQVJfRElTUExBWV9QM19UT19MSU5FQVJfU1JHQiApLFxuXHRcdGZyb21SZWZlcmVuY2U6ICggY29sb3IgKSA9PiBjb2xvci5hcHBseU1hdHJpeDMoIExJTkVBUl9TUkdCX1RPX0xJTkVBUl9ESVNQTEFZX1AzICksXG5cdH0sXG5cdFsgRGlzcGxheVAzQ29sb3JTcGFjZSBdOiB7XG5cdFx0dHJhbnNmZXI6IFNSR0JUcmFuc2Zlcixcblx0XHRwcmltYXJpZXM6IFAzUHJpbWFyaWVzLFxuXHRcdHRvUmVmZXJlbmNlOiAoIGNvbG9yICkgPT4gY29sb3IuY29udmVydFNSR0JUb0xpbmVhcigpLmFwcGx5TWF0cml4MyggTElORUFSX0RJU1BMQVlfUDNfVE9fTElORUFSX1NSR0IgKSxcblx0XHRmcm9tUmVmZXJlbmNlOiAoIGNvbG9yICkgPT4gY29sb3IuYXBwbHlNYXRyaXgzKCBMSU5FQVJfU1JHQl9UT19MSU5FQVJfRElTUExBWV9QMyApLmNvbnZlcnRMaW5lYXJUb1NSR0IoKSxcblx0fSxcbn07XG5cbmNvbnN0IFNVUFBPUlRFRF9XT1JLSU5HX0NPTE9SX1NQQUNFUyA9IG5ldyBTZXQoIFsgTGluZWFyU1JHQkNvbG9yU3BhY2UsIExpbmVhckRpc3BsYXlQM0NvbG9yU3BhY2UgXSApO1xuXG5jb25zdCBDb2xvck1hbmFnZW1lbnQgPSB7XG5cblx0ZW5hYmxlZDogdHJ1ZSxcblxuXHRfd29ya2luZ0NvbG9yU3BhY2U6IExpbmVhclNSR0JDb2xvclNwYWNlLFxuXG5cdGdldCB3b3JraW5nQ29sb3JTcGFjZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl93b3JraW5nQ29sb3JTcGFjZTtcblxuXHR9LFxuXG5cdHNldCB3b3JraW5nQ29sb3JTcGFjZSggY29sb3JTcGFjZSApIHtcblxuXHRcdGlmICggISBTVVBQT1JURURfV09SS0lOR19DT0xPUl9TUEFDRVMuaGFzKCBjb2xvclNwYWNlICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggYFVuc3VwcG9ydGVkIHdvcmtpbmcgY29sb3Igc3BhY2UsIFwiJHsgY29sb3JTcGFjZSB9XCIuYCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fd29ya2luZ0NvbG9yU3BhY2UgPSBjb2xvclNwYWNlO1xuXG5cdH0sXG5cblx0Y29udmVydDogZnVuY3Rpb24gKCBjb2xvciwgc291cmNlQ29sb3JTcGFjZSwgdGFyZ2V0Q29sb3JTcGFjZSApIHtcblxuXHRcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSB8fCBzb3VyY2VDb2xvclNwYWNlID09PSB0YXJnZXRDb2xvclNwYWNlIHx8ICEgc291cmNlQ29sb3JTcGFjZSB8fCAhIHRhcmdldENvbG9yU3BhY2UgKSB7XG5cblx0XHRcdHJldHVybiBjb2xvcjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNvdXJjZVRvUmVmZXJlbmNlID0gQ09MT1JfU1BBQ0VTWyBzb3VyY2VDb2xvclNwYWNlIF0udG9SZWZlcmVuY2U7XG5cdFx0Y29uc3QgdGFyZ2V0RnJvbVJlZmVyZW5jZSA9IENPTE9SX1NQQUNFU1sgdGFyZ2V0Q29sb3JTcGFjZSBdLmZyb21SZWZlcmVuY2U7XG5cblx0XHRyZXR1cm4gdGFyZ2V0RnJvbVJlZmVyZW5jZSggc291cmNlVG9SZWZlcmVuY2UoIGNvbG9yICkgKTtcblxuXHR9LFxuXG5cdGZyb21Xb3JraW5nQ29sb3JTcGFjZTogZnVuY3Rpb24gKCBjb2xvciwgdGFyZ2V0Q29sb3JTcGFjZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbnZlcnQoIGNvbG9yLCB0aGlzLl93b3JraW5nQ29sb3JTcGFjZSwgdGFyZ2V0Q29sb3JTcGFjZSApO1xuXG5cdH0sXG5cblx0dG9Xb3JraW5nQ29sb3JTcGFjZTogZnVuY3Rpb24gKCBjb2xvciwgc291cmNlQ29sb3JTcGFjZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbnZlcnQoIGNvbG9yLCBzb3VyY2VDb2xvclNwYWNlLCB0aGlzLl93b3JraW5nQ29sb3JTcGFjZSApO1xuXG5cdH0sXG5cblx0Z2V0UHJpbWFyaWVzOiBmdW5jdGlvbiAoIGNvbG9yU3BhY2UgKSB7XG5cblx0XHRyZXR1cm4gQ09MT1JfU1BBQ0VTWyBjb2xvclNwYWNlIF0ucHJpbWFyaWVzO1xuXG5cdH0sXG5cblx0Z2V0VHJhbnNmZXI6IGZ1bmN0aW9uICggY29sb3JTcGFjZSApIHtcblxuXHRcdGlmICggY29sb3JTcGFjZSA9PT0gTm9Db2xvclNwYWNlICkgcmV0dXJuIExpbmVhclRyYW5zZmVyO1xuXG5cdFx0cmV0dXJuIENPTE9SX1NQQUNFU1sgY29sb3JTcGFjZSBdLnRyYW5zZmVyO1xuXG5cdH0sXG5cbn07XG5cblxuZnVuY3Rpb24gU1JHQlRvTGluZWFyKCBjICkge1xuXG5cdHJldHVybiAoIGMgPCAwLjA0MDQ1ICkgPyBjICogMC4wNzczOTkzODA4IDogTWF0aC5wb3coIGMgKiAwLjk0Nzg2NzI5ODYgKyAwLjA1MjEzMjcwMTQsIDIuNCApO1xuXG59XG5cbmZ1bmN0aW9uIExpbmVhclRvU1JHQiggYyApIHtcblxuXHRyZXR1cm4gKCBjIDwgMC4wMDMxMzA4ICkgPyBjICogMTIuOTIgOiAxLjA1NSAqICggTWF0aC5wb3coIGMsIDAuNDE2NjYgKSApIC0gMC4wNTU7XG5cbn1cblxubGV0IF9jYW52YXM7XG5cbmNsYXNzIEltYWdlVXRpbHMge1xuXG5cdHN0YXRpYyBnZXREYXRhVVJMKCBpbWFnZSApIHtcblxuXHRcdGlmICggL15kYXRhOi9pLnRlc3QoIGltYWdlLnNyYyApICkge1xuXG5cdFx0XHRyZXR1cm4gaW1hZ2Uuc3JjO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgPT09ICd1bmRlZmluZWQnICkge1xuXG5cdFx0XHRyZXR1cm4gaW1hZ2Uuc3JjO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGNhbnZhcztcblxuXHRcdGlmICggaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApIHtcblxuXHRcdFx0Y2FudmFzID0gaW1hZ2U7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIF9jYW52YXMgPT09IHVuZGVmaW5lZCApIF9jYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoICdjYW52YXMnICk7XG5cblx0XHRcdF9jYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcblx0XHRcdF9jYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0XHRjb25zdCBjb250ZXh0ID0gX2NhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG5cblx0XHRcdGlmICggaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGEgKSB7XG5cblx0XHRcdFx0Y29udGV4dC5wdXRJbWFnZURhdGEoIGltYWdlLCAwLCAwICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y2FudmFzID0gX2NhbnZhcztcblxuXHRcdH1cblxuXHRcdGlmICggY2FudmFzLndpZHRoID4gMjA0OCB8fCBjYW52YXMuaGVpZ2h0ID4gMjA0OCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5nZXREYXRhVVJMOiBJbWFnZSBjb252ZXJ0ZWQgdG8ganBnIGZvciBwZXJmb3JtYW5jZSByZWFzb25zJywgaW1hZ2UgKTtcblxuXHRcdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9qcGVnJywgMC42ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL3BuZycgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c3RhdGljIHNSR0JUb0xpbmVhciggaW1hZ2UgKSB7XG5cblx0XHRpZiAoICggdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHx8XG5cdFx0XHQoIHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApIHx8XG5cdFx0XHQoIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCApICkge1xuXG5cdFx0XHRjb25zdCBjYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoICdjYW52YXMnICk7XG5cblx0XHRcdGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuXHRcdFx0Y29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG5cdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdFx0Y29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblx0XHRcdGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0ZGF0YVsgaSBdID0gU1JHQlRvTGluZWFyKCBkYXRhWyBpIF0gLyAyNTUgKSAqIDI1NTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2VEYXRhLCAwLCAwICk7XG5cblx0XHRcdHJldHVybiBjYW52YXM7XG5cblx0XHR9IGVsc2UgaWYgKCBpbWFnZS5kYXRhICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0gaW1hZ2UuZGF0YS5zbGljZSggMCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSApIHtcblxuXHRcdFx0XHRcdGRhdGFbIGkgXSA9IE1hdGguZmxvb3IoIFNSR0JUb0xpbmVhciggZGF0YVsgaSBdIC8gMjU1ICkgKiAyNTUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gYXNzdW1pbmcgZmxvYXRcblxuXHRcdFx0XHRcdGRhdGFbIGkgXSA9IFNSR0JUb0xpbmVhciggZGF0YVsgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdHdpZHRoOiBpbWFnZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBpbWFnZS5oZWlnaHRcblx0XHRcdH07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZVV0aWxzLnNSR0JUb0xpbmVhcigpOiBVbnN1cHBvcnRlZCBpbWFnZSB0eXBlLiBObyBjb2xvciBzcGFjZSBjb252ZXJzaW9uIGFwcGxpZWQuJyApO1xuXHRcdFx0cmV0dXJuIGltYWdlO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5sZXQgX3NvdXJjZUlkID0gMDtcblxuY2xhc3MgU291cmNlIHtcblxuXHRjb25zdHJ1Y3RvciggZGF0YSA9IG51bGwgKSB7XG5cblx0XHR0aGlzLmlzU291cmNlID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX3NvdXJjZUlkICsrIH0gKTtcblxuXHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0XHR0aGlzLmRhdGFSZWFkeSA9IHRydWU7XG5cblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXG5cdH1cblxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XG5cblx0XHRpZiAoICEgaXNSb290T2JqZWN0ICYmIG1ldGEuaW1hZ2VzWyB0aGlzLnV1aWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gbWV0YS5pbWFnZXNbIHRoaXMudXVpZCBdO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3V0cHV0ID0ge1xuXHRcdFx0dXVpZDogdGhpcy51dWlkLFxuXHRcdFx0dXJsOiAnJ1xuXHRcdH07XG5cblx0XHRjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuXG5cdFx0aWYgKCBkYXRhICE9PSBudWxsICkge1xuXG5cdFx0XHRsZXQgdXJsO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblxuXHRcdFx0XHQvLyBjdWJlIHRleHR1cmVcblxuXHRcdFx0XHR1cmwgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGRhdGFbIGkgXS5pc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHR1cmwucHVzaCggc2VyaWFsaXplSW1hZ2UoIGRhdGFbIGkgXS5pbWFnZSApICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR1cmwucHVzaCggc2VyaWFsaXplSW1hZ2UoIGRhdGFbIGkgXSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIHRleHR1cmVcblxuXHRcdFx0XHR1cmwgPSBzZXJpYWxpemVJbWFnZSggZGF0YSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dHB1dC51cmwgPSB1cmw7XG5cblx0XHR9XG5cblx0XHRpZiAoICEgaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHRtZXRhLmltYWdlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVJbWFnZSggaW1hZ2UgKSB7XG5cblx0aWYgKCAoIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgKSB8fFxuXHRcdCggdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkgfHxcblx0XHQoIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCApICkge1xuXG5cdFx0Ly8gZGVmYXVsdCBpbWFnZXNcblxuXHRcdHJldHVybiBJbWFnZVV0aWxzLmdldERhdGFVUkwoIGltYWdlICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGlmICggaW1hZ2UuZGF0YSApIHtcblxuXHRcdFx0Ly8gaW1hZ2VzIG9mIERhdGFUZXh0dXJlXG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IEFycmF5LmZyb20oIGltYWdlLmRhdGEgKSxcblx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodCxcblx0XHRcdFx0dHlwZTogaW1hZ2UuZGF0YS5jb25zdHJ1Y3Rvci5uYW1lXG5cdFx0XHR9O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVGV4dHVyZTogVW5hYmxlIHRvIHNlcmlhbGl6ZSBUZXh0dXJlLicgKTtcblx0XHRcdHJldHVybiB7fTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxubGV0IF90ZXh0dXJlSWQgPSAwO1xuXG5jbGFzcyBUZXh0dXJlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRjb25zdHJ1Y3RvciggaW1hZ2UgPSBUZXh0dXJlLkRFRkFVTFRfSU1BR0UsIG1hcHBpbmcgPSBUZXh0dXJlLkRFRkFVTFRfTUFQUElORywgd3JhcFMgPSBDbGFtcFRvRWRnZVdyYXBwaW5nLCB3cmFwVCA9IENsYW1wVG9FZGdlV3JhcHBpbmcsIG1hZ0ZpbHRlciA9IExpbmVhckZpbHRlciwgbWluRmlsdGVyID0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLCBmb3JtYXQgPSBSR0JBRm9ybWF0LCB0eXBlID0gVW5zaWduZWRCeXRlVHlwZSwgYW5pc290cm9weSA9IFRleHR1cmUuREVGQVVMVF9BTklTT1RST1BZLCBjb2xvclNwYWNlID0gTm9Db2xvclNwYWNlICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX3RleHR1cmVJZCArKyB9ICk7XG5cblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXG5cdFx0dGhpcy5zb3VyY2UgPSBuZXcgU291cmNlKCBpbWFnZSApO1xuXHRcdHRoaXMubWlwbWFwcyA9IFtdO1xuXG5cdFx0dGhpcy5tYXBwaW5nID0gbWFwcGluZztcblx0XHR0aGlzLmNoYW5uZWwgPSAwO1xuXG5cdFx0dGhpcy53cmFwUyA9IHdyYXBTO1xuXHRcdHRoaXMud3JhcFQgPSB3cmFwVDtcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyO1xuXHRcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyO1xuXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcblxuXHRcdHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuXHRcdHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBudWxsO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cblx0XHR0aGlzLm9mZnNldCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XG5cdFx0dGhpcy5yZXBlYXQgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXHRcdHRoaXMuY2VudGVyID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4MygpO1xuXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuXHRcdHRoaXMuZmxpcFkgPSB0cnVlO1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gNDtcdC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXG5cdFx0dGhpcy5jb2xvclNwYWNlID0gY29sb3JTcGFjZTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cdFx0dGhpcy5vblVwZGF0ZSA9IG51bGw7XG5cblx0XHR0aGlzLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IGZhbHNlOyAvLyBpbmRpY2F0ZXMgd2hldGhlciBhIHRleHR1cmUgYmVsb25ncyB0byBhIHJlbmRlciB0YXJnZXQgb3Igbm90XG5cdFx0dGhpcy5wbXJlbVZlcnNpb24gPSAwOyAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRleHR1cmUgc2hvdWxkIGJlIHByb2Nlc3NlZCBieSBQTVJFTUdlbmVyYXRvciBvciBub3QgKG9ubHkgcmVsZXZhbnQgZm9yIHJlbmRlciB0YXJnZXQgdGV4dHVyZXMpXG5cblx0fVxuXG5cdGdldCBpbWFnZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnNvdXJjZS5kYXRhO1xuXG5cdH1cblxuXHRzZXQgaW1hZ2UoIHZhbHVlID0gbnVsbCApIHtcblxuXHRcdHRoaXMuc291cmNlLmRhdGEgPSB2YWx1ZTtcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4KCkge1xuXG5cdFx0dGhpcy5tYXRyaXguc2V0VXZUcmFuc2Zvcm0oIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnksIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnksIHRoaXMucm90YXRpb24sIHRoaXMuY2VudGVyLngsIHRoaXMuY2VudGVyLnkgKTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2Uuc291cmNlO1xuXHRcdHRoaXMubWlwbWFwcyA9IHNvdXJjZS5taXBtYXBzLnNsaWNlKCAwICk7XG5cblx0XHR0aGlzLm1hcHBpbmcgPSBzb3VyY2UubWFwcGluZztcblx0XHR0aGlzLmNoYW5uZWwgPSBzb3VyY2UuY2hhbm5lbDtcblxuXHRcdHRoaXMud3JhcFMgPSBzb3VyY2Uud3JhcFM7XG5cdFx0dGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gc291cmNlLm1hZ0ZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XG5cblx0XHR0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcblxuXHRcdHRoaXMuZm9ybWF0ID0gc291cmNlLmZvcm1hdDtcblx0XHR0aGlzLmludGVybmFsRm9ybWF0ID0gc291cmNlLmludGVybmFsRm9ybWF0O1xuXHRcdHRoaXMudHlwZSA9IHNvdXJjZS50eXBlO1xuXG5cdFx0dGhpcy5vZmZzZXQuY29weSggc291cmNlLm9mZnNldCApO1xuXHRcdHRoaXMucmVwZWF0LmNvcHkoIHNvdXJjZS5yZXBlYXQgKTtcblx0XHR0aGlzLmNlbnRlci5jb3B5KCBzb3VyY2UuY2VudGVyICk7XG5cdFx0dGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcblxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcblx0XHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbHlBbHBoYTtcblx0XHR0aGlzLmZsaXBZID0gc291cmNlLmZsaXBZO1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gc291cmNlLnVucGFja0FsaWdubWVudDtcblx0XHR0aGlzLmNvbG9yU3BhY2UgPSBzb3VyY2UuY29sb3JTcGFjZTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdGNvbnN0IGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xuXG5cdFx0aWYgKCAhIGlzUm9vdE9iamVjdCAmJiBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF07XG5cblx0XHR9XG5cblx0XHRjb25zdCBvdXRwdXQgPSB7XG5cblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ1RleHR1cmUnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdUZXh0dXJlLnRvSlNPTidcblx0XHRcdH0sXG5cblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdG5hbWU6IHRoaXMubmFtZSxcblxuXHRcdFx0aW1hZ2U6IHRoaXMuc291cmNlLnRvSlNPTiggbWV0YSApLnV1aWQsXG5cblx0XHRcdG1hcHBpbmc6IHRoaXMubWFwcGluZyxcblx0XHRcdGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcblxuXHRcdFx0cmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcblx0XHRcdG9mZnNldDogWyB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55IF0sXG5cdFx0XHRjZW50ZXI6IFsgdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSBdLFxuXHRcdFx0cm90YXRpb246IHRoaXMucm90YXRpb24sXG5cblx0XHRcdHdyYXA6IFsgdGhpcy53cmFwUywgdGhpcy53cmFwVCBdLFxuXG5cdFx0XHRmb3JtYXQ6IHRoaXMuZm9ybWF0LFxuXHRcdFx0aW50ZXJuYWxGb3JtYXQ6IHRoaXMuaW50ZXJuYWxGb3JtYXQsXG5cdFx0XHR0eXBlOiB0aGlzLnR5cGUsXG5cdFx0XHRjb2xvclNwYWNlOiB0aGlzLmNvbG9yU3BhY2UsXG5cblx0XHRcdG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXIsXG5cdFx0XHRtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxuXHRcdFx0YW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5LFxuXG5cdFx0XHRmbGlwWTogdGhpcy5mbGlwWSxcblxuXHRcdFx0Z2VuZXJhdGVNaXBtYXBzOiB0aGlzLmdlbmVyYXRlTWlwbWFwcyxcblx0XHRcdHByZW11bHRpcGx5QWxwaGE6IHRoaXMucHJlbXVsdGlwbHlBbHBoYSxcblx0XHRcdHVucGFja0FsaWdubWVudDogdGhpcy51bnBhY2tBbGlnbm1lbnRcblxuXHRcdH07XG5cblx0XHRpZiAoIE9iamVjdC5rZXlzKCB0aGlzLnVzZXJEYXRhICkubGVuZ3RoID4gMCApIG91dHB1dC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG5cblx0XHRpZiAoICEgaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHRtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSA9IG91dHB1dDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cblx0dHJhbnNmb3JtVXYoIHV2ICkge1xuXG5cdFx0aWYgKCB0aGlzLm1hcHBpbmcgIT09IFVWTWFwcGluZyApIHJldHVybiB1djtcblxuXHRcdHV2LmFwcGx5TWF0cml4MyggdGhpcy5tYXRyaXggKTtcblxuXHRcdGlmICggdXYueCA8IDAgfHwgdXYueCA+IDEgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHRoaXMud3JhcFMgKSB7XG5cblx0XHRcdFx0Y2FzZSBSZXBlYXRXcmFwcGluZzpcblxuXHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcblxuXHRcdFx0XHRcdHV2LnggPSB1di54IDwgMCA/IDAgOiAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcblxuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnggKSAlIDIgKSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dXYueCA9IE1hdGguY2VpbCggdXYueCApIC0gdXYueDtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdXYueSA8IDAgfHwgdXYueSA+IDEgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHRoaXMud3JhcFQgKSB7XG5cblx0XHRcdFx0Y2FzZSBSZXBlYXRXcmFwcGluZzpcblxuXHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcblxuXHRcdFx0XHRcdHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcblxuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnkgKSAlIDIgKSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dXYueSA9IE1hdGguY2VpbCggdXYueSApIC0gdXYueTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5mbGlwWSApIHtcblxuXHRcdFx0dXYueSA9IDEgLSB1di55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHV2O1xuXG5cdH1cblxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy52ZXJzaW9uICsrO1xuXHRcdFx0dGhpcy5zb3VyY2UubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQgbmVlZHNQTVJFTVVwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLnBtcmVtVmVyc2lvbiArKztcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuVGV4dHVyZS5ERUZBVUxUX0lNQUdFID0gbnVsbDtcblRleHR1cmUuREVGQVVMVF9NQVBQSU5HID0gVVZNYXBwaW5nO1xuVGV4dHVyZS5ERUZBVUxUX0FOSVNPVFJPUFkgPSAxO1xuXG5jbGFzcyBWZWN0b3I0IHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEgKSB7XG5cblx0XHRWZWN0b3I0LnByb3RvdHlwZS5pc1ZlY3RvcjQgPSB0cnVlO1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cdFx0dGhpcy53ID0gdztcblxuXHR9XG5cblx0Z2V0IHdpZHRoKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuejtcblxuXHR9XG5cblx0c2V0IHdpZHRoKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMueiA9IHZhbHVlO1xuXG5cdH1cblxuXHRnZXQgaGVpZ2h0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudztcblxuXHR9XG5cblx0c2V0IGhlaWdodCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLncgPSB2YWx1ZTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cdFx0dGhpcy53ID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0dGhpcy56ID0gc2NhbGFyO1xuXHRcdHRoaXMudyA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRZKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRaKCB6ICkge1xuXG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRXKCB3ICkge1xuXG5cdFx0dGhpcy53ID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRDb21wb25lbnQoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50KCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRjYXNlIDM6IHJldHVybiB0aGlzLnc7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XG5cblx0fVxuXG5cdGNvcHkoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblx0XHR0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZCggdiApIHtcblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXHRcdHRoaXMudyArPSB2Lnc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cdFx0dGhpcy56ICs9IHM7XG5cdFx0dGhpcy53ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xuXHRcdHRoaXMudyA9IGEudyArIGIudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsZWRWZWN0b3IoIHYsIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHR0aGlzLnogKz0gdi56ICogcztcblx0XHR0aGlzLncgKz0gdi53ICogcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWIoIHYgKSB7XG5cblx0XHR0aGlzLnggLT0gdi54O1xuXHRcdHRoaXMueSAtPSB2Lnk7XG5cdFx0dGhpcy56IC09IHYuejtcblx0XHR0aGlzLncgLT0gdi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXHRcdHRoaXMueiAtPSBzO1xuXHRcdHRoaXMudyAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblx0XHR0aGlzLncgPSBhLncgLSBiLnc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIHYgKSB7XG5cblx0XHR0aGlzLnggKj0gdi54O1xuXHRcdHRoaXMueSAqPSB2Lnk7XG5cdFx0dGhpcy56ICo9IHYuejtcblx0XHR0aGlzLncgKj0gdi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcblx0XHR0aGlzLncgKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICogdztcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICogdztcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSAqIHc7XG5cdFx0dGhpcy53ID0gZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKiB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpdmlkZVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9XG5cblx0c2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXG5cblx0XHQvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XG5cblx0XHRjb25zdCBzID0gTWF0aC5zcXJ0KCAxIC0gcS53ICogcS53ICk7XG5cblx0XHRpZiAoIHMgPCAwLjAwMDEgKSB7XG5cblx0XHRcdHRoaXMueCA9IDE7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0dGhpcy56ID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMueCA9IHEueCAvIHM7XG5cdFx0XHR0aGlzLnkgPSBxLnkgLyBzO1xuXHRcdFx0dGhpcy56ID0gcS56IC8gcztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXgoIG0gKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHRsZXQgYW5nbGUsIHgsIHksIHo7IC8vIHZhcmlhYmxlcyBmb3IgcmVzdWx0XG5cdFx0Y29uc3QgZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXG5cdFx0XHRlcHNpbG9uMiA9IDAuMSxcdFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcblxuXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcblx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG5cdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKSAmJlxuXHRcdCAgICAgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uICkgJiZcblx0XHQgICAgICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xuXG5cdFx0XHQvLyBzaW5ndWxhcml0eSBmb3VuZFxuXHRcdFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xuXHRcdFx0Ly8gaW4gbGVhZGluZyBkaWFnb25hbCBhbmQgemVybyBpbiBvdGhlciB0ZXJtc1xuXG5cdFx0XHRpZiAoICggTWF0aC5hYnMoIG0xMiArIG0yMSApIDwgZXBzaWxvbjIgKSAmJlxuXHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yICkgJiZcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTIzICsgbTMyICkgPCBlcHNpbG9uMiApICYmXG5cdFx0XHQgICAgICggTWF0aC5hYnMoIG0xMSArIG0yMiArIG0zMyAtIDMgKSA8IGVwc2lsb24yICkgKSB7XG5cblx0XHRcdFx0Ly8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXG5cblx0XHRcdFx0dGhpcy5zZXQoIDEsIDAsIDAsIDAgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxuXG5cdFx0XHRhbmdsZSA9IE1hdGguUEk7XG5cblx0XHRcdGNvbnN0IHh4ID0gKCBtMTEgKyAxICkgLyAyO1xuXHRcdFx0Y29uc3QgeXkgPSAoIG0yMiArIDEgKSAvIDI7XG5cdFx0XHRjb25zdCB6eiA9ICggbTMzICsgMSApIC8gMjtcblx0XHRcdGNvbnN0IHh5ID0gKCBtMTIgKyBtMjEgKSAvIDQ7XG5cdFx0XHRjb25zdCB4eiA9ICggbTEzICsgbTMxICkgLyA0O1xuXHRcdFx0Y29uc3QgeXogPSAoIG0yMyArIG0zMiApIC8gNDtcblxuXHRcdFx0aWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcblxuXHRcdFx0XHQvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG5cdFx0XHRcdGlmICggeHggPCBlcHNpbG9uICkge1xuXG5cdFx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0eCA9IE1hdGguc3FydCggeHggKTtcblx0XHRcdFx0XHR5ID0geHkgLyB4O1xuXHRcdFx0XHRcdHogPSB4eiAvIHg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCB5eSA+IHp6ICkge1xuXG5cdFx0XHRcdC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cblx0XHRcdFx0aWYgKCB5eSA8IGVwc2lsb24gKSB7XG5cblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR5ID0gTWF0aC5zcXJ0KCB5eSApO1xuXHRcdFx0XHRcdHggPSB4eSAvIHk7XG5cdFx0XHRcdFx0eiA9IHl6IC8geTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xuXG5cdFx0XHRcdGlmICggenogPCBlcHNpbG9uICkge1xuXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHR6ID0gMDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0eiA9IE1hdGguc3FydCggenogKTtcblx0XHRcdFx0XHR4ID0geHogLyB6O1xuXHRcdFx0XHRcdHkgPSB5eiAvIHo7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0KCB4LCB5LCB6LCBhbmdsZSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpczsgLy8gcmV0dXJuIDE4MCBkZWcgcm90YXRpb25cblxuXHRcdH1cblxuXHRcdC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcblxuXHRcdGxldCBzID0gTWF0aC5zcXJ0KCAoIG0zMiAtIG0yMyApICogKCBtMzIgLSBtMjMgKSArXG5cdFx0XHQoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKSArXG5cdFx0XHQoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxuXG5cdFx0aWYgKCBNYXRoLmFicyggcyApIDwgMC4wMDEgKSBzID0gMTtcblxuXHRcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcblx0XHQvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcblxuXHRcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdHRoaXMueSA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWluKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XG5cdFx0dGhpcy53ID0gTWF0aC5taW4oIHRoaXMudywgdi53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWF4KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XG5cdFx0dGhpcy53ID0gTWF0aC5tYXgoIHRoaXMudywgdi53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xuXHRcdHRoaXMudyA9IE1hdGgubWF4KCBtaW4udywgTWF0aC5taW4oIG1heC53LCB0aGlzLncgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy55ICkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnogKSApO1xuXHRcdHRoaXMudyA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMudyApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xuXG5cdH1cblxuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXHRcdHRoaXMudyA9IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblx0XHR0aGlzLncgPSBNYXRoLmNlaWwoIHRoaXMudyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cdFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmRUb1plcm8oKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnRydW5jKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnRydW5jKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLnRydW5jKCB0aGlzLnogKTtcblx0XHR0aGlzLncgPSBNYXRoLnRydW5jKCB0aGlzLncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRuZWdhdGUoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblx0XHR0aGlzLncgPSAtIHRoaXMudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xuXG5cdH1cblxuXHRsZW5ndGhTcSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XG5cblx0fVxuXG5cdGxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xuXG5cdH1cblxuXHRtYW5oYXR0YW5MZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xuXG5cdH1cblxuXHRub3JtYWxpemUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xuXG5cdH1cblxuXHRzZXRMZW5ndGgoIGxlbmd0aCApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcblxuXHR9XG5cblx0bGVycCggdiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cdFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcblx0XHR0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogPSB2MS56ICsgKCB2Mi56IC0gdjEueiApICogYWxwaGE7XG5cdFx0dGhpcy53ID0gdjEudyArICggdjIudyAtIHYxLncgKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggdiApIHtcblxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLnc7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XG5cblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcblx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WiggaW5kZXggKTtcblx0XHR0aGlzLncgPSBhdHRyaWJ1dGUuZ2V0VyggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyYW5kb20oKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueSA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy56ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLncgPSBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdCpbIFN5bWJvbC5pdGVyYXRvciBdKCkge1xuXG5cdFx0eWllbGQgdGhpcy54O1xuXHRcdHlpZWxkIHRoaXMueTtcblx0XHR5aWVsZCB0aGlzLno7XG5cdFx0eWllbGQgdGhpcy53O1xuXG5cdH1cblxufVxuXG4vKlxuIEluIG9wdGlvbnMsIHdlIGNhbiBzcGVjaWZ5OlxuICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxuICogZGVwdGhCdWZmZXIvc3RlbmNpbEJ1ZmZlcjogQm9vbGVhbnMgdG8gaW5kaWNhdGUgaWYgd2Ugc2hvdWxkIGdlbmVyYXRlIHRoZXNlIGJ1ZmZlcnNcbiovXG5jbGFzcyBSZW5kZXJUYXJnZXQgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzUmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcblxuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLmRlcHRoID0gMTtcblxuXHRcdHRoaXMuc2Npc3NvciA9IG5ldyBWZWN0b3I0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cdFx0dGhpcy5zY2lzc29yVGVzdCA9IGZhbHNlO1xuXG5cdFx0dGhpcy52aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRjb25zdCBpbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgZGVwdGg6IDEgfTtcblxuXHRcdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKCB7XG5cdFx0XHRnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuXHRcdFx0aW50ZXJuYWxGb3JtYXQ6IG51bGwsXG5cdFx0XHRtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcblx0XHRcdGRlcHRoQnVmZmVyOiB0cnVlLFxuXHRcdFx0c3RlbmNpbEJ1ZmZlcjogZmFsc2UsXG5cdFx0XHRyZXNvbHZlRGVwdGhCdWZmZXI6IHRydWUsXG5cdFx0XHRyZXNvbHZlU3RlbmNpbEJ1ZmZlcjogdHJ1ZSxcblx0XHRcdGRlcHRoVGV4dHVyZTogbnVsbCxcblx0XHRcdHNhbXBsZXM6IDAsXG5cdFx0XHRjb3VudDogMVxuXHRcdH0sIG9wdGlvbnMgKTtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSggaW1hZ2UsIG9wdGlvbnMubWFwcGluZywgb3B0aW9ucy53cmFwUywgb3B0aW9ucy53cmFwVCwgb3B0aW9ucy5tYWdGaWx0ZXIsIG9wdGlvbnMubWluRmlsdGVyLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBvcHRpb25zLmFuaXNvdHJvcHksIG9wdGlvbnMuY29sb3JTcGFjZSApO1xuXG5cdFx0dGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuXHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0dGV4dHVyZS5pbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQ7XG5cblx0XHR0aGlzLnRleHR1cmVzID0gW107XG5cblx0XHRjb25zdCBjb3VudCA9IG9wdGlvbnMuY291bnQ7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXSA9IHRleHR1cmUuY2xvbmUoKTtcblx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhCdWZmZXI7XG5cdFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyO1xuXG5cdFx0dGhpcy5yZXNvbHZlRGVwdGhCdWZmZXIgPSBvcHRpb25zLnJlc29sdmVEZXB0aEJ1ZmZlcjtcblx0XHR0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5yZXNvbHZlU3RlbmNpbEJ1ZmZlcjtcblxuXHRcdHRoaXMuZGVwdGhUZXh0dXJlID0gb3B0aW9ucy5kZXB0aFRleHR1cmU7XG5cblx0XHR0aGlzLnNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXM7XG5cblx0fVxuXG5cdGdldCB0ZXh0dXJlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudGV4dHVyZXNbIDAgXTtcblxuXHR9XG5cblx0c2V0IHRleHR1cmUoIHZhbHVlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlc1sgMCBdID0gdmFsdWU7XG5cblx0fVxuXG5cdHNldFNpemUoIHdpZHRoLCBoZWlnaHQsIGRlcHRoID0gMSApIHtcblxuXHRcdGlmICggdGhpcy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT09IGhlaWdodCB8fCB0aGlzLmRlcHRoICE9PSBkZXB0aCApIHtcblxuXHRcdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0aGlzLnRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXS5pbWFnZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHR0aGlzLnRleHR1cmVzWyBpIF0uaW1hZ2UuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0XHR0aGlzLnRleHR1cmVzWyBpIF0uaW1hZ2UuZGVwdGggPSBkZXB0aDtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMudmlld3BvcnQuc2V0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cdFx0dGhpcy5zY2lzc29yLnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG5cdFx0dGhpcy5kZXB0aCA9IHNvdXJjZS5kZXB0aDtcblxuXHRcdHRoaXMuc2Npc3Nvci5jb3B5KCBzb3VyY2Uuc2Npc3NvciApO1xuXHRcdHRoaXMuc2Npc3NvclRlc3QgPSBzb3VyY2Uuc2Npc3NvclRlc3Q7XG5cblx0XHR0aGlzLnZpZXdwb3J0LmNvcHkoIHNvdXJjZS52aWV3cG9ydCApO1xuXG5cdFx0dGhpcy50ZXh0dXJlcy5sZW5ndGggPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHNvdXJjZS50ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy50ZXh0dXJlc1sgaSBdID0gc291cmNlLnRleHR1cmVzWyBpIF0uY2xvbmUoKTtcblx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZW5zdXJlIGltYWdlIG9iamVjdCBpcyBub3Qgc2hhcmVkLCBzZWUgIzIwMzI4XG5cblx0XHRjb25zdCBpbWFnZSA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UudGV4dHVyZS5pbWFnZSApO1xuXHRcdHRoaXMudGV4dHVyZS5zb3VyY2UgPSBuZXcgU291cmNlKCBpbWFnZSApO1xuXG5cdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcblx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcblxuXHRcdHRoaXMucmVzb2x2ZURlcHRoQnVmZmVyID0gc291cmNlLnJlc29sdmVEZXB0aEJ1ZmZlcjtcblx0XHR0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyID0gc291cmNlLnJlc29sdmVTdGVuY2lsQnVmZmVyO1xuXG5cdFx0aWYgKCBzb3VyY2UuZGVwdGhUZXh0dXJlICE9PSBudWxsICkgdGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlLmNsb25lKCk7XG5cblx0XHR0aGlzLnNhbXBsZXMgPSBzb3VyY2Uuc2FtcGxlcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFdlYkdMUmVuZGVyVGFyZ2V0IGV4dGVuZHMgUmVuZGVyVGFyZ2V0IHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRzdXBlciggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG5cdFx0dGhpcy5pc1dlYkdMUmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRGF0YUFycmF5VGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCBkYXRhID0gbnVsbCwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEgKSB7XG5cblx0XHRzdXBlciggbnVsbCApO1xuXG5cdFx0dGhpcy5pc0RhdGFBcnJheVRleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy5pbWFnZSA9IHsgZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGggfTtcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHR0aGlzLndyYXBSID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzID0gbmV3IFNldCgpO1xuXG5cdH1cblxuXHRhZGRMYXllclVwZGF0ZSggbGF5ZXJJbmRleCApIHtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzLmFkZCggbGF5ZXJJbmRleCApO1xuXG5cdH1cblxuXHRjbGVhckxheWVyVXBkYXRlcygpIHtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzLmNsZWFyKCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFdlYkdMQXJyYXlSZW5kZXJUYXJnZXQgZXh0ZW5kcyBXZWJHTFJlbmRlclRhcmdldCB7XG5cblx0Y29uc3RydWN0b3IoIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRzdXBlciggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG5cdFx0dGhpcy5pc1dlYkdMQXJyYXlSZW5kZXJUYXJnZXQgPSB0cnVlO1xuXG5cdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xuXG5cdFx0dGhpcy50ZXh0dXJlID0gbmV3IERhdGFBcnJheVRleHR1cmUoIG51bGwsIHdpZHRoLCBoZWlnaHQsIGRlcHRoICk7XG5cblx0XHR0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRGF0YTNEVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCBkYXRhID0gbnVsbCwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEgKSB7XG5cblx0XHQvLyBXZSdyZSBnb2luZyB0byBhZGQgLnNldFhYWCgpIG1ldGhvZHMgZm9yIHNldHRpbmcgcHJvcGVydGllcyBsYXRlci5cblx0XHQvLyBVc2VycyBjYW4gc3RpbGwgc2V0IGluIERhdGFUZXh0dXJlM0QgZGlyZWN0bHkuXG5cdFx0Ly9cblx0XHQvL1x0Y29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZTNEKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xuXHRcdC8vIFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gMTY7XG5cdFx0Ly9cblx0XHQvLyBTZWUgIzE0ODM5XG5cblx0XHRzdXBlciggbnVsbCApO1xuXG5cdFx0dGhpcy5pc0RhdGEzRFRleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy5pbWFnZSA9IHsgZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGggfTtcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHR0aGlzLndyYXBSID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcblxuXHR9XG5cbn1cblxuY2xhc3MgV2ViR0wzRFJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XG5cblx0XHR0aGlzLmlzV2ViR0wzRFJlbmRlclRhcmdldCA9IHRydWU7XG5cblx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cblx0XHR0aGlzLnRleHR1cmUgPSBuZXcgRGF0YTNEVGV4dHVyZSggbnVsbCwgd2lkdGgsIGhlaWdodCwgZGVwdGggKTtcblxuXHRcdHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBRdWF0ZXJuaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEgKSB7XG5cblx0XHR0aGlzLmlzUXVhdGVybmlvbiA9IHRydWU7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl93ID0gdztcblxuXHR9XG5cblx0c3RhdGljIHNsZXJwRmxhdCggZHN0LCBkc3RPZmZzZXQsIHNyYzAsIHNyY09mZnNldDAsIHNyYzEsIHNyY09mZnNldDEsIHQgKSB7XG5cblx0XHQvLyBmdXp6LWZyZWUsIGFycmF5LWJhc2VkIFF1YXRlcm5pb24gU0xFUlAgb3BlcmF0aW9uXG5cblx0XHRsZXQgeDAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMCBdLFxuXHRcdFx0eTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdLFxuXHRcdFx0ejAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMiBdLFxuXHRcdFx0dzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdO1xuXG5cdFx0Y29uc3QgeDEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMCBdLFxuXHRcdFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxuXHRcdFx0ejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdLFxuXHRcdFx0dzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xuXG5cdFx0aWYgKCB0ID09PSAwICkge1xuXG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDAgXSA9IHgwO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0ID09PSAxICkge1xuXG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDAgXSA9IHgxO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MTtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejE7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcxO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEgKSB7XG5cblx0XHRcdGxldCBzID0gMSAtIHQ7XG5cdFx0XHRjb25zdCBjb3MgPSB4MCAqIHgxICsgeTAgKiB5MSArIHowICogejEgKyB3MCAqIHcxLFxuXHRcdFx0XHRkaXIgPSAoIGNvcyA+PSAwID8gMSA6IC0gMSApLFxuXHRcdFx0XHRzcXJTaW4gPSAxIC0gY29zICogY29zO1xuXG5cdFx0XHQvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxuXHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNxcnQoIHNxclNpbiApLFxuXHRcdFx0XHRcdGxlbiA9IE1hdGguYXRhbjIoIHNpbiwgY29zICogZGlyICk7XG5cblx0XHRcdFx0cyA9IE1hdGguc2luKCBzICogbGVuICkgLyBzaW47XG5cdFx0XHRcdHQgPSBNYXRoLnNpbiggdCAqIGxlbiApIC8gc2luO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHREaXIgPSB0ICogZGlyO1xuXG5cdFx0XHR4MCA9IHgwICogcyArIHgxICogdERpcjtcblx0XHRcdHkwID0geTAgKiBzICsgeTEgKiB0RGlyO1xuXHRcdFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XG5cdFx0XHR3MCA9IHcwICogcyArIHcxICogdERpcjtcblxuXHRcdFx0Ly8gTm9ybWFsaXplIGluIGNhc2Ugd2UganVzdCBkaWQgYSBsZXJwOlxuXHRcdFx0aWYgKCBzID09PSAxIC0gdCApIHtcblxuXHRcdFx0XHRjb25zdCBmID0gMSAvIE1hdGguc3FydCggeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCApO1xuXG5cdFx0XHRcdHgwICo9IGY7XG5cdFx0XHRcdHkwICo9IGY7XG5cdFx0XHRcdHowICo9IGY7XG5cdFx0XHRcdHcwICo9IGY7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcblxuXHR9XG5cblx0c3RhdGljIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSApIHtcblxuXHRcdGNvbnN0IHgwID0gc3JjMFsgc3JjT2Zmc2V0MCBdO1xuXHRcdGNvbnN0IHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXTtcblx0XHRjb25zdCB6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF07XG5cdFx0Y29uc3QgdzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdO1xuXG5cdFx0Y29uc3QgeDEgPSBzcmMxWyBzcmNPZmZzZXQxIF07XG5cdFx0Y29uc3QgeTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdO1xuXHRcdGNvbnN0IHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXTtcblx0XHRjb25zdCB3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XG5cblx0XHRkc3RbIGRzdE9mZnNldCBdID0geDAgKiB3MSArIHcwICogeDEgKyB5MCAqIHoxIC0gejAgKiB5MTtcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwICogdzEgKyB3MCAqIHkxICsgejAgKiB4MSAtIHgwICogejE7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MCAqIHcxICsgdzAgKiB6MSArIHgwICogeTEgLSB5MCAqIHgxO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzAgKiB3MSAtIHgwICogeDEgLSB5MCAqIHkxIC0gejAgKiB6MTtcblxuXHRcdHJldHVybiBkc3Q7XG5cblx0fVxuXG5cdGdldCB4KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0fVxuXG5cdHNldCB4KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cblx0fVxuXG5cdHNldCB5KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB6KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0fVxuXG5cdHNldCB6KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB3KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3c7XG5cblx0fVxuXG5cdHNldCB3KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3cgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdHNldCggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XG5cblx0fVxuXG5cdGNvcHkoIHF1YXRlcm5pb24gKSB7XG5cblx0XHR0aGlzLl94ID0gcXVhdGVybmlvbi54O1xuXHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XG5cdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcblx0XHR0aGlzLl93ID0gcXVhdGVybmlvbi53O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21FdWxlciggZXVsZXIsIHVwZGF0ZSA9IHRydWUgKSB7XG5cblx0XHRjb25zdCB4ID0gZXVsZXIuX3gsIHkgPSBldWxlci5feSwgeiA9IGV1bGVyLl96LCBvcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuXHRcdC8vXHRjb250ZW50L1NwaW5DYWxjLm1cblxuXHRcdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRcdGNvbnN0IHNpbiA9IE1hdGguc2luO1xuXG5cdFx0Y29uc3QgYzEgPSBjb3MoIHggLyAyICk7XG5cdFx0Y29uc3QgYzIgPSBjb3MoIHkgLyAyICk7XG5cdFx0Y29uc3QgYzMgPSBjb3MoIHogLyAyICk7XG5cblx0XHRjb25zdCBzMSA9IHNpbiggeCAvIDIgKTtcblx0XHRjb25zdCBzMiA9IHNpbiggeSAvIDIgKTtcblx0XHRjb25zdCBzMyA9IHNpbiggeiAvIDIgKTtcblxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0XHRjYXNlICdYWVonOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhaJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pYWSc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVgnOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHVwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cblx0XHRjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl94ID0gYXhpcy54ICogcztcblx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcblx0XHR0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcblx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdLFxuXG5cdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcblxuXHRcdGlmICggdHJhY2UgPiAwICkge1xuXG5cdFx0XHRjb25zdCBzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcblx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcblxuXHRcdH1cblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tVW5pdFZlY3RvcnMoIHZGcm9tLCB2VG8gKSB7XG5cblx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuXHRcdGxldCByID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cblx0XHRpZiAoIHIgPCBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0Ly8gdkZyb20gYW5kIHZUbyBwb2ludCBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zXG5cblx0XHRcdHIgPSAwO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAtIHZGcm9tLnk7XG5cdFx0XHRcdHRoaXMuX3kgPSB2RnJvbS54O1xuXHRcdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdHRoaXMuX3kgPSAtIHZGcm9tLno7XG5cdFx0XHRcdHRoaXMuX3ogPSB2RnJvbS55O1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7IC8vIGlubGluZWQgdG8gYXZvaWQgY3ljbGljIGRlcGVuZGVuY3kgb24gVmVjdG9yM1xuXG5cdFx0XHR0aGlzLl94ID0gdkZyb20ueSAqIHZUby56IC0gdkZyb20ueiAqIHZUby55O1xuXHRcdFx0dGhpcy5feSA9IHZGcm9tLnogKiB2VG8ueCAtIHZGcm9tLnggKiB2VG8uejtcblx0XHRcdHRoaXMuX3ogPSB2RnJvbS54ICogdlRvLnkgLSB2RnJvbS55ICogdlRvLng7XG5cdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRhbmdsZVRvKCBxICkge1xuXG5cdFx0cmV0dXJuIDIgKiBNYXRoLmFjb3MoIE1hdGguYWJzKCBjbGFtcCggdGhpcy5kb3QoIHEgKSwgLSAxLCAxICkgKSApO1xuXG5cdH1cblxuXHRyb3RhdGVUb3dhcmRzKCBxLCBzdGVwICkge1xuXG5cdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcblxuXHRcdGlmICggYW5nbGUgPT09IDAgKSByZXR1cm4gdGhpcztcblxuXHRcdGNvbnN0IHQgPSBNYXRoLm1pbiggMSwgc3RlcCAvIGFuZ2xlICk7XG5cblx0XHR0aGlzLnNsZXJwKCBxLCB0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDEgKTtcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Ly8gcXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpO1xuXG5cdH1cblxuXHRjb25qdWdhdGUoKSB7XG5cblx0XHR0aGlzLl94ICo9IC0gMTtcblx0XHR0aGlzLl95ICo9IC0gMTtcblx0XHR0aGlzLl96ICo9IC0gMTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cblx0fVxuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG5cdH1cblxuXHRub3JtYWxpemUoKSB7XG5cblx0XHRsZXQgbCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIGwgPT09IDAgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdHRoaXMuX3cgPSAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bCA9IDEgLyBsO1xuXG5cdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XG5cdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cblx0fVxuXG5cdHByZW11bHRpcGx5KCBxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xuXG5cdH1cblxuXHRtdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHRjb25zdCBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xuXHRcdGNvbnN0IHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XG5cblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNsZXJwKCBxYiwgdCApIHtcblxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cblx0XHRjb25zdCB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHRsZXQgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcblx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcblxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNxclNpbkhhbGZUaGV0YSA9IDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YTtcblxuXHRcdGlmICggc3FyU2luSGFsZlRoZXRhIDw9IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRjb25zdCBzID0gMSAtIHQ7XG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcblx0XHRcdHRoaXMuX3ggPSBzICogeCArIHQgKiB0aGlzLl94O1xuXHRcdFx0dGhpcy5feSA9IHMgKiB5ICsgdCAqIHRoaXMuX3k7XG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcblxuXHRcdFx0dGhpcy5ub3JtYWxpemUoKTsgLy8gbm9ybWFsaXplIGNhbGxzIF9vbkNoYW5nZUNhbGxiYWNrKClcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIHNxclNpbkhhbGZUaGV0YSApO1xuXHRcdGNvbnN0IGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XG5cdFx0Y29uc3QgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuXHRcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuXHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcblxuXHR9XG5cblx0cmFuZG9tKCkge1xuXG5cdFx0Ly8gc2V0cyB0aGlzIHF1YXRlcm5pb24gdG8gYSB1bmlmb3JtIHJhbmRvbSB1bml0IHF1YXRlcm5uaW9uXG5cblx0XHQvLyBLZW4gU2hvZW1ha2Vcblx0XHQvLyBVbmlmb3JtIHJhbmRvbSByb3RhdGlvbnNcblx0XHQvLyBELiBLaXJrLCBlZGl0b3IsIEdyYXBoaWNzIEdlbXMgSUlJLCBwYWdlcyAxMjQtMTMyLiBBY2FkZW1pYyBQcmVzcywgTmV3IFlvcmssIDE5OTIuXG5cblx0XHRjb25zdCB0aGV0YTEgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCk7XG5cdFx0Y29uc3QgdGhldGEyID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0Y29uc3QgeDAgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdGNvbnN0IHIxID0gTWF0aC5zcXJ0KCAxIC0geDAgKTtcblx0XHRjb25zdCByMiA9IE1hdGguc3FydCggeDAgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldChcblx0XHRcdHIxICogTWF0aC5zaW4oIHRoZXRhMSApLFxuXHRcdFx0cjEgKiBNYXRoLmNvcyggdGhldGExICksXG5cdFx0XHRyMiAqIE1hdGguc2luKCB0aGV0YTIgKSxcblx0XHRcdHIyICogTWF0aC5jb3MoIHRoZXRhMiApLFxuXHRcdCk7XG5cblx0fVxuXG5cdGVxdWFscyggcXVhdGVybmlvbiApIHtcblxuXHRcdHJldHVybiAoIHF1YXRlcm5pb24uX3ggPT09IHRoaXMuX3ggKSAmJiAoIHF1YXRlcm5pb24uX3kgPT09IHRoaXMuX3kgKSAmJiAoIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogKSAmJiAoIHF1YXRlcm5pb24uX3cgPT09IHRoaXMuX3cgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy5feSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XG5cblx0XHR0aGlzLl94ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy5feSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMuX3ogPSBhdHRyaWJ1dGUuZ2V0WiggaW5kZXggKTtcblx0XHR0aGlzLl93ID0gYXR0cmlidXRlLmdldFcoIGluZGV4ICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudG9BcnJheSgpO1xuXG5cdH1cblxuXHRfb25DaGFuZ2UoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdF9vbkNoYW5nZUNhbGxiYWNrKCkge31cblxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcblxuXHRcdHlpZWxkIHRoaXMuX3g7XG5cdFx0eWllbGQgdGhpcy5feTtcblx0XHR5aWVsZCB0aGlzLl96O1xuXHRcdHlpZWxkIHRoaXMuX3c7XG5cblx0fVxuXG59XG5cbmNsYXNzIFZlY3RvcjMge1xuXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwICkge1xuXG5cdFx0VmVjdG9yMy5wcm90b3R5cGUuaXNWZWN0b3IzID0gdHJ1ZTtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSB6O1xuXG5cdH1cblxuXHRzZXQoIHgsIHksIHogKSB7XG5cblx0XHRpZiAoIHogPT09IHVuZGVmaW5lZCApIHogPSB0aGlzLno7IC8vIHNwcml0ZS5zY2FsZS5zZXQoeCx5KVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggPSBzY2FsYXI7XG5cdFx0dGhpcy55ID0gc2NhbGFyO1xuXHRcdHRoaXMueiA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRZKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRaKCB6ICkge1xuXG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRDb21wb25lbnQoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldENvbXBvbmVudCggaW5kZXggKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xuXHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcblxuXHR9XG5cblx0Y29weSggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0dGhpcy56ID0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZCggdiApIHtcblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXHRcdHRoaXMueiArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHRoaXMueiA9IGEueiArIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsZWRWZWN0b3IoIHYsIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHR0aGlzLnogKz0gdi56ICogcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWIoIHYgKSB7XG5cblx0XHR0aGlzLnggLT0gdi54O1xuXHRcdHRoaXMueSAtPSB2Lnk7XG5cdFx0dGhpcy56IC09IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblx0XHR0aGlzLnogLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIHYgKSB7XG5cblx0XHR0aGlzLnggKj0gdi54O1xuXHRcdHRoaXMueSAqPSB2Lnk7XG5cdFx0dGhpcy56ICo9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXHRcdHRoaXMueiAqPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHlWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICogYi54O1xuXHRcdHRoaXMueSA9IGEueSAqIGIueTtcblx0XHR0aGlzLnogPSBhLnogKiBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlFdWxlciggZXVsZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uJDQuc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cblx0fVxuXG5cdGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24kNC5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU5vcm1hbE1hdHJpeCggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4MyggbSApLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG0gKSB7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgdyA9IDEgLyAoIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICk7XG5cblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKSAqIHc7XG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICkgKiB3O1xuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlRdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Ly8gcXVhdGVybmlvbiBxIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0Y29uc3QgdnggPSB0aGlzLngsIHZ5ID0gdGhpcy55LCB2eiA9IHRoaXMuejtcblx0XHRjb25zdCBxeCA9IHEueCwgcXkgPSBxLnksIHF6ID0gcS56LCBxdyA9IHEudztcblxuXHRcdC8vIHQgPSAyICogY3Jvc3MoIHEueHl6LCB2ICk7XG5cdFx0Y29uc3QgdHggPSAyICogKCBxeSAqIHZ6IC0gcXogKiB2eSApO1xuXHRcdGNvbnN0IHR5ID0gMiAqICggcXogKiB2eCAtIHF4ICogdnogKTtcblx0XHRjb25zdCB0eiA9IDIgKiAoIHF4ICogdnkgLSBxeSAqIHZ4ICk7XG5cblx0XHQvLyB2ICsgcS53ICogdCArIGNyb3NzKCBxLnh5eiwgdCApO1xuXHRcdHRoaXMueCA9IHZ4ICsgcXcgKiB0eCArIHF5ICogdHogLSBxeiAqIHR5O1xuXHRcdHRoaXMueSA9IHZ5ICsgcXcgKiB0eSArIHF6ICogdHggLSBxeCAqIHR6O1xuXHRcdHRoaXMueiA9IHZ6ICsgcXcgKiB0eiArIHF4ICogdHkgLSBxeSAqIHR4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHR9XG5cblx0dW5wcm9qZWN0KCBjYW1lcmEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbiggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGl2aWRlU2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdH1cblxuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xuXG5cdH1cblxuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kVG9aZXJvKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC50cnVuYyggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC50cnVuYyggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC50cnVuYyggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bmVnYXRlKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZG90KCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuXHR9XG5cblx0Ly8gVE9ETyBsZW5ndGhTcXVhcmVkP1xuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fVxuXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xuXG5cdH1cblxuXHRsZXJwKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogPSB2MS56ICsgKCB2Mi56IC0gdjEueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y3Jvc3MoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcblxuXHR9XG5cblx0Y3Jvc3NWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcblx0XHRjb25zdCBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cHJvamVjdE9uVmVjdG9yKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSB2Lmxlbmd0aFNxKCk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRjb25zdCBzY2FsYXIgPSB2LmRvdCggdGhpcyApIC8gZGVub21pbmF0b3I7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2ICkubXVsdGlwbHlTY2FsYXIoIHNjYWxhciApO1xuXG5cdH1cblxuXHRwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XG5cblx0XHRfdmVjdG9yJGMuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcblxuXHRcdHJldHVybiB0aGlzLnN1YiggX3ZlY3RvciRjICk7XG5cblx0fVxuXG5cdHJlZmxlY3QoIG5vcm1hbCApIHtcblxuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLnN1YiggX3ZlY3RvciRjLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuXHR9XG5cblx0YW5nbGVUbyggdiApIHtcblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSByZXR1cm4gTWF0aC5QSSAvIDI7XG5cblx0XHRjb25zdCB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cblx0XHRyZXR1cm4gTWF0aC5hY29zKCBjbGFtcCggdGhldGEsIC0gMSwgMSApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSB7XG5cblx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xuXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuXHR9XG5cblx0bWFuaGF0dGFuRGlzdGFuY2VUbyggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICkgKyBNYXRoLmFicyggdGhpcy56IC0gdi56ICk7XG5cblx0fVxuXG5cdHNldEZyb21TcGhlcmljYWwoIHMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKCBzLnJhZGl1cywgcy5waGksIHMudGhldGEgKTtcblxuXHR9XG5cblx0c2V0RnJvbVNwaGVyaWNhbENvb3JkcyggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdFx0Y29uc3Qgc2luUGhpUmFkaXVzID0gTWF0aC5zaW4oIHBoaSApICogcmFkaXVzO1xuXG5cdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jb3MoIHBoaSApICogcmFkaXVzO1xuXHRcdHRoaXMueiA9IHNpblBoaVJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21DeWxpbmRyaWNhbCggYyApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21DeWxpbmRyaWNhbENvb3JkcyggYy5yYWRpdXMsIGMudGhldGEsIGMueSApO1xuXG5cdH1cblxuXHRzZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIHJhZGl1cywgdGhldGEsIHkgKSB7XG5cblx0XHR0aGlzLnggPSByYWRpdXMgKiBNYXRoLnNpbiggdGhldGEgKTtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMTIgXTtcblx0XHR0aGlzLnkgPSBlWyAxMyBdO1xuXHRcdHRoaXMueiA9IGVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeFNjYWxlKCBtICkge1xuXG5cdFx0Y29uc3Qgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN6ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XG5cblx0XHR0aGlzLnggPSBzeDtcblx0XHR0aGlzLnkgPSBzeTtcblx0XHR0aGlzLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4Q29sdW1uKCBtLCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXgzQ29sdW1uKCBtLCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiAzICk7XG5cblx0fVxuXG5cdHNldEZyb21FdWxlciggZSApIHtcblxuXHRcdHRoaXMueCA9IGUuX3g7XG5cdFx0dGhpcy55ID0gZS5feTtcblx0XHR0aGlzLnogPSBlLl96O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Db2xvciggYyApIHtcblxuXHRcdHRoaXMueCA9IGMucjtcblx0XHR0aGlzLnkgPSBjLmc7XG5cdFx0dGhpcy56ID0gYy5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggdiApIHtcblxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4ICkge1xuXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmFuZG9tKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueiA9IE1hdGgucmFuZG9tKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmFuZG9tRGlyZWN0aW9uKCkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9tYXRod29ybGQud29sZnJhbS5jb20vU3BoZXJlUG9pbnRQaWNraW5nLmh0bWxcblxuXHRcdGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuXHRcdGNvbnN0IHUgPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG5cdFx0Y29uc3QgYyA9IE1hdGguc3FydCggMSAtIHUgKiB1ICk7XG5cblx0XHR0aGlzLnggPSBjICogTWF0aC5jb3MoIHRoZXRhICk7XG5cdFx0dGhpcy55ID0gdTtcblx0XHR0aGlzLnogPSBjICogTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLng7XG5cdFx0eWllbGQgdGhpcy55O1xuXHRcdHlpZWxkIHRoaXMuejtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciRjID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3F1YXRlcm5pb24kNCA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcblxuY2xhc3MgQm94MyB7XG5cblx0Y29uc3RydWN0b3IoIG1pbiA9IG5ldyBWZWN0b3IzKCArIEluZmluaXR5LCArIEluZmluaXR5LCArIEluZmluaXR5ICksIG1heCA9IG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICkgKSB7XG5cblx0XHR0aGlzLmlzQm94MyA9IHRydWU7XG5cblx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHR0aGlzLm1heCA9IG1heDtcblxuXHR9XG5cblx0c2V0KCBtaW4sIG1heCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21BcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3ZlY3RvciRiLmZyb21BcnJheSggYXJyYXksIGkgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3ZlY3RvciRiLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xuXG5cdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZSggY2VudGVyLCBzaXplICkge1xuXG5cdFx0Y29uc3QgaGFsZlNpemUgPSBfdmVjdG9yJGIuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU9iamVjdCggb2JqZWN0LCBwcmVjaXNlID0gZmFsc2UgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggYm94ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlRW1wdHkoKSB7XG5cblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aXNFbXB0eSgpIHtcblxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cblx0fVxuXG5cdGdldENlbnRlciggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9XG5cblx0Z2V0U2l6ZSggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG5cdH1cblxuXHRleHBhbmRCeVBvaW50KCBwb2ludCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlWZWN0b3IoIHZlY3RvciApIHtcblxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHBhbmRCeVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSA9IGZhbHNlICkge1xuXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcblx0XHQvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcblxuXHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIGZhbHNlICk7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdFx0Ly8gcHJlY2lzZSBBQUJCIGNvbXB1dGF0aW9uIGJhc2VkIG9uIHZlcnRleCBkYXRhIHJlcXVpcmVzIGF0IGxlYXN0IGEgcG9zaXRpb24gYXR0cmlidXRlLlxuXHRcdFx0Ly8gaW5zdGFuY2luZyBpc24ndCBzdXBwb3J0ZWQgc28gZmFyIGFuZCB1c2VzIHRoZSBub3JtYWwgKGNvbnNlcnZhdGl2ZSkgY29kZSBwYXRoLlxuXG5cdFx0XHRpZiAoIHByZWNpc2UgPT09IHRydWUgJiYgcG9zaXRpb25BdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmlzTWVzaCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LmdldFZlcnRleFBvc2l0aW9uKCBpLCBfdmVjdG9yJGIgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IkYi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X3ZlY3RvciRiLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdmVjdG9yJGIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuYm91bmRpbmdCb3ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIG9iamVjdC1sZXZlbCBib3VuZGluZyBib3hcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfYm94JDQuY29weSggb2JqZWN0LmJvdW5kaW5nQm94ICk7XG5cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gZ2VvbWV0cnktbGV2ZWwgYm91bmRpbmcgYm94XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9ib3gkNC5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfYm94JDQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR0aGlzLnVuaW9uKCBfYm94JDQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBwcmVjaXNlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcblx0XHRcdHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55IHx8XG5cdFx0XHRwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcblxuXHR9XG5cblx0Y29udGFpbnNCb3goIGJveCApIHtcblxuXHRcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJlxuXHRcdFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4LnkgJiZcblx0XHRcdHRoaXMubWluLnogPD0gYm94Lm1pbi56ICYmIGJveC5tYXgueiA8PSB0aGlzLm1heC56O1xuXG5cdH1cblxuXHRnZXRQYXJhbWV0ZXIoIHBvaW50LCB0YXJnZXQgKSB7XG5cblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldChcblx0XHRcdCggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcblx0XHRcdCggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxuXHRcdCk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNCb3goIGJveCApIHtcblxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXHRcdHJldHVybiBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcblx0XHRcdGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxuXHRcdFx0Ym94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ID8gZmFsc2UgOiB0cnVlO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxuXHRcdHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgX3ZlY3RvciRiICk7XG5cblx0XHQvLyBJZiB0aGF0IHBvaW50IGlzIGluc2lkZSB0aGUgc3BoZXJlLCB0aGUgQUFCQiBhbmQgc3BoZXJlIGludGVyc2VjdC5cblx0XHRyZXR1cm4gX3ZlY3RvciRiLmRpc3RhbmNlVG9TcXVhcmVkKCBzcGhlcmUuY2VudGVyICkgPD0gKCBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cyApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xuXHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG5cdFx0bGV0IG1pbiwgbWF4O1xuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblxuXHRcdH1cblxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xuXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKCBtaW4gPD0gLSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gLSBwbGFuZS5jb25zdGFudCApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29tcHV0ZSBib3ggY2VudGVyIGFuZCBleHRlbnRzXG5cdFx0dGhpcy5nZXRDZW50ZXIoIF9jZW50ZXIgKTtcblx0XHRfZXh0ZW50cy5zdWJWZWN0b3JzKCB0aGlzLm1heCwgX2NlbnRlciApO1xuXG5cdFx0Ly8gdHJhbnNsYXRlIHRyaWFuZ2xlIHRvIGFhYmIgb3JpZ2luXG5cdFx0X3YwJDIuc3ViVmVjdG9ycyggdHJpYW5nbGUuYSwgX2NlbnRlciApO1xuXHRcdF92MSQ3LnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmIsIF9jZW50ZXIgKTtcblx0XHRfdjIkNC5zdWJWZWN0b3JzKCB0cmlhbmdsZS5jLCBfY2VudGVyICk7XG5cblx0XHQvLyBjb21wdXRlIGVkZ2UgdmVjdG9ycyBmb3IgdHJpYW5nbGVcblx0XHRfZjAuc3ViVmVjdG9ycyggX3YxJDcsIF92MCQyICk7XG5cdFx0X2YxLnN1YlZlY3RvcnMoIF92MiQ0LCBfdjEkNyApO1xuXHRcdF9mMi5zdWJWZWN0b3JzKCBfdjAkMiwgX3YyJDQgKTtcblxuXHRcdC8vIHRlc3QgYWdhaW5zdCBheGVzIHRoYXQgYXJlIGdpdmVuIGJ5IGNyb3NzIHByb2R1Y3QgY29tYmluYXRpb25zIG9mIHRoZSBlZGdlcyBvZiB0aGUgdHJpYW5nbGUgYW5kIHRoZSBlZGdlcyBvZiB0aGUgYWFiYlxuXHRcdC8vIG1ha2UgYW4gYXhpcyB0ZXN0aW5nIG9mIGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIGFhYmIgYWdhaW5zdCBlYWNoIG9mIHRoZSAzIHNpZGVzIG9mIHRoZSB0cmlhbmdsZSA9IDkgYXhpcyBvZiBzZXBhcmF0aW9uXG5cdFx0Ly8gYXhpc19paiA9IHVfaSB4IGZfaiAodTAsIHUxLCB1MiA9IGZhY2Ugbm9ybWFscyBvZiBhYWJiID0geCx5LHogYXhlcyB2ZWN0b3JzIHNpbmNlIGFhYmIgaXMgYXhpcyBhbGlnbmVkKVxuXHRcdGxldCBheGVzID0gW1xuXHRcdFx0MCwgLSBfZjAueiwgX2YwLnksIDAsIC0gX2YxLnosIF9mMS55LCAwLCAtIF9mMi56LCBfZjIueSxcblx0XHRcdF9mMC56LCAwLCAtIF9mMC54LCBfZjEueiwgMCwgLSBfZjEueCwgX2YyLnosIDAsIC0gX2YyLngsXG5cdFx0XHQtIF9mMC55LCBfZjAueCwgMCwgLSBfZjEueSwgX2YxLngsIDAsIC0gX2YyLnksIF9mMi54LCAwXG5cdFx0XTtcblx0XHRpZiAoICEgc2F0Rm9yQXhlcyggYXhlcywgX3YwJDIsIF92MSQ3LCBfdjIkNCwgX2V4dGVudHMgKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdGVzdCAzIGZhY2Ugbm9ybWFscyBmcm9tIHRoZSBhYWJiXG5cdFx0YXhlcyA9IFsgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSBdO1xuXHRcdGlmICggISBzYXRGb3JBeGVzKCBheGVzLCBfdjAkMiwgX3YxJDcsIF92MiQ0LCBfZXh0ZW50cyApICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHQvLyBmaW5hbGx5IHRlc3RpbmcgdGhlIGZhY2Ugbm9ybWFsIG9mIHRoZSB0cmlhbmdsZVxuXHRcdC8vIHVzZSBhbHJlYWR5IGV4aXN0aW5nIHRyaWFuZ2xlIGVkZ2UgdmVjdG9ycyBoZXJlXG5cdFx0X3RyaWFuZ2xlTm9ybWFsLmNyb3NzVmVjdG9ycyggX2YwLCBfZjEgKTtcblx0XHRheGVzID0gWyBfdHJpYW5nbGVOb3JtYWwueCwgX3RyaWFuZ2xlTm9ybWFsLnksIF90cmlhbmdsZU5vcm1hbC56IF07XG5cblx0XHRyZXR1cm4gc2F0Rm9yQXhlcyggYXhlcywgX3YwJDIsIF92MSQ3LCBfdjIkNCwgX2V4dGVudHMgKTtcblxuXHR9XG5cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGFtcFBvaW50KCBwb2ludCwgX3ZlY3RvciRiICkuZGlzdGFuY2VUbyggcG9pbnQgKTtcblxuXHR9XG5cblx0Z2V0Qm91bmRpbmdTcGhlcmUoIHRhcmdldCApIHtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCB0YXJnZXQuY2VudGVyICk7XG5cblx0XHRcdHRhcmdldC5yYWRpdXMgPSB0aGlzLmdldFNpemUoIF92ZWN0b3IkYiApLmxlbmd0aCgpICogMC41O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0aW50ZXJzZWN0KCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdC8vIGVuc3VyZSB0aGF0IGlmIHRoZXJlIGlzIG5vIG92ZXJsYXAsIHRoZSByZXN1bHQgaXMgZnVsbHkgZW1wdHksIG5vdCBzbGlnaHRseSBlbXB0eSB3aXRoIG5vbi1pbmYvK2luZiB2YWx1ZXMgdGhhdCB3aWxsIGNhdXNlIHN1YnNlcXVlbmNlIGludGVyc2VjdHMgdG8gZXJyb25lb3VzbHkgcmV0dXJuIHZhbGlkIHZhbHVlcy5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkgdGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR1bmlvbiggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHQvLyB0cmFuc2Zvcm0gb2YgZW1wdHkgYm94IGlzIGFuIGVtcHR5IGJveC5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkgcmV0dXJuIHRoaXM7XG5cblx0XHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xuXHRcdF9wb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcblx0XHRfcG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXG5cdFx0X3BvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxuXHRcdF9wb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcblx0XHRfcG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXG5cdFx0X3BvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxuXHRcdF9wb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcblx0XHRfcG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTExXG5cblx0XHR0aGlzLnNldEZyb21Qb2ludHMoIF9wb2ludHMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIG9mZnNldCApIHtcblxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIGJveCApIHtcblxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3BvaW50cyA9IFtcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKClcbl07XG5cbmNvbnN0IF92ZWN0b3IkYiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2JveCQ0ID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuXG4vLyB0cmlhbmdsZSBjZW50ZXJlZCB2ZXJ0aWNlc1xuXG5jb25zdCBfdjAkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MSQ3ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyJDQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbi8vIHRyaWFuZ2xlIGVkZ2UgdmVjdG9yc1xuXG5jb25zdCBfZjAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF9jZW50ZXIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZXh0ZW50cyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90cmlhbmdsZU5vcm1hbCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90ZXN0QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuZnVuY3Rpb24gc2F0Rm9yQXhlcyggYXhlcywgdjAsIHYxLCB2MiwgZXh0ZW50cyApIHtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGogPSBheGVzLmxlbmd0aCAtIDM7IGkgPD0gajsgaSArPSAzICkge1xuXG5cdFx0X3Rlc3RBeGlzLmZyb21BcnJheSggYXhlcywgaSApO1xuXHRcdC8vIHByb2plY3QgdGhlIGFhYmIgb250byB0aGUgc2VwYXJhdGluZyBheGlzXG5cdFx0Y29uc3QgciA9IGV4dGVudHMueCAqIE1hdGguYWJzKCBfdGVzdEF4aXMueCApICsgZXh0ZW50cy55ICogTWF0aC5hYnMoIF90ZXN0QXhpcy55ICkgKyBleHRlbnRzLnogKiBNYXRoLmFicyggX3Rlc3RBeGlzLnogKTtcblx0XHQvLyBwcm9qZWN0IGFsbCAzIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZSBvbnRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcblx0XHRjb25zdCBwMCA9IHYwLmRvdCggX3Rlc3RBeGlzICk7XG5cdFx0Y29uc3QgcDEgPSB2MS5kb3QoIF90ZXN0QXhpcyApO1xuXHRcdGNvbnN0IHAyID0gdjIuZG90KCBfdGVzdEF4aXMgKTtcblx0XHQvLyBhY3R1YWwgdGVzdCwgYmFzaWNhbGx5IHNlZSBpZiBlaXRoZXIgb2YgdGhlIG1vc3QgZXh0cmVtZSBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzIGludGVyc2VjdHMgclxuXHRcdGlmICggTWF0aC5tYXgoIC0gTWF0aC5tYXgoIHAwLCBwMSwgcDIgKSwgTWF0aC5taW4oIHAwLCBwMSwgcDIgKSApID4gciApIHtcblxuXHRcdFx0Ly8gcG9pbnRzIG9mIHRoZSBwcm9qZWN0ZWQgdHJpYW5nbGUgYXJlIG91dHNpZGUgdGhlIHByb2plY3RlZCBoYWxmLWxlbmd0aCBvZiB0aGUgYWFiYlxuXHRcdFx0Ly8gdGhlIGF4aXMgaXMgc2VwYXJhdGluZyBhbmQgd2UgY2FuIGV4aXRcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG5cbn1cblxuY29uc3QgX2JveCQzID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuY29uc3QgX3YxJDYgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjIkMyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgU3BoZXJlIHtcblxuXHRjb25zdHJ1Y3RvciggY2VudGVyID0gbmV3IFZlY3RvcjMoKSwgcmFkaXVzID0gLSAxICkge1xuXG5cdFx0dGhpcy5pc1NwaGVyZSA9IHRydWU7XG5cblx0XHR0aGlzLmNlbnRlciA9IGNlbnRlcjtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuXHR9XG5cblx0c2V0KCBjZW50ZXIsIHJhZGl1cyApIHtcblxuXHRcdHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XG5cblx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcblxuXHRcdGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfYm94JDMuc2V0RnJvbVBvaW50cyggcG9pbnRzICkuZ2V0Q2VudGVyKCBjZW50ZXIgKTtcblxuXHRcdH1cblxuXHRcdGxldCBtYXhSYWRpdXNTcSA9IDA7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBzcGhlcmUgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XG5cdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGlzRW1wdHkoKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLnJhZGl1cyA8IDAgKTtcblxuXHR9XG5cblx0bWFrZUVtcHR5KCkge1xuXG5cdFx0dGhpcy5jZW50ZXIuc2V0KCAwLCAwLCAwICk7XG5cdFx0dGhpcy5yYWRpdXMgPSAtIDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdGNvbnN0IHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcblxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggcmFkaXVzU3VtICogcmFkaXVzU3VtICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNCb3goIGJveCApIHtcblxuXHRcdHJldHVybiBib3guaW50ZXJzZWN0c1NwaGVyZSggdGhpcyApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMuY2VudGVyICkgKSA8PSB0aGlzLnJhZGl1cztcblxuXHR9XG5cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdHRhcmdldC5jb3B5KCBwb2ludCApO1xuXG5cdFx0aWYgKCBkZWx0YUxlbmd0aFNxID4gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKSB7XG5cblx0XHRcdHRhcmdldC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XG5cdFx0XHR0YXJnZXQubXVsdGlwbHlTY2FsYXIoIHRoaXMucmFkaXVzICkuYWRkKCB0aGlzLmNlbnRlciApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Z2V0Qm91bmRpbmdCb3goIHRhcmdldCApIHtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdC8vIEVtcHR5IHNwaGVyZSBwcm9kdWNlcyBlbXB0eSBib3VuZGluZyBib3hcblx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cblx0XHR9XG5cblx0XHR0YXJnZXQuc2V0KCB0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXIgKTtcblx0XHR0YXJnZXQuZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cdFx0dGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZSggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuYWRkKCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHBhbmRCeVBvaW50KCBwb2ludCApIHtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHRoaXMuY2VudGVyLmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdHRoaXMucmFkaXVzID0gMDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRfdjEkNi5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5jZW50ZXIgKTtcblxuXHRcdGNvbnN0IGxlbmd0aFNxID0gX3YxJDYubGVuZ3RoU3EoKTtcblxuXHRcdGlmICggbGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBtaW5pbWFsIHNwaGVyZVxuXG5cdFx0XHRjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoIGxlbmd0aFNxICk7XG5cblx0XHRcdGNvbnN0IGRlbHRhID0gKCBsZW5ndGggLSB0aGlzLnJhZGl1cyApICogMC41O1xuXG5cdFx0XHR0aGlzLmNlbnRlci5hZGRTY2FsZWRWZWN0b3IoIF92MSQ2LCBkZWx0YSAvIGxlbmd0aCApO1xuXG5cdFx0XHR0aGlzLnJhZGl1cyArPSBkZWx0YTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR1bmlvbiggc3BoZXJlICkge1xuXG5cdFx0aWYgKCBzcGhlcmUuaXNFbXB0eSgpICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHRoaXMuY29weSggc3BoZXJlICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNlbnRlci5lcXVhbHMoIHNwaGVyZS5jZW50ZXIgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0IHRoaXMucmFkaXVzID0gTWF0aC5tYXgoIHRoaXMucmFkaXVzLCBzcGhlcmUucmFkaXVzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfdjIkMy5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLmNlbnRlciApLnNldExlbmd0aCggc3BoZXJlLnJhZGl1cyApO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92MSQ2LmNvcHkoIHNwaGVyZS5jZW50ZXIgKS5hZGQoIF92MiQzICkgKTtcblxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdjEkNi5jb3B5KCBzcGhlcmUuY2VudGVyICkuc3ViKCBfdjIkMyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciRhID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3NlZ0NlbnRlciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9zZWdEaXIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZGlmZiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2VkZ2UxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2VkZ2UyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX25vcm1hbCQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBSYXkge1xuXG5cdGNvbnN0cnVjdG9yKCBvcmlnaW4gPSBuZXcgVmVjdG9yMygpLCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMyggMCwgMCwgLSAxICkgKSB7XG5cblx0XHR0aGlzLm9yaWdpbiA9IG9yaWdpbjtcblx0XHR0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcblxuXHR9XG5cblx0c2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIG9yaWdpbiApO1xuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIHJheSApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXQoIHQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5vcmlnaW4gKS5hZGRTY2FsZWRWZWN0b3IoIHRoaXMuZGlyZWN0aW9uLCB0ICk7XG5cblx0fVxuXG5cdGxvb2tBdCggdiApIHtcblxuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHYgKS5zdWIoIHRoaXMub3JpZ2luICkubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVjYXN0KCB0ICkge1xuXG5cdFx0dGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgX3ZlY3RvciRhICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0dGFyZ2V0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0Y29uc3QgZGlyZWN0aW9uRGlzdGFuY2UgPSB0YXJnZXQuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5vcmlnaW4gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5vcmlnaW4gKS5hZGRTY2FsZWRWZWN0b3IoIHRoaXMuZGlyZWN0aW9uLCBkaXJlY3Rpb25EaXN0YW5jZSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRjb25zdCBkaXJlY3Rpb25EaXN0YW5jZSA9IF92ZWN0b3IkYS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHQvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxuXG5cdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdH1cblxuXHRcdF92ZWN0b3IkYS5jb3B5KCB0aGlzLm9yaWdpbiApLmFkZFNjYWxlZFZlY3RvciggdGhpcy5kaXJlY3Rpb24sIGRpcmVjdGlvbkRpc3RhbmNlICk7XG5cblx0XHRyZXR1cm4gX3ZlY3RvciRhLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVNxVG9TZWdtZW50KCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcblxuXHRcdC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Btam9uaWFrL0dlb21ldHJpY1Rvb2xzL2Jsb2IvbWFzdGVyL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlRGlzdFJheVNlZ21lbnQuaFxuXHRcdC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XG5cdFx0Ly8gZGVmaW5lZCBieSB2MCBhbmQgdjFcblx0XHQvLyBJdCBjYW4gYWxzbyBzZXQgdHdvIG9wdGlvbmFsIHRhcmdldHMgOlxuXHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxuXHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcblxuXHRcdF9zZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXHRcdF9zZWdEaXIuY29weSggdjEgKS5zdWIoIHYwICkubm9ybWFsaXplKCk7XG5cdFx0X2RpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIF9zZWdDZW50ZXIgKTtcblxuXHRcdGNvbnN0IHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8oIHYxICkgKiAwLjU7XG5cdFx0Y29uc3QgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIF9zZWdEaXIgKTtcblx0XHRjb25zdCBiMCA9IF9kaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblx0XHRjb25zdCBiMSA9IC0gX2RpZmYuZG90KCBfc2VnRGlyICk7XG5cdFx0Y29uc3QgYyA9IF9kaWZmLmxlbmd0aFNxKCk7XG5cdFx0Y29uc3QgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcblx0XHRsZXQgczAsIHMxLCBzcXJEaXN0LCBleHREZXQ7XG5cblx0XHRpZiAoIGRldCA+IDAgKSB7XG5cblx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuXHRcdFx0czAgPSBhMDEgKiBiMSAtIGIwO1xuXHRcdFx0czEgPSBhMDEgKiBiMCAtIGIxO1xuXHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG5cdFx0XHRpZiAoIHMwID49IDAgKSB7XG5cblx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcblxuXHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMFxuXHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxuXG5cdFx0XHRcdFx0XHRjb25zdCBpbnZEZXQgPSAxIC8gZGV0O1xuXHRcdFx0XHRcdFx0czAgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0czEgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IHMwICogKCBzMCArIGEwMSAqIHMxICsgMiAqIGIwICkgKyBzMSAqICggYTAxICogczAgKyBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAxXG5cblx0XHRcdFx0XHRcdHMxID0gc2VnRXh0ZW50O1xuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gcmVnaW9uIDVcblxuXHRcdFx0XHRcdHMxID0gLSBzZWdFeHRlbnQ7XG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuXHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggczEgPD0gLSBleHREZXQgKSB7XG5cblx0XHRcdFx0XHQvLyByZWdpb24gNFxuXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuXHRcdFx0XHRcdHMxID0gKCBzMCA+IDAgKSA/IC0gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcblx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHMxIDw9IGV4dERldCApIHtcblxuXHRcdFx0XHRcdC8vIHJlZ2lvbiAzXG5cblx0XHRcdFx0XHRzMCA9IDA7XG5cdFx0XHRcdFx0czEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuXHRcdFx0XHRcdHNxckRpc3QgPSBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHJlZ2lvbiAyXG5cblx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuXHRcdFx0XHRcdHMxID0gKCBzMCA+IDAgKSA/IHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG5cdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXG5cblx0XHRcdHMxID0gKCBhMDEgPiAwICkgPyAtIHNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcblx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblJheSApIHtcblxuXHRcdFx0b3B0aW9uYWxQb2ludE9uUmF5LmNvcHkoIHRoaXMub3JpZ2luICkuYWRkU2NhbGVkVmVjdG9yKCB0aGlzLmRpcmVjdGlvbiwgczAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcblxuXHRcdFx0b3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBfc2VnQ2VudGVyICkuYWRkU2NhbGVkVmVjdG9yKCBfc2VnRGlyLCBzMSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNxckRpc3Q7XG5cblx0fVxuXG5cdGludGVyc2VjdFNwaGVyZSggc3BoZXJlLCB0YXJnZXQgKSB7XG5cblx0XHRfdmVjdG9yJGEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcblx0XHRjb25zdCB0Y2EgPSBfdmVjdG9yJGEuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXHRcdGNvbnN0IGQyID0gX3ZlY3RvciRhLmRvdCggX3ZlY3RvciRhICkgLSB0Y2EgKiB0Y2E7XG5cdFx0Y29uc3QgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuXG5cdFx0aWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IHRoYyA9IE1hdGguc3FydCggcmFkaXVzMiAtIGQyICk7XG5cblx0XHQvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxuXHRcdGNvbnN0IHQwID0gdGNhIC0gdGhjO1xuXG5cdFx0Ly8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxuXHRcdGNvbnN0IHQxID0gdGNhICsgdGhjO1xuXG5cdFx0Ly8gdGVzdCB0byBzZWUgaWYgdDEgaXMgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcblx0XHRpZiAoIHQxIDwgMCApIHJldHVybiBudWxsO1xuXG5cdFx0Ly8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XG5cdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxuXHRcdC8vIGluIG9yZGVyIHRvIGFsd2F5cyByZXR1cm4gYW4gaW50ZXJzZWN0IHBvaW50IHRoYXQgaXMgaW4gZnJvbnQgb2YgdGhlIHJheS5cblx0XHRpZiAoIHQwIDwgMCApIHJldHVybiB0aGlzLmF0KCB0MSwgdGFyZ2V0ICk7XG5cblx0XHQvLyBlbHNlIHQwIGlzIGluIGZyb250IG9mIHRoZSByYXksIHNvIHJldHVybiB0aGUgZmlyc3QgY29sbGlzaW9uIHBvaW50IHNjYWxlZCBieSB0MFxuXHRcdHJldHVybiB0aGlzLmF0KCB0MCwgdGFyZ2V0ICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gKCBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cyApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcblxuXHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0aWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIDA7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXG5cblx0XHRyZXR1cm4gdCA+PSAwID8gdCA6IG51bGw7XG5cblx0fVxuXG5cdGludGVyc2VjdFBsYW5lKCBwbGFuZSwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xuXG5cdFx0aWYgKCB0ID09PSBudWxsICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmF0KCB0LCB0YXJnZXQgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1BsYW5lKCBwbGFuZSApIHtcblxuXHRcdC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcblxuXHRcdGNvbnN0IGRpc3RUb1BvaW50ID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0aWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yICogZGlzdFRvUG9pbnQgPCAwICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vIHJheSBvcmlnaW4gaXMgYmVoaW5kIHRoZSBwbGFuZSAoYW5kIGlzIHBvaW50aW5nIGJlaGluZCBpdClcblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0aW50ZXJzZWN0Qm94KCBib3gsIHRhcmdldCApIHtcblxuXHRcdGxldCB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcblxuXHRcdGNvbnN0IGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcblx0XHRcdGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcblx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblxuXHRcdGNvbnN0IG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG5cdFx0aWYgKCBpbnZkaXJ4ID49IDAgKSB7XG5cblx0XHRcdHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXHRcdFx0dG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0bWluID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblx0XHRcdHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XG5cblx0XHRcdHR5bWluID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdHR5bWF4ID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuXHRcdH1cblxuXHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cblx0XHRpZiAoIHR5bWluID4gdG1pbiB8fCBpc05hTiggdG1pbiApICkgdG1pbiA9IHR5bWluO1xuXG5cdFx0aWYgKCB0eW1heCA8IHRtYXggfHwgaXNOYU4oIHRtYXggKSApIHRtYXggPSB0eW1heDtcblxuXHRcdGlmICggaW52ZGlyeiA+PSAwICkge1xuXG5cdFx0XHR0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHR9XG5cblx0XHRpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xuXG5cdFx0aWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcblxuXHRcdGlmICggdHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XG5cblx0XHQvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXG5cblx0XHRpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIHRhcmdldCApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3goIGJveCwgX3ZlY3RvciRhICkgIT09IG51bGw7XG5cblx0fVxuXG5cdGludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIHRhcmdldCApIHtcblxuXHRcdC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxuXG5cdFx0Ly8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcG1qb25pYWsvR2VvbWV0cmljVG9vbHMvYmxvYi9tYXN0ZXIvR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVJbnRyUmF5M1RyaWFuZ2xlMy5oXG5cblx0XHRfZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xuXHRcdF9lZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0X25vcm1hbCQxLmNyb3NzVmVjdG9ycyggX2VkZ2UxLCBfZWRnZTIgKTtcblxuXHRcdC8vIFNvbHZlIFEgKyB0KkQgPSBiMSpFMSArIGIyKkUyIChRID0ga0RpZmYsIEQgPSByYXkgZGlyZWN0aW9uLFxuXHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcblx0XHQvLyAgIHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcblx0XHQvLyAgIHxEb3QoRCxOKXwqYjIgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhFMSxRKSlcblx0XHQvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxuXHRcdGxldCBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoIF9ub3JtYWwkMSApO1xuXHRcdGxldCBzaWduO1xuXG5cdFx0aWYgKCBEZE4gPiAwICkge1xuXG5cdFx0XHRpZiAoIGJhY2tmYWNlQ3VsbGluZyApIHJldHVybiBudWxsO1xuXHRcdFx0c2lnbiA9IDE7XG5cblx0XHR9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xuXG5cdFx0XHRzaWduID0gLSAxO1xuXHRcdFx0RGROID0gLSBEZE47XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdF9kaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XG5cdFx0Y29uc3QgRGRReEUyID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggX2VkZ2UyLmNyb3NzVmVjdG9ycyggX2RpZmYsIF9lZGdlMiApICk7XG5cblx0XHQvLyBiMSA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdGlmICggRGRReEUyIDwgMCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBEZEUxeFEgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBfZWRnZTEuY3Jvc3MoIF9kaWZmICkgKTtcblxuXHRcdC8vIGIyIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0aWYgKCBEZEUxeFEgPCAwICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0aWYgKCBEZFF4RTIgKyBEZEUxeFEgPiBEZE4gKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cblx0XHRjb25zdCBRZE4gPSAtIHNpZ24gKiBfZGlmZi5kb3QoIF9ub3JtYWwkMSApO1xuXG5cdFx0Ly8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdGlmICggUWROIDwgMCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cblx0XHRyZXR1cm4gdGhpcy5hdCggUWROIC8gRGROLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXg0ICkge1xuXG5cdFx0dGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XG5cdFx0dGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXg0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCByYXkgKSB7XG5cblx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBNYXRyaXg0IHtcblxuXHRjb25zdHJ1Y3RvciggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0TWF0cml4NC5wcm90b3R5cGUuaXNNYXRyaXg0ID0gdHJ1ZTtcblxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNldCggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldCggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDQgXSA9IG4xMjsgdGVbIDggXSA9IG4xMzsgdGVbIDEyIF0gPSBuMTQ7XG5cdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XG5cdFx0dGVbIDIgXSA9IG4zMTsgdGVbIDYgXSA9IG4zMjsgdGVbIDEwIF0gPSBuMzM7IHRlWyAxNCBdID0gbjM0O1xuXHRcdHRlWyAzIF0gPSBuNDE7IHRlWyA3IF0gPSBuNDI7IHRlWyAxMSBdID0gbjQzOyB0ZVsgMTUgXSA9IG40NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cblx0fVxuXG5cdGNvcHkoIG0gKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF07IHRlWyAxIF0gPSBtZVsgMSBdOyB0ZVsgMiBdID0gbWVbIDIgXTsgdGVbIDMgXSA9IG1lWyAzIF07XG5cdFx0dGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdOyB0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07XG5cdFx0dGVbIDggXSA9IG1lWyA4IF07IHRlWyA5IF0gPSBtZVsgOSBdOyB0ZVsgMTAgXSA9IG1lWyAxMCBdOyB0ZVsgMTEgXSA9IG1lWyAxMSBdO1xuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07IHRlWyAxMyBdID0gbWVbIDEzIF07IHRlWyAxNCBdID0gbWVbIDE0IF07IHRlWyAxNSBdID0gbWVbIDE1IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weVBvc2l0aW9uKCBtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuXHRcdHRlWyAxMyBdID0gbWVbIDEzIF07XG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtZVsgMCBdLCBtZVsgMyBdLCBtZVsgNiBdLCAwLFxuXHRcdFx0bWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSwgMCxcblx0XHRcdG1lWyAyIF0sIG1lWyA1IF0sIG1lWyA4IF0sIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4dHJhY3RCYXNpcyggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDAgKTtcblx0XHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VCYXNpcyggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcblx0XHRcdHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXG5cdFx0XHR4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXh0cmFjdFJvdGF0aW9uKCBtICkge1xuXG5cdFx0Ly8gdGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCByZWZsZWN0aW9uIG1hdHJpY2VzXG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3Qgc2NhbGVYID0gMSAvIF92MSQ1LnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzY2FsZVkgPSAxIC8gX3YxJDUuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHNjYWxlWiA9IDEgLyBfdjEkNS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMyBdID0gMDtcblxuXHRcdHRlWyA0IF0gPSBtZVsgNCBdICogc2NhbGVZO1xuXHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xuXHRcdHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xuXHRcdHRlWyA3IF0gPSAwO1xuXG5cdFx0dGVbIDggXSA9IG1lWyA4IF0gKiBzY2FsZVo7XG5cdFx0dGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XG5cdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAxNCBdID0gMDtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyKCBldWxlciApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XG5cdFx0Y29uc3QgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcblx0XHRjb25zdCBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XG5cblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0Y29uc3QgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZDtcblxuXHRcdFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuXHRcdFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XG5cblx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdGNvbnN0IGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjZSArIGRmICogYjtcblx0XHRcdHRlWyA0IF0gPSBkZSAqIGIgLSBjZjtcblx0XHRcdHRlWyA4IF0gPSBhICogZDtcblxuXHRcdFx0dGVbIDEgXSA9IGEgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IC0gYjtcblxuXHRcdFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xuXHRcdFx0dGVbIDYgXSA9IGRmICsgY2UgKiBiO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0Y29uc3QgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IC0gYSAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XG5cblx0XHRcdHRlWyAxIF0gPSBjZiArIGRlICogYjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcblxuXHRcdFx0dGVbIDIgXSA9IC0gYSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XG5cblx0XHRcdGNvbnN0IGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcblx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcblxuXHRcdFx0dGVbIDEgXSA9IGMgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0Y29uc3QgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IGJkIC0gYWMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGJjICogZiArIGFkO1xuXG5cdFx0XHR0ZVsgMSBdID0gZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkICogZTtcblx0XHRcdHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcblx0XHRcdHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGY7XG5cdFx0XHR0ZVsgOCBdID0gZCAqIGU7XG5cblx0XHRcdHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcblxuXHRcdFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xuXHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcblxuXHRcdH1cblxuXHRcdC8vIGJvdHRvbSByb3dcblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBsYXN0IGNvbHVtblxuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbXBvc2UoIF96ZXJvLCBxLCBfb25lICk7XG5cblx0fVxuXG5cdGxvb2tBdCggZXllLCB0YXJnZXQsIHVwICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0X3ouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKTtcblxuXHRcdGlmICggX3oubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gZXllIGFuZCB0YXJnZXQgYXJlIGluIHRoZSBzYW1lIHBvc2l0aW9uXG5cblx0XHRcdF96LnogPSAxO1xuXG5cdFx0fVxuXG5cdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0X3guY3Jvc3NWZWN0b3JzKCB1cCwgX3ogKTtcblxuXHRcdGlmICggX3gubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gdXAgYW5kIHogYXJlIHBhcmFsbGVsXG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHVwLnogKSA9PT0gMSApIHtcblxuXHRcdFx0XHRfei54ICs9IDAuMDAwMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfei56ICs9IDAuMDAwMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfei5ub3JtYWxpemUoKTtcblx0XHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHR9XG5cblx0XHRfeC5ub3JtYWxpemUoKTtcblx0XHRfeS5jcm9zc1ZlY3RvcnMoIF96LCBfeCApO1xuXG5cdFx0dGVbIDAgXSA9IF94Lng7IHRlWyA0IF0gPSBfeS54OyB0ZVsgOCBdID0gX3oueDtcblx0XHR0ZVsgMSBdID0gX3gueTsgdGVbIDUgXSA9IF95Lnk7IHRlWyA5IF0gPSBfei55O1xuXHRcdHRlWyAyIF0gPSBfeC56OyB0ZVsgNiBdID0gX3kuejsgdGVbIDEwIF0gPSBfei56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH1cblxuXHRwcmVtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9XG5cblx0bXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIHtcblxuXHRcdGNvbnN0IGFlID0gYS5lbGVtZW50cztcblx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG5cdFx0Y29uc3QgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDUgXSwgYTIzID0gYWVbIDkgXSwgYTI0ID0gYWVbIDEzIF07XG5cdFx0Y29uc3QgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDYgXSwgYTMzID0gYWVbIDEwIF0sIGEzNCA9IGFlWyAxNCBdO1xuXHRcdGNvbnN0IGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuXHRcdGNvbnN0IGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xuXHRcdGNvbnN0IGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcblx0XHRjb25zdCBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XG5cblx0XHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuXHRcdHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XG5cdFx0dGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0Mztcblx0XHR0ZVsgMTIgXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcblxuXHRcdHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XG5cdFx0dGVbIDUgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0Mjtcblx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xuXHRcdHRlWyAxMyBdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xuXG5cdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcblx0XHR0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xuXHRcdHRlWyAxMCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzICsgYTM0ICogYjQzO1xuXHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xuXG5cdFx0dGVbIDMgXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcblx0XHR0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xuXHRcdHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuXHRcdHRlWyAxNSBdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA4IF0gKj0gczsgdGVbIDEyIF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuXHRcdHRlWyAzIF0gKj0gczsgdGVbIDcgXSAqPSBzOyB0ZVsgMTEgXSAqPSBzOyB0ZVsgMTUgXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRldGVybWluYW50KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XG5cdFx0Y29uc3QgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0Y29uc3QgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xuXHRcdGNvbnN0IG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcblxuXHRcdC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG5cdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0bjQxICogKFxuXHRcdFx0XHQrIG4xNCAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgLSBuMTMgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjE0ICogbjIyICogbjMzXG5cdFx0XHRcdCArIG4xMiAqIG4yNCAqIG4zM1xuXHRcdFx0XHQgKyBuMTMgKiBuMjIgKiBuMzRcblx0XHRcdFx0IC0gbjEyICogbjIzICogbjM0XG5cdFx0XHQpICtcblx0XHRcdG40MiAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjMgKiBuMzRcblx0XHRcdFx0IC0gbjExICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xNCAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgLSBuMTMgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjEzICogbjI0ICogbjMxXG5cdFx0XHRcdCAtIG4xNCAqIG4yMyAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDMgKiAoXG5cdFx0XHRcdCsgbjExICogbjI0ICogbjMyXG5cdFx0XHRcdCAtIG4xMSAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTQgKiBuMjEgKiBuMzJcblx0XHRcdFx0ICsgbjEyICogbjIxICogbjM0XG5cdFx0XHRcdCArIG4xNCAqIG4yMiAqIG4zMVxuXHRcdFx0XHQgLSBuMTIgKiBuMjQgKiBuMzFcblx0XHRcdCkgK1xuXHRcdFx0bjQ0ICogKFxuXHRcdFx0XHQtIG4xMyAqIG4yMiAqIG4zMVxuXHRcdFx0XHQgLSBuMTEgKiBuMjMgKiBuMzJcblx0XHRcdFx0ICsgbjExICogbjIyICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgLSBuMTIgKiBuMjEgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjIzICogbjMxXG5cdFx0XHQpXG5cblx0XHQpO1xuXG5cdH1cblxuXHR0cmFuc3Bvc2UoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0bGV0IHRtcDtcblxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRQb3NpdGlvbiggeCwgeSwgeiApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XG5cblx0XHRcdHRlWyAxMiBdID0geC54O1xuXHRcdFx0dGVbIDEzIF0gPSB4Lnk7XG5cdFx0XHR0ZVsgMTQgXSA9IHguejtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRlWyAxMiBdID0geDtcblx0XHRcdHRlWyAxMyBdID0geTtcblx0XHRcdHRlWyAxNCBdID0gejtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpbnZlcnQoKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHMsXG5cblx0XHRcdG4xMSA9IHRlWyAwIF0sIG4yMSA9IHRlWyAxIF0sIG4zMSA9IHRlWyAyIF0sIG40MSA9IHRlWyAzIF0sXG5cdFx0XHRuMTIgPSB0ZVsgNCBdLCBuMjIgPSB0ZVsgNSBdLCBuMzIgPSB0ZVsgNiBdLCBuNDIgPSB0ZVsgNyBdLFxuXHRcdFx0bjEzID0gdGVbIDggXSwgbjIzID0gdGVbIDkgXSwgbjMzID0gdGVbIDEwIF0sIG40MyA9IHRlWyAxMSBdLFxuXHRcdFx0bjE0ID0gdGVbIDEyIF0sIG4yNCA9IHRlWyAxMyBdLCBuMzQgPSB0ZVsgMTQgXSwgbjQ0ID0gdGVbIDE1IF0sXG5cblx0XHRcdHQxMSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NCxcblx0XHRcdHQxMiA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NCxcblx0XHRcdHQxMyA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NCxcblx0XHRcdHQxNCA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcblxuXHRcdGNvbnN0IGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMyArIG40MSAqIHQxNDtcblxuXHRcdGlmICggZGV0ID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwICk7XG5cblx0XHRjb25zdCBkZXRJbnYgPSAxIC8gZGV0O1xuXG5cdFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcblx0XHR0ZVsgMSBdID0gKCBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMiBdID0gKCBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMyBdID0gKCBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyA0IF0gPSB0MTIgKiBkZXRJbnY7XG5cdFx0dGVbIDUgXSA9ICggbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDYgXSA9ICggbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDcgXSA9ICggbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgOCBdID0gdDEzICogZGV0SW52O1xuXHRcdHRlWyA5IF0gPSAoIG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAxMCBdID0gKCBuMTIgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjIgKiBuNDEgKyBuMTQgKiBuMjEgKiBuNDIgLSBuMTEgKiBuMjQgKiBuNDIgLSBuMTIgKiBuMjEgKiBuNDQgKyBuMTEgKiBuMjIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMTEgXSA9ICggbjEzICogbjIyICogbjQxIC0gbjEyICogbjIzICogbjQxIC0gbjEzICogbjIxICogbjQyICsgbjExICogbjIzICogbjQyICsgbjEyICogbjIxICogbjQzIC0gbjExICogbjIyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgMTIgXSA9IHQxNCAqIGRldEludjtcblx0XHR0ZVsgMTMgXSA9ICggbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDE0IF0gPSAoIG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNCApICogZGV0SW52O1xuXHRcdHRlWyAxNSBdID0gKCBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzMgKSAqIGRldEludjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzY2FsZSggdiApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xuXG5cdFx0dGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcblx0XHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xuXHRcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xuXHRcdHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE1heFNjYWxlT25BeGlzKCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3Qgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG5cdFx0Y29uc3Qgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XG5cdFx0Y29uc3Qgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcblxuXHR9XG5cblx0bWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICkge1xuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgMCwgeC54LFxuXHRcdFx0XHQwLCAxLCAwLCB4LnksXG5cdFx0XHRcdDAsIDAsIDEsIHgueixcblx0XHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgMCwgeCxcblx0XHRcdFx0MCwgMSwgMCwgeSxcblx0XHRcdFx0MCwgMCwgMSwgeixcblx0XHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblgoIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIGMsIC0gcywgMCxcblx0XHRcdDAsIHMsIGMsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblkoIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0IGMsIDAsIHMsIDAsXG5cdFx0XHQgMCwgMSwgMCwgMCxcblx0XHRcdC0gcywgMCwgYywgMCxcblx0XHRcdCAwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblooIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0YywgLSBzLCAwLCAwLFxuXHRcdFx0cywgYywgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0Y29uc3QgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXHRcdGNvbnN0IHQgPSAxIC0gYztcblx0XHRjb25zdCB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xuXHRcdGNvbnN0IHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuXHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2NhbGUoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCwgMCxcblx0XHRcdDAsIHksIDAsIDAsXG5cdFx0XHQwLCAwLCB6LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2hlYXIoIHh5LCB4eiwgeXgsIHl6LCB6eCwgenkgKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgeXgsIHp4LCAwLFxuXHRcdFx0eHksIDEsIHp5LCAwLFxuXHRcdFx0eHosIHl6LCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCB4ID0gcXVhdGVybmlvbi5feCwgeSA9IHF1YXRlcm5pb24uX3ksIHogPSBxdWF0ZXJuaW9uLl96LCB3ID0gcXVhdGVybmlvbi5fdztcblx0XHRjb25zdCB4MiA9IHggKyB4LFx0eTIgPSB5ICsgeSwgejIgPSB6ICsgejtcblx0XHRjb25zdCB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xuXHRcdGNvbnN0IHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG5cdFx0Y29uc3Qgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcblxuXHRcdGNvbnN0IHN4ID0gc2NhbGUueCwgc3kgPSBzY2FsZS55LCBzeiA9IHNjYWxlLno7XG5cblx0XHR0ZVsgMCBdID0gKCAxIC0gKCB5eSArIHp6ICkgKSAqIHN4O1xuXHRcdHRlWyAxIF0gPSAoIHh5ICsgd3ogKSAqIHN4O1xuXHRcdHRlWyAyIF0gPSAoIHh6IC0gd3kgKSAqIHN4O1xuXHRcdHRlWyAzIF0gPSAwO1xuXG5cdFx0dGVbIDQgXSA9ICggeHkgLSB3eiApICogc3k7XG5cdFx0dGVbIDUgXSA9ICggMSAtICggeHggKyB6eiApICkgKiBzeTtcblx0XHR0ZVsgNiBdID0gKCB5eiArIHd4ICkgKiBzeTtcblx0XHR0ZVsgNyBdID0gMDtcblxuXHRcdHRlWyA4IF0gPSAoIHh6ICsgd3kgKSAqIHN6O1xuXHRcdHRlWyA5IF0gPSAoIHl6IC0gd3ggKSAqIHN6O1xuXHRcdHRlWyAxMCBdID0gKCAxIC0gKCB4eCArIHl5ICkgKSAqIHN6O1xuXHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdHRlWyAxMiBdID0gcG9zaXRpb24ueDtcblx0XHR0ZVsgMTMgXSA9IHBvc2l0aW9uLnk7XG5cdFx0dGVbIDE0IF0gPSBwb3NpdGlvbi56O1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGxldCBzeCA9IF92MSQ1LnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN5ID0gX3YxJDUuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3ogPSBfdjEkNS5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XG5cblx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuXHRcdGNvbnN0IGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XG5cblx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG5cdFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuXHRcdHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcblxuXHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cdFx0X20xJDQuY29weSggdGhpcyApO1xuXG5cdFx0Y29uc3QgaW52U1ggPSAxIC8gc3g7XG5cdFx0Y29uc3QgaW52U1kgPSAxIC8gc3k7XG5cdFx0Y29uc3QgaW52U1ogPSAxIC8gc3o7XG5cblx0XHRfbTEkNC5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuXHRcdF9tMSQ0LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG5cdFx0X20xJDQuZWxlbWVudHNbIDIgXSAqPSBpbnZTWDtcblxuXHRcdF9tMSQ0LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG5cdFx0X20xJDQuZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcblx0XHRfbTEkNC5lbGVtZW50c1sgNiBdICo9IGludlNZO1xuXG5cdFx0X20xJDQuZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcblx0XHRfbTEkNC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuXHRcdF9tMSQ0LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xuXG5cdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSQ0ICk7XG5cblx0XHRzY2FsZS54ID0gc3g7XG5cdFx0c2NhbGUueSA9IHN5O1xuXHRcdHNjYWxlLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyLCBjb29yZGluYXRlU3lzdGVtID0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0Y29uc3QgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdGNvbnN0IGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHRsZXQgYywgZDtcblxuXHRcdGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuXHRcdFx0ZCA9ICggLSAyICogZmFyICogbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjb29yZGluYXRlU3lzdGVtID09PSBXZWJHUFVDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjID0gLSBmYXIgLyAoIGZhciAtIG5lYXIgKTtcblx0XHRcdGQgPSAoIC0gZmFyICogbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VQZXJzcGVjdGl2ZSgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAnICsgY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0fVxuXG5cdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhOyBcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7IFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7IFx0dGVbIDE0IF0gPSBkO1xuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciwgY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBoID0gMS4wIC8gKCB0b3AgLSBib3R0b20gKTtcblx0XHRjb25zdCBwID0gMS4wIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHRjb25zdCB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XG5cdFx0Y29uc3QgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xuXG5cdFx0bGV0IHosIHpJbnY7XG5cblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9ICggZmFyICsgbmVhciApICogcDtcblx0XHRcdHpJbnYgPSAtIDIgKiBwO1xuXG5cdFx0fSBlbHNlIGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9IG5lYXIgKiBwO1xuXHRcdFx0ekludiA9IC0gMSAqIHA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VPcnRob2dyYXBoaWMoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdH1cblxuXHRcdHRlWyAwIF0gPSAyICogdztcdHRlWyA0IF0gPSAwO1x0XHR0ZVsgOCBdID0gMDsgXHRcdHRlWyAxMiBdID0gLSB4O1xuXHRcdHRlWyAxIF0gPSAwOyBcdFx0dGVbIDUgXSA9IDIgKiBoO1x0dGVbIDkgXSA9IDA7IFx0XHR0ZVsgMTMgXSA9IC0geTtcblx0XHR0ZVsgMiBdID0gMDsgXHRcdHRlWyA2IF0gPSAwO1x0XHR0ZVsgMTAgXSA9IHpJbnY7XHR0ZVsgMTQgXSA9IC0gejtcblx0XHR0ZVsgMyBdID0gMDsgXHRcdHRlWyA3IF0gPSAwO1x0XHR0ZVsgMTEgXSA9IDA7XHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIG1hdHJpeCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxufVxuXG5jb25zdCBfdjEkNSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tMSQ0ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3plcm8gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCAwLCAwICk7XG5jb25zdCBfb25lID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xuY29uc3QgX3ggPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfeSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF96ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfbWF0cml4JDIgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfcXVhdGVybmlvbiQzID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5jbGFzcyBFdWxlciB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gRXVsZXIuREVGQVVMVF9PUkRFUiApIHtcblxuXHRcdHRoaXMuaXNFdWxlciA9IHRydWU7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdH1cblxuXHRnZXQgeCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH1cblxuXHRzZXQgeCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH1cblxuXHRzZXQgeSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeigpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH1cblxuXHRzZXQgeiggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgb3JkZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fb3JkZXI7XG5cblx0fVxuXG5cdHNldCBvcmRlciggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCBvcmRlciA9IHRoaXMuX29yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0Y29weSggZXVsZXIgKSB7XG5cblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXgoIG0sIG9yZGVyID0gdGhpcy5fb3JkZXIsIHVwZGF0ZSA9IHRydWUgKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XG5cdFx0Y29uc3QgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcblx0XHRjb25zdCBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0XHRjYXNlICdYWVonOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhaJzpcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pYWSc6XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVgnOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0aWYgKCB1cGRhdGUgPT09IHRydWUgKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVF1YXRlcm5pb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHRfbWF0cml4JDIubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX21hdHJpeCQyLCBvcmRlciwgdXBkYXRlICk7XG5cblx0fVxuXG5cdHNldEZyb21WZWN0b3IzKCB2LCBvcmRlciA9IHRoaXMuX29yZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciApO1xuXG5cdH1cblxuXHRyZW9yZGVyKCBuZXdPcmRlciApIHtcblxuXHRcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cblxuXHRcdF9xdWF0ZXJuaW9uJDMuc2V0RnJvbUV1bGVyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggX3F1YXRlcm5pb24kMywgbmV3T3JkZXIgKTtcblxuXHR9XG5cblx0ZXF1YWxzKCBldWxlciApIHtcblxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0X29uQ2hhbmdlKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLl94O1xuXHRcdHlpZWxkIHRoaXMuX3k7XG5cdFx0eWllbGQgdGhpcy5fejtcblx0XHR5aWVsZCB0aGlzLl9vcmRlcjtcblxuXHR9XG5cbn1cblxuRXVsZXIuREVGQVVMVF9PUkRFUiA9ICdYWVonO1xuXG5jbGFzcyBMYXllcnMge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMSB8IDA7XG5cblx0fVxuXG5cdHNldCggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayA9ICggMSA8PCBjaGFubmVsIHwgMCApID4+PiAwO1xuXG5cdH1cblxuXHRlbmFibGUoIGNoYW5uZWwgKSB7XG5cblx0XHR0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsIHwgMDtcblxuXHR9XG5cblx0ZW5hYmxlQWxsKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMHhmZmZmZmZmZiB8IDA7XG5cblx0fVxuXG5cdHRvZ2dsZSggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWwgfCAwO1xuXG5cdH1cblxuXHRkaXNhYmxlKCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrICY9IH4gKCAxIDw8IGNoYW5uZWwgfCAwICk7XG5cblx0fVxuXG5cdGRpc2FibGVBbGwoKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAwO1xuXG5cdH1cblxuXHR0ZXN0KCBsYXllcnMgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiBsYXllcnMubWFzayApICE9PSAwO1xuXG5cdH1cblxuXHRpc0VuYWJsZWQoIGNoYW5uZWwgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiAoIDEgPDwgY2hhbm5lbCB8IDAgKSApICE9PSAwO1xuXG5cdH1cblxufVxuXG5sZXQgX29iamVjdDNESWQgPSAwO1xuXG5jb25zdCBfdjEkNCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9tMSQzID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3RhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3Bvc2l0aW9uJDMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfc2NhbGUkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uJDIgPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmNvbnN0IF94QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDAsIDAgKTtcbmNvbnN0IF95QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcbmNvbnN0IF96QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxuY29uc3QgX2FkZGVkRXZlbnQgPSB7IHR5cGU6ICdhZGRlZCcgfTtcbmNvbnN0IF9yZW1vdmVkRXZlbnQgPSB7IHR5cGU6ICdyZW1vdmVkJyB9O1xuXG5jb25zdCBfY2hpbGRhZGRlZEV2ZW50ID0geyB0eXBlOiAnY2hpbGRhZGRlZCcsIGNoaWxkOiBudWxsIH07XG5jb25zdCBfY2hpbGRyZW1vdmVkRXZlbnQgPSB7IHR5cGU6ICdjaGlsZHJlbW92ZWQnLCBjaGlsZDogbnVsbCB9O1xuXG5jbGFzcyBPYmplY3QzRCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc09iamVjdDNEID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX29iamVjdDNESWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xuXG5cdFx0dGhpcy5wYXJlbnQgPSBudWxsO1xuXHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuXHRcdHRoaXMudXAgPSBPYmplY3QzRC5ERUZBVUxUX1VQLmNsb25lKCk7XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgcm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblx0XHRjb25zdCBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRjb25zdCBzY2FsZSA9IG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XG5cblx0XHRmdW5jdGlvbiBvblJvdGF0aW9uQ2hhbmdlKCkge1xuXG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XG5cblx0XHRcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRyb3RhdGlvbi5fb25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcblx0XHRxdWF0ZXJuaW9uLl9vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcG9zaXRpb25cblx0XHRcdH0sXG5cdFx0XHRyb3RhdGlvbjoge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiByb3RhdGlvblxuXHRcdFx0fSxcblx0XHRcdHF1YXRlcm5pb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcXVhdGVybmlvblxuXHRcdFx0fSxcblx0XHRcdHNjYWxlOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHNjYWxlXG5cdFx0XHR9LFxuXHRcdFx0bW9kZWxWaWV3TWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4NCgpXG5cdFx0XHR9LFxuXHRcdFx0bm9ybWFsTWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfQVVUT19VUERBVEU7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9IE9iamVjdDNELkRFRkFVTFRfTUFUUklYX1dPUkxEX0FVVE9fVVBEQVRFOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcblx0XHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuXHRcdHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdH1cblxuXHRvbkJlZm9yZVNoYWRvdyggLyogcmVuZGVyZXIsIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBncm91cCAqLyApIHt9XG5cblx0b25BZnRlclNoYWRvdyggLyogcmVuZGVyZXIsIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBncm91cCAqLyApIHt9XG5cblx0b25CZWZvcmVSZW5kZXIoIC8qIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICovICkge31cblxuXHRvbkFmdGVyUmVuZGVyKCAvKiByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCAqLyApIHt9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSggbWF0cml4ICk7XG5cblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdH1cblxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21NYXRyaXgoIG0gKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cblx0fVxuXG5cdHJvdGF0ZU9uQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdF9xMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBfcTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVPbldvcmxkQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF94QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0cm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF95QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0cm90YXRlWiggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF96QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0dHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIHtcblxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0X3YxJDQuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmFkZCggX3YxJDQubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGVYKCBkaXN0YW5jZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggX3hBeGlzLCBkaXN0YW5jZSApO1xuXG5cdH1cblxuXHR0cmFuc2xhdGVZKCBkaXN0YW5jZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggX3lBeGlzLCBkaXN0YW5jZSApO1xuXG5cdH1cblxuXHR0cmFuc2xhdGVaKCBkaXN0YW5jZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggX3pBeGlzLCBkaXN0YW5jZSApO1xuXG5cdH1cblxuXHRsb2NhbFRvV29ybGQoIHZlY3RvciApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH1cblxuXHR3b3JsZFRvTG9jYWwoIHZlY3RvciApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggX20xJDMuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpICk7XG5cblx0fVxuXG5cdGxvb2tBdCggeCwgeSwgeiApIHtcblxuXHRcdC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgcGFyZW50KHMpXG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHRfdGFyZ2V0LmNvcHkoIHggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF90YXJnZXQuc2V0KCB4LCB5LCB6ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRfcG9zaXRpb24kMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggdGhpcy5pc0NhbWVyYSB8fCB0aGlzLmlzTGlnaHQgKSB7XG5cblx0XHRcdF9tMSQzLmxvb2tBdCggX3Bvc2l0aW9uJDMsIF90YXJnZXQsIHRoaXMudXAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9tMSQzLmxvb2tBdCggX3RhcmdldCwgX3Bvc2l0aW9uJDMsIHRoaXMudXAgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSQzICk7XG5cblx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0X20xJDMuZXh0cmFjdFJvdGF0aW9uKCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdF9xMS5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSQzICk7XG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIF9xMS5pbnZlcnQoKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRhZGQoIG9iamVjdCApIHtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5hZGQoIGFyZ3VtZW50c1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhblxcJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuJywgb2JqZWN0ICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0ICYmIG9iamVjdC5pc09iamVjdDNEICkge1xuXG5cdFx0XHRvYmplY3QucmVtb3ZlRnJvbVBhcmVudCgpO1xuXHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX2FkZGVkRXZlbnQgKTtcblxuXHRcdFx0X2NoaWxkYWRkZWRFdmVudC5jaGlsZCA9IG9iamVjdDtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggX2NoaWxkYWRkZWRFdmVudCApO1xuXHRcdFx0X2NoaWxkYWRkZWRFdmVudC5jaGlsZCA9IG51bGw7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELicsIG9iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJlbW92ZSggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnJlbW92ZSggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcblxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IG51bGw7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIF9yZW1vdmVkRXZlbnQgKTtcblxuXHRcdFx0X2NoaWxkcmVtb3ZlZEV2ZW50LmNoaWxkID0gb2JqZWN0O1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBfY2hpbGRyZW1vdmVkRXZlbnQgKTtcblx0XHRcdF9jaGlsZHJlbW92ZWRFdmVudC5jaGlsZCA9IG51bGw7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlRnJvbVBhcmVudCgpIHtcblxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdHBhcmVudC5yZW1vdmUoIHRoaXMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGVhcigpIHtcblxuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggLi4uIHRoaXMuY2hpbGRyZW4gKTtcblxuXHR9XG5cblx0YXR0YWNoKCBvYmplY3QgKSB7XG5cblx0XHQvLyBhZGRzIG9iamVjdCBhcyBhIGNoaWxkIG9mIHRoaXMsIHdoaWxlIG1haW50YWluaW5nIHRoZSBvYmplY3QncyB3b3JsZCB0cmFuc2Zvcm1cblxuXHRcdC8vIE5vdGU6IFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgc2NlbmUgZ3JhcGhzIGhhdmluZyBub24tdW5pZm9ybWx5LXNjYWxlZCBub2RlcyhzKVxuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF9tMSQzLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHRcdGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0b2JqZWN0LnBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdFx0X20xJDMubXVsdGlwbHkoIG9iamVjdC5wYXJlbnQubWF0cml4V29ybGQgKTtcblxuXHRcdH1cblxuXHRcdG9iamVjdC5hcHBseU1hdHJpeDQoIF9tMSQzICk7XG5cblx0XHRvYmplY3QucmVtb3ZlRnJvbVBhcmVudCgpO1xuXHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XG5cblx0XHRvYmplY3QudXBkYXRlV29ybGRNYXRyaXgoIGZhbHNlLCB0cnVlICk7XG5cblx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX2FkZGVkRXZlbnQgKTtcblxuXHRcdF9jaGlsZGFkZGVkRXZlbnQuY2hpbGQgPSBvYmplY3Q7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBfY2hpbGRhZGRlZEV2ZW50ICk7XG5cdFx0X2NoaWxkYWRkZWRFdmVudC5jaGlsZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0T2JqZWN0QnlJZCggaWQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xuXG5cdH1cblxuXHRnZXRPYmplY3RCeU5hbWUoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuXHR9XG5cblx0Z2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRjb25zdCBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdGdldE9iamVjdHNCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSwgcmVzdWx0ID0gW10gKSB7XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXN1bHQucHVzaCggdGhpcyApO1xuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS5nZXRPYmplY3RzQnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUsIHJlc3VsdCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0Z2V0V29ybGRQb3NpdGlvbiggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHJldHVybiB0YXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdGdldFdvcmxkUXVhdGVybmlvbiggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24kMywgdGFyZ2V0LCBfc2NhbGUkMiApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Z2V0V29ybGRTY2FsZSggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24kMywgX3F1YXRlcm5pb24kMiwgdGFyZ2V0ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRnZXRXb3JsZERpcmVjdGlvbiggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdGNvbnN0IGUgPSB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzO1xuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIGVbIDggXSwgZVsgOSBdLCBlWyAxMCBdICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdHJheWNhc3QoIC8qIHJheWNhc3RlciwgaW50ZXJzZWN0cyAqLyApIHt9XG5cblx0dHJhdmVyc2UoIGNhbGxiYWNrICkge1xuXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKSB7XG5cblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRjYWxsYmFjayggdGhpcyApO1xuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApIHtcblxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdGNhbGxiYWNrKCBwYXJlbnQgKTtcblxuXHRcdFx0cGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXgoKSB7XG5cblx0XHR0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlICkge1xuXG5cdFx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRmb3JjZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0aWYgKCBjaGlsZC5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPT09IHRydWUgfHwgZm9yY2UgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y2hpbGQudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dXBkYXRlV29ybGRNYXRyaXgoIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuICkge1xuXG5cdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHRpZiAoIHVwZGF0ZVBhcmVudHMgPT09IHRydWUgJiYgcGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdHBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cblxuXHRcdGlmICggdXBkYXRlQ2hpbGRyZW4gPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IGNoaWxkcmVuWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRjaGlsZC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIHRydWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Ly8gbWV0YSBpcyBhIHN0cmluZyB3aGVuIGNhbGxlZCBmcm9tIEpTT04uc3RyaW5naWZ5XG5cdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XG5cblx0XHRjb25zdCBvdXRwdXQgPSB7fTtcblxuXHRcdC8vIG1ldGEgaXMgYSBoYXNoIHVzZWQgdG8gY29sbGVjdCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMuXG5cdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3Rcblx0XHQvLyBiZWluZyBzZXJpYWxpemVkLlxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHQvLyBpbml0aWFsaXplIG1ldGEgb2JqXG5cdFx0XHRtZXRhID0ge1xuXHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcblx0XHRcdFx0bWF0ZXJpYWxzOiB7fSxcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRpbWFnZXM6IHt9LFxuXHRcdFx0XHRzaGFwZXM6IHt9LFxuXHRcdFx0XHRza2VsZXRvbnM6IHt9LFxuXHRcdFx0XHRhbmltYXRpb25zOiB7fSxcblx0XHRcdFx0bm9kZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRvdXRwdXQubWV0YWRhdGEgPSB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ09iamVjdCcsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHQvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXG5cblx0XHRjb25zdCBvYmplY3QgPSB7fTtcblxuXHRcdG9iamVjdC51dWlkID0gdGhpcy51dWlkO1xuXHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgb2JqZWN0Lm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCB0aGlzLmNhc3RTaGFkb3cgPT09IHRydWUgKSBvYmplY3QuY2FzdFNoYWRvdyA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLnJlY2VpdmVTaGFkb3cgPT09IHRydWUgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgb2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblx0XHRpZiAoIHRoaXMuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgKSBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuXHRcdGlmICggdGhpcy5yZW5kZXJPcmRlciAhPT0gMCApIG9iamVjdC5yZW5kZXJPcmRlciA9IHRoaXMucmVuZGVyT3JkZXI7XG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBvYmplY3QudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuXG5cdFx0b2JqZWN0LmxheWVycyA9IHRoaXMubGF5ZXJzLm1hc2s7XG5cdFx0b2JqZWN0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcblx0XHRvYmplY3QudXAgPSB0aGlzLnVwLnRvQXJyYXkoKTtcblxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSBmYWxzZSApIG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHQvLyBvYmplY3Qgc3BlY2lmaWMgcHJvcGVydGllc1xuXG5cdFx0aWYgKCB0aGlzLmlzSW5zdGFuY2VkTWVzaCApIHtcblxuXHRcdFx0b2JqZWN0LnR5cGUgPSAnSW5zdGFuY2VkTWVzaCc7XG5cdFx0XHRvYmplY3QuY291bnQgPSB0aGlzLmNvdW50O1xuXHRcdFx0b2JqZWN0Lmluc3RhbmNlTWF0cml4ID0gdGhpcy5pbnN0YW5jZU1hdHJpeC50b0pTT04oKTtcblx0XHRcdGlmICggdGhpcy5pbnN0YW5jZUNvbG9yICE9PSBudWxsICkgb2JqZWN0Lmluc3RhbmNlQ29sb3IgPSB0aGlzLmluc3RhbmNlQ29sb3IudG9KU09OKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0b2JqZWN0LnR5cGUgPSAnQmF0Y2hlZE1lc2gnO1xuXHRcdFx0b2JqZWN0LnBlck9iamVjdEZydXN0dW1DdWxsZWQgPSB0aGlzLnBlck9iamVjdEZydXN0dW1DdWxsZWQ7XG5cdFx0XHRvYmplY3Quc29ydE9iamVjdHMgPSB0aGlzLnNvcnRPYmplY3RzO1xuXG5cdFx0XHRvYmplY3QuZHJhd1JhbmdlcyA9IHRoaXMuX2RyYXdSYW5nZXM7XG5cdFx0XHRvYmplY3QucmVzZXJ2ZWRSYW5nZXMgPSB0aGlzLl9yZXNlcnZlZFJhbmdlcztcblxuXHRcdFx0b2JqZWN0LnZpc2liaWxpdHkgPSB0aGlzLl92aXNpYmlsaXR5O1xuXHRcdFx0b2JqZWN0LmFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcblx0XHRcdG9iamVjdC5ib3VuZHMgPSB0aGlzLl9ib3VuZHMubWFwKCBib3VuZCA9PiAoIHtcblx0XHRcdFx0Ym94SW5pdGlhbGl6ZWQ6IGJvdW5kLmJveEluaXRpYWxpemVkLFxuXHRcdFx0XHRib3hNaW46IGJvdW5kLmJveC5taW4udG9BcnJheSgpLFxuXHRcdFx0XHRib3hNYXg6IGJvdW5kLmJveC5tYXgudG9BcnJheSgpLFxuXG5cdFx0XHRcdHNwaGVyZUluaXRpYWxpemVkOiBib3VuZC5zcGhlcmVJbml0aWFsaXplZCxcblx0XHRcdFx0c3BoZXJlUmFkaXVzOiBib3VuZC5zcGhlcmUucmFkaXVzLFxuXHRcdFx0XHRzcGhlcmVDZW50ZXI6IGJvdW5kLnNwaGVyZS5jZW50ZXIudG9BcnJheSgpXG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0b2JqZWN0Lm1heEdlb21ldHJ5Q291bnQgPSB0aGlzLl9tYXhHZW9tZXRyeUNvdW50O1xuXHRcdFx0b2JqZWN0Lm1heFZlcnRleENvdW50ID0gdGhpcy5fbWF4VmVydGV4Q291bnQ7XG5cdFx0XHRvYmplY3QubWF4SW5kZXhDb3VudCA9IHRoaXMuX21heEluZGV4Q291bnQ7XG5cblx0XHRcdG9iamVjdC5nZW9tZXRyeUluaXRpYWxpemVkID0gdGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZDtcblx0XHRcdG9iamVjdC5nZW9tZXRyeUNvdW50ID0gdGhpcy5fZ2VvbWV0cnlDb3VudDtcblxuXHRcdFx0b2JqZWN0Lm1hdHJpY2VzVGV4dHVyZSA9IHRoaXMuX21hdHJpY2VzVGV4dHVyZS50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0aWYgKCB0aGlzLl9jb2xvcnNUZXh0dXJlICE9PSBudWxsICkgb2JqZWN0LmNvbG9yc1RleHR1cmUgPSB0aGlzLl9jb2xvcnNUZXh0dXJlLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0b2JqZWN0LmJvdW5kaW5nU3BoZXJlID0ge1xuXHRcdFx0XHRcdGNlbnRlcjogb2JqZWN0LmJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCksXG5cdFx0XHRcdFx0cmFkaXVzOiBvYmplY3QuYm91bmRpbmdTcGhlcmUucmFkaXVzXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdG9iamVjdC5ib3VuZGluZ0JveCA9IHtcblx0XHRcdFx0XHRtaW46IG9iamVjdC5ib3VuZGluZ0JveC5taW4udG9BcnJheSgpLFxuXHRcdFx0XHRcdG1heDogb2JqZWN0LmJvdW5kaW5nQm94Lm1heC50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZSggbGlicmFyeSwgZWxlbWVudCApIHtcblxuXHRcdFx0aWYgKCBsaWJyYXJ5WyBlbGVtZW50LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID0gZWxlbWVudC50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbWVudC51dWlkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlzU2NlbmUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5iYWNrZ3JvdW5kICkge1xuXG5cdFx0XHRcdGlmICggdGhpcy5iYWNrZ3JvdW5kLmlzQ29sb3IgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZC50b0pTT04oKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmJhY2tncm91bmQuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmVudmlyb25tZW50ICYmIHRoaXMuZW52aXJvbm1lbnQuaXNUZXh0dXJlICYmIHRoaXMuZW52aXJvbm1lbnQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdG9iamVjdC5lbnZpcm9ubWVudCA9IHRoaXMuZW52aXJvbm1lbnQudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5pc01lc2ggfHwgdGhpcy5pc0xpbmUgfHwgdGhpcy5pc1BvaW50cyApIHtcblxuXHRcdFx0b2JqZWN0Lmdlb21ldHJ5ID0gc2VyaWFsaXplKCBtZXRhLmdlb21ldHJpZXMsIHRoaXMuZ2VvbWV0cnkgKTtcblxuXHRcdFx0Y29uc3QgcGFyYW1ldGVycyA9IHRoaXMuZ2VvbWV0cnkucGFyYW1ldGVycztcblxuXHRcdFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgJiYgcGFyYW1ldGVycy5zaGFwZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCBzaGFwZXMgPSBwYXJhbWV0ZXJzLnNoYXBlcztcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzWyBpIF07XG5cblx0XHRcdFx0XHRcdHNlcmlhbGl6ZSggbWV0YS5zaGFwZXMsIHNoYXBlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHNlcmlhbGl6ZSggbWV0YS5zaGFwZXMsIHNoYXBlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlzU2tpbm5lZE1lc2ggKSB7XG5cblx0XHRcdG9iamVjdC5iaW5kTW9kZSA9IHRoaXMuYmluZE1vZGU7XG5cdFx0XHRvYmplY3QuYmluZE1hdHJpeCA9IHRoaXMuYmluZE1hdHJpeC50b0FycmF5KCk7XG5cblx0XHRcdGlmICggdGhpcy5za2VsZXRvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNlcmlhbGl6ZSggbWV0YS5za2VsZXRvbnMsIHRoaXMuc2tlbGV0b24gKTtcblxuXHRcdFx0XHRvYmplY3Quc2tlbGV0b24gPSB0aGlzLnNrZWxldG9uLnV1aWQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHRoaXMubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRjb25zdCB1dWlkcyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMubWF0ZXJpYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHV1aWRzLnB1c2goIHNlcmlhbGl6ZSggbWV0YS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWxbIGkgXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHV1aWRzO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHNlcmlhbGl6ZSggbWV0YS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRvYmplY3QuY2hpbGRyZW4gPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmICggdGhpcy5hbmltYXRpb25zLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdG9iamVjdC5hbmltYXRpb25zID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zWyBpIF07XG5cblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMucHVzaCggc2VyaWFsaXplKCBtZXRhLmFuaW1hdGlvbnMsIGFuaW1hdGlvbiApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5nZW9tZXRyaWVzICk7XG5cdFx0XHRjb25zdCBtYXRlcmlhbHMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm1hdGVyaWFscyApO1xuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XG5cdFx0XHRjb25zdCBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xuXHRcdFx0Y29uc3Qgc2hhcGVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5zaGFwZXMgKTtcblx0XHRcdGNvbnN0IHNrZWxldG9ucyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuc2tlbGV0b25zICk7XG5cdFx0XHRjb25zdCBhbmltYXRpb25zID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5hbmltYXRpb25zICk7XG5cdFx0XHRjb25zdCBub2RlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubm9kZXMgKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyaWVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG5cdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIG91dHB1dC5pbWFnZXMgPSBpbWFnZXM7XG5cdFx0XHRpZiAoIHNoYXBlcy5sZW5ndGggPiAwICkgb3V0cHV0LnNoYXBlcyA9IHNoYXBlcztcblx0XHRcdGlmICggc2tlbGV0b25zLmxlbmd0aCA+IDAgKSBvdXRwdXQuc2tlbGV0b25zID0gc2tlbGV0b25zO1xuXHRcdFx0aWYgKCBhbmltYXRpb25zLmxlbmd0aCA+IDAgKSBvdXRwdXQuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5cdFx0XHRpZiAoIG5vZGVzLmxlbmd0aCA+IDAgKSBvdXRwdXQubm9kZXMgPSBub2RlcztcblxuXHRcdH1cblxuXHRcdG91dHB1dC5vYmplY3QgPSBvYmplY3Q7XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdFx0Ly8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcblx0XHQvLyByZW1vdmUgbWV0YWRhdGEgb24gZWFjaCBpdGVtXG5cdFx0Ly8gYW5kIHJldHVybiBhcyBhcnJheVxuXHRcdGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUoIGNhY2hlICkge1xuXG5cdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBjYWNoZSApIHtcblxuXHRcdFx0XHRjb25zdCBkYXRhID0gY2FjaGVbIGtleSBdO1xuXHRcdFx0XHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcblx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbG9uZSggcmVjdXJzaXZlICkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlID0gdHJ1ZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0dGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcblxuXHRcdHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XG5cdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHNvdXJjZS5yb3RhdGlvbi5vcmRlcjtcblx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggc291cmNlLnF1YXRlcm5pb24gKTtcblx0XHR0aGlzLnNjYWxlLmNvcHkoIHNvdXJjZS5zY2FsZSApO1xuXG5cdFx0dGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xuXHRcdHRoaXMubWF0cml4V29ybGQuY29weSggc291cmNlLm1hdHJpeFdvcmxkICk7XG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblxuXHRcdHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblxuXHRcdHRoaXMubGF5ZXJzLm1hc2sgPSBzb3VyY2UubGF5ZXJzLm1hc2s7XG5cdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcblxuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xuXHRcdHRoaXMucmVuZGVyT3JkZXIgPSBzb3VyY2UucmVuZGVyT3JkZXI7XG5cblx0XHR0aGlzLmFuaW1hdGlvbnMgPSBzb3VyY2UuYW5pbWF0aW9ucy5zbGljZSgpO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xuXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNvdXJjZS5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5bIGkgXTtcblx0XHRcdFx0dGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbk9iamVjdDNELkRFRkFVTFRfVVAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XG5PYmplY3QzRC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURSA9IHRydWU7XG5PYmplY3QzRC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURSA9IHRydWU7XG5cbmNvbnN0IF92MCQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YxJDMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjIkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MyQyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfdmFiID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZhYyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92YmMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmFwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZicCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92Y3AgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNsYXNzIFRyaWFuZ2xlIHtcblxuXHRjb25zdHJ1Y3RvciggYSA9IG5ldyBWZWN0b3IzKCksIGIgPSBuZXcgVmVjdG9yMygpLCBjID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdHRoaXMuYSA9IGE7XG5cdFx0dGhpcy5iID0gYjtcblx0XHR0aGlzLmMgPSBjO1xuXG5cdH1cblxuXHRzdGF0aWMgZ2V0Tm9ybWFsKCBhLCBiLCBjLCB0YXJnZXQgKSB7XG5cblx0XHR0YXJnZXQuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdF92MCQxLnN1YlZlY3RvcnMoIGEsIGIgKTtcblx0XHR0YXJnZXQuY3Jvc3MoIF92MCQxICk7XG5cblx0XHRjb25zdCB0YXJnZXRMZW5ndGhTcSA9IHRhcmdldC5sZW5ndGhTcSgpO1xuXHRcdGlmICggdGFyZ2V0TGVuZ3RoU3EgPiAwICkge1xuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCB0YXJnZXRMZW5ndGhTcSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggMCwgMCwgMCApO1xuXG5cdH1cblxuXHQvLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuXHQvLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxuXHRzdGF0aWMgZ2V0QmFyeWNvb3JkKCBwb2ludCwgYSwgYiwgYywgdGFyZ2V0ICkge1xuXG5cdFx0X3YwJDEuc3ViVmVjdG9ycyggYywgYSApO1xuXHRcdF92MSQzLnN1YlZlY3RvcnMoIGIsIGEgKTtcblx0XHRfdjIkMi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xuXG5cdFx0Y29uc3QgZG90MDAgPSBfdjAkMS5kb3QoIF92MCQxICk7XG5cdFx0Y29uc3QgZG90MDEgPSBfdjAkMS5kb3QoIF92MSQzICk7XG5cdFx0Y29uc3QgZG90MDIgPSBfdjAkMS5kb3QoIF92MiQyICk7XG5cdFx0Y29uc3QgZG90MTEgPSBfdjEkMy5kb3QoIF92MSQzICk7XG5cdFx0Y29uc3QgZG90MTIgPSBfdjEkMy5kb3QoIF92MiQyICk7XG5cblx0XHRjb25zdCBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcblxuXHRcdC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuXHRcdGlmICggZGVub20gPT09IDAgKSB7XG5cblx0XHRcdHRhcmdldC5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW52RGVub20gPSAxIC8gZGVub207XG5cdFx0Y29uc3QgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xuXHRcdGNvbnN0IHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcblxuXHRcdC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xuXG5cdH1cblxuXHRzdGF0aWMgY29udGFpbnNQb2ludCggcG9pbnQsIGEsIGIsIGMgKSB7XG5cblx0XHQvLyBpZiB0aGUgdHJpYW5nbGUgaXMgZGVnZW5lcmF0ZSB0aGVuIHdlIGNhbid0IGNvbnRhaW4gYSBwb2ludFxuXHRcdGlmICggdGhpcy5nZXRCYXJ5Y29vcmQoIHBvaW50LCBhLCBiLCBjLCBfdjMkMiApID09PSBudWxsICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKCBfdjMkMi54ID49IDAgKSAmJiAoIF92MyQyLnkgPj0gMCApICYmICggKCBfdjMkMi54ICsgX3YzJDIueSApIDw9IDEgKTtcblxuXHR9XG5cblx0c3RhdGljIGdldEludGVycG9sYXRpb24oIHBvaW50LCBwMSwgcDIsIHAzLCB2MSwgdjIsIHYzLCB0YXJnZXQgKSB7XG5cblx0XHRpZiAoIHRoaXMuZ2V0QmFyeWNvb3JkKCBwb2ludCwgcDEsIHAyLCBwMywgX3YzJDIgKSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGFyZ2V0LnggPSAwO1xuXHRcdFx0dGFyZ2V0LnkgPSAwO1xuXHRcdFx0aWYgKCAneicgaW4gdGFyZ2V0ICkgdGFyZ2V0LnogPSAwO1xuXHRcdFx0aWYgKCAndycgaW4gdGFyZ2V0ICkgdGFyZ2V0LncgPSAwO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHR0YXJnZXQuc2V0U2NhbGFyKCAwICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggdjEsIF92MyQyLnggKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCB2MiwgX3YzJDIueSApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIHYzLCBfdjMkMi56ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRzdGF0aWMgaXNGcm9udEZhY2luZyggYSwgYiwgYywgZGlyZWN0aW9uICkge1xuXG5cdFx0X3YwJDEuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdF92MSQzLnN1YlZlY3RvcnMoIGEsIGIgKTtcblxuXHRcdC8vIHN0cmljdGx5IGZyb250IGZhY2luZ1xuXHRcdHJldHVybiAoIF92MCQxLmNyb3NzKCBfdjEkMyApLmRvdCggZGlyZWN0aW9uICkgPCAwICkgPyB0cnVlIDogZmFsc2U7XG5cblx0fVxuXG5cdHNldCggYSwgYiwgYyApIHtcblxuXHRcdHRoaXMuYS5jb3B5KCBhICk7XG5cdFx0dGhpcy5iLmNvcHkoIGIgKTtcblx0XHR0aGlzLmMuY29weSggYyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XG5cblx0XHR0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XG5cdFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuXHRcdHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQXR0cmlidXRlQW5kSW5kaWNlcyggYXR0cmlidXRlLCBpMCwgaTEsIGkyICkge1xuXG5cdFx0dGhpcy5hLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaTAgKTtcblx0XHR0aGlzLmIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpMSApO1xuXHRcdHRoaXMuYy5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcHkoIHRyaWFuZ2xlICkge1xuXG5cdFx0dGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcblx0XHR0aGlzLmIuY29weSggdHJpYW5nbGUuYiApO1xuXHRcdHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0QXJlYSgpIHtcblxuXHRcdF92MCQxLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XG5cdFx0X3YxJDMuc3ViVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKTtcblxuXHRcdHJldHVybiBfdjAkMS5jcm9zcyggX3YxJDMgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHR9XG5cblx0Z2V0TWlkcG9pbnQoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xuXG5cdH1cblxuXHRnZXROb3JtYWwoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiBUcmlhbmdsZS5nZXROb3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCApO1xuXG5cdH1cblxuXHRnZXRQbGFuZSggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuXHR9XG5cblx0Z2V0QmFyeWNvb3JkKCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEJhcnljb29yZCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCApO1xuXG5cdH1cblxuXHRnZXRJbnRlcnBvbGF0aW9uKCBwb2ludCwgdjEsIHYyLCB2MywgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB2MSwgdjIsIHYzLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuXHR9XG5cblx0aXNGcm9udEZhY2luZyggZGlyZWN0aW9uICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmlzRnJvbnRGYWNpbmcoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIGRpcmVjdGlvbiApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNUcmlhbmdsZSggdGhpcyApO1xuXG5cdH1cblxuXHRjbG9zZXN0UG9pbnRUb1BvaW50KCBwLCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCBhID0gdGhpcy5hLCBiID0gdGhpcy5iLCBjID0gdGhpcy5jO1xuXHRcdGxldCB2LCB3O1xuXG5cdFx0Ly8gYWxnb3JpdGhtIHRoYW5rcyB0byBSZWFsLVRpbWUgQ29sbGlzaW9uIERldGVjdGlvbiBieSBDaHJpc3RlciBFcmljc29uLFxuXHRcdC8vIHB1Ymxpc2hlZCBieSBNb3JnYW4gS2F1Zm1hbm4gUHVibGlzaGVycywgKGMpIDIwMDUgRWxzZXZpZXIgSW5jLixcblx0XHQvLyB1bmRlciB0aGUgYWNjb21wYW55aW5nIGxpY2Vuc2U7IHNlZSBjaGFwdGVyIDUuMS41IGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbi5cblx0XHQvLyBiYXNpY2FsbHksIHdlJ3JlIGRpc3Rpbmd1aXNoaW5nIHdoaWNoIG9mIHRoZSB2b3Jvbm9pIHJlZ2lvbnMgb2YgdGhlIHRyaWFuZ2xlXG5cdFx0Ly8gdGhlIHBvaW50IGxpZXMgaW4gd2l0aCB0aGUgbWluaW11bSBhbW91bnQgb2YgcmVkdW5kYW50IGNvbXB1dGF0aW9uLlxuXG5cdFx0X3ZhYi5zdWJWZWN0b3JzKCBiLCBhICk7XG5cdFx0X3ZhYy5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0X3ZhcC5zdWJWZWN0b3JzKCBwLCBhICk7XG5cdFx0Y29uc3QgZDEgPSBfdmFiLmRvdCggX3ZhcCApO1xuXHRcdGNvbnN0IGQyID0gX3ZhYy5kb3QoIF92YXAgKTtcblx0XHRpZiAoIGQxIDw9IDAgJiYgZDIgPD0gMCApIHtcblxuXHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBBOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEsIDAsIDApXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGEgKTtcblxuXHRcdH1cblxuXHRcdF92YnAuc3ViVmVjdG9ycyggcCwgYiApO1xuXHRcdGNvbnN0IGQzID0gX3ZhYi5kb3QoIF92YnAgKTtcblx0XHRjb25zdCBkNCA9IF92YWMuZG90KCBfdmJwICk7XG5cdFx0aWYgKCBkMyA+PSAwICYmIGQ0IDw9IGQzICkge1xuXG5cdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEI7IGJhcnljZW50cmljIGNvb3JkcyAoMCwgMSwgMClcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYiApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdmMgPSBkMSAqIGQ0IC0gZDMgKiBkMjtcblx0XHRpZiAoIHZjIDw9IDAgJiYgZDEgPj0gMCAmJiBkMyA8PSAwICkge1xuXG5cdFx0XHR2ID0gZDEgLyAoIGQxIC0gZDMgKTtcblx0XHRcdC8vIGVkZ2UgcmVnaW9uIG9mIEFCOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEtdiwgdiwgMClcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYSApLmFkZFNjYWxlZFZlY3RvciggX3ZhYiwgdiApO1xuXG5cdFx0fVxuXG5cdFx0X3ZjcC5zdWJWZWN0b3JzKCBwLCBjICk7XG5cdFx0Y29uc3QgZDUgPSBfdmFiLmRvdCggX3ZjcCApO1xuXHRcdGNvbnN0IGQ2ID0gX3ZhYy5kb3QoIF92Y3AgKTtcblx0XHRpZiAoIGQ2ID49IDAgJiYgZDUgPD0gZDYgKSB7XG5cblx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAwLCAxKVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBjICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2YiA9IGQ1ICogZDIgLSBkMSAqIGQ2O1xuXHRcdGlmICggdmIgPD0gMCAmJiBkMiA+PSAwICYmIGQ2IDw9IDAgKSB7XG5cblx0XHRcdHcgPSBkMiAvICggZDIgLSBkNiApO1xuXHRcdFx0Ly8gZWRnZSByZWdpb24gb2YgQUM7IGJhcnljZW50cmljIGNvb3JkcyAoMS13LCAwLCB3KVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFjLCB3ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2YSA9IGQzICogZDYgLSBkNSAqIGQ0O1xuXHRcdGlmICggdmEgPD0gMCAmJiAoIGQ0IC0gZDMgKSA+PSAwICYmICggZDUgLSBkNiApID49IDAgKSB7XG5cblx0XHRcdF92YmMuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdFx0dyA9ICggZDQgLSBkMyApIC8gKCAoIGQ0IC0gZDMgKSArICggZDUgLSBkNiApICk7XG5cdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBCQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLXcsIHcpXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGIgKS5hZGRTY2FsZWRWZWN0b3IoIF92YmMsIHcgKTsgLy8gZWRnZSByZWdpb24gb2YgQkNcblxuXHRcdH1cblxuXHRcdC8vIGZhY2UgcmVnaW9uXG5cdFx0Y29uc3QgZGVub20gPSAxIC8gKCB2YSArIHZiICsgdmMgKTtcblx0XHQvLyB1ID0gdmEgKiBkZW5vbVxuXHRcdHYgPSB2YiAqIGRlbm9tO1xuXHRcdHcgPSB2YyAqIGRlbm9tO1xuXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFiLCB2ICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFjLCB3ICk7XG5cblx0fVxuXG5cdGVxdWFscyggdHJpYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9jb2xvcktleXdvcmRzID0geyAnYWxpY2VibHVlJzogMHhGMEY4RkYsICdhbnRpcXVld2hpdGUnOiAweEZBRUJENywgJ2FxdWEnOiAweDAwRkZGRiwgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCwgJ2F6dXJlJzogMHhGMEZGRkYsXG5cdCdiZWlnZSc6IDB4RjVGNURDLCAnYmlzcXVlJzogMHhGRkU0QzQsICdibGFjayc6IDB4MDAwMDAwLCAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCwgJ2JsdWUnOiAweDAwMDBGRiwgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcblx0J2Jyb3duJzogMHhBNTJBMkEsICdidXJseXdvb2QnOiAweERFQjg4NywgJ2NhZGV0Ymx1ZSc6IDB4NUY5RUEwLCAnY2hhcnRyZXVzZSc6IDB4N0ZGRjAwLCAnY2hvY29sYXRlJzogMHhEMjY5MUUsICdjb3JhbCc6IDB4RkY3RjUwLFxuXHQnY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCwgJ2Nvcm5zaWxrJzogMHhGRkY4REMsICdjcmltc29uJzogMHhEQzE0M0MsICdjeWFuJzogMHgwMEZGRkYsICdkYXJrYmx1ZSc6IDB4MDAwMDhCLCAnZGFya2N5YW4nOiAweDAwOEI4Qixcblx0J2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQiwgJ2RhcmtncmF5JzogMHhBOUE5QTksICdkYXJrZ3JlZW4nOiAweDAwNjQwMCwgJ2RhcmtncmV5JzogMHhBOUE5QTksICdkYXJra2hha2knOiAweEJEQjc2QiwgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXG5cdCdkYXJrb2xpdmVncmVlbic6IDB4NTU2QjJGLCAnZGFya29yYW5nZSc6IDB4RkY4QzAwLCAnZGFya29yY2hpZCc6IDB4OTkzMkNDLCAnZGFya3JlZCc6IDB4OEIwMDAwLCAnZGFya3NhbG1vbic6IDB4RTk5NjdBLCAnZGFya3NlYWdyZWVuJzogMHg4RkJDOEYsXG5cdCdkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG5cdCdkZWVwcGluayc6IDB4RkYxNDkzLCAnZGVlcHNreWJsdWUnOiAweDAwQkZGRiwgJ2RpbWdyYXknOiAweDY5Njk2OSwgJ2RpbWdyZXknOiAweDY5Njk2OSwgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRiwgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxuXHQnZmxvcmFsd2hpdGUnOiAweEZGRkFGMCwgJ2ZvcmVzdGdyZWVuJzogMHgyMjhCMjIsICdmdWNoc2lhJzogMHhGRjAwRkYsICdnYWluc2Jvcm8nOiAweERDRENEQywgJ2dob3N0d2hpdGUnOiAweEY4RjhGRiwgJ2dvbGQnOiAweEZGRDcwMCxcblx0J2dvbGRlbnJvZCc6IDB4REFBNTIwLCAnZ3JheSc6IDB4ODA4MDgwLCAnZ3JlZW4nOiAweDAwODAwMCwgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsICdncmV5JzogMHg4MDgwODAsICdob25leWRldyc6IDB4RjBGRkYwLCAnaG90cGluayc6IDB4RkY2OUI0LFxuXHQnaW5kaWFucmVkJzogMHhDRDVDNUMsICdpbmRpZ28nOiAweDRCMDA4MiwgJ2l2b3J5JzogMHhGRkZGRjAsICdraGFraSc6IDB4RjBFNjhDLCAnbGF2ZW5kZXInOiAweEU2RTZGQSwgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSwgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxuXHQnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsICdsaWdodGJsdWUnOiAweEFERDhFNiwgJ2xpZ2h0Y29yYWwnOiAweEYwODA4MCwgJ2xpZ2h0Y3lhbic6IDB4RTBGRkZGLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAweEZBRkFEMiwgJ2xpZ2h0Z3JheSc6IDB4RDNEM0QzLFxuXHQnbGlnaHRncmVlbic6IDB4OTBFRTkwLCAnbGlnaHRncmV5JzogMHhEM0QzRDMsICdsaWdodHBpbmsnOiAweEZGQjZDMSwgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcblx0J2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LCAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSwgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsICdsaW1lJzogMHgwMEZGMDAsICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcblx0J2xpbmVuJzogMHhGQUYwRTYsICdtYWdlbnRhJzogMHhGRjAwRkYsICdtYXJvb24nOiAweDgwMDAwMCwgJ21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSwgJ21lZGl1bWJsdWUnOiAweDAwMDBDRCwgJ21lZGl1bW9yY2hpZCc6IDB4QkE1NUQzLFxuXHQnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLCAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLCAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXG5cdCdtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSwgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLCAnbWludGNyZWFtJzogMHhGNUZGRkEsICdtaXN0eXJvc2UnOiAweEZGRTRFMSwgJ21vY2Nhc2luJzogMHhGRkU0QjUsICduYXZham93aGl0ZSc6IDB4RkZERUFELFxuXHQnbmF2eSc6IDB4MDAwMDgwLCAnb2xkbGFjZSc6IDB4RkRGNUU2LCAnb2xpdmUnOiAweDgwODAwMCwgJ29saXZlZHJhYic6IDB4NkI4RTIzLCAnb3JhbmdlJzogMHhGRkE1MDAsICdvcmFuZ2VyZWQnOiAweEZGNDUwMCwgJ29yY2hpZCc6IDB4REE3MEQ2LFxuXHQncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLCAncGFsZWdyZWVuJzogMHg5OEZCOTgsICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsICdwYXBheWF3aGlwJzogMHhGRkVGRDUsICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcblx0J3BlcnUnOiAweENEODUzRiwgJ3BpbmsnOiAweEZGQzBDQiwgJ3BsdW0nOiAweEREQTBERCwgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNiwgJ3B1cnBsZSc6IDB4ODAwMDgwLCAncmViZWNjYXB1cnBsZSc6IDB4NjYzMzk5LCAncmVkJzogMHhGRjAwMDAsICdyb3N5YnJvd24nOiAweEJDOEY4Rixcblx0J3JveWFsYmx1ZSc6IDB4NDE2OUUxLCAnc2FkZGxlYnJvd24nOiAweDhCNDUxMywgJ3NhbG1vbic6IDB4RkE4MDcyLCAnc2FuZHlicm93bic6IDB4RjRBNDYwLCAnc2VhZ3JlZW4nOiAweDJFOEI1NywgJ3NlYXNoZWxsJzogMHhGRkY1RUUsXG5cdCdzaWVubmEnOiAweEEwNTIyRCwgJ3NpbHZlcic6IDB4QzBDMEMwLCAnc2t5Ymx1ZSc6IDB4ODdDRUVCLCAnc2xhdGVibHVlJzogMHg2QTVBQ0QsICdzbGF0ZWdyYXknOiAweDcwODA5MCwgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLCAnc25vdyc6IDB4RkZGQUZBLFxuXHQnc3ByaW5nZ3JlZW4nOiAweDAwRkY3RiwgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LCAndGFuJzogMHhEMkI0OEMsICd0ZWFsJzogMHgwMDgwODAsICd0aGlzdGxlJzogMHhEOEJGRDgsICd0b21hdG8nOiAweEZGNjM0NywgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuXHQndmlvbGV0JzogMHhFRTgyRUUsICd3aGVhdCc6IDB4RjVERUIzLCAnd2hpdGUnOiAweEZGRkZGRiwgJ3doaXRlc21va2UnOiAweEY1RjVGNSwgJ3llbGxvdyc6IDB4RkZGRjAwLCAneWVsbG93Z3JlZW4nOiAweDlBQ0QzMiB9O1xuXG5jb25zdCBfaHNsQSA9IHsgaDogMCwgczogMCwgbDogMCB9O1xuY29uc3QgX2hzbEIgPSB7IGg6IDAsIHM6IDAsIGw6IDAgfTtcblxuZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApIHtcblxuXHRpZiAoIHQgPCAwICkgdCArPSAxO1xuXHRpZiAoIHQgPiAxICkgdCAtPSAxO1xuXHRpZiAoIHQgPCAxIC8gNiApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqIHQ7XG5cdGlmICggdCA8IDEgLyAyICkgcmV0dXJuIHE7XG5cdGlmICggdCA8IDIgLyAzICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogKCAyIC8gMyAtIHQgKTtcblx0cmV0dXJuIHA7XG5cbn1cblxuY2xhc3MgQ29sb3Ige1xuXG5cdGNvbnN0cnVjdG9yKCByLCBnLCBiICkge1xuXG5cdFx0dGhpcy5pc0NvbG9yID0gdHJ1ZTtcblxuXHRcdHRoaXMuciA9IDE7XG5cdFx0dGhpcy5nID0gMTtcblx0XHR0aGlzLmIgPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCByLCBnLCBiICk7XG5cblx0fVxuXG5cdHNldCggciwgZywgYiApIHtcblxuXHRcdGlmICggZyA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gciBpcyBUSFJFRS5Db2xvciwgaGV4IG9yIHN0cmluZ1xuXG5cdFx0XHRjb25zdCB2YWx1ZSA9IHI7XG5cblx0XHRcdGlmICggdmFsdWUgJiYgdmFsdWUuaXNDb2xvciApIHtcblxuXHRcdFx0XHR0aGlzLmNvcHkoIHZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdFx0dGhpcy5zZXRIZXgoIHZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdFx0dGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5zZXRSR0IoIHIsIGcsIGIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMuciA9IHNjYWxhcjtcblx0XHR0aGlzLmcgPSBzY2FsYXI7XG5cdFx0dGhpcy5iID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEhleCggaGV4LCBjb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UgKSB7XG5cblx0XHRoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcblxuXHRcdHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XG5cdFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xuXHRcdHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XG5cblx0XHRDb2xvck1hbmFnZW1lbnQudG9Xb3JraW5nQ29sb3JTcGFjZSggdGhpcywgY29sb3JTcGFjZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFJHQiggciwgZywgYiwgY29sb3JTcGFjZSA9IENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSApIHtcblxuXHRcdHRoaXMuciA9IHI7XG5cdFx0dGhpcy5nID0gZztcblx0XHR0aGlzLmIgPSBiO1xuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LnRvV29ya2luZ0NvbG9yU3BhY2UoIHRoaXMsIGNvbG9yU3BhY2UgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRIU0woIGgsIHMsIGwsIGNvbG9yU3BhY2UgPSBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2UgKSB7XG5cblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXHRcdGggPSBldWNsaWRlYW5Nb2R1bG8oIGgsIDEgKTtcblx0XHRzID0gY2xhbXAoIHMsIDAsIDEgKTtcblx0XHRsID0gY2xhbXAoIGwsIDAsIDEgKTtcblxuXHRcdGlmICggcyA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gbDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcblx0XHRcdGNvbnN0IHEgPSAoIDIgKiBsICkgLSBwO1xuXG5cdFx0XHR0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcblx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcblx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xuXG5cdFx0fVxuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LnRvV29ya2luZ0NvbG9yU3BhY2UoIHRoaXMsIGNvbG9yU3BhY2UgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTdHlsZSggc3R5bGUsIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUFscGhhKCBzdHJpbmcgKSB7XG5cblx0XHRcdGlmICggc3RyaW5nID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgJyArIHN0eWxlICsgJyB3aWxsIGJlIGlnbm9yZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblxuXHRcdGxldCBtO1xuXG5cdFx0aWYgKCBtID0gL14oXFx3KylcXCgoW15cXCldKilcXCkvLmV4ZWMoIHN0eWxlICkgKSB7XG5cblx0XHRcdC8vIHJnYiAvIGhzbFxuXG5cdFx0XHRsZXQgY29sb3I7XG5cdFx0XHRjb25zdCBuYW1lID0gbVsgMSBdO1xuXHRcdFx0Y29uc3QgY29tcG9uZW50cyA9IG1bIDIgXTtcblxuXHRcdFx0c3dpdGNoICggbmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdyZ2InOlxuXHRcdFx0XHRjYXNlICdyZ2JhJzpcblxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXlxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXG5cblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNCBdICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnNldFJHQihcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NSxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NSxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NSxcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXlxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXG5cblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNCBdICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnNldFJHQihcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMCxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDEwMCxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMCxcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2hzbCc6XG5cdFx0XHRcdGNhc2UgJ2hzbGEnOlxuXG5cdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eXFxzKihcXGQqXFwuP1xcZCspXFxzKixcXHMqKFxcZCpcXC4/XFxkKylcXCVcXHMqLFxccyooXFxkKlxcLj9cXGQrKVxcJVxccyooPzosXFxzKihcXGQqXFwuP1xcZCspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBoc2woMTIwLDUwJSw1MCUpIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxuXG5cdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDQgXSApO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRIU0woXG5cdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGNvbG9yWyAxIF0gKSAvIDM2MCxcblx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggY29sb3JbIDIgXSApIC8gMTAwLFxuXHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBjb2xvclsgMyBdICkgLyAxMDAsXG5cdFx0XHRcdFx0XHRcdGNvbG9yU3BhY2Vcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgbW9kZWwgJyArIHN0eWxlICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mXFxkXSspJC8uZXhlYyggc3R5bGUgKSApIHtcblxuXHRcdFx0Ly8gaGV4IGNvbG9yXG5cblx0XHRcdGNvbnN0IGhleCA9IG1bIDEgXTtcblx0XHRcdGNvbnN0IHNpemUgPSBoZXgubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0Ly8gI2ZmMFxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRSR0IoXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDE1LFxuXHRcdFx0XHRcdHBhcnNlSW50KCBoZXguY2hhckF0KCAxICksIDE2ICkgLyAxNSxcblx0XHRcdFx0XHRwYXJzZUludCggaGV4LmNoYXJBdCggMiApLCAxNiApIC8gMTUsXG5cdFx0XHRcdFx0Y29sb3JTcGFjZVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBzaXplID09PSA2ICkge1xuXG5cdFx0XHRcdC8vICNmZjAwMDBcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SGV4KCBwYXJzZUludCggaGV4LCAxNiApLCBjb2xvclNwYWNlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEludmFsaWQgaGV4IGNvbG9yICcgKyBzdHlsZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDb2xvck5hbWUoIHN0eWxlLCBjb2xvclNwYWNlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Q29sb3JOYW1lKCBzdHlsZSwgY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlICkge1xuXG5cdFx0Ly8gY29sb3Iga2V5d29yZHNcblx0XHRjb25zdCBoZXggPSBfY29sb3JLZXl3b3Jkc1sgc3R5bGUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0aWYgKCBoZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gcmVkXG5cdFx0XHR0aGlzLnNldEhleCggaGV4LCBjb2xvclNwYWNlICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyB1bmtub3duIGNvbG9yXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAnICsgc3R5bGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiApO1xuXG5cdH1cblxuXHRjb3B5KCBjb2xvciApIHtcblxuXHRcdHRoaXMuciA9IGNvbG9yLnI7XG5cdFx0dGhpcy5nID0gY29sb3IuZztcblx0XHR0aGlzLmIgPSBjb2xvci5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlTUkdCVG9MaW5lYXIoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yID0gU1JHQlRvTGluZWFyKCBjb2xvci5yICk7XG5cdFx0dGhpcy5nID0gU1JHQlRvTGluZWFyKCBjb2xvci5nICk7XG5cdFx0dGhpcy5iID0gU1JHQlRvTGluZWFyKCBjb2xvci5iICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weUxpbmVhclRvU1JHQiggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLnIgKTtcblx0XHR0aGlzLmcgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLmcgKTtcblx0XHR0aGlzLmIgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLmIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb252ZXJ0U1JHQlRvTGluZWFyKCkge1xuXG5cdFx0dGhpcy5jb3B5U1JHQlRvTGluZWFyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29udmVydExpbmVhclRvU1JHQigpIHtcblxuXHRcdHRoaXMuY29weUxpbmVhclRvU1JHQiggdGhpcyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldEhleCggY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlICkge1xuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xuXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIGNsYW1wKCBfY29sb3IuciAqIDI1NSwgMCwgMjU1ICkgKSAqIDY1NTM2ICsgTWF0aC5yb3VuZCggY2xhbXAoIF9jb2xvci5nICogMjU1LCAwLCAyNTUgKSApICogMjU2ICsgTWF0aC5yb3VuZCggY2xhbXAoIF9jb2xvci5iICogMjU1LCAwLCAyNTUgKSApO1xuXG5cdH1cblxuXHRnZXRIZXhTdHJpbmcoIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcblxuXHRcdHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoIGNvbG9yU3BhY2UgKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtIDYgKTtcblxuXHR9XG5cblx0Z2V0SFNMKCB0YXJnZXQsIGNvbG9yU3BhY2UgPSBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2UgKSB7XG5cblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xuXG5cdFx0Y29uc3QgciA9IF9jb2xvci5yLCBnID0gX2NvbG9yLmcsIGIgPSBfY29sb3IuYjtcblxuXHRcdGNvbnN0IG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XG5cdFx0Y29uc3QgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcblxuXHRcdGxldCBodWUsIHNhdHVyYXRpb247XG5cdFx0Y29uc3QgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcblxuXHRcdGlmICggbWluID09PSBtYXggKSB7XG5cblx0XHRcdGh1ZSA9IDA7XG5cdFx0XHRzYXR1cmF0aW9uID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGRlbHRhID0gbWF4IC0gbWluO1xuXG5cdFx0XHRzYXR1cmF0aW9uID0gbGlnaHRuZXNzIDw9IDAuNSA/IGRlbHRhIC8gKCBtYXggKyBtaW4gKSA6IGRlbHRhIC8gKCAyIC0gbWF4IC0gbWluICk7XG5cblx0XHRcdHN3aXRjaCAoIG1heCApIHtcblxuXHRcdFx0XHRjYXNlIHI6IGh1ZSA9ICggZyAtIGIgKSAvIGRlbHRhICsgKCBnIDwgYiA/IDYgOiAwICk7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgYjogaHVlID0gKCByIC0gZyApIC8gZGVsdGEgKyA0OyBicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRodWUgLz0gNjtcblxuXHRcdH1cblxuXHRcdHRhcmdldC5oID0gaHVlO1xuXHRcdHRhcmdldC5zID0gc2F0dXJhdGlvbjtcblx0XHR0YXJnZXQubCA9IGxpZ2h0bmVzcztcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGdldFJHQiggdGFyZ2V0LCBjb2xvclNwYWNlID0gQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlICkge1xuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xuXG5cdFx0dGFyZ2V0LnIgPSBfY29sb3Iucjtcblx0XHR0YXJnZXQuZyA9IF9jb2xvci5nO1xuXHRcdHRhcmdldC5iID0gX2NvbG9yLmI7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRnZXRTdHlsZSggY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlICkge1xuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xuXG5cdFx0Y29uc3QgciA9IF9jb2xvci5yLCBnID0gX2NvbG9yLmcsIGIgPSBfY29sb3IuYjtcblxuXHRcdGlmICggY29sb3JTcGFjZSAhPT0gU1JHQkNvbG9yU3BhY2UgKSB7XG5cblx0XHRcdC8vIFJlcXVpcmVzIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgNCAoaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci00LykuXG5cdFx0XHRyZXR1cm4gYGNvbG9yKCR7IGNvbG9yU3BhY2UgfSAkeyByLnRvRml4ZWQoIDMgKSB9ICR7IGcudG9GaXhlZCggMyApIH0gJHsgYi50b0ZpeGVkKCAzICkgfSlgO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGByZ2IoJHsgTWF0aC5yb3VuZCggciAqIDI1NSApIH0sJHsgTWF0aC5yb3VuZCggZyAqIDI1NSApIH0sJHsgTWF0aC5yb3VuZCggYiAqIDI1NSApIH0pYDtcblxuXHR9XG5cblx0b2Zmc2V0SFNMKCBoLCBzLCBsICkge1xuXG5cdFx0dGhpcy5nZXRIU0woIF9oc2xBICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRIU0woIF9oc2xBLmggKyBoLCBfaHNsQS5zICsgcywgX2hzbEEubCArIGwgKTtcblxuXHR9XG5cblx0YWRkKCBjb2xvciApIHtcblxuXHRcdHRoaXMuciArPSBjb2xvci5yO1xuXHRcdHRoaXMuZyArPSBjb2xvci5nO1xuXHRcdHRoaXMuYiArPSBjb2xvci5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZENvbG9ycyggY29sb3IxLCBjb2xvcjIgKSB7XG5cblx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xuXHRcdHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XG5cdFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnIgKz0gcztcblx0XHR0aGlzLmcgKz0gcztcblx0XHR0aGlzLmIgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWIoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yID0gTWF0aC5tYXgoIDAsIHRoaXMuciAtIGNvbG9yLnIgKTtcblx0XHR0aGlzLmcgPSBNYXRoLm1heCggMCwgdGhpcy5nIC0gY29sb3IuZyApO1xuXHRcdHRoaXMuYiA9IE1hdGgubWF4KCAwLCB0aGlzLmIgLSBjb2xvci5iICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XG5cdFx0dGhpcy5nICo9IGNvbG9yLmc7XG5cdFx0dGhpcy5iICo9IGNvbG9yLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHlTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnIgKj0gcztcblx0XHR0aGlzLmcgKj0gcztcblx0XHR0aGlzLmIgKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcblx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcblx0XHR0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwQ29sb3JzKCBjb2xvcjEsIGNvbG9yMiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnIgPSBjb2xvcjEuciArICggY29sb3IyLnIgLSBjb2xvcjEuciApICogYWxwaGE7XG5cdFx0dGhpcy5nID0gY29sb3IxLmcgKyAoIGNvbG9yMi5nIC0gY29sb3IxLmcgKSAqIGFscGhhO1xuXHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgKCBjb2xvcjIuYiAtIGNvbG9yMS5iICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwSFNMKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLmdldEhTTCggX2hzbEEgKTtcblx0XHRjb2xvci5nZXRIU0woIF9oc2xCICk7XG5cblx0XHRjb25zdCBoID0gbGVycCggX2hzbEEuaCwgX2hzbEIuaCwgYWxwaGEgKTtcblx0XHRjb25zdCBzID0gbGVycCggX2hzbEEucywgX2hzbEIucywgYWxwaGEgKTtcblx0XHRjb25zdCBsID0gbGVycCggX2hzbEEubCwgX2hzbEIubCwgYWxwaGEgKTtcblxuXHRcdHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVZlY3RvcjMoIHYgKSB7XG5cblx0XHR0aGlzLnIgPSB2Lng7XG5cdFx0dGhpcy5nID0gdi55O1xuXHRcdHRoaXMuYiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy5yID0gZVsgMCBdICogciArIGVbIDMgXSAqIGcgKyBlWyA2IF0gKiBiO1xuXHRcdHRoaXMuZyA9IGVbIDEgXSAqIHIgKyBlWyA0IF0gKiBnICsgZVsgNyBdICogYjtcblx0XHR0aGlzLmIgPSBlWyAyIF0gKiByICsgZVsgNSBdICogZyArIGVbIDggXSAqIGI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCBjICkge1xuXG5cdFx0cmV0dXJuICggYy5yID09PSB0aGlzLnIgKSAmJiAoIGMuZyA9PT0gdGhpcy5nICkgJiYgKCBjLmIgPT09IHRoaXMuYiApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy5yID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy5iID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuYjtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMuciA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMuZyA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMuYiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdHJldHVybiB0aGlzLmdldEhleCgpO1xuXG5cdH1cblxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcblxuXHRcdHlpZWxkIHRoaXMucjtcblx0XHR5aWVsZCB0aGlzLmc7XG5cdFx0eWllbGQgdGhpcy5iO1xuXG5cdH1cblxufVxuXG5jb25zdCBfY29sb3IgPSAvKkBfX1BVUkVfXyovIG5ldyBDb2xvcigpO1xuXG5Db2xvci5OQU1FUyA9IF9jb2xvcktleXdvcmRzO1xuXG5sZXQgX21hdGVyaWFsSWQgPSAwO1xuXG5jbGFzcyBNYXRlcmlhbCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX21hdGVyaWFsSWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5ibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xuXHRcdHRoaXMuc2lkZSA9IEZyb250U2lkZTtcblx0XHR0aGlzLnZlcnRleENvbG9ycyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5vcGFjaXR5ID0gMTtcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cdFx0dGhpcy5hbHBoYUhhc2ggPSBmYWxzZTtcblxuXHRcdHRoaXMuYmxlbmRTcmMgPSBTcmNBbHBoYUZhY3Rvcjtcblx0XHR0aGlzLmJsZW5kRHN0ID0gT25lTWludXNTcmNBbHBoYUZhY3Rvcjtcblx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBBZGRFcXVhdGlvbjtcblx0XHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHRcdHRoaXMuYmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRcdHRoaXMuYmxlbmRDb2xvciA9IG5ldyBDb2xvciggMCwgMCwgMCApO1xuXHRcdHRoaXMuYmxlbmRBbHBoYSA9IDA7XG5cblx0XHR0aGlzLmRlcHRoRnVuYyA9IExlc3NFcXVhbERlcHRoO1xuXHRcdHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcblx0XHR0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5zdGVuY2lsV3JpdGVNYXNrID0gMHhmZjtcblx0XHR0aGlzLnN0ZW5jaWxGdW5jID0gQWx3YXlzU3RlbmNpbEZ1bmM7XG5cdFx0dGhpcy5zdGVuY2lsUmVmID0gMDtcblx0XHR0aGlzLnN0ZW5jaWxGdW5jTWFzayA9IDB4ZmY7XG5cdFx0dGhpcy5zdGVuY2lsRmFpbCA9IEtlZXBTdGVuY2lsT3A7XG5cdFx0dGhpcy5zdGVuY2lsWkZhaWwgPSBLZWVwU3RlbmNpbE9wO1xuXHRcdHRoaXMuc3RlbmNpbFpQYXNzID0gS2VlcFN0ZW5jaWxPcDtcblx0XHR0aGlzLnN0ZW5jaWxXcml0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IG51bGw7XG5cdFx0dGhpcy5jbGlwSW50ZXJzZWN0aW9uID0gZmFsc2U7XG5cdFx0dGhpcy5jbGlwU2hhZG93cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zaGFkb3dTaWRlID0gbnVsbDtcblxuXHRcdHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XG5cblx0XHR0aGlzLnByZWNpc2lvbiA9IG51bGw7IC8vIG92ZXJyaWRlIHRoZSByZW5kZXJlcidzIGRlZmF1bHQgcHJlY2lzaW9uIGZvciB0aGlzIG1hdGVyaWFsXG5cblx0XHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xuXHRcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcblxuXHRcdHRoaXMuZGl0aGVyaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLmFscGhhVG9Db3ZlcmFnZSA9IGZhbHNlO1xuXHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XG5cdFx0dGhpcy5mb3JjZVNpbmdsZVBhc3MgPSBmYWxzZTtcblxuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0XHR0aGlzLnRvbmVNYXBwZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblxuXHRcdHRoaXMuX2FscGhhVGVzdCA9IDA7XG5cblx0fVxuXG5cdGdldCBhbHBoYVRlc3QoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fYWxwaGFUZXN0O1xuXG5cdH1cblxuXHRzZXQgYWxwaGFUZXN0KCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5fYWxwaGFUZXN0ID4gMCAhPT0gdmFsdWUgPiAwICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9hbHBoYVRlc3QgPSB2YWx1ZTtcblxuXHR9XG5cblx0b25CdWlsZCggLyogc2hhZGVyb2JqZWN0LCByZW5kZXJlciAqLyApIHt9XG5cblx0b25CZWZvcmVSZW5kZXIoIC8qIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgb2JqZWN0LCBncm91cCAqLyApIHt9XG5cblx0b25CZWZvcmVDb21waWxlKCAvKiBzaGFkZXJvYmplY3QsIHJlbmRlcmVyICovICkge31cblxuXHRjdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5vbkJlZm9yZUNvbXBpbGUudG9TdHJpbmcoKTtcblxuXHR9XG5cblx0c2V0VmFsdWVzKCB2YWx1ZXMgKSB7XG5cblx0XHRpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIHZhbHVlcyApIHtcblxuXHRcdFx0Y29uc3QgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xuXG5cdFx0XHRpZiAoIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCBgVEhSRUUuTWF0ZXJpYWw6IHBhcmFtZXRlciAnJHsga2V5IH0nIGhhcyB2YWx1ZSBvZiB1bmRlZmluZWQuYCApO1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzWyBrZXkgXTtcblxuXHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIGBUSFJFRS5NYXRlcmlhbDogJyR7IGtleSB9JyBpcyBub3QgYSBwcm9wZXJ0eSBvZiBUSFJFRS4keyB0aGlzLnR5cGUgfS5gICk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc0NvbG9yICkge1xuXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoICggY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc1ZlY3RvcjMgKSAmJiAoIG5ld1ZhbHVlICYmIG5ld1ZhbHVlLmlzVmVjdG9yMyApICkge1xuXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5jb3B5KCBuZXdWYWx1ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XG5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0bWV0YSA9IHtcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRpbWFnZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ01hdGVyaWFsJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWwudG9KU09OJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBzdGFuZGFyZCBNYXRlcmlhbCBzZXJpYWxpemF0aW9uXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdGlmICggdGhpcy5jb2xvciAmJiB0aGlzLmNvbG9yLmlzQ29sb3IgKSBkYXRhLmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblxuXHRcdGlmICggdGhpcy5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEucm91Z2huZXNzID0gdGhpcy5yb3VnaG5lc3M7XG5cdFx0aWYgKCB0aGlzLm1ldGFsbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5tZXRhbG5lc3MgPSB0aGlzLm1ldGFsbmVzcztcblxuXHRcdGlmICggdGhpcy5zaGVlbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGVlbiA9IHRoaXMuc2hlZW47XG5cdFx0aWYgKCB0aGlzLnNoZWVuQ29sb3IgJiYgdGhpcy5zaGVlbkNvbG9yLmlzQ29sb3IgKSBkYXRhLnNoZWVuQ29sb3IgPSB0aGlzLnNoZWVuQ29sb3IuZ2V0SGV4KCk7XG5cdFx0aWYgKCB0aGlzLnNoZWVuUm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoZWVuUm91Z2huZXNzID0gdGhpcy5zaGVlblJvdWdobmVzcztcblx0XHRpZiAoIHRoaXMuZW1pc3NpdmUgJiYgdGhpcy5lbWlzc2l2ZS5pc0NvbG9yICkgZGF0YS5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCk7XG5cdFx0aWYgKCB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5lbWlzc2l2ZUludGVuc2l0eSAhPT0gMSApIGRhdGEuZW1pc3NpdmVJbnRlbnNpdHkgPSB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFyICYmIHRoaXMuc3BlY3VsYXIuaXNDb2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xuXHRcdGlmICggdGhpcy5zcGVjdWxhckludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zcGVjdWxhckludGVuc2l0eSA9IHRoaXMuc3BlY3VsYXJJbnRlbnNpdHk7XG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFyQ29sb3IgJiYgdGhpcy5zcGVjdWxhckNvbG9yLmlzQ29sb3IgKSBkYXRhLnNwZWN1bGFyQ29sb3IgPSB0aGlzLnNwZWN1bGFyQ29sb3IuZ2V0SGV4KCk7XG5cdFx0aWYgKCB0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcblx0XHRpZiAoIHRoaXMuY2xlYXJjb2F0ICE9PSB1bmRlZmluZWQgKSBkYXRhLmNsZWFyY29hdCA9IHRoaXMuY2xlYXJjb2F0O1xuXHRcdGlmICggdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuY2xlYXJjb2F0Um91Z2huZXNzID0gdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3M7XG5cblx0XHRpZiAoIHRoaXMuY2xlYXJjb2F0TWFwICYmIHRoaXMuY2xlYXJjb2F0TWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5jbGVhcmNvYXRNYXAgPSB0aGlzLmNsZWFyY29hdE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcCAmJiB0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAgJiYgdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmNsZWFyY29hdE5vcm1hbE1hcCA9IHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRkYXRhLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gdGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZS50b0FycmF5KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZGlzcGVyc2lvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5kaXNwZXJzaW9uID0gdGhpcy5kaXNwZXJzaW9uO1xuXG5cdFx0aWYgKCB0aGlzLmlyaWRlc2NlbmNlICE9PSB1bmRlZmluZWQgKSBkYXRhLmlyaWRlc2NlbmNlID0gdGhpcy5pcmlkZXNjZW5jZTtcblx0XHRpZiAoIHRoaXMuaXJpZGVzY2VuY2VJT1IgIT09IHVuZGVmaW5lZCApIGRhdGEuaXJpZGVzY2VuY2VJT1IgPSB0aGlzLmlyaWRlc2NlbmNlSU9SO1xuXHRcdGlmICggdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlICE9PSB1bmRlZmluZWQgKSBkYXRhLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2U7XG5cblx0XHRpZiAoIHRoaXMuaXJpZGVzY2VuY2VNYXAgJiYgdGhpcy5pcmlkZXNjZW5jZU1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuaXJpZGVzY2VuY2VNYXAgPSB0aGlzLmlyaWRlc2NlbmNlTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgJiYgdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPSB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgZGF0YS5hbmlzb3Ryb3B5ID0gdGhpcy5hbmlzb3Ryb3B5O1xuXHRcdGlmICggdGhpcy5hbmlzb3Ryb3B5Um90YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuYW5pc290cm9weVJvdGF0aW9uID0gdGhpcy5hbmlzb3Ryb3B5Um90YXRpb247XG5cblx0XHRpZiAoIHRoaXMuYW5pc290cm9weU1hcCAmJiB0aGlzLmFuaXNvdHJvcHlNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmFuaXNvdHJvcHlNYXAgPSB0aGlzLmFuaXNvdHJvcHlNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tYXAgJiYgdGhpcy5tYXAuaXNUZXh0dXJlICkgZGF0YS5tYXAgPSB0aGlzLm1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5tYXRjYXAgJiYgdGhpcy5tYXRjYXAuaXNUZXh0dXJlICkgZGF0YS5tYXRjYXAgPSB0aGlzLm1hdGNhcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5hbHBoYU1hcCAmJiB0aGlzLmFscGhhTWFwLmlzVGV4dHVyZSApIGRhdGEuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRpZiAoIHRoaXMubGlnaHRNYXAgJiYgdGhpcy5saWdodE1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRkYXRhLmxpZ2h0TWFwSW50ZW5zaXR5ID0gdGhpcy5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hb01hcCAmJiB0aGlzLmFvTWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5hb01hcCA9IHRoaXMuYW9NYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEuYW9NYXBJbnRlbnNpdHkgPSB0aGlzLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmJ1bXBNYXAgJiYgdGhpcy5idW1wTWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5idW1wTWFwID0gdGhpcy5idW1wTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRkYXRhLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbE1hcCAmJiB0aGlzLm5vcm1hbE1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEubm9ybWFsTWFwVHlwZSA9IHRoaXMubm9ybWFsTWFwVHlwZTtcblx0XHRcdGRhdGEubm9ybWFsU2NhbGUgPSB0aGlzLm5vcm1hbFNjYWxlLnRvQXJyYXkoKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5kaXNwbGFjZW1lbnRNYXAgJiYgdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZGlzcGxhY2VtZW50TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudFNjYWxlID0gdGhpcy5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5yb3VnaG5lc3NNYXAgJiYgdGhpcy5yb3VnaG5lc3NNYXAuaXNUZXh0dXJlICkgZGF0YS5yb3VnaG5lc3NNYXAgPSB0aGlzLnJvdWdobmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5tZXRhbG5lc3NNYXAgJiYgdGhpcy5tZXRhbG5lc3NNYXAuaXNUZXh0dXJlICkgZGF0YS5tZXRhbG5lc3NNYXAgPSB0aGlzLm1ldGFsbmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0aWYgKCB0aGlzLmVtaXNzaXZlTWFwICYmIHRoaXMuZW1pc3NpdmVNYXAuaXNUZXh0dXJlICkgZGF0YS5lbWlzc2l2ZU1hcCA9IHRoaXMuZW1pc3NpdmVNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXJNYXAgJiYgdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUgKSBkYXRhLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCAmJiB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLmlzVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFyQ29sb3JNYXAgJiYgdGhpcy5zcGVjdWxhckNvbG9yTWFwLmlzVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJDb2xvck1hcCA9IHRoaXMuc3BlY3VsYXJDb2xvck1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0aWYgKCB0aGlzLmVudk1hcCAmJiB0aGlzLmVudk1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdFx0aWYgKCB0aGlzLmNvbWJpbmUgIT09IHVuZGVmaW5lZCApIGRhdGEuY29tYmluZSA9IHRoaXMuY29tYmluZTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5lbnZNYXBSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5lbnZNYXBSb3RhdGlvbiA9IHRoaXMuZW52TWFwUm90YXRpb24udG9BcnJheSgpO1xuXHRcdGlmICggdGhpcy5lbnZNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIGRhdGEuZW52TWFwSW50ZW5zaXR5ID0gdGhpcy5lbnZNYXBJbnRlbnNpdHk7XG5cdFx0aWYgKCB0aGlzLnJlZmxlY3Rpdml0eSAhPT0gdW5kZWZpbmVkICkgZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcblx0XHRpZiAoIHRoaXMucmVmcmFjdGlvblJhdGlvICE9PSB1bmRlZmluZWQgKSBkYXRhLnJlZnJhY3Rpb25SYXRpbyA9IHRoaXMucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0aWYgKCB0aGlzLmdyYWRpZW50TWFwICYmIHRoaXMuZ3JhZGllbnRNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmdyYWRpZW50TWFwID0gdGhpcy5ncmFkaWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnRyYW5zbWlzc2lvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS50cmFuc21pc3Npb24gPSB0aGlzLnRyYW5zbWlzc2lvbjtcblx0XHRpZiAoIHRoaXMudHJhbnNtaXNzaW9uTWFwICYmIHRoaXMudHJhbnNtaXNzaW9uTWFwLmlzVGV4dHVyZSApIGRhdGEudHJhbnNtaXNzaW9uTWFwID0gdGhpcy50cmFuc21pc3Npb25NYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRpZiAoIHRoaXMudGhpY2tuZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnRoaWNrbmVzcyA9IHRoaXMudGhpY2tuZXNzO1xuXHRcdGlmICggdGhpcy50aGlja25lc3NNYXAgJiYgdGhpcy50aGlja25lc3NNYXAuaXNUZXh0dXJlICkgZGF0YS50aGlja25lc3NNYXAgPSB0aGlzLnRoaWNrbmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlICE9PSBJbmZpbml0eSApIGRhdGEuYXR0ZW51YXRpb25EaXN0YW5jZSA9IHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZTtcblx0XHRpZiAoIHRoaXMuYXR0ZW51YXRpb25Db2xvciAhPT0gdW5kZWZpbmVkICkgZGF0YS5hdHRlbnVhdGlvbkNvbG9yID0gdGhpcy5hdHRlbnVhdGlvbkNvbG9yLmdldEhleCgpO1xuXG5cdFx0aWYgKCB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZSA9IHRoaXMuc2l6ZTtcblx0XHRpZiAoIHRoaXMuc2hhZG93U2lkZSAhPT0gbnVsbCApIGRhdGEuc2hhZG93U2lkZSA9IHRoaXMuc2hhZG93U2lkZTtcblx0XHRpZiAoIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0aWYgKCB0aGlzLmJsZW5kaW5nICE9PSBOb3JtYWxCbGVuZGluZyApIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuXHRcdGlmICggdGhpcy5zaWRlICE9PSBGcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG5cdFx0aWYgKCB0aGlzLnZlcnRleENvbG9ycyA9PT0gdHJ1ZSApIGRhdGEudmVydGV4Q29sb3JzID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy5vcGFjaXR5IDwgMSApIGRhdGEub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblx0XHRpZiAoIHRoaXMudHJhbnNwYXJlbnQgPT09IHRydWUgKSBkYXRhLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy5ibGVuZFNyYyAhPT0gU3JjQWxwaGFGYWN0b3IgKSBkYXRhLmJsZW5kU3JjID0gdGhpcy5ibGVuZFNyYztcblx0XHRpZiAoIHRoaXMuYmxlbmREc3QgIT09IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgKSBkYXRhLmJsZW5kRHN0ID0gdGhpcy5ibGVuZERzdDtcblx0XHRpZiAoIHRoaXMuYmxlbmRFcXVhdGlvbiAhPT0gQWRkRXF1YXRpb24gKSBkYXRhLmJsZW5kRXF1YXRpb24gPSB0aGlzLmJsZW5kRXF1YXRpb247XG5cdFx0aWYgKCB0aGlzLmJsZW5kU3JjQWxwaGEgIT09IG51bGwgKSBkYXRhLmJsZW5kU3JjQWxwaGEgPSB0aGlzLmJsZW5kU3JjQWxwaGE7XG5cdFx0aWYgKCB0aGlzLmJsZW5kRHN0QWxwaGEgIT09IG51bGwgKSBkYXRhLmJsZW5kRHN0QWxwaGEgPSB0aGlzLmJsZW5kRHN0QWxwaGE7XG5cdFx0aWYgKCB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSAhPT0gbnVsbCApIGRhdGEuYmxlbmRFcXVhdGlvbkFscGhhID0gdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cdFx0aWYgKCB0aGlzLmJsZW5kQ29sb3IgJiYgdGhpcy5ibGVuZENvbG9yLmlzQ29sb3IgKSBkYXRhLmJsZW5kQ29sb3IgPSB0aGlzLmJsZW5kQ29sb3IuZ2V0SGV4KCk7XG5cdFx0aWYgKCB0aGlzLmJsZW5kQWxwaGEgIT09IDAgKSBkYXRhLmJsZW5kQWxwaGEgPSB0aGlzLmJsZW5kQWxwaGE7XG5cblx0XHRpZiAoIHRoaXMuZGVwdGhGdW5jICE9PSBMZXNzRXF1YWxEZXB0aCApIGRhdGEuZGVwdGhGdW5jID0gdGhpcy5kZXB0aEZ1bmM7XG5cdFx0aWYgKCB0aGlzLmRlcHRoVGVzdCA9PT0gZmFsc2UgKSBkYXRhLmRlcHRoVGVzdCA9IHRoaXMuZGVwdGhUZXN0O1xuXHRcdGlmICggdGhpcy5kZXB0aFdyaXRlID09PSBmYWxzZSApIGRhdGEuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcblx0XHRpZiAoIHRoaXMuY29sb3JXcml0ZSA9PT0gZmFsc2UgKSBkYXRhLmNvbG9yV3JpdGUgPSB0aGlzLmNvbG9yV3JpdGU7XG5cblx0XHRpZiAoIHRoaXMuc3RlbmNpbFdyaXRlTWFzayAhPT0gMHhmZiApIGRhdGEuc3RlbmNpbFdyaXRlTWFzayA9IHRoaXMuc3RlbmNpbFdyaXRlTWFzaztcblx0XHRpZiAoIHRoaXMuc3RlbmNpbEZ1bmMgIT09IEFsd2F5c1N0ZW5jaWxGdW5jICkgZGF0YS5zdGVuY2lsRnVuYyA9IHRoaXMuc3RlbmNpbEZ1bmM7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxSZWYgIT09IDAgKSBkYXRhLnN0ZW5jaWxSZWYgPSB0aGlzLnN0ZW5jaWxSZWY7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxGdW5jTWFzayAhPT0gMHhmZiApIGRhdGEuc3RlbmNpbEZ1bmNNYXNrID0gdGhpcy5zdGVuY2lsRnVuY01hc2s7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxGYWlsICE9PSBLZWVwU3RlbmNpbE9wICkgZGF0YS5zdGVuY2lsRmFpbCA9IHRoaXMuc3RlbmNpbEZhaWw7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxaRmFpbCAhPT0gS2VlcFN0ZW5jaWxPcCApIGRhdGEuc3RlbmNpbFpGYWlsID0gdGhpcy5zdGVuY2lsWkZhaWw7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxaUGFzcyAhPT0gS2VlcFN0ZW5jaWxPcCApIGRhdGEuc3RlbmNpbFpQYXNzID0gdGhpcy5zdGVuY2lsWlBhc3M7XG5cdFx0aWYgKCB0aGlzLnN0ZW5jaWxXcml0ZSA9PT0gdHJ1ZSApIGRhdGEuc3RlbmNpbFdyaXRlID0gdGhpcy5zdGVuY2lsV3JpdGU7XG5cblx0XHQvLyByb3RhdGlvbiAoU3ByaXRlTWF0ZXJpYWwpXG5cdFx0aWYgKCB0aGlzLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yb3RhdGlvbiAhPT0gMCApIGRhdGEucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXG5cdFx0aWYgKCB0aGlzLnBvbHlnb25PZmZzZXQgPT09IHRydWUgKSBkYXRhLnBvbHlnb25PZmZzZXQgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSAwICkgZGF0YS5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xuXHRcdGlmICggdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgIT09IDAgKSBkYXRhLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMucG9seWdvbk9mZnNldFVuaXRzO1xuXG5cdFx0aWYgKCB0aGlzLmxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGluZXdpZHRoICE9PSAxICkgZGF0YS5saW5ld2lkdGggPSB0aGlzLmxpbmV3aWR0aDtcblx0XHRpZiAoIHRoaXMuZGFzaFNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuZGFzaFNpemUgPSB0aGlzLmRhc2hTaXplO1xuXHRcdGlmICggdGhpcy5nYXBTaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLmdhcFNpemUgPSB0aGlzLmdhcFNpemU7XG5cdFx0aWYgKCB0aGlzLnNjYWxlICE9PSB1bmRlZmluZWQgKSBkYXRhLnNjYWxlID0gdGhpcy5zY2FsZTtcblxuXHRcdGlmICggdGhpcy5kaXRoZXJpbmcgPT09IHRydWUgKSBkYXRhLmRpdGhlcmluZyA9IHRydWU7XG5cblx0XHRpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XG5cdFx0aWYgKCB0aGlzLmFscGhhSGFzaCA9PT0gdHJ1ZSApIGRhdGEuYWxwaGFIYXNoID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMuYWxwaGFUb0NvdmVyYWdlID09PSB0cnVlICkgZGF0YS5hbHBoYVRvQ292ZXJhZ2UgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSBkYXRhLnByZW11bHRpcGxpZWRBbHBoYSA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLmZvcmNlU2luZ2xlUGFzcyA9PT0gdHJ1ZSApIGRhdGEuZm9yY2VTaW5nbGVQYXNzID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy53aXJlZnJhbWUgPT09IHRydWUgKSBkYXRhLndpcmVmcmFtZSA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA+IDEgKSBkYXRhLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5lY2FwICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5lam9pbiAhPT0gJ3JvdW5kJyApIGRhdGEud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0aWYgKCB0aGlzLmZsYXRTaGFkaW5nID09PSB0cnVlICkgZGF0YS5mbGF0U2hhZGluZyA9IHRydWU7XG5cblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBkYXRhLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdGlmICggdGhpcy50b25lTWFwcGVkID09PSBmYWxzZSApIGRhdGEudG9uZU1hcHBlZCA9IGZhbHNlO1xuXG5cdFx0aWYgKCB0aGlzLmZvZyA9PT0gZmFsc2UgKSBkYXRhLmZvZyA9IGZhbHNlO1xuXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdC8vIFRPRE86IENvcGllZCBmcm9tIE9iamVjdDNELnRvSlNPTlxuXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XG5cblx0XHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGNhY2hlWyBrZXkgXTtcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuXHRcdH1cblxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcblx0XHRcdGNvbnN0IGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XG5cblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIGRhdGEudGV4dHVyZXMgPSB0ZXh0dXJlcztcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBkYXRhLmltYWdlcyA9IGltYWdlcztcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cblx0XHR0aGlzLmJsZW5kaW5nID0gc291cmNlLmJsZW5kaW5nO1xuXHRcdHRoaXMuc2lkZSA9IHNvdXJjZS5zaWRlO1xuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuXHRcdHRoaXMub3BhY2l0eSA9IHNvdXJjZS5vcGFjaXR5O1xuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSBzb3VyY2UudHJhbnNwYXJlbnQ7XG5cblx0XHR0aGlzLmJsZW5kU3JjID0gc291cmNlLmJsZW5kU3JjO1xuXHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uID0gc291cmNlLmJsZW5kRXF1YXRpb247XG5cdFx0dGhpcy5ibGVuZFNyY0FscGhhID0gc291cmNlLmJsZW5kU3JjQWxwaGE7XG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBzb3VyY2UuYmxlbmRFcXVhdGlvbkFscGhhO1xuXHRcdHRoaXMuYmxlbmRDb2xvci5jb3B5KCBzb3VyY2UuYmxlbmRDb2xvciApO1xuXHRcdHRoaXMuYmxlbmRBbHBoYSA9IHNvdXJjZS5ibGVuZEFscGhhO1xuXG5cdFx0dGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xuXHRcdHRoaXMuZGVwdGhUZXN0ID0gc291cmNlLmRlcHRoVGVzdDtcblx0XHR0aGlzLmRlcHRoV3JpdGUgPSBzb3VyY2UuZGVwdGhXcml0ZTtcblxuXHRcdHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IHNvdXJjZS5zdGVuY2lsV3JpdGVNYXNrO1xuXHRcdHRoaXMuc3RlbmNpbEZ1bmMgPSBzb3VyY2Uuc3RlbmNpbEZ1bmM7XG5cdFx0dGhpcy5zdGVuY2lsUmVmID0gc291cmNlLnN0ZW5jaWxSZWY7XG5cdFx0dGhpcy5zdGVuY2lsRnVuY01hc2sgPSBzb3VyY2Uuc3RlbmNpbEZ1bmNNYXNrO1xuXHRcdHRoaXMuc3RlbmNpbEZhaWwgPSBzb3VyY2Uuc3RlbmNpbEZhaWw7XG5cdFx0dGhpcy5zdGVuY2lsWkZhaWwgPSBzb3VyY2Uuc3RlbmNpbFpGYWlsO1xuXHRcdHRoaXMuc3RlbmNpbFpQYXNzID0gc291cmNlLnN0ZW5jaWxaUGFzcztcblx0XHR0aGlzLnN0ZW5jaWxXcml0ZSA9IHNvdXJjZS5zdGVuY2lsV3JpdGU7XG5cblx0XHRjb25zdCBzcmNQbGFuZXMgPSBzb3VyY2UuY2xpcHBpbmdQbGFuZXM7XG5cdFx0bGV0IGRzdFBsYW5lcyA9IG51bGw7XG5cblx0XHRpZiAoIHNyY1BsYW5lcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgbiA9IHNyY1BsYW5lcy5sZW5ndGg7XG5cdFx0XHRkc3RQbGFuZXMgPSBuZXcgQXJyYXkoIG4gKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdGRzdFBsYW5lc1sgaSBdID0gc3JjUGxhbmVzWyBpIF0uY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IGRzdFBsYW5lcztcblx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBzb3VyY2UuY2xpcEludGVyc2VjdGlvbjtcblx0XHR0aGlzLmNsaXBTaGFkb3dzID0gc291cmNlLmNsaXBTaGFkb3dzO1xuXG5cdFx0dGhpcy5zaGFkb3dTaWRlID0gc291cmNlLnNoYWRvd1NpZGU7XG5cblx0XHR0aGlzLmNvbG9yV3JpdGUgPSBzb3VyY2UuY29sb3JXcml0ZTtcblxuXHRcdHRoaXMucHJlY2lzaW9uID0gc291cmNlLnByZWNpc2lvbjtcblxuXHRcdHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xuXHRcdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xuXHRcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gc291cmNlLnBvbHlnb25PZmZzZXRVbml0cztcblxuXHRcdHRoaXMuZGl0aGVyaW5nID0gc291cmNlLmRpdGhlcmluZztcblxuXHRcdHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcblx0XHR0aGlzLmFscGhhSGFzaCA9IHNvdXJjZS5hbHBoYUhhc2g7XG5cdFx0dGhpcy5hbHBoYVRvQ292ZXJhZ2UgPSBzb3VyY2UuYWxwaGFUb0NvdmVyYWdlO1xuXHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gc291cmNlLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHR0aGlzLmZvcmNlU2luZ2xlUGFzcyA9IHNvdXJjZS5mb3JjZVNpbmdsZVBhc3M7XG5cblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblxuXHRcdHRoaXMudG9uZU1hcHBlZCA9IHNvdXJjZS50b25lTWFwcGVkO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1lc2hCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNNZXNoQmFzaWNNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZW1pc3NpdmVcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHR0aGlzLmFvTWFwID0gbnVsbDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcblx0XHR0aGlzLmVudk1hcFJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG5cdFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuXHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0XHR0aGlzLmVudk1hcFJvdGF0aW9uLmNvcHkoIHNvdXJjZS5lbnZNYXBSb3RhdGlvbiApO1xuXHRcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuLy8gRmFzdCBIYWxmIEZsb2F0IENvbnZlcnNpb25zLCBodHRwOi8vd3d3LmZveC10b29sa2l0Lm9yZy9mdHAvZmFzdGhhbGZmbG9hdGNvbnZlcnNpb24ucGRmXG5cbmNvbnN0IF90YWJsZXMgPSAvKkBfX1BVUkVfXyovIF9nZW5lcmF0ZVRhYmxlcygpO1xuXG5mdW5jdGlvbiBfZ2VuZXJhdGVUYWJsZXMoKSB7XG5cblx0Ly8gZmxvYXQzMiB0byBmbG9hdDE2IGhlbHBlcnNcblxuXHRjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoIDQgKTtcblx0Y29uc3QgZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICk7XG5cdGNvbnN0IHVpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXG5cdGNvbnN0IGJhc2VUYWJsZSA9IG5ldyBVaW50MzJBcnJheSggNTEyICk7XG5cdGNvbnN0IHNoaWZ0VGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDUxMiApO1xuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IDI1NjsgKysgaSApIHtcblxuXHRcdGNvbnN0IGUgPSBpIC0gMTI3O1xuXG5cdFx0Ly8gdmVyeSBzbWFsbCBudW1iZXIgKDAsIC0wKVxuXG5cdFx0aWYgKCBlIDwgLSAyNyApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAweDAwMDA7XG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gMjQ7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IDI0O1xuXG5cdFx0XHQvLyBzbWFsbCBudW1iZXIgKGRlbm9ybSlcblxuXHRcdH0gZWxzZSBpZiAoIGUgPCAtIDE0ICkge1xuXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9IDB4MDQwMCA+PiAoIC0gZSAtIDE0ICk7XG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gKCAweDA0MDAgPj4gKCAtIGUgLSAxNCApICkgfCAweDgwMDA7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAtIGUgLSAxO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAtIGUgLSAxO1xuXG5cdFx0XHQvLyBub3JtYWwgbnVtYmVyXG5cblx0XHR9IGVsc2UgaWYgKCBlIDw9IDE1ICkge1xuXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9ICggZSArIDE1ICkgPDwgMTA7XG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gKCAoIGUgKyAxNSApIDw8IDEwICkgfCAweDgwMDA7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAxMztcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gMTM7XG5cblx0XHRcdC8vIGxhcmdlIG51bWJlciAoSW5maW5pdHksIC1JbmZpbml0eSlcblxuXHRcdH0gZWxzZSBpZiAoIGUgPCAxMjggKSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHg3YzAwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ZmMwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDI0O1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAyNDtcblxuXHRcdFx0Ly8gc3RheSAoTmFOLCBJbmZpbml0eSwgLUluZmluaXR5KVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAweDdjMDA7XG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gMHhmYzAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gMTM7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IDEzO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBmbG9hdDE2IHRvIGZsb2F0MzIgaGVscGVyc1xuXG5cdGNvbnN0IG1hbnRpc3NhVGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDIwNDggKTtcblx0Y29uc3QgZXhwb25lbnRUYWJsZSA9IG5ldyBVaW50MzJBcnJheSggNjQgKTtcblx0Y29uc3Qgb2Zmc2V0VGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDY0ICk7XG5cblx0Zm9yICggbGV0IGkgPSAxOyBpIDwgMTAyNDsgKysgaSApIHtcblxuXHRcdGxldCBtID0gaSA8PCAxMzsgLy8gemVybyBwYWQgbWFudGlzc2EgYml0c1xuXHRcdGxldCBlID0gMDsgLy8gemVybyBleHBvbmVudFxuXG5cdFx0Ly8gbm9ybWFsaXplZFxuXHRcdHdoaWxlICggKCBtICYgMHgwMDgwMDAwMCApID09PSAwICkge1xuXG5cdFx0XHRtIDw8PSAxO1xuXHRcdFx0ZSAtPSAweDAwODAwMDAwOyAvLyBkZWNyZW1lbnQgZXhwb25lbnRcblxuXHRcdH1cblxuXHRcdG0gJj0gfiAweDAwODAwMDAwOyAvLyBjbGVhciBsZWFkaW5nIDEgYml0XG5cdFx0ZSArPSAweDM4ODAwMDAwOyAvLyBhZGp1c3QgYmlhc1xuXG5cdFx0bWFudGlzc2FUYWJsZVsgaSBdID0gbSB8IGU7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMTAyNDsgaSA8IDIwNDg7ICsrIGkgKSB7XG5cblx0XHRtYW50aXNzYVRhYmxlWyBpIF0gPSAweDM4MDAwMDAwICsgKCAoIGkgLSAxMDI0ICkgPDwgMTMgKTtcblxuXHR9XG5cblx0Zm9yICggbGV0IGkgPSAxOyBpIDwgMzE7ICsrIGkgKSB7XG5cblx0XHRleHBvbmVudFRhYmxlWyBpIF0gPSBpIDw8IDIzO1xuXG5cdH1cblxuXHRleHBvbmVudFRhYmxlWyAzMSBdID0gMHg0NzgwMDAwMDtcblx0ZXhwb25lbnRUYWJsZVsgMzIgXSA9IDB4ODAwMDAwMDA7XG5cblx0Zm9yICggbGV0IGkgPSAzMzsgaSA8IDYzOyArKyBpICkge1xuXG5cdFx0ZXhwb25lbnRUYWJsZVsgaSBdID0gMHg4MDAwMDAwMCArICggKCBpIC0gMzIgKSA8PCAyMyApO1xuXG5cdH1cblxuXHRleHBvbmVudFRhYmxlWyA2MyBdID0gMHhjNzgwMDAwMDtcblxuXHRmb3IgKCBsZXQgaSA9IDE7IGkgPCA2NDsgKysgaSApIHtcblxuXHRcdGlmICggaSAhPT0gMzIgKSB7XG5cblx0XHRcdG9mZnNldFRhYmxlWyBpIF0gPSAxMDI0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGZsb2F0VmlldzogZmxvYXRWaWV3LFxuXHRcdHVpbnQzMlZpZXc6IHVpbnQzMlZpZXcsXG5cdFx0YmFzZVRhYmxlOiBiYXNlVGFibGUsXG5cdFx0c2hpZnRUYWJsZTogc2hpZnRUYWJsZSxcblx0XHRtYW50aXNzYVRhYmxlOiBtYW50aXNzYVRhYmxlLFxuXHRcdGV4cG9uZW50VGFibGU6IGV4cG9uZW50VGFibGUsXG5cdFx0b2Zmc2V0VGFibGU6IG9mZnNldFRhYmxlXG5cdH07XG5cbn1cblxuLy8gZmxvYXQzMiB0byBmbG9hdDE2XG5cbmZ1bmN0aW9uIHRvSGFsZkZsb2F0KCB2YWwgKSB7XG5cblx0aWYgKCBNYXRoLmFicyggdmFsICkgPiA2NTUwNCApIGNvbnNvbGUud2FybiggJ1RIUkVFLkRhdGFVdGlscy50b0hhbGZGbG9hdCgpOiBWYWx1ZSBvdXQgb2YgcmFuZ2UuJyApO1xuXG5cdHZhbCA9IGNsYW1wKCB2YWwsIC0gNjU1MDQsIDY1NTA0ICk7XG5cblx0X3RhYmxlcy5mbG9hdFZpZXdbIDAgXSA9IHZhbDtcblx0Y29uc3QgZiA9IF90YWJsZXMudWludDMyVmlld1sgMCBdO1xuXHRjb25zdCBlID0gKCBmID4+IDIzICkgJiAweDFmZjtcblx0cmV0dXJuIF90YWJsZXMuYmFzZVRhYmxlWyBlIF0gKyAoICggZiAmIDB4MDA3ZmZmZmYgKSA+PiBfdGFibGVzLnNoaWZ0VGFibGVbIGUgXSApO1xuXG59XG5cbi8vIGZsb2F0MTYgdG8gZmxvYXQzMlxuXG5mdW5jdGlvbiBmcm9tSGFsZkZsb2F0KCB2YWwgKSB7XG5cblx0Y29uc3QgbSA9IHZhbCA+PiAxMDtcblx0X3RhYmxlcy51aW50MzJWaWV3WyAwIF0gPSBfdGFibGVzLm1hbnRpc3NhVGFibGVbIF90YWJsZXMub2Zmc2V0VGFibGVbIG0gXSArICggdmFsICYgMHgzZmYgKSBdICsgX3RhYmxlcy5leHBvbmVudFRhYmxlWyBtIF07XG5cdHJldHVybiBfdGFibGVzLmZsb2F0Vmlld1sgMCBdO1xuXG59XG5cbmNvbnN0IERhdGFVdGlscyA9IHtcblx0dG9IYWxmRmxvYXQ6IHRvSGFsZkZsb2F0LFxuXHRmcm9tSGFsZkZsb2F0OiBmcm9tSGFsZkZsb2F0LFxufTtcblxuY29uc3QgX3ZlY3RvciQ5ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZlY3RvcjIkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxuY2xhc3MgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkID0gZmFsc2UgKSB7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuaXNCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gaXRlbVNpemUgOiAwO1xuXHRcdHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG5cblx0XHR0aGlzLnVzYWdlID0gU3RhdGljRHJhd1VzYWdlO1xuXHRcdHRoaXMuX3VwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcblx0XHR0aGlzLnVwZGF0ZVJhbmdlcyA9IFtdO1xuXHRcdHRoaXMuZ3B1VHlwZSA9IEZsb2F0VHlwZTtcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0fVxuXG5cdG9uVXBsb2FkQ2FsbGJhY2soKSB7fVxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdH1cblxuXHRnZXQgdXBkYXRlUmFuZ2UoKSB7XG5cblx0XHR3YXJuT25jZSggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogdXBkYXRlUmFuZ2UoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gcjE2OS4gVXNlIGFkZFVwZGF0ZVJhbmdlKCkgaW5zdGVhZC4nICk7IC8vIEBkZXByZWNhdGVkLCByMTU5XG5cdFx0cmV0dXJuIHRoaXMuX3VwZGF0ZVJhbmdlO1xuXG5cdH1cblxuXHRzZXRVc2FnZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnVzYWdlID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkVXBkYXRlUmFuZ2UoIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdHRoaXMudXBkYXRlUmFuZ2VzLnB1c2goIHsgc3RhcnQsIGNvdW50IH0gKTtcblxuXHR9XG5cblx0Y2xlYXJVcGRhdGVSYW5nZXMoKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVJhbmdlcy5sZW5ndGggPSAwO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblx0XHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XG5cdFx0dGhpcy5pdGVtU2l6ZSA9IHNvdXJjZS5pdGVtU2l6ZTtcblx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXHRcdHRoaXMubm9ybWFsaXplZCA9IHNvdXJjZS5ub3JtYWxpemVkO1xuXG5cdFx0dGhpcy51c2FnZSA9IHNvdXJjZS51c2FnZTtcblx0XHR0aGlzLmdwdVR5cGUgPSBzb3VyY2UuZ3B1VHlwZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5QXQoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XG5cblx0XHRpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcblx0XHRpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlBcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDMoIG0gKSB7XG5cblx0XHRpZiAoIHRoaXMuaXRlbVNpemUgPT09IDIgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdF92ZWN0b3IyJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXHRcdFx0XHRfdmVjdG9yMiQxLmFwcGx5TWF0cml4MyggbSApO1xuXG5cdFx0XHRcdHRoaXMuc2V0WFkoIGksIF92ZWN0b3IyJDEueCwgX3ZlY3RvcjIkMS55ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXRlbVNpemUgPT09IDMgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdF92ZWN0b3IkOS5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cdFx0XHRcdF92ZWN0b3IkOS5hcHBseU1hdHJpeDMoIG0gKTtcblxuXHRcdFx0XHR0aGlzLnNldFhZWiggaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdF92ZWN0b3IkOS5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IkOS5hcHBseU1hdHJpeDQoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IkOS54LCBfdmVjdG9yJDkueSwgX3ZlY3RvciQ5LnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU5vcm1hbE1hdHJpeCggbSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yJDkuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXG5cdFx0XHRfdmVjdG9yJDkuYXBwbHlOb3JtYWxNYXRyaXgoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IkOS54LCBfdmVjdG9yJDkueSwgX3ZlY3RvciQ5LnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3RvciQ5LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcblxuXHRcdFx0X3ZlY3RvciQ5LnRyYW5zZm9ybURpcmVjdGlvbiggbSApO1xuXG5cdFx0XHR0aGlzLnNldFhZWiggaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldCggdmFsdWUsIG9mZnNldCA9IDAgKSB7XG5cblx0XHQvLyBNYXRjaGluZyBCdWZmZXJBdHRyaWJ1dGUgY29uc3RydWN0b3IsIGRvIG5vdCBub3JtYWxpemUgdGhlIGFycmF5LlxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50KCBpbmRleCwgY29tcG9uZW50ICkge1xuXG5cdFx0bGV0IHZhbHVlID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgY29tcG9uZW50IF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHZhbHVlID0gZGVub3JtYWxpemUoIHZhbHVlLCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG5cdHNldENvbXBvbmVudCggaW5kZXgsIGNvbXBvbmVudCwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHZhbHVlID0gbm9ybWFsaXplKCB2YWx1ZSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgY29tcG9uZW50IF0gPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRYKCBpbmRleCApIHtcblxuXHRcdGxldCB4ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBkZW5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHg7XG5cblx0fVxuXG5cdHNldFgoIGluZGV4LCB4ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WSggaW5kZXggKSB7XG5cblx0XHRsZXQgeSA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IGRlbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geTtcblxuXHR9XG5cblx0c2V0WSggaW5kZXgsIHkgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WiggaW5kZXggKSB7XG5cblx0XHRsZXQgeiA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeiA9IGRlbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gejtcblxuXHR9XG5cblx0c2V0WiggaW5kZXgsIHogKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0VyggaW5kZXggKSB7XG5cblx0XHRsZXQgdyA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdztcblxuXHR9XG5cblx0c2V0VyggaW5kZXgsIHcgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFkoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWiggaW5kZXgsIHgsIHksIHogKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWlcoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0b25VcGxvYWQoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuYXJyYXksIHRoaXMuaXRlbVNpemUgKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRpdGVtU2l6ZTogdGhpcy5pdGVtU2l6ZSxcblx0XHRcdHR5cGU6IHRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdGFycmF5OiBBcnJheS5mcm9tKCB0aGlzLmFycmF5ICksXG5cdFx0XHRub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcblx0XHR9O1xuXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdGlmICggdGhpcy51c2FnZSAhPT0gU3RhdGljRHJhd1VzYWdlICkgZGF0YS51c2FnZSA9IHRoaXMudXNhZ2U7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuLy9cblxuY2xhc3MgSW50OEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBVaW50OEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgSW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEludDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBGbG9hdDE2QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdHRoaXMuaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0WCggaW5kZXggKSB7XG5cblx0XHRsZXQgeCA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBkZW5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHg7XG5cblx0fVxuXG5cdHNldFgoIGluZGV4LCB4ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WSggaW5kZXggKSB7XG5cblx0XHRsZXQgeSA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSApO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB5ID0gZGVub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB5O1xuXG5cdH1cblxuXHRzZXRZKCBpbmRleCwgeSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRaKCBpbmRleCApIHtcblxuXHRcdGxldCB6ID0gZnJvbUhhbGZGbG9hdCggdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBkZW5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHo7XG5cblx0fVxuXG5cdHNldFooIGluZGV4LCB6ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB0b0hhbGZGbG9hdCggeiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFcoIGluZGV4ICkge1xuXG5cdFx0bGV0IHcgPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gKTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdztcblxuXHR9XG5cblx0c2V0VyggaW5kZXgsIHcgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHRvSGFsZkZsb2F0KCB3ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFkoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWiggaW5kZXgsIHgsIHksIHogKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0gdG9IYWxmRmxvYXQoIHggKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHRvSGFsZkZsb2F0KCB5ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB0b0hhbGZGbG9hdCggeiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWlcoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gdG9IYWxmRmxvYXQoIHogKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHRvSGFsZkZsb2F0KCB3ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuXG5jbGFzcyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmxldCBfaWQkMiA9IDA7XG5cbmNvbnN0IF9tMSQyID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX29iaiA9IC8qQF9fUFVSRV9fKi8gbmV3IE9iamVjdDNEKCk7XG5jb25zdCBfb2Zmc2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2JveCQyID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuY29uc3QgX2JveE1vcnBoVGFyZ2V0cyA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF92ZWN0b3IkOCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgQnVmZmVyR2VvbWV0cnkgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNCdWZmZXJHZW9tZXRyeSA9IHRydWU7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IF9pZCQyICsrIH0gKTtcblxuXHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy50eXBlID0gJ0J1ZmZlckdlb21ldHJ5JztcblxuXHRcdHRoaXMuaW5kZXggPSBudWxsO1xuXHRcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXG5cdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHR0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZmFsc2U7XG5cblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHR0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSB9O1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdH1cblxuXHRnZXRJbmRleCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmluZGV4O1xuXG5cdH1cblxuXHRzZXRJbmRleCggaW5kZXggKSB7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGluZGV4ICkgKSB7XG5cblx0XHRcdHRoaXMuaW5kZXggPSBuZXcgKCBhcnJheU5lZWRzVWludDMyKCBpbmRleCApID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlICkoIGluZGV4LCAxICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmluZGV4ID0gaW5kZXg7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0QXR0cmlidXRlKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdH1cblxuXHRzZXRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZSApIHtcblxuXHRcdHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRlbGV0ZUF0dHJpYnV0ZSggbmFtZSApIHtcblxuXHRcdGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRoYXNBdHRyaWJ1dGUoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gIT09IHVuZGVmaW5lZDtcblxuXHR9XG5cblx0YWRkR3JvdXAoIHN0YXJ0LCBjb3VudCwgbWF0ZXJpYWxJbmRleCA9IDAgKSB7XG5cblx0XHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGNvdW50OiBjb3VudCxcblx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0Y2xlYXJHcm91cHMoKSB7XG5cblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXG5cdH1cblxuXHRzZXREcmF3UmFuZ2UoIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBjb3VudDtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cG9zaXRpb24uYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdFx0bm9ybWFsLmFwcGx5Tm9ybWFsTWF0cml4KCBub3JtYWxNYXRyaXggKTtcblxuXHRcdFx0bm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRhbmdlbnQgPSB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudDtcblxuXHRcdGlmICggdGFuZ2VudCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0YW5nZW50LnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4ICk7XG5cblx0XHRcdHRhbmdlbnQubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5UXVhdGVybmlvbiggcSApIHtcblxuXHRcdF9tMSQyLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xJDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVYKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cblx0XHRfbTEkMi5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSQyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xuXG5cdFx0X20xJDIubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEkMiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdGF0ZVooIGFuZ2xlICkge1xuXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcblxuXHRcdF9tMSQyLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xJDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cblx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuXHRcdF9tMSQyLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSQyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2NhbGUoIHgsIHksIHogKSB7XG5cblx0XHQvLyBzY2FsZSBnZW9tZXRyeVxuXG5cdFx0X20xJDIubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xJDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsb29rQXQoIHZlY3RvciApIHtcblxuXHRcdF9vYmoubG9va0F0KCB2ZWN0b3IgKTtcblxuXHRcdF9vYmoudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX29iai5tYXRyaXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjZW50ZXIoKSB7XG5cblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoIF9vZmZzZXQgKS5uZWdhdGUoKTtcblxuXHRcdHRoaXMudHJhbnNsYXRlKCBfb2Zmc2V0LngsIF9vZmZzZXQueSwgX29mZnNldC56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwb2ludCA9IHBvaW50c1sgaSBdO1xuXHRcdFx0cG9zaXRpb24ucHVzaCggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCAzICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb21wdXRlQm91bmRpbmdCb3goKSB7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggcG9zaXRpb24gJiYgcG9zaXRpb24uaXNHTEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBib3guJywgdGhpcyApO1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldChcblx0XHRcdFx0bmV3IFZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKSxcblx0XHRcdFx0bmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKVxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvblsgaSBdO1xuXHRcdFx0XHRcdF9ib3gkMi5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaEF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yJDguYWRkVmVjdG9ycyggdGhpcy5ib3VuZGluZ0JveC5taW4sIF9ib3gkMi5taW4gKTtcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciQ4ICk7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGRWZWN0b3JzKCB0aGlzLmJvdW5kaW5nQm94Lm1heCwgX2JveCQyLm1heCApO1xuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfdmVjdG9yJDggKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX2JveCQyLm1pbiApO1xuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfYm94JDIubWF4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICYmIHBvc2l0aW9uLmlzR0xCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgc3BoZXJlLicsIHRoaXMgKTtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXQoIG5ldyBWZWN0b3IzKCksIEluZmluaXR5ICk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggcG9zaXRpb24gKSB7XG5cblx0XHRcdC8vIGZpcnN0LCBmaW5kIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZVxuXG5cdFx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuXHRcdFx0X2JveCQyLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvblsgaSBdO1xuXHRcdFx0XHRcdF9ib3hNb3JwaFRhcmdldHMuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdGlmICggdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSApIHtcblxuXHRcdFx0XHRcdFx0X3ZlY3RvciQ4LmFkZFZlY3RvcnMoIF9ib3gkMi5taW4sIF9ib3hNb3JwaFRhcmdldHMubWluICk7XG5cdFx0XHRcdFx0XHRfYm94JDIuZXhwYW5kQnlQb2ludCggX3ZlY3RvciQ4ICk7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGRWZWN0b3JzKCBfYm94JDIubWF4LCBfYm94TW9ycGhUYXJnZXRzLm1heCApO1xuXHRcdFx0XHRcdFx0X2JveCQyLmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IkOCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X2JveCQyLmV4cGFuZEJ5UG9pbnQoIF9ib3hNb3JwaFRhcmdldHMubWluICk7XG5cdFx0XHRcdFx0XHRfYm94JDIuZXhwYW5kQnlQb2ludCggX2JveE1vcnBoVGFyZ2V0cy5tYXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0X2JveCQyLmdldENlbnRlciggY2VudGVyICk7XG5cblx0XHRcdC8vIHNlY29uZCwgdHJ5IHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcblx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuXHRcdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvc2l0aW9uLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZlY3RvciQ4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpICk7XG5cblx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggX3ZlY3RvciQ4ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25bIGkgXTtcblx0XHRcdFx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbW9ycGhBdHRyaWJ1dGUuY291bnQ7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0X3ZlY3RvciQ4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlLCBqICk7XG5cblx0XHRcdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0X29mZnNldC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaiApO1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yJDguYWRkKCBfb2Zmc2V0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggX3ZlY3RvciQ4ICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cblx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb21wdXRlVGFuZ2VudHMoKSB7XG5cblx0XHRjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXG5cdFx0Ly8gKHBlciB2ZXJ0ZXggdGFuZ2VudHMpXG5cblx0XHRpZiAoIGluZGV4ID09PSBudWxsIHx8XG5cdFx0XHQgYXR0cmlidXRlcy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQgYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0IGF0dHJpYnV0ZXMudXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgZmFpbGVkLiBNaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZXMgKGluZGV4LCBwb3NpdGlvbiwgbm9ybWFsIG9yIHV2KScgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBub3JtYWxBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLm5vcm1hbDtcblx0XHRjb25zdCB1dkF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudXY7XG5cblx0XHRpZiAoIHRoaXMuaGFzQXR0cmlidXRlKCAndGFuZ2VudCcgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndGFuZ2VudCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIDQgKiBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCApLCA0ICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRhbmdlbnRBdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3RhbmdlbnQnICk7XG5cblx0XHRjb25zdCB0YW4xID0gW10sIHRhbjIgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpICsrICkge1xuXG5cdFx0XHR0YW4xWyBpIF0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dGFuMlsgaSBdID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHZBID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdHZCID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdHZDID0gbmV3IFZlY3RvcjMoKSxcblxuXHRcdFx0dXZBID0gbmV3IFZlY3RvcjIoKSxcblx0XHRcdHV2QiA9IG5ldyBWZWN0b3IyKCksXG5cdFx0XHR1dkMgPSBuZXcgVmVjdG9yMigpLFxuXG5cdFx0XHRzZGlyID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdHRkaXIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVHJpYW5nbGUoIGEsIGIsIGMgKSB7XG5cblx0XHRcdHZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBhICk7XG5cdFx0XHR2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYiApO1xuXHRcdFx0dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGMgKTtcblxuXHRcdFx0dXZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2QXR0cmlidXRlLCBhICk7XG5cdFx0XHR1dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXZBdHRyaWJ1dGUsIGIgKTtcblx0XHRcdHV2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1dkF0dHJpYnV0ZSwgYyApO1xuXG5cdFx0XHR2Qi5zdWIoIHZBICk7XG5cdFx0XHR2Qy5zdWIoIHZBICk7XG5cblx0XHRcdHV2Qi5zdWIoIHV2QSApO1xuXHRcdFx0dXZDLnN1YiggdXZBICk7XG5cblx0XHRcdGNvbnN0IHIgPSAxLjAgLyAoIHV2Qi54ICogdXZDLnkgLSB1dkMueCAqIHV2Qi55ICk7XG5cblx0XHRcdC8vIHNpbGVudGx5IGlnbm9yZSBkZWdlbmVyYXRlIHV2IHRyaWFuZ2xlcyBoYXZpbmcgY29pbmNpZGVudCBvciBjb2xpbmVhciB2ZXJ0aWNlc1xuXG5cdFx0XHRpZiAoICEgaXNGaW5pdGUoIHIgKSApIHJldHVybjtcblxuXHRcdFx0c2Rpci5jb3B5KCB2QiApLm11bHRpcGx5U2NhbGFyKCB1dkMueSApLmFkZFNjYWxlZFZlY3RvciggdkMsIC0gdXZCLnkgKS5tdWx0aXBseVNjYWxhciggciApO1xuXHRcdFx0dGRpci5jb3B5KCB2QyApLm11bHRpcGx5U2NhbGFyKCB1dkIueCApLmFkZFNjYWxlZFZlY3RvciggdkIsIC0gdXZDLnggKS5tdWx0aXBseVNjYWxhciggciApO1xuXG5cdFx0XHR0YW4xWyBhIF0uYWRkKCBzZGlyICk7XG5cdFx0XHR0YW4xWyBiIF0uYWRkKCBzZGlyICk7XG5cdFx0XHR0YW4xWyBjIF0uYWRkKCBzZGlyICk7XG5cblx0XHRcdHRhbjJbIGEgXS5hZGQoIHRkaXIgKTtcblx0XHRcdHRhbjJbIGIgXS5hZGQoIHRkaXIgKTtcblx0XHRcdHRhbjJbIGMgXS5hZGQoIHRkaXIgKTtcblxuXHRcdH1cblxuXHRcdGxldCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0Z3JvdXBzID0gWyB7XG5cdFx0XHRcdHN0YXJ0OiAwLFxuXHRcdFx0XHRjb3VudDogaW5kZXguY291bnRcblx0XHRcdH0gXTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRjb25zdCBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xuXG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKFxuXHRcdFx0XHRcdGluZGV4LmdldFgoIGogKyAwICksXG5cdFx0XHRcdFx0aW5kZXguZ2V0WCggaiArIDEgKSxcblx0XHRcdFx0XHRpbmRleC5nZXRYKCBqICsgMiApXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IHRtcCA9IG5ldyBWZWN0b3IzKCksIHRtcDIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG4gPSBuZXcgVmVjdG9yMygpLCBuMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVWZXJ0ZXgoIHYgKSB7XG5cblx0XHRcdG4uZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsQXR0cmlidXRlLCB2ICk7XG5cdFx0XHRuMi5jb3B5KCBuICk7XG5cblx0XHRcdGNvbnN0IHQgPSB0YW4xWyB2IF07XG5cblx0XHRcdC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cblx0XHRcdHRtcC5jb3B5KCB0ICk7XG5cdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuXHRcdFx0dG1wMi5jcm9zc1ZlY3RvcnMoIG4yLCB0ICk7XG5cdFx0XHRjb25zdCB0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHYgXSApO1xuXHRcdFx0Y29uc3QgdyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cblx0XHRcdHRhbmdlbnRBdHRyaWJ1dGUuc2V0WFlaVyggdiwgdG1wLngsIHRtcC55LCB0bXAueiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdGNvbnN0IGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpbmRleC5nZXRYKCBqICsgMCApICk7XG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaW5kZXguZ2V0WCggaiArIDEgKSApO1xuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGluZGV4LmdldFgoIGogKyAyICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb21wdXRlVmVydGV4Tm9ybWFscygpIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRpZiAoIHBvc2l0aW9uQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxldCBub3JtYWxBdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcblxuXHRcdFx0aWYgKCBub3JtYWxBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAqIDMgKSwgMyApO1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbEF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBub3JtYWxBdHRyaWJ1dGUuY291bnQ7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGksIDAsIDAsIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcEEgPSBuZXcgVmVjdG9yMygpLCBwQiA9IG5ldyBWZWN0b3IzKCksIHBDID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IG5BID0gbmV3IFZlY3RvcjMoKSwgbkIgPSBuZXcgVmVjdG9yMygpLCBuQyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gaW5kZXhlZCBlbGVtZW50c1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBpbmRleC5jb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2QSA9IGluZGV4LmdldFgoIGkgKyAwICk7XG5cdFx0XHRcdFx0Y29uc3QgdkIgPSBpbmRleC5nZXRYKCBpICsgMSApO1xuXHRcdFx0XHRcdGNvbnN0IHZDID0gaW5kZXguZ2V0WCggaSArIDIgKTtcblxuXHRcdFx0XHRcdHBBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCB2QSApO1xuXHRcdFx0XHRcdHBCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCB2QiApO1xuXHRcdFx0XHRcdHBDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCB2QyApO1xuXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0XHRuQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxBdHRyaWJ1dGUsIHZBICk7XG5cdFx0XHRcdFx0bkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsQXR0cmlidXRlLCB2QiApO1xuXHRcdFx0XHRcdG5DLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbEF0dHJpYnV0ZSwgdkMgKTtcblxuXHRcdFx0XHRcdG5BLmFkZCggY2IgKTtcblx0XHRcdFx0XHRuQi5hZGQoIGNiICk7XG5cdFx0XHRcdFx0bkMuYWRkKCBjYiApO1xuXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggdkEsIG5BLngsIG5BLnksIG5BLnogKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCB2QiwgbkIueCwgbkIueSwgbkIueiApO1xuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIHZDLCBuQy54LCBuQy55LCBuQy56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRwQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDAgKTtcblx0XHRcdFx0XHRwQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDEgKTtcblx0XHRcdFx0XHRwQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDIgKTtcblxuXHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggaSArIDAsIGNiLngsIGNiLnksIGNiLnogKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpICsgMSwgY2IueCwgY2IueSwgY2IueiApO1xuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGkgKyAyLCBjYi54LCBjYi55LCBjYi56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXG5cdFx0XHRub3JtYWxBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRub3JtYWxpemVOb3JtYWxzKCkge1xuXG5cdFx0Y29uc3Qgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbm9ybWFscy5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yJDguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgaSApO1xuXG5cdFx0XHRfdmVjdG9yJDgubm9ybWFsaXplKCk7XG5cblx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpLCBfdmVjdG9yJDgueCwgX3ZlY3RvciQ4LnksIF92ZWN0b3IkOC56ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvTm9uSW5kZXhlZCgpIHtcblxuXHRcdGZ1bmN0aW9uIGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGUubm9ybWFsaXplZDtcblxuXHRcdFx0Y29uc3QgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdGxldCBpbmRleCA9IDAsIGluZGV4MiA9IDA7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBhdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKyBhdHRyaWJ1dGUub2Zmc2V0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5MiwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuaW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRjb25zdCBpbmRpY2VzID0gdGhpcy5pbmRleC5hcnJheTtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gYXR0cmlidXRlc1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZSA9IGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApO1xuXG5cdFx0XHRnZW9tZXRyeTIuc2V0QXR0cmlidXRlKCBuYW1lLCBuZXdBdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBuZXdBdHRyaWJ1dGUgPSBjb252ZXJ0QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGljZXMgKTtcblxuXHRcdFx0XHRtb3JwaEFycmF5LnB1c2goIG5ld0F0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5Mi5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IG1vcnBoQXJyYXk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeTIubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0Ly8gZ3JvdXBzXG5cblx0XHRjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0Z2VvbWV0cnkyLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTI7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjYsXG5cdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHQvLyBmb3Igc2ltcGxpY2l0eSB0aGUgY29kZSBhc3N1bWVzIGF0dHJpYnV0ZXMgYXJlIG5vdCBzaGFyZWQgYWNyb3NzIGdlb21ldHJpZXMsIHNlZSAjMTU4MTFcblxuXHRcdGRhdGEuZGF0YSA9IHsgYXR0cmlidXRlczoge30gfTtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5pbmRleCA9IHtcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0YXJyYXk6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBpbmRleC5hcnJheSApXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblxuXHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0gYXR0cmlidXRlLnRvSlNPTiggZGF0YS5kYXRhICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHRsZXQgaGFzTW9ycGhBdHRyaWJ1dGVzID0gZmFsc2U7XG5cblx0XHRmb3IgKCBjb25zdCBrZXkgaW4gdGhpcy5tb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZUFycmF5ID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXR0cmlidXRlQXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlQXJyYXlbIGkgXTtcblxuXHRcdFx0XHRhcnJheS5wdXNoKCBhdHRyaWJ1dGUudG9KU09OKCBkYXRhLmRhdGEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXJyYXkubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRtb3JwaEF0dHJpYnV0ZXNbIGtleSBdID0gYXJyYXk7XG5cblx0XHRcdFx0aGFzTW9ycGhBdHRyaWJ1dGVzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBoYXNNb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5tb3JwaEF0dHJpYnV0ZXMgPSBtb3JwaEF0dHJpYnV0ZXM7XG5cdFx0XHRkYXRhLmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cblx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmU7XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XG5cdFx0XHRcdGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcblx0XHRcdFx0cmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdC8vIHJlc2V0XG5cblx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblx0XHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXHRcdHRoaXMuZ3JvdXBzID0gW107XG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHQvLyB1c2VkIGZvciBzdG9yaW5nIGNsb25lZCwgc2hhcmVkIGRhdGFcblxuXHRcdGNvbnN0IGRhdGEgPSB7fTtcblxuXHRcdC8vIG5hbWVcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0Ly8gaW5kZXhcblxuXHRcdGNvbnN0IGluZGV4ID0gc291cmNlLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoIGRhdGEgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYXR0cmlidXRlc1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCBkYXRhICkgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHNvdXJjZS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIG1vcnBoQXR0cmlidXRlWyBpIF0uY2xvbmUoIGRhdGEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcblxuXHRcdH1cblxuXHRcdHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBzb3VyY2UubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHQvLyBncm91cHNcblxuXHRcdGNvbnN0IGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgYm94XG5cblx0XHRjb25zdCBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcblxuXHRcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZHJhdyByYW5nZVxuXG5cdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzb3VyY2UuZHJhd1JhbmdlLnN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gc291cmNlLmRyYXdSYW5nZS5jb3VudDtcblxuXHRcdC8vIHVzZXIgZGF0YVxuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHNvdXJjZS51c2VyRGF0YTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9pbnZlcnNlTWF0cml4JDMgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfcmF5JDMgPSAvKkBfX1BVUkVfXyovIG5ldyBSYXkoKTtcbmNvbnN0IF9zcGhlcmUkNiA9IC8qQF9fUFVSRV9fKi8gbmV3IFNwaGVyZSgpO1xuY29uc3QgX3NwaGVyZUhpdEF0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfdkEkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92QiQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZDJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF90ZW1wQSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tb3JwaEEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF91dkEkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF91dkIkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF91dkMkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxuY29uc3QgX25vcm1hbEEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbm9ybWFsQiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ub3JtYWxDID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfaW50ZXJzZWN0aW9uUG9pbnQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgTWVzaCBleHRlbmRzIE9iamVjdDNEIHtcblxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKSwgbWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTWVzaCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaCc7XG5cblx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdFx0dGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0aWYgKCBzb3VyY2UubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5tb3JwaFRhcmdldERpY3Rpb25hcnkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMubWF0ZXJpYWwgPSBBcnJheS5pc0FycmF5KCBzb3VyY2UubWF0ZXJpYWwgKSA/IHNvdXJjZS5tYXRlcmlhbC5zbGljZSgpIDogc291cmNlLm1hdGVyaWFsO1xuXHRcdHRoaXMuZ2VvbWV0cnkgPSBzb3VyY2UuZ2VvbWV0cnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dXBkYXRlTW9ycGhUYXJnZXRzKCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggbW9ycGhBdHRyaWJ1dGVzICk7XG5cblx0XHRpZiAoIGtleXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbIGtleXNbIDAgXSBdO1xuXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBuYW1lID0gbW9ycGhBdHRyaWJ1dGVbIG0gXS5uYW1lIHx8IFN0cmluZyggbSApO1xuXG5cdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gPSBtO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRnZXRWZXJ0ZXhQb3NpdGlvbiggaW5kZXgsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0dGFyZ2V0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleCApO1xuXG5cdFx0Y29uc3QgbW9ycGhJbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHRpZiAoIG1vcnBoUG9zaXRpb24gJiYgbW9ycGhJbmZsdWVuY2VzICkge1xuXG5cdFx0XHRfbW9ycGhBLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbIGkgXTtcblx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaFBvc2l0aW9uWyBpIF07XG5cblx0XHRcdFx0aWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRfdGVtcEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUsIGluZGV4ICk7XG5cblx0XHRcdFx0aWYgKCBtb3JwaFRhcmdldHNSZWxhdGl2ZSApIHtcblxuXHRcdFx0XHRcdF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKCBfdGVtcEEsIGluZmx1ZW5jZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfbW9ycGhBLmFkZFNjYWxlZFZlY3RvciggX3RlbXBBLnN1YiggdGFyZ2V0ICksIGluZmx1ZW5jZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0YXJnZXQuYWRkKCBfbW9ycGhBICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRyYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuXHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdC8vIHRlc3Qgd2l0aCBib3VuZGluZyBzcGhlcmUgaW4gd29ybGQgc3BhY2VcblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdF9zcGhlcmUkNi5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdF9zcGhlcmUkNi5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cblx0XHQvLyBjaGVjayBkaXN0YW5jZSBmcm9tIHJheSBvcmlnaW4gdG8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHRfcmF5JDMuY29weSggcmF5Y2FzdGVyLnJheSApLnJlY2FzdCggcmF5Y2FzdGVyLm5lYXIgKTtcblxuXHRcdGlmICggX3NwaGVyZSQ2LmNvbnRhaW5zUG9pbnQoIF9yYXkkMy5vcmlnaW4gKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGlmICggX3JheSQzLmludGVyc2VjdFNwaGVyZSggX3NwaGVyZSQ2LCBfc3BoZXJlSGl0QXQgKSA9PT0gbnVsbCApIHJldHVybjtcblxuXHRcdFx0aWYgKCBfcmF5JDMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKCBfc3BoZXJlSGl0QXQgKSA+ICggcmF5Y2FzdGVyLmZhciAtIHJheWNhc3Rlci5uZWFyICkgKiogMiApIHJldHVybjtcblxuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgcmF5IHRvIGxvY2FsIHNwYWNlIG9mIG1lc2hcblxuXHRcdF9pbnZlcnNlTWF0cml4JDMuY29weSggbWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblx0XHRfcmF5JDMuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggX2ludmVyc2VNYXRyaXgkMyApO1xuXG5cdFx0Ly8gdGVzdCB3aXRoIGJvdW5kaW5nIGJveCBpbiBsb2NhbCBzcGFjZVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBfcmF5JDMuaW50ZXJzZWN0c0JveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR9XG5cblx0XHQvLyB0ZXN0IGZvciBpbnRlcnNlY3Rpb25zIHdpdGggZ2VvbWV0cnlcblxuXHRcdHRoaXMuX2NvbXB1dGVJbnRlcnNlY3Rpb25zKCByYXljYXN0ZXIsIGludGVyc2VjdHMsIF9yYXkkMyApO1xuXG5cdH1cblxuXHRfY29tcHV0ZUludGVyc2VjdGlvbnMoIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmF5TG9jYWxTcGFjZSApIHtcblxuXHRcdGxldCBpbnRlcnNlY3Rpb247XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgdXYgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2O1xuXHRcdGNvbnN0IHV2MSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYxO1xuXHRcdGNvbnN0IG5vcm1hbCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuXHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHQvLyBpbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsWyBncm91cC5tYXRlcmlhbEluZGV4IF07XG5cblx0XHRcdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCBncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0ICk7XG5cdFx0XHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIGluZGV4LmNvdW50LCBNYXRoLm1pbiggKCBncm91cC5zdGFydCArIGdyb3VwLmNvdW50ICksICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKSApO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WCggaiApO1xuXHRcdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4LmdldFgoIGogKyAxICk7XG5cdFx0XHRcdFx0XHRjb25zdCBjID0gaW5kZXguZ2V0WCggaiArIDIgKTtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgZ3JvdXBNYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXlMb2NhbFNwYWNlLCB1diwgdXYxLCBub3JtYWwsIGEsIGIsIGMgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGogLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRleGVkIGJ1ZmZlciBzZW1hbnRpY3Ncblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2UubWF0ZXJpYWxJbmRleCA9IGdyb3VwLm1hdGVyaWFsSW5kZXg7XG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCggMCwgZHJhd1JhbmdlLnN0YXJ0ICk7XG5cdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBpbmRleC5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKCBpICk7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4LmdldFgoIGkgKyAxICk7XG5cdFx0XHRcdFx0Y29uc3QgYyA9IGluZGV4LmdldFgoIGkgKyAyICk7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0dlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXlMb2NhbFNwYWNlLCB1diwgdXYxLCBub3JtYWwsIGEsIGIsIGMgKTtcblxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIG5vbi1pbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsWyBncm91cC5tYXRlcmlhbEluZGV4IF07XG5cblx0XHRcdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCBncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0ICk7XG5cdFx0XHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIHBvc2l0aW9uLmNvdW50LCBNYXRoLm1pbiggKCBncm91cC5zdGFydCArIGdyb3VwLmNvdW50ICksICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKSApO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhID0gajtcblx0XHRcdFx0XHRcdGNvbnN0IGIgPSBqICsgMTtcblx0XHRcdFx0XHRcdGNvbnN0IGMgPSBqICsgMjtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgZ3JvdXBNYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXlMb2NhbFNwYWNlLCB1diwgdXYxLCBub3JtYWwsIGEsIGIsIGMgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGogLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBub24taW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlLm1hdGVyaWFsSW5kZXggPSBncm91cC5tYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIDAsIGRyYXdSYW5nZS5zdGFydCApO1xuXHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbiggcG9zaXRpb24uY291bnQsICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhID0gaTtcblx0XHRcdFx0XHRjb25zdCBiID0gaSArIDE7XG5cdFx0XHRcdFx0Y29uc3QgYyA9IGkgKyAyO1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5TG9jYWxTcGFjZSwgdXYsIHV2MSwgbm9ybWFsLCBhLCBiLCBjICk7XG5cblx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGkgLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBub24taW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBjaGVja0ludGVyc2VjdGlvbiQxKCBvYmplY3QsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgcEEsIHBCLCBwQywgcG9pbnQgKSB7XG5cblx0bGV0IGludGVyc2VjdDtcblxuXHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICkge1xuXG5cdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQywgcEIsIHBBLCB0cnVlLCBwb2ludCApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBBLCBwQiwgcEMsICggbWF0ZXJpYWwuc2lkZSA9PT0gRnJvbnRTaWRlICksIHBvaW50ICk7XG5cblx0fVxuXG5cdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0X2ludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggcG9pbnQgKTtcblx0X2ludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XG5cblx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybiBudWxsO1xuXG5cdHJldHVybiB7XG5cdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdHBvaW50OiBfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpLFxuXHRcdG9iamVjdDogb2JqZWN0XG5cdH07XG5cbn1cblxuZnVuY3Rpb24gY2hlY2tHZW9tZXRyeUludGVyc2VjdGlvbiggb2JqZWN0LCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHV2LCB1djEsIG5vcm1hbCwgYSwgYiwgYyApIHtcblxuXHRvYmplY3QuZ2V0VmVydGV4UG9zaXRpb24oIGEsIF92QSQxICk7XG5cdG9iamVjdC5nZXRWZXJ0ZXhQb3NpdGlvbiggYiwgX3ZCJDEgKTtcblx0b2JqZWN0LmdldFZlcnRleFBvc2l0aW9uKCBjLCBfdkMkMSApO1xuXG5cdGNvbnN0IGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uJDEoIG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBfdkEkMSwgX3ZCJDEsIF92QyQxLCBfaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuXHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdGlmICggdXYgKSB7XG5cblx0XHRcdF91dkEkMS5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYSApO1xuXHRcdFx0X3V2QiQxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBiICk7XG5cdFx0XHRfdXZDJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGMgKTtcblxuXHRcdFx0aW50ZXJzZWN0aW9uLnV2ID0gVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggX2ludGVyc2VjdGlvblBvaW50LCBfdkEkMSwgX3ZCJDEsIF92QyQxLCBfdXZBJDEsIF91dkIkMSwgX3V2QyQxLCBuZXcgVmVjdG9yMigpICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHV2MSApIHtcblxuXHRcdFx0X3V2QSQxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2MSwgYSApO1xuXHRcdFx0X3V2QiQxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2MSwgYiApO1xuXHRcdFx0X3V2QyQxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2MSwgYyApO1xuXG5cdFx0XHRpbnRlcnNlY3Rpb24udXYxID0gVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggX2ludGVyc2VjdGlvblBvaW50LCBfdkEkMSwgX3ZCJDEsIF92QyQxLCBfdXZBJDEsIF91dkIkMSwgX3V2QyQxLCBuZXcgVmVjdG9yMigpICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG5vcm1hbCApIHtcblxuXHRcdFx0X25vcm1hbEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLCBhICk7XG5cdFx0XHRfbm9ybWFsQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGIgKTtcblx0XHRcdF9ub3JtYWxDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgYyApO1xuXG5cdFx0XHRpbnRlcnNlY3Rpb24ubm9ybWFsID0gVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggX2ludGVyc2VjdGlvblBvaW50LCBfdkEkMSwgX3ZCJDEsIF92QyQxLCBfbm9ybWFsQSwgX25vcm1hbEIsIF9ub3JtYWxDLCBuZXcgVmVjdG9yMygpICk7XG5cblx0XHRcdGlmICggaW50ZXJzZWN0aW9uLm5vcm1hbC5kb3QoIHJheS5kaXJlY3Rpb24gKSA+IDAgKSB7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbC5tdWx0aXBseVNjYWxhciggLSAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGZhY2UgPSB7XG5cdFx0XHRhOiBhLFxuXHRcdFx0YjogYixcblx0XHRcdGM6IGMsXG5cdFx0XHRub3JtYWw6IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRtYXRlcmlhbEluZGV4OiAwXG5cdFx0fTtcblxuXHRcdFRyaWFuZ2xlLmdldE5vcm1hbCggX3ZBJDEsIF92QiQxLCBfdkMkMSwgZmFjZS5ub3JtYWwgKTtcblxuXHRcdGludGVyc2VjdGlvbi5mYWNlID0gZmFjZTtcblxuXHR9XG5cblx0cmV0dXJuIGludGVyc2VjdGlvbjtcblxufVxuXG5jbGFzcyBCb3hHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEsIHdpZHRoU2VnbWVudHMgPSAxLCBoZWlnaHRTZWdtZW50cyA9IDEsIGRlcHRoU2VnbWVudHMgPSAxICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdGRlcHRoOiBkZXB0aCxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG5cdFx0fTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdC8vIHNlZ21lbnRzXG5cblx0XHR3aWR0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApO1xuXHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKTtcblx0XHRkZXB0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggZGVwdGhTZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IG51bWJlck9mVmVydGljZXMgPSAwO1xuXHRcdGxldCBncm91cFN0YXJ0ID0gMDtcblxuXHRcdC8vIGJ1aWxkIGVhY2ggc2lkZSBvZiB0aGUgYm94IGdlb21ldHJ5XG5cblx0XHRidWlsZFBsYW5lKCAneicsICd5JywgJ3gnLCAtIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgd2lkdGgsIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAwICk7IC8vIHB4XG5cdFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCAtIHdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMSApOyAvLyBueFxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAneScsIDEsIDEsIHdpZHRoLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAyICk7IC8vIHB5XG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneicsICd5JywgMSwgLSAxLCB3aWR0aCwgZGVwdGgsIC0gaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAzICk7IC8vIG55XG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICd6JywgMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDQgKTsgLy8gcHpcblx0XHRidWlsZFBsYW5lKCAneCcsICd5JywgJ3onLCAtIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgLSBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDUgKTsgLy8gbnpcblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdFx0ZnVuY3Rpb24gYnVpbGRQbGFuZSggdSwgdiwgdywgdWRpciwgdmRpciwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGdyaWRYLCBncmlkWSwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdFx0Y29uc3Qgc2VnbWVudFdpZHRoID0gd2lkdGggLyBncmlkWDtcblx0XHRcdGNvbnN0IHNlZ21lbnRIZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuXHRcdFx0Y29uc3Qgd2lkdGhIYWxmID0gd2lkdGggLyAyO1xuXHRcdFx0Y29uc3QgaGVpZ2h0SGFsZiA9IGhlaWdodCAvIDI7XG5cdFx0XHRjb25zdCBkZXB0aEhhbGYgPSBkZXB0aCAvIDI7XG5cblx0XHRcdGNvbnN0IGdyaWRYMSA9IGdyaWRYICsgMTtcblx0XHRcdGNvbnN0IGdyaWRZMSA9IGdyaWRZICsgMTtcblxuXHRcdFx0bGV0IHZlcnRleENvdW50ZXIgPSAwO1xuXHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0XHRjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAoIGxldCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB5ID0gaXkgKiBzZWdtZW50SGVpZ2h0IC0gaGVpZ2h0SGFsZjtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB4ID0gaXggKiBzZWdtZW50V2lkdGggLSB3aWR0aEhhbGY7XG5cblx0XHRcdFx0XHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuXG5cdFx0XHRcdFx0dmVjdG9yWyB1IF0gPSB4ICogdWRpcjtcblx0XHRcdFx0XHR2ZWN0b3JbIHYgXSA9IHkgKiB2ZGlyO1xuXHRcdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGhIYWxmO1xuXG5cdFx0XHRcdFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byB2ZXJ0ZXggYnVmZmVyXG5cblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XG5cblx0XHRcdFx0XHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuXG5cdFx0XHRcdFx0dmVjdG9yWyB1IF0gPSAwO1xuXHRcdFx0XHRcdHZlY3RvclsgdiBdID0gMDtcblx0XHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoID4gMCA/IDEgOiAtIDE7XG5cblx0XHRcdFx0XHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIG5vcm1hbCBidWZmZXJcblxuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xuXG5cdFx0XHRcdFx0Ly8gdXZzXG5cblx0XHRcdFx0XHR1dnMucHVzaCggaXggLyBncmlkWCApO1xuXHRcdFx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcblxuXHRcdFx0XHRcdC8vIGNvdW50ZXJzXG5cblx0XHRcdFx0XHR2ZXJ0ZXhDb3VudGVyICs9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0Ly8gMS4geW91IG5lZWQgdGhyZWUgaW5kaWNlcyB0byBkcmF3IGEgc2luZ2xlIGZhY2Vcblx0XHRcdC8vIDIuIGEgc2luZ2xlIHNlZ21lbnQgY29uc2lzdHMgb2YgdHdvIGZhY2VzXG5cdFx0XHQvLyAzLiBzbyB3ZSBuZWVkIHRvIGdlbmVyYXRlIHNpeCAoMiozKSBpbmRpY2VzIHBlciBzZWdtZW50XG5cblx0XHRcdGZvciAoIGxldCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9IG51bWJlck9mVmVydGljZXMgKyBpeCArIGdyaWRYMSAqIGl5O1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdFx0Y29uc3QgZCA9IG51bWJlck9mVmVydGljZXMgKyAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cblx0XHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdFx0XHQvLyBpbmNyZWFzZSBjb3VudGVyXG5cblx0XHRcdFx0XHRncm91cENvdW50ICs9IDY7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblx0XHRcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCBtYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG5cdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cblx0XHRcdC8vIHVwZGF0ZSB0b3RhbCBudW1iZXIgb2YgdmVydGljZXNcblxuXHRcdFx0bnVtYmVyT2ZWZXJ0aWNlcyArPSB2ZXJ0ZXhDb3VudGVyO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQm94R2VvbWV0cnkoIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LCBkYXRhLmRlcHRoLCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEuZGVwdGhTZWdtZW50cyApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIFVuaWZvcm0gVXRpbGl0aWVzXG4gKi9cblxuZnVuY3Rpb24gY2xvbmVVbmlmb3Jtcyggc3JjICkge1xuXG5cdGNvbnN0IGRzdCA9IHt9O1xuXG5cdGZvciAoIGNvbnN0IHUgaW4gc3JjICkge1xuXG5cdFx0ZHN0WyB1IF0gPSB7fTtcblxuXHRcdGZvciAoIGNvbnN0IHAgaW4gc3JjWyB1IF0gKSB7XG5cblx0XHRcdGNvbnN0IHByb3BlcnR5ID0gc3JjWyB1IF1bIHAgXTtcblxuXHRcdFx0aWYgKCBwcm9wZXJ0eSAmJiAoIHByb3BlcnR5LmlzQ29sb3IgfHxcblx0XHRcdFx0cHJvcGVydHkuaXNNYXRyaXgzIHx8IHByb3BlcnR5LmlzTWF0cml4NCB8fFxuXHRcdFx0XHRwcm9wZXJ0eS5pc1ZlY3RvcjIgfHwgcHJvcGVydHkuaXNWZWN0b3IzIHx8IHByb3BlcnR5LmlzVmVjdG9yNCB8fFxuXHRcdFx0XHRwcm9wZXJ0eS5pc1RleHR1cmUgfHwgcHJvcGVydHkuaXNRdWF0ZXJuaW9uICkgKSB7XG5cblx0XHRcdFx0aWYgKCBwcm9wZXJ0eS5pc1JlbmRlclRhcmdldFRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdVbmlmb3Jtc1V0aWxzOiBUZXh0dXJlcyBvZiByZW5kZXIgdGFyZ2V0cyBjYW5ub3QgYmUgY2xvbmVkIHZpYSBjbG9uZVVuaWZvcm1zKCkgb3IgbWVyZ2VVbmlmb3JtcygpLicgKTtcblx0XHRcdFx0XHRkc3RbIHUgXVsgcCBdID0gbnVsbDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZHN0WyB1IF1bIHAgXSA9IHByb3BlcnR5LmNsb25lKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBwcm9wZXJ0eSApICkge1xuXG5cdFx0XHRcdGRzdFsgdSBdWyBwIF0gPSBwcm9wZXJ0eS5zbGljZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGRzdFsgdSBdWyBwIF0gPSBwcm9wZXJ0eTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZHN0O1xuXG59XG5cbmZ1bmN0aW9uIG1lcmdlVW5pZm9ybXMoIHVuaWZvcm1zICkge1xuXG5cdGNvbnN0IG1lcmdlZCA9IHt9O1xuXG5cdGZvciAoIGxldCB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcblxuXHRcdGNvbnN0IHRtcCA9IGNsb25lVW5pZm9ybXMoIHVuaWZvcm1zWyB1IF0gKTtcblxuXHRcdGZvciAoIGNvbnN0IHAgaW4gdG1wICkge1xuXG5cdFx0XHRtZXJnZWRbIHAgXSA9IHRtcFsgcCBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gbWVyZ2VkO1xuXG59XG5cbmZ1bmN0aW9uIGNsb25lVW5pZm9ybXNHcm91cHMoIHNyYyApIHtcblxuXHRjb25zdCBkc3QgPSBbXTtcblxuXHRmb3IgKCBsZXQgdSA9IDA7IHUgPCBzcmMubGVuZ3RoOyB1ICsrICkge1xuXG5cdFx0ZHN0LnB1c2goIHNyY1sgdSBdLmNsb25lKCkgKTtcblxuXHR9XG5cblx0cmV0dXJuIGRzdDtcblxufVxuXG5mdW5jdGlvbiBnZXRVbmxpdFVuaWZvcm1Db2xvclNwYWNlKCByZW5kZXJlciApIHtcblxuXHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cblx0aWYgKCBjdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsICkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIzOTM3I2lzc3VlY29tbWVudC0xMTExMDY3Mzk4XG5cdFx0cmV0dXJuIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2U7XG5cblx0fVxuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzI3ODY4XG5cdGlmICggY3VycmVudFJlbmRlclRhcmdldC5pc1hSUmVuZGVyVGFyZ2V0ID09PSB0cnVlICkge1xuXG5cdFx0cmV0dXJuIGN1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlO1xuXG5cdH1cblxuXHRyZXR1cm4gQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlO1xuXG59XG5cbi8vIExlZ2FjeVxuXG5jb25zdCBVbmlmb3Jtc1V0aWxzID0geyBjbG9uZTogY2xvbmVVbmlmb3JtcywgbWVyZ2U6IG1lcmdlVW5pZm9ybXMgfTtcblxudmFyIGRlZmF1bHRfdmVydGV4ID0gXCJ2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn1cIjtcblxudmFyIGRlZmF1bHRfZnJhZ21lbnQgPSBcInZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59XCI7XG5cbmNsYXNzIFNoYWRlck1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNTaGFkZXJNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhZGVyTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5kZWZpbmVzID0ge307XG5cdFx0dGhpcy51bmlmb3JtcyA9IHt9O1xuXHRcdHRoaXMudW5pZm9ybXNHcm91cHMgPSBbXTtcblxuXHRcdHRoaXMudmVydGV4U2hhZGVyID0gZGVmYXVsdF92ZXJ0ZXg7XG5cdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGRlZmF1bHRfZnJhZ21lbnQ7XG5cblx0XHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHRcdHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcblx0XHR0aGlzLmNsaXBwaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2UgdXNlci1kZWZpbmVkIGNsaXBwaW5nIHBsYW5lc1xuXG5cdFx0dGhpcy5mb3JjZVNpbmdsZVBhc3MgPSB0cnVlO1xuXG5cdFx0dGhpcy5leHRlbnNpb25zID0ge1xuXHRcdFx0Y2xpcEN1bGxEaXN0YW5jZTogZmFsc2UsIC8vIHNldCB0byB1c2UgdmVydGV4IHNoYWRlciBjbGlwcGluZ1xuXHRcdFx0bXVsdGlEcmF3OiBmYWxzZSAvLyBzZXQgdG8gdXNlIHZlcnRleCBzaGFkZXIgbXVsdGlfZHJhdyAvIGVuYWJsZSBnbF9EcmF3SURcblx0XHR9O1xuXG5cdFx0Ly8gV2hlbiByZW5kZXJlZCBnZW9tZXRyeSBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgYXR0cmlidXRlcyBidXQgdGhlIG1hdGVyaWFsIGRvZXMsXG5cdFx0Ly8gdXNlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGluIFdlYkdMLiBUaGlzIGF2b2lkcyBlcnJvcnMgd2hlbiBidWZmZXIgZGF0YSBpcyBtaXNzaW5nLlxuXHRcdHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IHtcblx0XHRcdCdjb2xvcic6IFsgMSwgMSwgMSBdLFxuXHRcdFx0J3V2JzogWyAwLCAwIF0sXG5cdFx0XHQndXYxJzogWyAwLCAwIF1cblx0XHR9O1xuXG5cdFx0dGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLmdsc2xWZXJzaW9uID0gbnVsbDtcblxuXHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBzb3VyY2UuZnJhZ21lbnRTaGFkZXI7XG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBzb3VyY2UudmVydGV4U2hhZGVyO1xuXG5cdFx0dGhpcy51bmlmb3JtcyA9IGNsb25lVW5pZm9ybXMoIHNvdXJjZS51bmlmb3JtcyApO1xuXHRcdHRoaXMudW5pZm9ybXNHcm91cHMgPSBjbG9uZVVuaWZvcm1zR3JvdXBzKCBzb3VyY2UudW5pZm9ybXNHcm91cHMgKTtcblxuXHRcdHRoaXMuZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UuZGVmaW5lcyApO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblx0XHR0aGlzLmxpZ2h0cyA9IHNvdXJjZS5saWdodHM7XG5cdFx0dGhpcy5jbGlwcGluZyA9IHNvdXJjZS5jbGlwcGluZztcblxuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UuZXh0ZW5zaW9ucyApO1xuXG5cdFx0dGhpcy5nbHNsVmVyc2lvbiA9IHNvdXJjZS5nbHNsVmVyc2lvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCBtZXRhICk7XG5cblx0XHRkYXRhLmdsc2xWZXJzaW9uID0gdGhpcy5nbHNsVmVyc2lvbjtcblx0XHRkYXRhLnVuaWZvcm1zID0ge307XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIHRoaXMudW5pZm9ybXMgKSB7XG5cblx0XHRcdGNvbnN0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zWyBuYW1lIF07XG5cdFx0XHRjb25zdCB2YWx1ZSA9IHVuaWZvcm0udmFsdWU7XG5cblx0XHRcdGlmICggdmFsdWUgJiYgdmFsdWUuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAndCcsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvSlNPTiggbWV0YSApLnV1aWRcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNDb2xvciApIHtcblxuXHRcdFx0XHRkYXRhLnVuaWZvcm1zWyBuYW1lIF0gPSB7XG5cdFx0XHRcdFx0dHlwZTogJ2MnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS5nZXRIZXgoKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc1ZlY3RvcjIgKSB7XG5cblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1sgbmFtZSBdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICd2MicsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc1ZlY3RvcjMgKSB7XG5cblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1sgbmFtZSBdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICd2MycsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc1ZlY3RvcjQgKSB7XG5cblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1sgbmFtZSBdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICd2NCcsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc01hdHJpeDMgKSB7XG5cblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1sgbmFtZSBdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICdtMycsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc01hdHJpeDQgKSB7XG5cblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1sgbmFtZSBdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICdtNCcsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBub3RlOiB0aGUgYXJyYXkgdmFyaWFudHMgdjJ2LCB2M3YsIHY0diwgbTR2IGFuZCB0diBhcmUgbm90IHN1cHBvcnRlZCBzbyBmYXJcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy5kZWZpbmVzICkubGVuZ3RoID4gMCApIGRhdGEuZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcblxuXHRcdGRhdGEudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XG5cdFx0ZGF0YS5mcmFnbWVudFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTaGFkZXI7XG5cblx0XHRkYXRhLmxpZ2h0cyA9IHRoaXMubGlnaHRzO1xuXHRcdGRhdGEuY2xpcHBpbmcgPSB0aGlzLmNsaXBwaW5nO1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIHRoaXMuZXh0ZW5zaW9ucyApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmV4dGVuc2lvbnNbIGtleSBdID09PSB0cnVlICkgZXh0ZW5zaW9uc1sga2V5IF0gPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggZXh0ZW5zaW9ucyApLmxlbmd0aCA+IDAgKSBkYXRhLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmNsYXNzIENhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzQ2FtZXJhID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdDYW1lcmEnO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHRoaXMuY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSggc291cmNlLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHNvdXJjZS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeEludmVyc2UgKTtcblxuXHRcdHRoaXMuY29vcmRpbmF0ZVN5c3RlbSA9IHNvdXJjZS5jb29yZGluYXRlU3lzdGVtO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFdvcmxkRGlyZWN0aW9uKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gc3VwZXIuZ2V0V29ybGREaXJlY3Rpb24oIHRhcmdldCApLm5lZ2F0ZSgpO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHR9XG5cblx0dXBkYXRlV29ybGRNYXRyaXgoIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuICkge1xuXG5cdFx0c3VwZXIudXBkYXRlV29ybGRNYXRyaXgoIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfdjMkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9taW5UYXJnZXQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5jb25zdCBfbWF4VGFyZ2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xuXG5cbmNsYXNzIFBlcnNwZWN0aXZlQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIHtcblxuXHRjb25zdHJ1Y3RvciggZm92ID0gNTAsIGFzcGVjdCA9IDEsIG5lYXIgPSAwLjEsIGZhciA9IDIwMDAgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1BlcnNwZWN0aXZlQ2FtZXJhID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XG5cblx0XHR0aGlzLmZvdiA9IGZvdjtcblx0XHR0aGlzLnpvb20gPSAxO1xuXG5cdFx0dGhpcy5uZWFyID0gbmVhcjtcblx0XHR0aGlzLmZhciA9IGZhcjtcblx0XHR0aGlzLmZvY3VzID0gMTA7XG5cblx0XHR0aGlzLmFzcGVjdCA9IGFzcGVjdDtcblx0XHR0aGlzLnZpZXcgPSBudWxsO1xuXG5cdFx0dGhpcy5maWxtR2F1Z2UgPSAzNTtcdC8vIHdpZHRoIG9mIHRoZSBmaWxtIChkZWZhdWx0IGluIG1pbGxpbWV0ZXJzKVxuXHRcdHRoaXMuZmlsbU9mZnNldCA9IDA7XHQvLyBob3Jpem9udGFsIGZpbG0gb2Zmc2V0IChzYW1lIHVuaXQgYXMgZ2F1Z2UpXG5cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5mb3YgPSBzb3VyY2UuZm92O1xuXHRcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXG5cdFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG5cdFx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuXHRcdHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG5cblx0XHR0aGlzLmFzcGVjdCA9IHNvdXJjZS5hc3BlY3Q7XG5cdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XG5cblx0XHR0aGlzLmZpbG1HYXVnZSA9IHNvdXJjZS5maWxtR2F1Z2U7XG5cdFx0dGhpcy5maWxtT2Zmc2V0ID0gc291cmNlLmZpbG1PZmZzZXQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIEZPViBieSBmb2NhbCBsZW5ndGggaW4gcmVzcGVjdCB0byB0aGUgY3VycmVudCAuZmlsbUdhdWdlLlxuXHQgKlxuXHQgKiBUaGUgZGVmYXVsdCBmaWxtIGdhdWdlIGlzIDM1LCBzbyB0aGF0IHRoZSBmb2NhbCBsZW5ndGggY2FuIGJlIHNwZWNpZmllZCBmb3Jcblx0ICogYSAzNW1tIChmdWxsIGZyYW1lKSBjYW1lcmEuXG5cdCAqXG5cdCAqIFZhbHVlcyBmb3IgZm9jYWwgbGVuZ3RoIGFuZCBmaWxtIGdhdWdlIG11c3QgaGF2ZSB0aGUgc2FtZSB1bml0LlxuXHQgKi9cblx0c2V0Rm9jYWxMZW5ndGgoIGZvY2FsTGVuZ3RoICkge1xuXG5cdFx0LyoqIHNlZSB7QGxpbmsgaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWx9ICovXG5cdFx0Y29uc3QgdkV4dGVudFNsb3BlID0gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyBmb2NhbExlbmd0aDtcblxuXHRcdHRoaXMuZm92ID0gUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oIHZFeHRlbnRTbG9wZSApO1xuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgZm9jYWwgbGVuZ3RoIGZyb20gdGhlIGN1cnJlbnQgLmZvdiBhbmQgLmZpbG1HYXVnZS5cblx0ICovXG5cdGdldEZvY2FsTGVuZ3RoKCkge1xuXG5cdFx0Y29uc3QgdkV4dGVudFNsb3BlID0gTWF0aC50YW4oIERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdiApO1xuXG5cdFx0cmV0dXJuIDAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gdkV4dGVudFNsb3BlO1xuXG5cdH1cblxuXHRnZXRFZmZlY3RpdmVGT1YoKSB7XG5cblx0XHRyZXR1cm4gUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oXG5cdFx0XHRNYXRoLnRhbiggREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICkgLyB0aGlzLnpvb20gKTtcblxuXHR9XG5cblx0Z2V0RmlsbVdpZHRoKCkge1xuXG5cdFx0Ly8gZmlsbSBub3QgY29tcGxldGVseSBjb3ZlcmVkIGluIHBvcnRyYWl0IGZvcm1hdCAoYXNwZWN0IDwgMSlcblx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbiggdGhpcy5hc3BlY3QsIDEgKTtcblxuXHR9XG5cblx0Z2V0RmlsbUhlaWdodCgpIHtcblxuXHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBsYW5kc2NhcGUgZm9ybWF0IChhc3BlY3QgPiAxKVxuXHRcdHJldHVybiB0aGlzLmZpbG1HYXVnZSAvIE1hdGgubWF4KCB0aGlzLmFzcGVjdCwgMSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIDJEIGJvdW5kcyBvZiB0aGUgY2FtZXJhJ3Mgdmlld2FibGUgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gZGlzdGFuY2UgYWxvbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uLlxuXHQgKiBTZXRzIG1pblRhcmdldCBhbmQgbWF4VGFyZ2V0IHRvIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbG93ZXItbGVmdCBhbmQgdXBwZXItcmlnaHQgY29ybmVycyBvZiB0aGUgdmlldyByZWN0YW5nbGUuXG5cdCAqL1xuXHRnZXRWaWV3Qm91bmRzKCBkaXN0YW5jZSwgbWluVGFyZ2V0LCBtYXhUYXJnZXQgKSB7XG5cblx0XHRfdjMkMS5zZXQoIC0gMSwgLSAxLCAwLjUgKS5hcHBseU1hdHJpeDQoIHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UgKTtcblxuXHRcdG1pblRhcmdldC5zZXQoIF92MyQxLngsIF92MyQxLnkgKS5tdWx0aXBseVNjYWxhciggLSBkaXN0YW5jZSAvIF92MyQxLnogKTtcblxuXHRcdF92MyQxLnNldCggMSwgMSwgMC41ICkuYXBwbHlNYXRyaXg0KCB0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XG5cblx0XHRtYXhUYXJnZXQuc2V0KCBfdjMkMS54LCBfdjMkMS55ICkubXVsdGlwbHlTY2FsYXIoIC0gZGlzdGFuY2UgLyBfdjMkMS56ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2FtZXJhJ3Mgdmlld2FibGUgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gZGlzdGFuY2UgYWxvbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uLlxuXHQgKiBDb3BpZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSB0YXJnZXQgVmVjdG9yMiwgd2hlcmUgeCBpcyB3aWR0aCBhbmQgeSBpcyBoZWlnaHQuXG5cdCAqL1xuXHRnZXRWaWV3U2l6ZSggZGlzdGFuY2UsIHRhcmdldCApIHtcblxuXHRcdHRoaXMuZ2V0Vmlld0JvdW5kcyggZGlzdGFuY2UsIF9taW5UYXJnZXQsIF9tYXhUYXJnZXQgKTtcblxuXHRcdHJldHVybiB0YXJnZXQuc3ViVmVjdG9ycyggX21heFRhcmdldCwgX21pblRhcmdldCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxuXHQgKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxuXHQgKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXG5cdCAqXG5cdCAqICAgKy0tLSstLS0rLS0tK1xuXHQgKiAgIHwgQSB8IEIgfCBDIHxcblx0ICogICArLS0tKy0tLSstLS0rXG5cdCAqICAgfCBEIHwgRSB8IEYgfFxuXHQgKiAgICstLS0rLS0tKy0tLStcblx0ICpcblx0ICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xuXHQgKlxuXHQgKiAgIGNvbnN0IHcgPSAxOTIwO1xuXHQgKiAgIGNvbnN0IGggPSAxMDgwO1xuXHQgKiAgIGNvbnN0IGZ1bGxXaWR0aCA9IHcgKiAzO1xuXHQgKiAgIGNvbnN0IGZ1bGxIZWlnaHQgPSBoICogMjtcblx0ICpcblx0ICogICAtLUEtLVxuXHQgKiAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xuXHQgKiAgIC0tQi0tXG5cdCAqICAgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XG5cdCAqICAgLS1DLS1cblx0ICogICBjYW1lcmEuc2V0Vmlld09mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcblx0ICogICAtLUQtLVxuXHQgKiAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xuXHQgKiAgIC0tRS0tXG5cdCAqICAgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XG5cdCAqICAgLS1GLS1cblx0ICogICBjYW1lcmEuc2V0Vmlld09mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcblx0ICpcblx0ICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxuXHQgKi9cblx0c2V0Vmlld09mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0dGhpcy5hc3BlY3QgPSBmdWxsV2lkdGggLyBmdWxsSGVpZ2h0O1xuXG5cdFx0aWYgKCB0aGlzLnZpZXcgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMudmlldyA9IHtcblx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0ZnVsbFdpZHRoOiAxLFxuXHRcdFx0XHRmdWxsSGVpZ2h0OiAxLFxuXHRcdFx0XHRvZmZzZXRYOiAwLFxuXHRcdFx0XHRvZmZzZXRZOiAwLFxuXHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0aGVpZ2h0OiAxXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy52aWV3LmVuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMudmlldy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XG5cdFx0dGhpcy52aWV3LmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xuXHRcdHRoaXMudmlldy5vZmZzZXRYID0geDtcblx0XHR0aGlzLnZpZXcub2Zmc2V0WSA9IHk7XG5cdFx0dGhpcy52aWV3LndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH1cblxuXHRjbGVhclZpZXdPZmZzZXQoKSB7XG5cblx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH1cblxuXHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkge1xuXG5cdFx0Y29uc3QgbmVhciA9IHRoaXMubmVhcjtcblx0XHRsZXQgdG9wID0gbmVhciAqIE1hdGgudGFuKCBERUcyUkFEICogMC41ICogdGhpcy5mb3YgKSAvIHRoaXMuem9vbTtcblx0XHRsZXQgaGVpZ2h0ID0gMiAqIHRvcDtcblx0XHRsZXQgd2lkdGggPSB0aGlzLmFzcGVjdCAqIGhlaWdodDtcblx0XHRsZXQgbGVmdCA9IC0gMC41ICogd2lkdGg7XG5cdFx0Y29uc3QgdmlldyA9IHRoaXMudmlldztcblxuXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkICkge1xuXG5cdFx0XHRjb25zdCBmdWxsV2lkdGggPSB2aWV3LmZ1bGxXaWR0aCxcblx0XHRcdFx0ZnVsbEhlaWdodCA9IHZpZXcuZnVsbEhlaWdodDtcblxuXHRcdFx0bGVmdCArPSB2aWV3Lm9mZnNldFggKiB3aWR0aCAvIGZ1bGxXaWR0aDtcblx0XHRcdHRvcCAtPSB2aWV3Lm9mZnNldFkgKiBoZWlnaHQgLyBmdWxsSGVpZ2h0O1xuXHRcdFx0d2lkdGggKj0gdmlldy53aWR0aCAvIGZ1bGxXaWR0aDtcblx0XHRcdGhlaWdodCAqPSB2aWV3LmhlaWdodCAvIGZ1bGxIZWlnaHQ7XG5cblx0XHR9XG5cblx0XHRjb25zdCBza2V3ID0gdGhpcy5maWxtT2Zmc2V0O1xuXHRcdGlmICggc2tldyAhPT0gMCApIGxlZnQgKz0gbmVhciAqIHNrZXcgLyB0aGlzLmdldEZpbG1XaWR0aCgpO1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSggbGVmdCwgbGVmdCArIHdpZHRoLCB0b3AsIHRvcCAtIGhlaWdodCwgbmVhciwgdGhpcy5mYXIsIHRoaXMuY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKS5pbnZlcnQoKTtcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3QuZm92ID0gdGhpcy5mb3Y7XG5cdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcblxuXHRcdGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG5cdFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cdFx0ZGF0YS5vYmplY3QuZm9jdXMgPSB0aGlzLmZvY3VzO1xuXG5cdFx0ZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XG5cblx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIGRhdGEub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy52aWV3ICk7XG5cblx0XHRkYXRhLm9iamVjdC5maWxtR2F1Z2UgPSB0aGlzLmZpbG1HYXVnZTtcblx0XHRkYXRhLm9iamVjdC5maWxtT2Zmc2V0ID0gdGhpcy5maWxtT2Zmc2V0O1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmNvbnN0IGZvdiA9IC0gOTA7IC8vIG5lZ2F0aXZlIGZvdiBpcyBub3QgYW4gZXJyb3JcbmNvbnN0IGFzcGVjdCA9IDE7XG5cbmNsYXNzIEN1YmVDYW1lcmEgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoIG5lYXIsIGZhciwgcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcblxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuXHRcdHRoaXMuY29vcmRpbmF0ZVN5c3RlbSA9IG51bGw7XG5cdFx0dGhpcy5hY3RpdmVNaXBtYXBMZXZlbCA9IDA7XG5cblx0XHRjb25zdCBjYW1lcmFQWCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYVBYLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdHRoaXMuYWRkKCBjYW1lcmFQWCApO1xuXG5cdFx0Y29uc3QgY2FtZXJhTlggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0XHRjYW1lcmFOWC5sYXllcnMgPSB0aGlzLmxheWVycztcblx0XHR0aGlzLmFkZCggY2FtZXJhTlggKTtcblxuXHRcdGNvbnN0IGNhbWVyYVBZID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdFx0Y2FtZXJhUFkubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0dGhpcy5hZGQoIGNhbWVyYVBZICk7XG5cblx0XHRjb25zdCBjYW1lcmFOWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYU5ZLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdHRoaXMuYWRkKCBjYW1lcmFOWSApO1xuXG5cdFx0Y29uc3QgY2FtZXJhUFogPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0XHRjYW1lcmFQWi5sYXllcnMgPSB0aGlzLmxheWVycztcblx0XHR0aGlzLmFkZCggY2FtZXJhUFogKTtcblxuXHRcdGNvbnN0IGNhbWVyYU5aID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdFx0Y2FtZXJhTloubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0dGhpcy5hZGQoIGNhbWVyYU5aICk7XG5cblx0fVxuXG5cdHVwZGF0ZUNvb3JkaW5hdGVTeXN0ZW0oKSB7XG5cblx0XHRjb25zdCBjb29yZGluYXRlU3lzdGVtID0gdGhpcy5jb29yZGluYXRlU3lzdGVtO1xuXG5cdFx0Y29uc3QgY2FtZXJhcyA9IHRoaXMuY2hpbGRyZW4uY29uY2F0KCk7XG5cblx0XHRjb25zdCBbIGNhbWVyYVBYLCBjYW1lcmFOWCwgY2FtZXJhUFksIGNhbWVyYU5ZLCBjYW1lcmFQWiwgY2FtZXJhTlogXSA9IGNhbWVyYXM7XG5cblx0XHRmb3IgKCBjb25zdCBjYW1lcmEgb2YgY2FtZXJhcyApIHRoaXMucmVtb3ZlKCBjYW1lcmEgKTtcblxuXHRcdGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjYW1lcmFQWC51cC5zZXQoIDAsIDEsIDAgKTtcblx0XHRcdGNhbWVyYVBYLmxvb2tBdCggMSwgMCwgMCApO1xuXG5cdFx0XHRjYW1lcmFOWC51cC5zZXQoIDAsIDEsIDAgKTtcblx0XHRcdGNhbWVyYU5YLmxvb2tBdCggLSAxLCAwLCAwICk7XG5cblx0XHRcdGNhbWVyYVBZLnVwLnNldCggMCwgMCwgLSAxICk7XG5cdFx0XHRjYW1lcmFQWS5sb29rQXQoIDAsIDEsIDAgKTtcblxuXHRcdFx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAxICk7XG5cdFx0XHRjYW1lcmFOWS5sb29rQXQoIDAsIC0gMSwgMCApO1xuXG5cdFx0XHRjYW1lcmFQWi51cC5zZXQoIDAsIDEsIDAgKTtcblx0XHRcdGNhbWVyYVBaLmxvb2tBdCggMCwgMCwgMSApO1xuXG5cdFx0XHRjYW1lcmFOWi51cC5zZXQoIDAsIDEsIDAgKTtcblx0XHRcdGNhbWVyYU5aLmxvb2tBdCggMCwgMCwgLSAxICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjb29yZGluYXRlU3lzdGVtID09PSBXZWJHUFVDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjYW1lcmFQWC51cC5zZXQoIDAsIC0gMSwgMCApO1xuXHRcdFx0Y2FtZXJhUFgubG9va0F0KCAtIDEsIDAsIDAgKTtcblxuXHRcdFx0Y2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0XHRcdGNhbWVyYU5YLmxvb2tBdCggMSwgMCwgMCApO1xuXG5cdFx0XHRjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcblx0XHRcdGNhbWVyYVBZLmxvb2tBdCggMCwgMSwgMCApO1xuXG5cdFx0XHRjYW1lcmFOWS51cC5zZXQoIDAsIDAsIC0gMSApO1xuXHRcdFx0Y2FtZXJhTlkubG9va0F0KCAwLCAtIDEsIDAgKTtcblxuXHRcdFx0Y2FtZXJhUFoudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0XHRcdGNhbWVyYVBaLmxvb2tBdCggMCwgMCwgMSApO1xuXG5cdFx0XHRjYW1lcmFOWi51cC5zZXQoIDAsIC0gMSwgMCApO1xuXHRcdFx0Y2FtZXJhTloubG9va0F0KCAwLCAwLCAtIDEgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkN1YmVDYW1lcmEudXBkYXRlQ29vcmRpbmF0ZVN5c3RlbSgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAnICsgY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggY29uc3QgY2FtZXJhIG9mIGNhbWVyYXMgKSB7XG5cblx0XHRcdHRoaXMuYWRkKCBjYW1lcmEgKTtcblxuXHRcdFx0Y2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZSggcmVuZGVyZXIsIHNjZW5lICkge1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdGNvbnN0IHsgcmVuZGVyVGFyZ2V0LCBhY3RpdmVNaXBtYXBMZXZlbCB9ID0gdGhpcztcblxuXHRcdGlmICggdGhpcy5jb29yZGluYXRlU3lzdGVtICE9PSByZW5kZXJlci5jb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHR0aGlzLmNvb3JkaW5hdGVTeXN0ZW0gPSByZW5kZXJlci5jb29yZGluYXRlU3lzdGVtO1xuXG5cdFx0XHR0aGlzLnVwZGF0ZUNvb3JkaW5hdGVTeXN0ZW0oKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IFsgY2FtZXJhUFgsIGNhbWVyYU5YLCBjYW1lcmFQWSwgY2FtZXJhTlksIGNhbWVyYVBaLCBjYW1lcmFOWiBdID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRjb25zdCBjdXJyZW50QWN0aXZlQ3ViZUZhY2UgPSByZW5kZXJlci5nZXRBY3RpdmVDdWJlRmFjZSgpO1xuXHRcdGNvbnN0IGN1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbCA9IHJlbmRlcmVyLmdldEFjdGl2ZU1pcG1hcExldmVsKCk7XG5cblx0XHRjb25zdCBjdXJyZW50WHJFbmFibGVkID0gcmVuZGVyZXIueHIuZW5hYmxlZDtcblxuXHRcdHJlbmRlcmVyLnhyLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdGNvbnN0IGdlbmVyYXRlTWlwbWFwcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblxuXHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIDAsIGFjdGl2ZU1pcG1hcExldmVsICk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFggKTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCAxLCBhY3RpdmVNaXBtYXBMZXZlbCApO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCwgMiwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWSApO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIDMsIGFjdGl2ZU1pcG1hcExldmVsICk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlkgKTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCA0LCBhY3RpdmVNaXBtYXBMZXZlbCApO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaICk7XG5cblx0XHQvLyBtaXBtYXBzIGFyZSBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBsYXN0IGNhbGwgb2YgcmVuZGVyKClcblx0XHQvLyBhdCB0aGlzIHBvaW50LCBhbGwgc2lkZXMgb2YgdGhlIGN1YmUgcmVuZGVyIHRhcmdldCBhcmUgZGVmaW5lZFxuXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIDUsIGFjdGl2ZU1pcG1hcExldmVsICk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlogKTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggY3VycmVudFJlbmRlclRhcmdldCwgY3VycmVudEFjdGl2ZUN1YmVGYWNlLCBjdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgKTtcblxuXHRcdHJlbmRlcmVyLnhyLmVuYWJsZWQgPSBjdXJyZW50WHJFbmFibGVkO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUubmVlZHNQTVJFTVVwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG59XG5cbmNsYXNzIEN1YmVUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cblx0Y29uc3RydWN0b3IoIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBjb2xvclNwYWNlICkge1xuXG5cdFx0aW1hZ2VzID0gaW1hZ2VzICE9PSB1bmRlZmluZWQgPyBpbWFnZXMgOiBbXTtcblx0XHRtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcblxuXHRcdHN1cGVyKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgY29sb3JTcGFjZSApO1xuXG5cdFx0dGhpcy5pc0N1YmVUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuXHR9XG5cblx0Z2V0IGltYWdlcygpIHtcblxuXHRcdHJldHVybiB0aGlzLmltYWdlO1xuXG5cdH1cblxuXHRzZXQgaW1hZ2VzKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuaW1hZ2UgPSB2YWx1ZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0IGV4dGVuZHMgV2ViR0xSZW5kZXJUYXJnZXQge1xuXG5cdGNvbnN0cnVjdG9yKCBzaXplID0gMSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoIHNpemUsIHNpemUsIG9wdGlvbnMgKTtcblxuXHRcdHRoaXMuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgPSB0cnVlO1xuXG5cdFx0Y29uc3QgaW1hZ2UgPSB7IHdpZHRoOiBzaXplLCBoZWlnaHQ6IHNpemUsIGRlcHRoOiAxIH07XG5cdFx0Y29uc3QgaW1hZ2VzID0gWyBpbWFnZSwgaW1hZ2UsIGltYWdlLCBpbWFnZSwgaW1hZ2UsIGltYWdlIF07XG5cblx0XHR0aGlzLnRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoIGltYWdlcywgb3B0aW9ucy5tYXBwaW5nLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSwgb3B0aW9ucy5jb2xvclNwYWNlICk7XG5cblx0XHQvLyBCeSBjb252ZW50aW9uIC0tIGxpa2VseSBiYXNlZCBvbiB0aGUgUmVuZGVyTWFuIHNwZWMgZnJvbSB0aGUgMTk5MCdzIC0tIGN1YmUgbWFwcyBhcmUgc3BlY2lmaWVkIGJ5IFdlYkdMIChhbmQgdGhyZWUuanMpXG5cdFx0Ly8gaW4gYSBjb29yZGluYXRlIHN5c3RlbSBpbiB3aGljaCBwb3NpdGl2ZS14IGlzIHRvIHRoZSByaWdodCB3aGVuIGxvb2tpbmcgdXAgdGhlIHBvc2l0aXZlLXogYXhpcyAtLSBpbiBvdGhlciB3b3Jkcyxcblx0XHQvLyBpbiBhIGxlZnQtaGFuZGVkIGNvb3JkaW5hdGUgc3lzdGVtLiBCeSBjb250aW51aW5nIHRoaXMgY29udmVudGlvbiwgcHJlZXhpc3RpbmcgY3ViZSBtYXBzIGNvbnRpbnVlZCB0byByZW5kZXIgY29ycmVjdGx5LlxuXG5cdFx0Ly8gdGhyZWUuanMgdXNlcyBhIHJpZ2h0LWhhbmRlZCBjb29yZGluYXRlIHN5c3RlbS4gU28gZW52aXJvbm1lbnQgbWFwcyB1c2VkIGluIHRocmVlLmpzIGFwcGVhciB0byBoYXZlIHB4IGFuZCBueCBzd2FwcGVkXG5cdFx0Ly8gYW5kIHRoZSBmbGFnIGlzUmVuZGVyVGFyZ2V0VGV4dHVyZSBjb250cm9scyB0aGlzIGNvbnZlcnNpb24uIFRoZSBmbGlwIGlzIG5vdCByZXF1aXJlZCB3aGVuIHVzaW5nIFdlYkdMQ3ViZVJlbmRlclRhcmdldC50ZXh0dXJlXG5cdFx0Ly8gYXMgYSBjdWJlIHRleHR1cmUgKHRoaXMgaXMgZGV0ZWN0ZWQgd2hlbiBpc1JlbmRlclRhcmdldFRleHR1cmUgaXMgc2V0IHRvIHRydWUgZm9yIGN1YmUgdGV4dHVyZXMpLlxuXG5cdFx0dGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cblx0XHR0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2U7XG5cdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkZpbHRlciA6IExpbmVhckZpbHRlcjtcblxuXHR9XG5cblx0ZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUoIHJlbmRlcmVyLCB0ZXh0dXJlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlLnR5cGUgPSB0ZXh0dXJlLnR5cGU7XG5cdFx0dGhpcy50ZXh0dXJlLmNvbG9yU3BhY2UgPSB0ZXh0dXJlLmNvbG9yU3BhY2U7XG5cblx0XHR0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyO1xuXHRcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB0ZXh0dXJlLm1hZ0ZpbHRlcjtcblxuXHRcdGNvbnN0IHNoYWRlciA9IHtcblxuXHRcdFx0dW5pZm9ybXM6IHtcblx0XHRcdFx0dEVxdWlyZWN0OiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHR9LFxuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IC8qIGdsc2wgKi9gXG5cblx0XHRcdFx0dmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcblxuXHRcdFx0XHR2ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHRcdHZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XG5cblx0XHRcdFx0XHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHRcdFx0XHRcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cblxuXHRcdFx0XHR9XG5cdFx0XHRgLFxuXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqL2BcblxuXHRcdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XG5cblx0XHRcdFx0dmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcblxuXHRcdFx0XHQjaW5jbHVkZSA8Y29tbW9uPlxuXG5cdFx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHRcdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGREaXJlY3Rpb24gKTtcblxuXHRcdFx0XHRcdHZlYzIgc2FtcGxlVVYgPSBlcXVpcmVjdFV2KCBkaXJlY3Rpb24gKTtcblxuXHRcdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1xuXG5cdFx0XHRcdH1cblx0XHRcdGBcblx0XHR9O1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQm94R2VvbWV0cnkoIDUsIDUsIDUgKTtcblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKCB7XG5cblx0XHRcdG5hbWU6ICdDdWJlbWFwRnJvbUVxdWlyZWN0JyxcblxuXHRcdFx0dW5pZm9ybXM6IGNsb25lVW5pZm9ybXMoIHNoYWRlci51bmlmb3JtcyApLFxuXHRcdFx0dmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlcixcblx0XHRcdHNpZGU6IEJhY2tTaWRlLFxuXHRcdFx0YmxlbmRpbmc6IE5vQmxlbmRpbmdcblxuXHRcdH0gKTtcblxuXHRcdG1hdGVyaWFsLnVuaWZvcm1zLnRFcXVpcmVjdC52YWx1ZSA9IHRleHR1cmU7XG5cblx0XHRjb25zdCBtZXNoID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0Y29uc3QgY3VycmVudE1pbkZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyO1xuXG5cdFx0Ly8gQXZvaWQgYmx1cnJlZCBwb2xlc1xuXHRcdGlmICggdGV4dHVyZS5taW5GaWx0ZXIgPT09IExpbmVhck1pcG1hcExpbmVhckZpbHRlciApIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG5cdFx0Y29uc3QgY2FtZXJhID0gbmV3IEN1YmVDYW1lcmEoIDEsIDEwLCB0aGlzICk7XG5cdFx0Y2FtZXJhLnVwZGF0ZSggcmVuZGVyZXIsIG1lc2ggKTtcblxuXHRcdHRleHR1cmUubWluRmlsdGVyID0gY3VycmVudE1pbkZpbHRlcjtcblxuXHRcdG1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdG1lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsZWFyKCByZW5kZXJlciwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG5cdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB0aGlzLCBpICk7XG5cblx0XHRcdHJlbmRlcmVyLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcblxuXHRcdH1cblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggY3VycmVudFJlbmRlclRhcmdldCApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfdmVjdG9yMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92ZWN0b3IyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX25vcm1hbE1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKTtcblxuY2xhc3MgUGxhbmUge1xuXG5cdGNvbnN0cnVjdG9yKCBub3JtYWwgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApLCBjb25zdGFudCA9IDAgKSB7XG5cblx0XHR0aGlzLmlzUGxhbmUgPSB0cnVlO1xuXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5ub3JtYWwgPSBub3JtYWw7XG5cdFx0dGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xuXG5cdH1cblxuXHRzZXQoIG5vcm1hbCwgY29uc3RhbnQgKSB7XG5cblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Q29tcG9uZW50cyggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMubm9ybWFsLnNldCggeCwgeSwgeiApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBub3JtYWwsIHBvaW50ICkge1xuXG5cdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG5cdFx0dGhpcy5jb25zdGFudCA9IC0gcG9pbnQuZG90KCB0aGlzLm5vcm1hbCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Db3BsYW5hclBvaW50cyggYSwgYiwgYyApIHtcblxuXHRcdGNvbnN0IG5vcm1hbCA9IF92ZWN0b3IxLnN1YlZlY3RvcnMoIGMsIGIgKS5jcm9zcyggX3ZlY3RvcjIuc3ViVmVjdG9ycyggYSwgYiApICkubm9ybWFsaXplKCk7XG5cblx0XHQvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xuXG5cdFx0dGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBhICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggcGxhbmUgKSB7XG5cblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBwbGFuZS5ub3JtYWwgKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bm9ybWFsaXplKCkge1xuXG5cdFx0Ly8gTm90ZTogd2lsbCBsZWFkIHRvIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIHBsYW5lIGlzIGludmFsaWQuXG5cblx0XHRjb25zdCBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XG5cdFx0dGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIGludmVyc2VOb3JtYWxMZW5ndGggKTtcblx0XHR0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bmVnYXRlKCkge1xuXG5cdFx0dGhpcy5jb25zdGFudCAqPSAtIDE7XG5cdFx0dGhpcy5ub3JtYWwubmVnYXRlKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XG5cblx0fVxuXG5cdHByb2plY3RQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5hZGRTY2FsZWRWZWN0b3IoIHRoaXMubm9ybWFsLCAtIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApICk7XG5cblx0fVxuXG5cdGludGVyc2VjdExpbmUoIGxpbmUsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IGRpcmVjdGlvbiA9IGxpbmUuZGVsdGEoIF92ZWN0b3IxICk7XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHRoaXMubm9ybWFsLmRvdCggZGlyZWN0aW9uICk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG5cdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXG5cdFx0XHRpZiAoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT09IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHQgPSAtICggbGluZS5zdGFydC5kb3QoIHRoaXMubm9ybWFsICkgKyB0aGlzLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBsaW5lLnN0YXJ0ICkuYWRkU2NhbGVkVmVjdG9yKCBkaXJlY3Rpb24sIHQgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c0xpbmUoIGxpbmUgKSB7XG5cblx0XHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cblxuXHRcdGNvbnN0IHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XG5cdFx0Y29uc3QgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLmVuZCApO1xuXG5cdFx0cmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xuXG5cdH1cblxuXHRjb3BsYW5hclBvaW50KCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIC0gdGhpcy5jb25zdGFudCApO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XG5cblx0XHRjb25zdCBub3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBfbm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRjb25zdCByZWZlcmVuY2VQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggX3ZlY3RvcjEgKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0Y29uc3Qgbm9ybWFsID0gdGhpcy5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuXHRcdHRoaXMuY29uc3RhbnQgPSAtIHJlZmVyZW5jZVBvaW50LmRvdCggbm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmNvbnN0YW50IC09IG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCBwbGFuZSApIHtcblxuXHRcdHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnQgKTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9zcGhlcmUkNSA9IC8qQF9fUFVSRV9fKi8gbmV3IFNwaGVyZSgpO1xuY29uc3QgX3ZlY3RvciQ3ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBGcnVzdHVtIHtcblxuXHRjb25zdHJ1Y3RvciggcDAgPSBuZXcgUGxhbmUoKSwgcDEgPSBuZXcgUGxhbmUoKSwgcDIgPSBuZXcgUGxhbmUoKSwgcDMgPSBuZXcgUGxhbmUoKSwgcDQgPSBuZXcgUGxhbmUoKSwgcDUgPSBuZXcgUGxhbmUoKSApIHtcblxuXHRcdHRoaXMucGxhbmVzID0gWyBwMCwgcDEsIHAyLCBwMywgcDQsIHA1IF07XG5cblx0fVxuXG5cdHNldCggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcblxuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG5cdFx0cGxhbmVzWyAwIF0uY29weSggcDAgKTtcblx0XHRwbGFuZXNbIDEgXS5jb3B5KCBwMSApO1xuXHRcdHBsYW5lc1sgMiBdLmNvcHkoIHAyICk7XG5cdFx0cGxhbmVzWyAzIF0uY29weSggcDMgKTtcblx0XHRwbGFuZXNbIDQgXS5jb3B5KCBwNCApO1xuXHRcdHBsYW5lc1sgNSBdLmNvcHkoIHA1ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggZnJ1c3R1bSApIHtcblxuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0cGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Qcm9qZWN0aW9uTWF0cml4KCBtLCBjb29yZGluYXRlU3lzdGVtID0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lMCA9IG1lWyAwIF0sIG1lMSA9IG1lWyAxIF0sIG1lMiA9IG1lWyAyIF0sIG1lMyA9IG1lWyAzIF07XG5cdFx0Y29uc3QgbWU0ID0gbWVbIDQgXSwgbWU1ID0gbWVbIDUgXSwgbWU2ID0gbWVbIDYgXSwgbWU3ID0gbWVbIDcgXTtcblx0XHRjb25zdCBtZTggPSBtZVsgOCBdLCBtZTkgPSBtZVsgOSBdLCBtZTEwID0gbWVbIDEwIF0sIG1lMTEgPSBtZVsgMTEgXTtcblx0XHRjb25zdCBtZTEyID0gbWVbIDEyIF0sIG1lMTMgPSBtZVsgMTMgXSwgbWUxNCA9IG1lWyAxNCBdLCBtZTE1ID0gbWVbIDE1IF07XG5cblx0XHRwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDEgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTAsIG1lNyArIG1lNCwgbWUxMSArIG1lOCwgbWUxNSArIG1lMTIgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDQgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTIsIG1lNyAtIG1lNiwgbWUxMSAtIG1lMTAsIG1lMTUgLSBtZTE0ICkubm9ybWFsaXplKCk7XG5cblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fSBlbHNlIGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUyLCBtZTYsIG1lMTAsIG1lMTQgKS5ub3JtYWxpemUoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIG9iamVjdC5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0X3NwaGVyZSQ1LmNvcHkoIG9iamVjdC5ib3VuZGluZ1NwaGVyZSApLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHRfc3BoZXJlJDUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSQ1ICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNTcHJpdGUoIHNwcml0ZSApIHtcblxuXHRcdF9zcGhlcmUkNS5jZW50ZXIuc2V0KCAwLCAwLCAwICk7XG5cdFx0X3NwaGVyZSQ1LnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3Njtcblx0XHRfc3BoZXJlJDUuYXBwbHlNYXRyaXg0KCBzcHJpdGUubWF0cml4V29ybGQgKTtcblxuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIF9zcGhlcmUkNSApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHRjb25zdCBjZW50ZXIgPSBzcGhlcmUuY2VudGVyO1xuXHRcdGNvbnN0IG5lZ1JhZGl1cyA9IC0gc3BoZXJlLnJhZGl1cztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcblxuXHRcdFx0aWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBsYW5lID0gcGxhbmVzWyBpIF07XG5cblx0XHRcdC8vIGNvcm5lciBhdCBtYXggZGlzdGFuY2VcblxuXHRcdFx0X3ZlY3RvciQ3LnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWF4LnggOiBib3gubWluLng7XG5cdFx0XHRfdmVjdG9yJDcueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcblx0XHRcdF92ZWN0b3IkNy56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xuXG5cdFx0XHRpZiAoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggX3ZlY3RvciQ3ICkgPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGNvbnRhaW5zUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIFdlYkdMQW5pbWF0aW9uKCkge1xuXG5cdGxldCBjb250ZXh0ID0gbnVsbDtcblx0bGV0IGlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdGxldCBhbmltYXRpb25Mb29wID0gbnVsbDtcblx0bGV0IHJlcXVlc3RJZCA9IG51bGw7XG5cblx0ZnVuY3Rpb24gb25BbmltYXRpb25GcmFtZSggdGltZSwgZnJhbWUgKSB7XG5cblx0XHRhbmltYXRpb25Mb29wKCB0aW1lLCBmcmFtZSApO1xuXG5cdFx0cmVxdWVzdElkID0gY29udGV4dC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIG9uQW5pbWF0aW9uRnJhbWUgKTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggaXNBbmltYXRpbmcgPT09IHRydWUgKSByZXR1cm47XG5cdFx0XHRpZiAoIGFuaW1hdGlvbkxvb3AgPT09IG51bGwgKSByZXR1cm47XG5cblx0XHRcdHJlcXVlc3RJZCA9IGNvbnRleHQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBvbkFuaW1hdGlvbkZyYW1lICk7XG5cblx0XHRcdGlzQW5pbWF0aW5nID0gdHJ1ZTtcblxuXHRcdH0sXG5cblx0XHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnRleHQuY2FuY2VsQW5pbWF0aW9uRnJhbWUoIHJlcXVlc3RJZCApO1xuXG5cdFx0XHRpc0FuaW1hdGluZyA9IGZhbHNlO1xuXG5cdFx0fSxcblxuXHRcdHNldEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdGFuaW1hdGlvbkxvb3AgPSBjYWxsYmFjaztcblxuXHRcdH0sXG5cblx0XHRzZXRDb250ZXh0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb250ZXh0ID0gdmFsdWU7XG5cblx0XHR9XG5cblx0fTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTEF0dHJpYnV0ZXMoIGdsICkge1xuXG5cdGNvbnN0IGJ1ZmZlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xuXG5cdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0Y29uc3QgdXNhZ2UgPSBhdHRyaWJ1dGUudXNhZ2U7XG5cdFx0Y29uc3Qgc2l6ZSA9IGFycmF5LmJ5dGVMZW5ndGg7XG5cblx0XHRjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGJ1ZmZlciApO1xuXHRcdGdsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGFycmF5LCB1c2FnZSApO1xuXG5cdFx0YXR0cmlidXRlLm9uVXBsb2FkQ2FsbGJhY2soKTtcblxuXHRcdGxldCB0eXBlO1xuXG5cdFx0aWYgKCBhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSApIHtcblxuXHRcdFx0dHlwZSA9IGdsLkZMT0FUO1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSApIHtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdHR5cGUgPSBnbC5IQUxGX0ZMT0FUO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5ICkge1xuXG5cdFx0XHR0eXBlID0gZ2wuU0hPUlQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICkge1xuXG5cdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfSU5UO1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5ICkge1xuXG5cdFx0XHR0eXBlID0gZ2wuSU5UO1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5CWVRFO1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ICkge1xuXG5cdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfQllURTtcblxuXHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVbnN1cHBvcnRlZCBidWZmZXIgZGF0YSBmb3JtYXQ6ICcgKyBhcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGJ1ZmZlcjogYnVmZmVyLFxuXHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdGJ5dGVzUGVyRWxlbWVudDogYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG5cdFx0XHR2ZXJzaW9uOiBhdHRyaWJ1dGUudmVyc2lvbixcblx0XHRcdHNpemU6IHNpemVcblx0XHR9O1xuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGJ1ZmZlciwgYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xuXG5cdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0Y29uc3QgdXBkYXRlUmFuZ2UgPSBhdHRyaWJ1dGUuX3VwZGF0ZVJhbmdlOyAvLyBAZGVwcmVjYXRlZCwgcjE1OVxuXHRcdGNvbnN0IHVwZGF0ZVJhbmdlcyA9IGF0dHJpYnV0ZS51cGRhdGVSYW5nZXM7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBidWZmZXIgKTtcblxuXHRcdGlmICggdXBkYXRlUmFuZ2UuY291bnQgPT09IC0gMSAmJiB1cGRhdGVSYW5nZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHQvLyBOb3QgdXNpbmcgdXBkYXRlIHJhbmdlc1xuXHRcdFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgMCwgYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdXBkYXRlUmFuZ2VzLmxlbmd0aCAhPT0gMCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdXBkYXRlUmFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcmFuZ2UgPSB1cGRhdGVSYW5nZXNbIGkgXTtcblxuXHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCByYW5nZS5zdGFydCAqIGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuXHRcdFx0XHRcdGFycmF5LCByYW5nZS5zdGFydCwgcmFuZ2UuY291bnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhdHRyaWJ1dGUuY2xlYXJVcGRhdGVSYW5nZXMoKTtcblxuXHRcdH1cblxuXHRcdC8vIEBkZXByZWNhdGVkLCByMTU5XG5cdFx0aWYgKCB1cGRhdGVSYW5nZS5jb3VudCAhPT0gLSAxICkge1xuXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCB1cGRhdGVSYW5nZS5vZmZzZXQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcblx0XHRcdFx0YXJyYXksIHVwZGF0ZVJhbmdlLm9mZnNldCwgdXBkYXRlUmFuZ2UuY291bnQgKTtcblxuXHRcdFx0dXBkYXRlUmFuZ2UuY291bnQgPSAtIDE7IC8vIHJlc2V0IHJhbmdlXG5cblx0XHR9XG5cblx0XHRhdHRyaWJ1dGUub25VcGxvYWRDYWxsYmFjaygpO1xuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIGdldCggYXR0cmlidXRlICkge1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xuXG5cdFx0cmV0dXJuIGJ1ZmZlcnMuZ2V0KCBhdHRyaWJ1dGUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XG5cblx0XHRjb25zdCBkYXRhID0gYnVmZmVycy5nZXQoIGF0dHJpYnV0ZSApO1xuXG5cdFx0aWYgKCBkYXRhICkge1xuXG5cdFx0XHRnbC5kZWxldGVCdWZmZXIoIGRhdGEuYnVmZmVyICk7XG5cblx0XHRcdGJ1ZmZlcnMuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZS5pc0dMQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRjb25zdCBjYWNoZWQgPSBidWZmZXJzLmdldCggYXR0cmlidXRlICk7XG5cblx0XHRcdGlmICggISBjYWNoZWQgfHwgY2FjaGVkLnZlcnNpb24gPCBhdHRyaWJ1dGUudmVyc2lvbiApIHtcblxuXHRcdFx0XHRidWZmZXJzLnNldCggYXR0cmlidXRlLCB7XG5cdFx0XHRcdFx0YnVmZmVyOiBhdHRyaWJ1dGUuYnVmZmVyLFxuXHRcdFx0XHRcdHR5cGU6IGF0dHJpYnV0ZS50eXBlLFxuXHRcdFx0XHRcdGJ5dGVzUGVyRWxlbWVudDogYXR0cmlidXRlLmVsZW1lbnRTaXplLFxuXHRcdFx0XHRcdHZlcnNpb246IGF0dHJpYnV0ZS52ZXJzaW9uXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XG5cblx0XHRjb25zdCBkYXRhID0gYnVmZmVycy5nZXQoIGF0dHJpYnV0ZSApO1xuXG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJ1ZmZlcnMuc2V0KCBhdHRyaWJ1dGUsIGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlLCBidWZmZXJUeXBlICkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGRhdGEudmVyc2lvbiA8IGF0dHJpYnV0ZS52ZXJzaW9uICkge1xuXG5cdFx0XHRpZiAoIGRhdGEuc2l6ZSAhPT0gYXR0cmlidXRlLmFycmF5LmJ5dGVMZW5ndGggKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBUaGUgc2l6ZSBvZiB0aGUgYnVmZmVyIGF0dHJpYnV0ZVxcJ3MgYXJyYXkgYnVmZmVyIGRvZXMgbm90IG1hdGNoIHRoZSBvcmlnaW5hbCBzaXplLiBSZXNpemluZyBidWZmZXIgYXR0cmlidXRlcyBpcyBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGVCdWZmZXIoIGRhdGEuYnVmZmVyLCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKTtcblxuXHRcdFx0ZGF0YS52ZXJzaW9uID0gYXR0cmlidXRlLnZlcnNpb247XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB7XG5cblx0XHRnZXQ6IGdldCxcblx0XHRyZW1vdmU6IHJlbW92ZSxcblx0XHR1cGRhdGU6IHVwZGF0ZVxuXG5cdH07XG5cbn1cblxuY2xhc3MgUGxhbmVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCB3aWR0aFNlZ21lbnRzID0gMSwgaGVpZ2h0U2VnbWVudHMgPSAxICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuXHRcdH07XG5cblx0XHRjb25zdCB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuXHRcdGNvbnN0IGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblxuXHRcdGNvbnN0IGdyaWRYID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApO1xuXHRcdGNvbnN0IGdyaWRZID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKTtcblxuXHRcdGNvbnN0IGdyaWRYMSA9IGdyaWRYICsgMTtcblx0XHRjb25zdCBncmlkWTEgPSBncmlkWSArIDE7XG5cblx0XHRjb25zdCBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcblx0XHRjb25zdCBzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcblxuXHRcdFx0Y29uc3QgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcblxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHggPSBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIC0geSwgMCApO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCBpeCAvIGdyaWRYICk7XG5cdFx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuXHRcdFx0XHRjb25zdCBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHRjb25zdCBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdGNvbnN0IGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgUGxhbmVHZW9tZXRyeSggZGF0YS53aWR0aCwgZGF0YS5oZWlnaHQsIGRhdGEud2lkdGhTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cyApO1xuXG5cdH1cblxufVxuXG52YXIgYWxwaGFoYXNoX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBSEFTSFxcblxcdGlmICggZGlmZnVzZUNvbG9yLmEgPCBnZXRBbHBoYUhhc2hUaHJlc2hvbGQoIHZQb3NpdGlvbiApICkgZGlzY2FyZDtcXG4jZW5kaWZcIjtcblxudmFyIGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBSEFTSFxcblxcdGNvbnN0IGZsb2F0IEFMUEhBX0hBU0hfU0NBTEUgPSAwLjA1O1xcblxcdGZsb2F0IGhhc2gyRCggdmVjMiB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gZnJhY3QoIDEuMGU0ICogc2luKCAxNy4wICogdmFsdWUueCArIDAuMSAqIHZhbHVlLnkgKSAqICggMC4xICsgYWJzKCBzaW4oIDEzLjAgKiB2YWx1ZS55ICsgdmFsdWUueCApICkgKSApO1xcblxcdH1cXG5cXHRmbG9hdCBoYXNoM0QoIHZlYzMgdmFsdWUgKSB7XFxuXFx0XFx0cmV0dXJuIGhhc2gyRCggdmVjMiggaGFzaDJEKCB2YWx1ZS54eSApLCB2YWx1ZS56ICkgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0QWxwaGFIYXNoVGhyZXNob2xkKCB2ZWMzIHBvc2l0aW9uICkge1xcblxcdFxcdGZsb2F0IG1heERlcml2ID0gbWF4KFxcblxcdFxcdFxcdGxlbmd0aCggZEZkeCggcG9zaXRpb24ueHl6ICkgKSxcXG5cXHRcXHRcXHRsZW5ndGgoIGRGZHkoIHBvc2l0aW9uLnh5eiApIClcXG5cXHRcXHQpO1xcblxcdFxcdGZsb2F0IHBpeFNjYWxlID0gMS4wIC8gKCBBTFBIQV9IQVNIX1NDQUxFICogbWF4RGVyaXYgKTtcXG5cXHRcXHR2ZWMyIHBpeFNjYWxlcyA9IHZlYzIoXFxuXFx0XFx0XFx0ZXhwMiggZmxvb3IoIGxvZzIoIHBpeFNjYWxlICkgKSApLFxcblxcdFxcdFxcdGV4cDIoIGNlaWwoIGxvZzIoIHBpeFNjYWxlICkgKSApXFxuXFx0XFx0KTtcXG5cXHRcXHR2ZWMyIGFscGhhID0gdmVjMihcXG5cXHRcXHRcXHRoYXNoM0QoIGZsb29yKCBwaXhTY2FsZXMueCAqIHBvc2l0aW9uLnh5eiApICksXFxuXFx0XFx0XFx0aGFzaDNEKCBmbG9vciggcGl4U2NhbGVzLnkgKiBwb3NpdGlvbi54eXogKSApXFxuXFx0XFx0KTtcXG5cXHRcXHRmbG9hdCBsZXJwRmFjdG9yID0gZnJhY3QoIGxvZzIoIHBpeFNjYWxlICkgKTtcXG5cXHRcXHRmbG9hdCB4ID0gKCAxLjAgLSBsZXJwRmFjdG9yICkgKiBhbHBoYS54ICsgbGVycEZhY3RvciAqIGFscGhhLnk7XFxuXFx0XFx0ZmxvYXQgYSA9IG1pbiggbGVycEZhY3RvciwgMS4wIC0gbGVycEZhY3RvciApO1xcblxcdFxcdHZlYzMgY2FzZXMgPSB2ZWMzKFxcblxcdFxcdFxcdHggKiB4IC8gKCAyLjAgKiBhICogKCAxLjAgLSBhICkgKSxcXG5cXHRcXHRcXHQoIHggLSAwLjUgKiBhICkgLyAoIDEuMCAtIGEgKSxcXG5cXHRcXHRcXHQxLjAgLSAoICggMS4wIC0geCApICogKCAxLjAgLSB4ICkgLyAoIDIuMCAqIGEgKiAoIDEuMCAtIGEgKSApIClcXG5cXHRcXHQpO1xcblxcdFxcdGZsb2F0IHRocmVzaG9sZCA9ICggeCA8ICggMS4wIC0gYSApIClcXG5cXHRcXHRcXHQ/ICggKCB4IDwgYSApID8gY2FzZXMueCA6IGNhc2VzLnkgKVxcblxcdFxcdFxcdDogY2FzZXMuejtcXG5cXHRcXHRyZXR1cm4gY2xhbXAoIHRocmVzaG9sZCAsIDEuMGUtNiwgMS4wICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgYWxwaGFtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2QWxwaGFNYXBVdiApLmc7XFxuI2VuZGlmXCI7XG5cbnZhciBhbHBoYW1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBhbHBoYXRlc3RfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQUxQSEFURVNUXFxuXFx0I2lmZGVmIEFMUEhBX1RPX0NPVkVSQUdFXFxuXFx0ZGlmZnVzZUNvbG9yLmEgPSBzbW9vdGhzdGVwKCBhbHBoYVRlc3QsIGFscGhhVGVzdCArIGZ3aWR0aCggZGlmZnVzZUNvbG9yLmEgKSwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHRpZiAoIGRpZmZ1c2VDb2xvci5hID09IDAuMCApIGRpc2NhcmQ7XFxuXFx0I2Vsc2VcXG5cXHRpZiAoIGRpZmZ1c2VDb2xvci5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBVEVTVFxcblxcdHVuaWZvcm0gZmxvYXQgYWxwaGFUZXN0O1xcbiNlbmRpZlwiO1xuXG52YXIgYW9tYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXHRmbG9hdCBhbWJpZW50T2NjbHVzaW9uID0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2QW9NYXBVdiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBhbWJpZW50T2NjbHVzaW9uO1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfQ0xFQVJDT0FUICkgXFxuXFx0XFx0Y2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCAqPSBhbWJpZW50T2NjbHVzaW9uO1xcblxcdCNlbmRpZlxcblxcdCNpZiBkZWZpbmVkKCBVU0VfU0hFRU4gKSBcXG5cXHRcXHRzaGVlblNwZWN1bGFySW5kaXJlY3QgKj0gYW1iaWVudE9jY2x1c2lvbjtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEIClcXG5cXHRcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIgKSApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKj0gY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBkb3ROViwgYW1iaWVudE9jY2x1c2lvbiwgbWF0ZXJpYWwucm91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBhb21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXG4jZW5kaWZcIjtcblxudmFyIGJhdGNoaW5nX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0JBVENISU5HXFxuXFx0YXR0cmlidXRlIGZsb2F0IGJhdGNoSWQ7XFxuXFx0dW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgYmF0Y2hpbmdUZXh0dXJlO1xcblxcdG1hdDQgZ2V0QmF0Y2hpbmdNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0aW50IHNpemUgPSB0ZXh0dXJlU2l6ZSggYmF0Y2hpbmdUZXh0dXJlLCAwICkueDtcXG5cXHRcXHRpbnQgaiA9IGludCggaSApICogNDtcXG5cXHRcXHRpbnQgeCA9IGogJSBzaXplO1xcblxcdFxcdGludCB5ID0gaiAvIHNpemU7XFxuXFx0XFx0dmVjNCB2MSA9IHRleGVsRmV0Y2goIGJhdGNoaW5nVGV4dHVyZSwgaXZlYzIoIHgsIHkgKSwgMCApO1xcblxcdFxcdHZlYzQgdjIgPSB0ZXhlbEZldGNoKCBiYXRjaGluZ1RleHR1cmUsIGl2ZWMyKCB4ICsgMSwgeSApLCAwICk7XFxuXFx0XFx0dmVjNCB2MyA9IHRleGVsRmV0Y2goIGJhdGNoaW5nVGV4dHVyZSwgaXZlYzIoIHggKyAyLCB5ICksIDAgKTtcXG5cXHRcXHR2ZWM0IHY0ID0gdGV4ZWxGZXRjaCggYmF0Y2hpbmdUZXh0dXJlLCBpdmVjMiggeCArIDMsIHkgKSwgMCApO1xcblxcdFxcdHJldHVybiBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0JBVENISU5HX0NPTE9SXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYmF0Y2hpbmdDb2xvclRleHR1cmU7XFxuXFx0dmVjMyBnZXRCYXRjaGluZ0NvbG9yKCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdGludCBzaXplID0gdGV4dHVyZVNpemUoIGJhdGNoaW5nQ29sb3JUZXh0dXJlLCAwICkueDtcXG5cXHRcXHRpbnQgaiA9IGludCggaSApO1xcblxcdFxcdGludCB4ID0gaiAlIHNpemU7XFxuXFx0XFx0aW50IHkgPSBqIC8gc2l6ZTtcXG5cXHRcXHRyZXR1cm4gdGV4ZWxGZXRjaCggYmF0Y2hpbmdDb2xvclRleHR1cmUsIGl2ZWMyKCB4LCB5ICksIDAgKS5yZ2I7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgYmF0Y2hpbmdfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0JBVENISU5HXFxuXFx0bWF0NCBiYXRjaGluZ01hdHJpeCA9IGdldEJhdGNoaW5nTWF0cml4KCBiYXRjaElkICk7XFxuI2VuZGlmXCI7XG5cbnZhciBiZWdpbl92ZXJ0ZXggPSBcInZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xcbiNpZmRlZiBVU0VfQUxQSEFIQVNIXFxuXFx0dlBvc2l0aW9uID0gdmVjMyggcG9zaXRpb24gKTtcXG4jZW5kaWZcIjtcblxudmFyIGJlZ2lubm9ybWFsX3ZlcnRleCA9IFwidmVjMyBvYmplY3ROb3JtYWwgPSB2ZWMzKCBub3JtYWwgKTtcXG4jaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHR2ZWMzIG9iamVjdFRhbmdlbnQgPSB2ZWMzKCB0YW5nZW50Lnh5eiApO1xcbiNlbmRpZlwiO1xuXG52YXIgYnNkZnMgPSBcImZsb2F0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKSB7XFxuXFx0cmV0dXJuIDAuMjU7XFxufVxcbmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXG59XFxudmVjMyBCUkRGX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzICkge1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7XFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCAxLjAsIGRvdFZIICk7XFxuXFx0ZmxvYXQgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKTtcXG5cXHRmbG9hdCBEID0gRF9CbGlublBob25nKCBzaGluaW5lc3MsIGRvdE5IICk7XFxuXFx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxufSAvLyB2YWxpZGF0ZWRcIjtcblxudmFyIGlyaWRlc2NlbmNlX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxuXFx0Y29uc3QgbWF0MyBYWVpfVE9fUkVDNzA5ID0gbWF0MyhcXG5cXHRcXHQgMy4yNDA0NTQyLCAtMC45NjkyNjYwLCAgMC4wNTU2NDM0LFxcblxcdFxcdC0xLjUzNzEzODUsICAxLjg3NjAxMDgsIC0wLjIwNDAyNTksXFxuXFx0XFx0LTAuNDk4NTMxNCwgIDAuMDQxNTU2MCwgIDEuMDU3MjI1MlxcblxcdCk7XFxuXFx0dmVjMyBGcmVzbmVsMFRvSW9yKCB2ZWMzIGZyZXNuZWwwICkge1xcblxcdFxcdHZlYzMgc3FydEYwID0gc3FydCggZnJlc25lbDAgKTtcXG5cXHRcXHRyZXR1cm4gKCB2ZWMzKCAxLjAgKSArIHNxcnRGMCApIC8gKCB2ZWMzKCAxLjAgKSAtIHNxcnRGMCApO1xcblxcdH1cXG5cXHR2ZWMzIElvclRvRnJlc25lbDAoIHZlYzMgdHJhbnNtaXR0ZWRJb3IsIGZsb2F0IGluY2lkZW50SW9yICkge1xcblxcdFxcdHJldHVybiBwb3cyKCAoIHRyYW5zbWl0dGVkSW9yIC0gdmVjMyggaW5jaWRlbnRJb3IgKSApIC8gKCB0cmFuc21pdHRlZElvciArIHZlYzMoIGluY2lkZW50SW9yICkgKSApO1xcblxcdH1cXG5cXHRmbG9hdCBJb3JUb0ZyZXNuZWwwKCBmbG9hdCB0cmFuc21pdHRlZElvciwgZmxvYXQgaW5jaWRlbnRJb3IgKSB7XFxuXFx0XFx0cmV0dXJuIHBvdzIoICggdHJhbnNtaXR0ZWRJb3IgLSBpbmNpZGVudElvciApIC8gKCB0cmFuc21pdHRlZElvciArIGluY2lkZW50SW9yICkpO1xcblxcdH1cXG5cXHR2ZWMzIGV2YWxTZW5zaXRpdml0eSggZmxvYXQgT1BELCB2ZWMzIHNoaWZ0ICkge1xcblxcdFxcdGZsb2F0IHBoYXNlID0gMi4wICogUEkgKiBPUEQgKiAxLjBlLTk7XFxuXFx0XFx0dmVjMyB2YWwgPSB2ZWMzKCA1LjQ4NTZlLTEzLCA0LjQyMDFlLTEzLCA1LjI0ODFlLTEzICk7XFxuXFx0XFx0dmVjMyBwb3MgPSB2ZWMzKCAxLjY4MTBlKzA2LCAxLjc5NTNlKzA2LCAyLjIwODRlKzA2ICk7XFxuXFx0XFx0dmVjMyB2YXIgPSB2ZWMzKCA0LjMyNzhlKzA5LCA5LjMwNDZlKzA5LCA2LjYxMjFlKzA5ICk7XFxuXFx0XFx0dmVjMyB4eXogPSB2YWwgKiBzcXJ0KCAyLjAgKiBQSSAqIHZhciApICogY29zKCBwb3MgKiBwaGFzZSArIHNoaWZ0ICkgKiBleHAoIC0gcG93MiggcGhhc2UgKSAqIHZhciApO1xcblxcdFxcdHh5ei54ICs9IDkuNzQ3MGUtMTQgKiBzcXJ0KCAyLjAgKiBQSSAqIDQuNTI4MmUrMDkgKSAqIGNvcyggMi4yMzk5ZSswNiAqIHBoYXNlICsgc2hpZnRbIDAgXSApICogZXhwKCAtIDQuNTI4MmUrMDkgKiBwb3cyKCBwaGFzZSApICk7XFxuXFx0XFx0eHl6IC89IDEuMDY4NWUtNztcXG5cXHRcXHR2ZWMzIHJnYiA9IFhZWl9UT19SRUM3MDkgKiB4eXo7XFxuXFx0XFx0cmV0dXJuIHJnYjtcXG5cXHR9XFxuXFx0dmVjMyBldmFsSXJpZGVzY2VuY2UoIGZsb2F0IG91dHNpZGVJT1IsIGZsb2F0IGV0YTIsIGZsb2F0IGNvc1RoZXRhMSwgZmxvYXQgdGhpbkZpbG1UaGlja25lc3MsIHZlYzMgYmFzZUYwICkge1xcblxcdFxcdHZlYzMgSTtcXG5cXHRcXHRmbG9hdCBpcmlkZXNjZW5jZUlPUiA9IG1peCggb3V0c2lkZUlPUiwgZXRhMiwgc21vb3Roc3RlcCggMC4wLCAwLjAzLCB0aGluRmlsbVRoaWNrbmVzcyApICk7XFxuXFx0XFx0ZmxvYXQgc2luVGhldGEyU3EgPSBwb3cyKCBvdXRzaWRlSU9SIC8gaXJpZGVzY2VuY2VJT1IgKSAqICggMS4wIC0gcG93MiggY29zVGhldGExICkgKTtcXG5cXHRcXHRmbG9hdCBjb3NUaGV0YTJTcSA9IDEuMCAtIHNpblRoZXRhMlNxO1xcblxcdFxcdGlmICggY29zVGhldGEyU3EgPCAwLjAgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZlYzMoIDEuMCApO1xcblxcdFxcdH1cXG5cXHRcXHRmbG9hdCBjb3NUaGV0YTIgPSBzcXJ0KCBjb3NUaGV0YTJTcSApO1xcblxcdFxcdGZsb2F0IFIwID0gSW9yVG9GcmVzbmVsMCggaXJpZGVzY2VuY2VJT1IsIG91dHNpZGVJT1IgKTtcXG5cXHRcXHRmbG9hdCBSMTIgPSBGX1NjaGxpY2soIFIwLCAxLjAsIGNvc1RoZXRhMSApO1xcblxcdFxcdGZsb2F0IFQxMjEgPSAxLjAgLSBSMTI7XFxuXFx0XFx0ZmxvYXQgcGhpMTIgPSAwLjA7XFxuXFx0XFx0aWYgKCBpcmlkZXNjZW5jZUlPUiA8IG91dHNpZGVJT1IgKSBwaGkxMiA9IFBJO1xcblxcdFxcdGZsb2F0IHBoaTIxID0gUEkgLSBwaGkxMjtcXG5cXHRcXHR2ZWMzIGJhc2VJT1IgPSBGcmVzbmVsMFRvSW9yKCBjbGFtcCggYmFzZUYwLCAwLjAsIDAuOTk5OSApICk7XFx0XFx0dmVjMyBSMSA9IElvclRvRnJlc25lbDAoIGJhc2VJT1IsIGlyaWRlc2NlbmNlSU9SICk7XFxuXFx0XFx0dmVjMyBSMjMgPSBGX1NjaGxpY2soIFIxLCAxLjAsIGNvc1RoZXRhMiApO1xcblxcdFxcdHZlYzMgcGhpMjMgPSB2ZWMzKCAwLjAgKTtcXG5cXHRcXHRpZiAoIGJhc2VJT1JbIDAgXSA8IGlyaWRlc2NlbmNlSU9SICkgcGhpMjNbIDAgXSA9IFBJO1xcblxcdFxcdGlmICggYmFzZUlPUlsgMSBdIDwgaXJpZGVzY2VuY2VJT1IgKSBwaGkyM1sgMSBdID0gUEk7XFxuXFx0XFx0aWYgKCBiYXNlSU9SWyAyIF0gPCBpcmlkZXNjZW5jZUlPUiApIHBoaTIzWyAyIF0gPSBQSTtcXG5cXHRcXHRmbG9hdCBPUEQgPSAyLjAgKiBpcmlkZXNjZW5jZUlPUiAqIHRoaW5GaWxtVGhpY2tuZXNzICogY29zVGhldGEyO1xcblxcdFxcdHZlYzMgcGhpID0gdmVjMyggcGhpMjEgKSArIHBoaTIzO1xcblxcdFxcdHZlYzMgUjEyMyA9IGNsYW1wKCBSMTIgKiBSMjMsIDFlLTUsIDAuOTk5OSApO1xcblxcdFxcdHZlYzMgcjEyMyA9IHNxcnQoIFIxMjMgKTtcXG5cXHRcXHR2ZWMzIFJzID0gcG93MiggVDEyMSApICogUjIzIC8gKCB2ZWMzKCAxLjAgKSAtIFIxMjMgKTtcXG5cXHRcXHR2ZWMzIEMwID0gUjEyICsgUnM7XFxuXFx0XFx0SSA9IEMwO1xcblxcdFxcdHZlYzMgQ20gPSBScyAtIFQxMjE7XFxuXFx0XFx0Zm9yICggaW50IG0gPSAxOyBtIDw9IDI7ICsrIG0gKSB7XFxuXFx0XFx0XFx0Q20gKj0gcjEyMztcXG5cXHRcXHRcXHR2ZWMzIFNtID0gMi4wICogZXZhbFNlbnNpdGl2aXR5KCBmbG9hdCggbSApICogT1BELCBmbG9hdCggbSApICogcGhpICk7XFxuXFx0XFx0XFx0SSArPSBDbSAqIFNtO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gbWF4KCBJLCB2ZWMzKCAwLjAgKSApO1xcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIGJ1bXBtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTtcXG5cXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cXHRcXHR2ZWMyIGRTVGR4ID0gZEZkeCggdkJ1bXBNYXBVdiApO1xcblxcdFxcdHZlYzIgZFNUZHkgPSBkRmR5KCB2QnVtcE1hcFV2ICk7XFxuXFx0XFx0ZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2QnVtcE1hcFV2ICkueDtcXG5cXHRcXHRmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZCdW1wTWFwVXYgKyBkU1RkeCApLnggLSBIbGw7XFxuXFx0XFx0ZmxvYXQgZEJ5ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2QnVtcE1hcFV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcdFxcdHJldHVybiB2ZWMyKCBkQngsIGRCeSApO1xcblxcdH1cXG5cXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5LCBmbG9hdCBmYWNlRGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgdlNpZ21hWCA9IG5vcm1hbGl6ZSggZEZkeCggc3VyZl9wb3MueHl6ICkgKTtcXG5cXHRcXHR2ZWMzIHZTaWdtYVkgPSBub3JtYWxpemUoIGRGZHkoIHN1cmZfcG9zLnh5eiApICk7XFxuXFx0XFx0dmVjMyB2TiA9IHN1cmZfbm9ybTtcXG5cXHRcXHR2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxuXFx0XFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcblxcdFxcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICkgKiBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQgPSBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxcblxcdHZlYzQgcGxhbmU7XFxuXFx0I2lmZGVmIEFMUEhBX1RPX0NPVkVSQUdFXFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2VUb1BsYW5lLCBkaXN0YW5jZUdyYWRpZW50O1xcblxcdFxcdGZsb2F0IGNsaXBPcGFjaXR5ID0gMS4wO1xcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBVTklPTl9DTElQUElOR19QTEFORVM7IGkgKysgKSB7XFxuXFx0XFx0XFx0cGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdO1xcblxcdFxcdFxcdGRpc3RhbmNlVG9QbGFuZSA9IC0gZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSArIHBsYW5lLnc7XFxuXFx0XFx0XFx0ZGlzdGFuY2VHcmFkaWVudCA9IGZ3aWR0aCggZGlzdGFuY2VUb1BsYW5lICkgLyAyLjA7XFxuXFx0XFx0XFx0Y2xpcE9wYWNpdHkgKj0gc21vb3Roc3RlcCggLSBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZVRvUGxhbmUgKTtcXG5cXHRcXHRcXHRpZiAoIGNsaXBPcGFjaXR5ID09IDAuMCApIGRpc2NhcmQ7XFxuXFx0XFx0fVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0XFx0I2lmIFVOSU9OX0NMSVBQSU5HX1BMQU5FUyA8IE5VTV9DTElQUElOR19QTEFORVNcXG5cXHRcXHRcXHRmbG9hdCB1bmlvbkNsaXBPcGFjaXR5ID0gMS4wO1xcblxcdFxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRcXHRmb3IgKCBpbnQgaSA9IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSA8IE5VTV9DTElQUElOR19QTEFORVM7IGkgKysgKSB7XFxuXFx0XFx0XFx0XFx0cGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdO1xcblxcdFxcdFxcdFxcdGRpc3RhbmNlVG9QbGFuZSA9IC0gZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSArIHBsYW5lLnc7XFxuXFx0XFx0XFx0XFx0ZGlzdGFuY2VHcmFkaWVudCA9IGZ3aWR0aCggZGlzdGFuY2VUb1BsYW5lICkgLyAyLjA7XFxuXFx0XFx0XFx0XFx0dW5pb25DbGlwT3BhY2l0eSAqPSAxLjAgLSBzbW9vdGhzdGVwKCAtIGRpc3RhbmNlR3JhZGllbnQsIGRpc3RhbmNlR3JhZGllbnQsIGRpc3RhbmNlVG9QbGFuZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdFxcdFxcdGNsaXBPcGFjaXR5ICo9IDEuMCAtIHVuaW9uQ2xpcE9wYWNpdHk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLmEgKj0gY2xpcE9wYWNpdHk7XFxuXFx0XFx0aWYgKCBkaWZmdXNlQ29sb3IuYSA9PSAwLjAgKSBkaXNjYXJkO1xcblxcdCNlbHNlXFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHtcXG5cXHRcXHRcXHRwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxuXFx0XFx0XFx0aWYgKCBkb3QoIHZDbGlwUG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApIGRpc2NhcmQ7XFxuXFx0XFx0fVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0XFx0I2lmIFVOSU9OX0NMSVBQSU5HX1BMQU5FUyA8IE5VTV9DTElQUElOR19QTEFORVNcXG5cXHRcXHRcXHRib29sIGNsaXBwZWQgPSB0cnVlO1xcblxcdFxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRcXHRmb3IgKCBpbnQgaSA9IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSA8IE5VTV9DTElQUElOR19QTEFORVM7IGkgKysgKSB7XFxuXFx0XFx0XFx0XFx0cGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdO1xcblxcdFxcdFxcdFxcdGNsaXBwZWQgPSAoIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgJiYgY2xpcHBlZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHRcXHRcXHRpZiAoIGNsaXBwZWQgKSBkaXNjYXJkO1xcblxcdFxcdCNlbmRpZlxcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxcblxcdHZhcnlpbmcgdmVjMyB2Q2xpcFBvc2l0aW9uO1xcblxcdHVuaWZvcm0gdmVjNCBjbGlwcGluZ1BsYW5lc1sgTlVNX0NMSVBQSU5HX1BMQU5FUyBdO1xcbiNlbmRpZlwiO1xuXG52YXIgY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjtcXG4jZW5kaWZcIjtcblxudmFyIGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXggPSBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxcblxcdHZDbGlwUG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcbiNlbmRpZlwiO1xuXG52YXIgY29sb3JfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxcblxcdGRpZmZ1c2VDb2xvciAqPSB2Q29sb3I7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SIClcXG5cXHRkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjtcXG4jZW5kaWZcIjtcblxudmFyIGNvbG9yX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxcblxcdHZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SIClcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlwiO1xuXG52YXIgY29sb3JfcGFyc192ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxcblxcdHZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SICkgfHwgZGVmaW5lZCggVVNFX0lOU1RBTkNJTkdfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfQkFUQ0hJTkdfQ09MT1IgKVxcblxcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXCI7XG5cbnZhciBjb2xvcl92ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxcblxcdHZDb2xvciA9IHZlYzQoIDEuMCApO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApIHx8IGRlZmluZWQoIFVTRV9JTlNUQU5DSU5HX0NPTE9SICkgfHwgZGVmaW5lZCggVVNFX0JBVENISU5HX0NPTE9SIClcXG5cXHR2Q29sb3IgPSB2ZWMzKCAxLjAgKTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NPTE9SXFxuXFx0dkNvbG9yICo9IGNvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUlxcblxcdHZDb2xvci54eXogKj0gaW5zdGFuY2VDb2xvci54eXo7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9CQVRDSElOR19DT0xPUlxcblxcdHZlYzMgYmF0Y2hpbmdDb2xvciA9IGdldEJhdGNoaW5nQ29sb3IoIGJhdGNoSWQgKTtcXG5cXHR2Q29sb3IueHl6ICo9IGJhdGNoaW5nQ29sb3IueHl6O1xcbiNlbmRpZlwiO1xuXG52YXIgY29tbW9uID0gXCIjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzXFxuI2RlZmluZSBQSTIgNi4yODMxODUzMDcxNzk1ODZcXG4jZGVmaW5lIFBJX0hBTEYgMS41NzA3OTYzMjY3OTQ4OTY2XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJIDAuMzE4MzA5ODg2MTgzNzkwN1xcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NDMwOTE4OTUzNVxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxuI2lmbmRlZiBzYXR1cmF0ZVxcbiNkZWZpbmUgc2F0dXJhdGUoIGEgKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNlbmRpZlxcbiNkZWZpbmUgd2hpdGVDb21wbGVtZW50KCBhICkgKCAxLjAgLSBzYXR1cmF0ZSggYSApIClcXG5mbG9hdCBwb3cyKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4OyB9XFxudmVjMyBwb3cyKCBjb25zdCBpbiB2ZWMzIHggKSB7IHJldHVybiB4Kng7IH1cXG5mbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH1cXG5mbG9hdCBwb3c0KCBjb25zdCBpbiBmbG9hdCB4ICkgeyBmbG9hdCB4MiA9IHgqeDsgcmV0dXJuIHgyKngyOyB9XFxuZmxvYXQgbWF4MyggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gbWF4KCBtYXgoIHYueCwgdi55ICksIHYueiApOyB9XFxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gZG90KCB2LCB2ZWMzKCAwLjMzMzMzMzMgKSApOyB9XFxuaGlnaHAgZmxvYXQgcmFuZCggY29uc3QgaW4gdmVjMiB1diApIHtcXG5cXHRjb25zdCBoaWdocCBmbG9hdCBhID0gMTIuOTg5OCwgYiA9IDc4LjIzMywgYyA9IDQzNzU4LjU0NTM7XFxuXFx0aGlnaHAgZmxvYXQgZHQgPSBkb3QoIHV2Lnh5LCB2ZWMyKCBhLGIgKSApLCBzbiA9IG1vZCggZHQsIFBJICk7XFxuXFx0cmV0dXJuIGZyYWN0KCBzaW4oIHNuICkgKiBjICk7XFxufVxcbiNpZmRlZiBISUdIX1BSRUNJU0lPTlxcblxcdGZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHsgcmV0dXJuIGxlbmd0aCggdiApOyB9XFxuI2Vsc2VcXG5cXHRmbG9hdCBwcmVjaXNpb25TYWZlTGVuZ3RoKCB2ZWMzIHYgKSB7XFxuXFx0XFx0ZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4MyggYWJzKCB2ICkgKTtcXG5cXHRcXHRyZXR1cm4gbGVuZ3RoKCB2IC8gbWF4Q29tcG9uZW50ICkgKiBtYXhDb21wb25lbnQ7XFxuXFx0fVxcbiNlbmRpZlxcbnN0cnVjdCBJbmNpZGVudExpZ2h0IHtcXG5cXHR2ZWMzIGNvbG9yO1xcblxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdGJvb2wgdmlzaWJsZTtcXG59O1xcbnN0cnVjdCBSZWZsZWN0ZWRMaWdodCB7XFxuXFx0dmVjMyBkaXJlY3REaWZmdXNlO1xcblxcdHZlYzMgZGlyZWN0U3BlY3VsYXI7XFxuXFx0dmVjMyBpbmRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBpbmRpcmVjdFNwZWN1bGFyO1xcbn07XFxuI2lmZGVmIFVTRV9BTFBIQUhBU0hcXG5cXHR2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xcbiNlbmRpZlxcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxufVxcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcblxcdHJldHVybiBub3JtYWxpemUoICggdmVjNCggZGlyLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcbn1cXG5tYXQzIHRyYW5zcG9zZU1hdDMoIGNvbnN0IGluIG1hdDMgbSApIHtcXG5cXHRtYXQzIHRtcDtcXG5cXHR0bXBbIDAgXSA9IHZlYzMoIG1bIDAgXS54LCBtWyAxIF0ueCwgbVsgMiBdLnggKTtcXG5cXHR0bXBbIDEgXSA9IHZlYzMoIG1bIDAgXS55LCBtWyAxIF0ueSwgbVsgMiBdLnkgKTtcXG5cXHR0bXBbIDIgXSA9IHZlYzMoIG1bIDAgXS56LCBtWyAxIF0ueiwgbVsgMiBdLnogKTtcXG5cXHRyZXR1cm4gdG1wO1xcbn1cXG5mbG9hdCBsdW1pbmFuY2UoIGNvbnN0IGluIHZlYzMgcmdiICkge1xcblxcdGNvbnN0IHZlYzMgd2VpZ2h0cyA9IHZlYzMoIDAuMjEyNjcyOSwgMC43MTUxNTIyLCAwLjA3MjE3NTAgKTtcXG5cXHRyZXR1cm4gZG90KCB3ZWlnaHRzLCByZ2IgKTtcXG59XFxuYm9vbCBpc1BlcnNwZWN0aXZlTWF0cml4KCBtYXQ0IG0gKSB7XFxuXFx0cmV0dXJuIG1bIDIgXVsgMyBdID09IC0gMS4wO1xcbn1cXG52ZWMyIGVxdWlyZWN0VXYoIGluIHZlYzMgZGlyICkge1xcblxcdGZsb2F0IHUgPSBhdGFuKCBkaXIueiwgZGlyLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblxcdGZsb2F0IHYgPSBhc2luKCBjbGFtcCggZGlyLnksIC0gMS4wLCAxLjAgKSApICogUkVDSVBST0NBTF9QSSArIDAuNTtcXG5cXHRyZXR1cm4gdmVjMiggdSwgdiApO1xcbn1cXG52ZWMzIEJSREZfTGFtYmVydCggY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IgKSB7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBkaWZmdXNlQ29sb3I7XFxufVxcbnZlYzMgRl9TY2hsaWNrKCBjb25zdCBpbiB2ZWMzIGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkge1xcblxcdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC0gNS41NTQ3MyAqIGRvdFZIIC0gNi45ODMxNiApICogZG90VkggKTtcXG5cXHRyZXR1cm4gZjAgKiAoIDEuMCAtIGZyZXNuZWwgKSArICggZjkwICogZnJlc25lbCApO1xcbn1cXG5mbG9hdCBGX1NjaGxpY2soIGNvbnN0IGluIGZsb2F0IGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkge1xcblxcdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC0gNS41NTQ3MyAqIGRvdFZIIC0gNi45ODMxNiApICogZG90VkggKTtcXG5cXHRyZXR1cm4gZjAgKiAoIDEuMCAtIGZyZXNuZWwgKSArICggZjkwICogZnJlc25lbCApO1xcbn0gLy8gdmFsaWRhdGVkXCI7XG5cbnZhciBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQgPSBcIiNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuXFx0I2RlZmluZSBjdWJlVVZfbWluTWlwTGV2ZWwgNC4wXFxuXFx0I2RlZmluZSBjdWJlVVZfbWluVGlsZVNpemUgMTYuMFxcblxcdGZsb2F0IGdldEZhY2UoIHZlYzMgZGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgYWJzRGlyZWN0aW9uID0gYWJzKCBkaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBmYWNlID0gLSAxLjA7XFxuXFx0XFx0aWYgKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi56ICkge1xcblxcdFxcdFxcdGlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi54ID4gMC4wID8gMC4wIDogMy4wO1xcblxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxLjAgOiA0LjA7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRpZiAoIGFic0RpcmVjdGlvbi56ID4gYWJzRGlyZWN0aW9uLnkgKVxcblxcdFxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueiA+IDAuMCA/IDIuMCA6IDUuMDtcXG5cXHRcXHRcXHRlbHNlXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMS4wIDogNC4wO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZmFjZTtcXG5cXHR9XFxuXFx0dmVjMiBnZXRVViggdmVjMyBkaXJlY3Rpb24sIGZsb2F0IGZhY2UgKSB7XFxuXFx0XFx0dmVjMiB1djtcXG5cXHRcXHRpZiAoIGZhY2UgPT0gMC4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCAtIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAyLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApO1xcblxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTtcXG5cXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gMC41ICogKCB1diArIDEuMCApO1xcblxcdH1cXG5cXHR2ZWMzIGJpbGluZWFyQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgbWlwSW50ICkge1xcblxcdFxcdGZsb2F0IGZhY2UgPSBnZXRGYWNlKCBkaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBmaWx0ZXJJbnQgPSBtYXgoIGN1YmVVVl9taW5NaXBMZXZlbCAtIG1pcEludCwgMC4wICk7XFxuXFx0XFx0bWlwSW50ID0gbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApO1xcblxcdFxcdGZsb2F0IGZhY2VTaXplID0gZXhwMiggbWlwSW50ICk7XFxuXFx0XFx0aGlnaHAgdmVjMiB1diA9IGdldFVWKCBkaXJlY3Rpb24sIGZhY2UgKSAqICggZmFjZVNpemUgLSAyLjAgKSArIDEuMDtcXG5cXHRcXHRpZiAoIGZhY2UgPiAyLjAgKSB7XFxuXFx0XFx0XFx0dXYueSArPSBmYWNlU2l6ZTtcXG5cXHRcXHRcXHRmYWNlIC09IDMuMDtcXG5cXHRcXHR9XFxuXFx0XFx0dXYueCArPSBmYWNlICogZmFjZVNpemU7XFxuXFx0XFx0dXYueCArPSBmaWx0ZXJJbnQgKiAzLjAgKiBjdWJlVVZfbWluVGlsZVNpemU7XFxuXFx0XFx0dXYueSArPSA0LjAgKiAoIGV4cDIoIENVQkVVVl9NQVhfTUlQICkgLSBmYWNlU2l6ZSApO1xcblxcdFxcdHV2LnggKj0gQ1VCRVVWX1RFWEVMX1dJRFRIO1xcblxcdFxcdHV2LnkgKj0gQ1VCRVVWX1RFWEVMX0hFSUdIVDtcXG5cXHRcXHQjaWZkZWYgdGV4dHVyZTJER3JhZEVYVFxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkRHcmFkRVhUKCBlbnZNYXAsIHV2LCB2ZWMyKCAwLjAgKSwgdmVjMiggMC4wICkgKS5yZ2I7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTJEKCBlbnZNYXAsIHV2ICkucmdiO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHQjZGVmaW5lIGN1YmVVVl9yMCAxLjBcXG5cXHQjZGVmaW5lIGN1YmVVVl9tMCAtIDIuMFxcblxcdCNkZWZpbmUgY3ViZVVWX3IxIDAuOFxcblxcdCNkZWZpbmUgY3ViZVVWX20xIC0gMS4wXFxuXFx0I2RlZmluZSBjdWJlVVZfcjQgMC40XFxuXFx0I2RlZmluZSBjdWJlVVZfbTQgMi4wXFxuXFx0I2RlZmluZSBjdWJlVVZfcjUgMC4zMDVcXG5cXHQjZGVmaW5lIGN1YmVVVl9tNSAzLjBcXG5cXHQjZGVmaW5lIGN1YmVVVl9yNiAwLjIxXFxuXFx0I2RlZmluZSBjdWJlVVZfbTYgNC4wXFxuXFx0ZmxvYXQgcm91Z2huZXNzVG9NaXAoIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRcXHRmbG9hdCBtaXAgPSAwLjA7XFxuXFx0XFx0aWYgKCByb3VnaG5lc3MgPj0gY3ViZVVWX3IxICkge1xcblxcdFxcdFxcdG1pcCA9ICggY3ViZVVWX3IwIC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tMSAtIGN1YmVVVl9tMCApIC8gKCBjdWJlVVZfcjAgLSBjdWJlVVZfcjEgKSArIGN1YmVVVl9tMDtcXG5cXHRcXHR9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gY3ViZVVWX3I0ICkge1xcblxcdFxcdFxcdG1pcCA9ICggY3ViZVVWX3IxIC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tNCAtIGN1YmVVVl9tMSApIC8gKCBjdWJlVVZfcjEgLSBjdWJlVVZfcjQgKSArIGN1YmVVVl9tMTtcXG5cXHRcXHR9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gY3ViZVVWX3I1ICkge1xcblxcdFxcdFxcdG1pcCA9ICggY3ViZVVWX3I0IC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tNSAtIGN1YmVVVl9tNCApIC8gKCBjdWJlVVZfcjQgLSBjdWJlVVZfcjUgKSArIGN1YmVVVl9tNDtcXG5cXHRcXHR9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gY3ViZVVWX3I2ICkge1xcblxcdFxcdFxcdG1pcCA9ICggY3ViZVVWX3I1IC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tNiAtIGN1YmVVVl9tNSApIC8gKCBjdWJlVVZfcjUgLSBjdWJlVVZfcjYgKSArIGN1YmVVVl9tNTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG1pcCA9IC0gMi4wICogbG9nMiggMS4xNiAqIHJvdWdobmVzcyApO1xcdFxcdH1cXG5cXHRcXHRyZXR1cm4gbWlwO1xcblxcdH1cXG5cXHR2ZWM0IHRleHR1cmVDdWJlVVYoIHNhbXBsZXIyRCBlbnZNYXAsIHZlYzMgc2FtcGxlRGlyLCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0XFx0ZmxvYXQgbWlwID0gY2xhbXAoIHJvdWdobmVzc1RvTWlwKCByb3VnaG5lc3MgKSwgY3ViZVVWX20wLCBDVUJFVVZfTUFYX01JUCApO1xcblxcdFxcdGZsb2F0IG1pcEYgPSBmcmFjdCggbWlwICk7XFxuXFx0XFx0ZmxvYXQgbWlwSW50ID0gZmxvb3IoIG1pcCApO1xcblxcdFxcdHZlYzMgY29sb3IwID0gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyLCBtaXBJbnQgKTtcXG5cXHRcXHRpZiAoIG1pcEYgPT0gMC4wICkge1xcblxcdFxcdFxcdHJldHVybiB2ZWM0KCBjb2xvcjAsIDEuMCApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dmVjMyBjb2xvcjEgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCArIDEuMCApO1xcblxcdFxcdFxcdHJldHVybiB2ZWM0KCBtaXgoIGNvbG9yMCwgY29sb3IxLCBtaXBGICksIDEuMCApO1xcblxcdFxcdH1cXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBkZWZhdWx0bm9ybWFsX3ZlcnRleCA9IFwidmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG9iamVjdE5vcm1hbDtcXG4jaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHR2ZWMzIHRyYW5zZm9ybWVkVGFuZ2VudCA9IG9iamVjdFRhbmdlbnQ7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9CQVRDSElOR1xcblxcdG1hdDMgYm0gPSBtYXQzKCBiYXRjaGluZ01hdHJpeCApO1xcblxcdHRyYW5zZm9ybWVkTm9ybWFsIC89IHZlYzMoIGRvdCggYm1bIDAgXSwgYm1bIDAgXSApLCBkb3QoIGJtWyAxIF0sIGJtWyAxIF0gKSwgZG90KCBibVsgMiBdLCBibVsgMiBdICkgKTtcXG5cXHR0cmFuc2Zvcm1lZE5vcm1hbCA9IGJtICogdHJhbnNmb3JtZWROb3JtYWw7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dHJhbnNmb3JtZWRUYW5nZW50ID0gYm0gKiB0cmFuc2Zvcm1lZFRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuXFx0bWF0MyBpbSA9IG1hdDMoIGluc3RhbmNlTWF0cml4ICk7XFxuXFx0dHJhbnNmb3JtZWROb3JtYWwgLz0gdmVjMyggZG90KCBpbVsgMCBdLCBpbVsgMCBdICksIGRvdCggaW1bIDEgXSwgaW1bIDEgXSApLCBkb3QoIGltWyAyIF0sIGltWyAyIF0gKSApO1xcblxcdHRyYW5zZm9ybWVkTm9ybWFsID0gaW0gKiB0cmFuc2Zvcm1lZE5vcm1hbDtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR0cmFuc2Zvcm1lZFRhbmdlbnQgPSBpbSAqIHRyYW5zZm9ybWVkVGFuZ2VudDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG50cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIHRyYW5zZm9ybWVkTm9ybWFsO1xcbiNpZmRlZiBGTElQX1NJREVEXFxuXFx0dHJhbnNmb3JtZWROb3JtYWwgPSAtIHRyYW5zZm9ybWVkTm9ybWFsO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdHRyYW5zZm9ybWVkVGFuZ2VudCA9ICggbW9kZWxWaWV3TWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWRUYW5nZW50LCAwLjAgKSApLnh5ejtcXG5cXHQjaWZkZWYgRkxJUF9TSURFRFxcblxcdFxcdHRyYW5zZm9ybWVkVGFuZ2VudCA9IC0gdHJhbnNmb3JtZWRUYW5nZW50O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xcblxcdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50QmlhcztcXG4jZW5kaWZcIjtcblxudmFyIGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsaXplKCBvYmplY3ROb3JtYWwgKSAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHZEaXNwbGFjZW1lbnRNYXBVdiApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcXG4jZW5kaWZcIjtcblxudmFyIGVtaXNzaXZlbWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dmVjNCBlbWlzc2l2ZUNvbG9yID0gdGV4dHVyZTJEKCBlbWlzc2l2ZU1hcCwgdkVtaXNzaXZlTWFwVXYgKTtcXG5cXHR0b3RhbEVtaXNzaXZlUmFkaWFuY2UgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuI2VuZGlmXCI7XG5cbnZhciBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBjb2xvcnNwYWNlX2ZyYWdtZW50ID0gXCJnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb091dHB1dFRleGVsKCBnbF9GcmFnQ29sb3IgKTtcIjtcblxudmFyIGNvbG9yc3BhY2VfcGFyc19mcmFnbWVudCA9IFwiXFxuY29uc3QgbWF0MyBMSU5FQVJfU1JHQl9UT19MSU5FQVJfRElTUExBWV9QMyA9IG1hdDMoXFxuXFx0dmVjMyggMC44MjI0NjIxLCAwLjE3NzUzOCwgMC4wICksXFxuXFx0dmVjMyggMC4wMzMxOTQxLCAwLjk2NjgwNTgsIDAuMCApLFxcblxcdHZlYzMoIDAuMDE3MDgyNywgMC4wNzIzOTc0LCAwLjkxMDUxOTkgKVxcbik7XFxuY29uc3QgbWF0MyBMSU5FQVJfRElTUExBWV9QM19UT19MSU5FQVJfU1JHQiA9IG1hdDMoXFxuXFx0dmVjMyggMS4yMjQ5NDAxLCAtIDAuMjI0OTQwNCwgMC4wICksXFxuXFx0dmVjMyggLSAwLjA0MjA1NjksIDEuMDQyMDU3MSwgMC4wICksXFxuXFx0dmVjMyggLSAwLjAxOTYzNzYsIC0gMC4wNzg2MzYxLCAxLjA5ODI3MzUgKVxcbik7XFxudmVjNCBMaW5lYXJTUkdCVG9MaW5lYXJEaXNwbGF5UDMoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqIExJTkVBUl9TUkdCX1RPX0xJTkVBUl9ESVNQTEFZX1AzLCB2YWx1ZS5hICk7XFxufVxcbnZlYzQgTGluZWFyRGlzcGxheVAzVG9MaW5lYXJTUkdCKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiBMSU5FQVJfRElTUExBWV9QM19UT19MSU5FQVJfU1JHQiwgdmFsdWUuYSApO1xcbn1cXG52ZWM0IExpbmVhclRyYW5zZmVyT0VURiggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmFsdWU7XFxufVxcbnZlYzQgc1JHQlRyYW5zZmVyT0VURiggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggMC40MTY2NiApICkgKiAxLjA1NSAtIHZlYzMoIDAuMDU1ICksIHZhbHVlLnJnYiAqIDEyLjkyLCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDAzMTMwOCApICkgKSApLCB2YWx1ZS5hICk7XFxufVxcbnZlYzQgTGluZWFyVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZhbHVlO1xcbn1cXG52ZWM0IExpbmVhclRvc1JHQiggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gc1JHQlRyYW5zZmVyT0VURiggdmFsdWUgKTtcXG59XCI7XG5cbnZhciBlbnZtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmZGVmIEVOVl9XT1JMRFBPU1xcblxcdFxcdHZlYzMgY2FtZXJhVG9GcmFnO1xcblxcdFxcdGlmICggaXNPcnRob2dyYXBoaWMgKSB7XFxuXFx0XFx0XFx0Y2FtZXJhVG9GcmFnID0gbm9ybWFsaXplKCB2ZWMzKCAtIHZpZXdNYXRyaXhbIDAgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDEgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDIgXVsgMiBdICkgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGNhbWVyYVRvRnJhZyA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcdFxcdH1cXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb0ZyYWcsIHdvcmxkTm9ybWFsICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb0ZyYWcsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGVudk1hcFJvdGF0aW9uICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdmVjNCggMC4wICk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWVxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfTUlYIClcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfQUREIClcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ICs9IGVudkNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0dW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblxcdHVuaWZvcm0gbWF0MyBlbnZNYXBSb3RhdGlvbjtcXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xcblxcdCNlbmRpZlxcblxcdFxcbiNlbmRpZlwiO1xuXG52YXIgZW52bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggTEFNQkVSVCApXFxuXFx0XFx0I2RlZmluZSBFTlZfV09STERQT1NcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WX1dPUkxEUE9TXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcdCNlbHNlXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgZW52bWFwX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKVxcblxcdFxcdCNkZWZpbmUgRU5WX1dPUkxEUE9TXFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVl9XT1JMRFBPU1xcblxcdFxcdFxcblxcdFxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXHQjZWxzZVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGVudm1hcF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmZGVmIEVOVl9XT1JMRFBPU1xcblxcdFxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMzIGNhbWVyYVRvVmVydGV4O1xcblxcdFxcdGlmICggaXNPcnRob2dyYXBoaWMgKSB7XFxuXFx0XFx0XFx0Y2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZlYzMoIC0gdmlld01hdHJpeFsgMCBdWyAyIF0sIC0gdmlld01hdHJpeFsgMSBdWyAyIF0sIC0gdmlld01hdHJpeFsgMiBdWyAyIF0gKSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Y2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXHRcXHR9XFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHR2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcdFxcdCNlbmRpZlxcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgZm9nX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHR2Rm9nRGVwdGggPSAtIG12UG9zaXRpb24uejtcXG4jZW5kaWZcIjtcblxudmFyIGZvZ19wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHR2YXJ5aW5nIGZsb2F0IHZGb2dEZXB0aDtcXG4jZW5kaWZcIjtcblxudmFyIGZvZ19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHQjaWZkZWYgRk9HX0VYUDJcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSAxLjAgLSBleHAoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiB2Rm9nRGVwdGggKiB2Rm9nRGVwdGggKTtcXG5cXHQjZWxzZVxcblxcdFxcdGZsb2F0IGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgdkZvZ0RlcHRoICk7XFxuXFx0I2VuZGlmXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcbiNlbmRpZlwiO1xuXG52YXIgZm9nX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcdHZhcnlpbmcgZmxvYXQgdkZvZ0RlcHRoO1xcblxcdCNpZmRlZiBGT0dfRVhQMlxcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ0ZhcjtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfR1JBRElFTlRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBncmFkaWVudE1hcDtcXG4jZW5kaWZcXG52ZWMzIGdldEdyYWRpZW50SXJyYWRpYW5jZSggdmVjMyBub3JtYWwsIHZlYzMgbGlnaHREaXJlY3Rpb24gKSB7XFxuXFx0ZmxvYXQgZG90TkwgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXJlY3Rpb24gKTtcXG5cXHR2ZWMyIGNvb3JkID0gdmVjMiggZG90TkwgKiAwLjUgKyAwLjUsIDAuMCApO1xcblxcdCNpZmRlZiBVU0VfR1JBRElFTlRNQVBcXG5cXHRcXHRyZXR1cm4gdmVjMyggdGV4dHVyZTJEKCBncmFkaWVudE1hcCwgY29vcmQgKS5yICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMyIGZ3ID0gZndpZHRoKCBjb29yZCApICogMC41O1xcblxcdFxcdHJldHVybiBtaXgoIHZlYzMoIDAuNyApLCB2ZWMzKCAxLjAgKSwgc21vb3Roc3RlcCggMC43IC0gZncueCwgMC43ICsgZncueCwgY29vcmQueCApICk7XFxuXFx0I2VuZGlmXFxufVwiO1xuXG52YXIgbGlnaHRtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCI7XG5cbnZhciBsaWdodHNfbGFtYmVydF9mcmFnbWVudCA9IFwiTGFtYmVydE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxubWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7XCI7XG5cbnZhciBsaWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5zdHJ1Y3QgTGFtYmVydE1hdGVyaWFsIHtcXG5cXHR2ZWMzIGRpZmZ1c2VDb2xvcjtcXG5cXHRmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbn07XFxudm9pZCBSRV9EaXJlY3RfTGFtYmVydCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gTGFtYmVydE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfTGFtYmVydCggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBMYW1iZXJ0TWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfTGFtYmVydFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX0xhbWJlcnRcIjtcblxudmFyIGxpZ2h0c19wYXJzX2JlZ2luID0gXCJ1bmlmb3JtIGJvb2wgcmVjZWl2ZVNoYWRvdztcXG51bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuI2lmIGRlZmluZWQoIFVTRV9MSUdIVF9QUk9CRVMgKVxcblxcdHVuaWZvcm0gdmVjMyBsaWdodFByb2JlWyA5IF07XFxuI2VuZGlmXFxudmVjMyBzaEdldElycmFkaWFuY2VBdCggaW4gdmVjMyBub3JtYWwsIGluIHZlYzMgc2hDb2VmZmljaWVudHNbIDkgXSApIHtcXG5cXHRmbG9hdCB4ID0gbm9ybWFsLngsIHkgPSBub3JtYWwueSwgeiA9IG5vcm1hbC56O1xcblxcdHZlYzMgcmVzdWx0ID0gc2hDb2VmZmljaWVudHNbIDAgXSAqIDAuODg2MjI3O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMSBdICogMi4wICogMC41MTE2NjQgKiB5O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMiBdICogMi4wICogMC41MTE2NjQgKiB6O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMyBdICogMi4wICogMC41MTE2NjQgKiB4O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNCBdICogMi4wICogMC40MjkwNDMgKiB4ICogeTtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDUgXSAqIDIuMCAqIDAuNDI5MDQzICogeSAqIHo7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA2IF0gKiAoIDAuNzQzMTI1ICogeiAqIHogLSAwLjI0NzcwOCApO1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNyBdICogMi4wICogMC40MjkwNDMgKiB4ICogejtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDggXSAqIDAuNDI5MDQzICogKCB4ICogeCAtIHkgKiB5ICk7XFxuXFx0cmV0dXJuIHJlc3VsdDtcXG59XFxudmVjMyBnZXRMaWdodFByb2JlSXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBsaWdodFByb2JlWyA5IF0sIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBzaEdldElycmFkaWFuY2VBdCggd29ybGROb3JtYWwsIGxpZ2h0UHJvYmUgKTtcXG5cXHRyZXR1cm4gaXJyYWRpYW5jZTtcXG59XFxudmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkge1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGFtYmllbnRMaWdodENvbG9yO1xcblxcdHJldHVybiBpcnJhZGlhbmNlO1xcbn1cXG5mbG9hdCBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBjb25zdCBpbiBmbG9hdCBsaWdodERpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXG5cXHRmbG9hdCBkaXN0YW5jZUZhbGxvZmYgPSAxLjAgLyBtYXgoIHBvdyggbGlnaHREaXN0YW5jZSwgZGVjYXlFeHBvbmVudCApLCAwLjAxICk7XFxuXFx0aWYgKCBjdXRvZmZEaXN0YW5jZSA+IDAuMCApIHtcXG5cXHRcXHRkaXN0YW5jZUZhbGxvZmYgKj0gcG93Miggc2F0dXJhdGUoIDEuMCAtIHBvdzQoIGxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSApICkgKTtcXG5cXHR9XFxuXFx0cmV0dXJuIGRpc3RhbmNlRmFsbG9mZjtcXG59XFxuZmxvYXQgZ2V0U3BvdEF0dGVudWF0aW9uKCBjb25zdCBpbiBmbG9hdCBjb25lQ29zaW5lLCBjb25zdCBpbiBmbG9hdCBwZW51bWJyYUNvc2luZSwgY29uc3QgaW4gZmxvYXQgYW5nbGVDb3NpbmUgKSB7XFxuXFx0cmV0dXJuIHNtb290aHN0ZXAoIGNvbmVDb3NpbmUsIHBlbnVtYnJhQ29zaW5lLCBhbmdsZUNvc2luZSApO1xcbn1cXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodHNbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0dm9pZCBnZXREaXJlY3Rpb25hbExpZ2h0SW5mbyggY29uc3QgaW4gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0LCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHtcXG5cXHRcXHRsaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7XFxuXFx0XFx0bGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XFxuXFx0XFx0bGlnaHQudmlzaWJsZSA9IHRydWU7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdHN0cnVjdCBQb2ludExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldFBvaW50TGlnaHRJbmZvKCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgb3V0IEluY2lkZW50TGlnaHQgbGlnaHQgKSB7XFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gcG9pbnRMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5UG9zaXRpb247XFxuXFx0XFx0bGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFx0XFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcblxcdFxcdGxpZ2h0LmNvbG9yID0gcG9pbnRMaWdodC5jb2xvcjtcXG5cXHRcXHRsaWdodC5jb2xvciAqPSBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBsaWdodERpc3RhbmNlLCBwb2ludExpZ2h0LmRpc3RhbmNlLCBwb2ludExpZ2h0LmRlY2F5ICk7XFxuXFx0XFx0bGlnaHQudmlzaWJsZSA9ICggbGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgU3BvdExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0XFx0ZmxvYXQgY29uZUNvcztcXG5cXHRcXHRmbG9hdCBwZW51bWJyYUNvcztcXG5cXHR9O1xcblxcdHVuaWZvcm0gU3BvdExpZ2h0IHNwb3RMaWdodHNbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdHZvaWQgZ2V0U3BvdExpZ2h0SW5mbyggY29uc3QgaW4gU3BvdExpZ2h0IHNwb3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHtcXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBzcG90TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeVBvc2l0aW9uO1xcblxcdFxcdGxpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcdFxcdGZsb2F0IGFuZ2xlQ29zID0gZG90KCBsaWdodC5kaXJlY3Rpb24sIHNwb3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBzcG90QXR0ZW51YXRpb24gPSBnZXRTcG90QXR0ZW51YXRpb24oIHNwb3RMaWdodC5jb25lQ29zLCBzcG90TGlnaHQucGVudW1icmFDb3MsIGFuZ2xlQ29zICk7XFxuXFx0XFx0aWYgKCBzcG90QXR0ZW51YXRpb24gPiAwLjAgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcblxcdFxcdFxcdGxpZ2h0LmNvbG9yID0gc3BvdExpZ2h0LmNvbG9yICogc3BvdEF0dGVudWF0aW9uO1xcblxcdFxcdFxcdGxpZ2h0LmNvbG9yICo9IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGxpZ2h0RGlzdGFuY2UsIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICk7XFxuXFx0XFx0XFx0bGlnaHQudmlzaWJsZSA9ICggbGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGxpZ2h0LmNvbG9yID0gdmVjMyggMC4wICk7XFxuXFx0XFx0XFx0bGlnaHQudmlzaWJsZSA9IGZhbHNlO1xcblxcdFxcdH1cXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxcblxcdHN0cnVjdCBSZWN0QXJlYUxpZ2h0IHtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBoYWxmV2lkdGg7XFxuXFx0XFx0dmVjMyBoYWxmSGVpZ2h0O1xcblxcdH07XFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbHRjXzE7XFx0dW5pZm9ybSBzYW1wbGVyMkQgbHRjXzI7XFxuXFx0dW5pZm9ybSBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHRzWyBOVU1fUkVDVF9BUkVBX0xJR0hUUyBdO1xcbiNlbmRpZlxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IEhlbWlzcGhlcmVMaWdodCB7XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBza3lDb2xvcjtcXG5cXHRcXHR2ZWMzIGdyb3VuZENvbG9yO1xcblxcdH07XFxuXFx0dW5pZm9ybSBIZW1pc3BoZXJlTGlnaHQgaGVtaXNwaGVyZUxpZ2h0c1sgTlVNX0hFTUlfTElHSFRTIF07XFxuXFx0dmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcXG5cXHRcXHRmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBoZW1pTGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3ROTCArIDAuNTtcXG5cXHRcXHR2ZWMzIGlycmFkaWFuY2UgPSBtaXgoIGhlbWlMaWdodC5ncm91bmRDb2xvciwgaGVtaUxpZ2h0LnNreUNvbG9yLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcdFxcdHJldHVybiBpcnJhZGlhbmNlO1xcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdHZlYzMgZ2V0SUJMSXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVZcXG5cXHRcXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgZW52TWFwUm90YXRpb24gKiB3b3JsZE5vcm1hbCwgMS4wICk7XFxuXFx0XFx0XFx0cmV0dXJuIFBJICogZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHZlYzMoIDAuMCApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHR2ZWMzIGdldElCTFJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVZcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCAtIHZpZXdEaXIsIG5vcm1hbCApO1xcblxcdFxcdFxcdHJlZmxlY3RWZWMgPSBub3JtYWxpemUoIG1peCggcmVmbGVjdFZlYywgbm9ybWFsLCByb3VnaG5lc3MgKiByb3VnaG5lc3MpICk7XFxuXFx0XFx0XFx0cmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCBlbnZNYXBSb3RhdGlvbiAqIHJlZmxlY3RWZWMsIHJvdWdobmVzcyApO1xcblxcdFxcdFxcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMyggMC4wICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcblxcdCNpZmRlZiBVU0VfQU5JU09UUk9QWVxcblxcdFxcdHZlYzMgZ2V0SUJMQW5pc290cm9weVJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIHZlYzMgYml0YW5nZW50LCBjb25zdCBpbiBmbG9hdCBhbmlzb3Ryb3B5ICkge1xcblxcdFxcdFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuXFx0XFx0XFx0XFx0dmVjMyBiZW50Tm9ybWFsID0gY3Jvc3MoIGJpdGFuZ2VudCwgdmlld0RpciApO1xcblxcdFxcdFxcdFxcdGJlbnROb3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBiZW50Tm9ybWFsLCBiaXRhbmdlbnQgKSApO1xcblxcdFxcdFxcdFxcdGJlbnROb3JtYWwgPSBub3JtYWxpemUoIG1peCggYmVudE5vcm1hbCwgbm9ybWFsLCBwb3cyKCBwb3cyKCAxLjAgLSBhbmlzb3Ryb3B5ICogKCAxLjAgLSByb3VnaG5lc3MgKSApICkgKSApO1xcblxcdFxcdFxcdFxcdHJldHVybiBnZXRJQkxSYWRpYW5jZSggdmlld0RpciwgYmVudE5vcm1hbCwgcm91Z2huZXNzICk7XFxuXFx0XFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmVjMyggMC4wICk7XFxuXFx0XFx0XFx0I2VuZGlmXFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgbGlnaHRzX3Rvb25fZnJhZ21lbnQgPSBcIlRvb25NYXRlcmlhbCBtYXRlcmlhbDtcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1wiO1xuXG52YXIgbGlnaHRzX3Rvb25fcGFyc19mcmFnbWVudCA9IFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuc3RydWN0IFRvb25NYXRlcmlhbCB7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3I7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9Ub29uKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEdyYWRpZW50SXJyYWRpYW5jZSggZ2VvbWV0cnlOb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfVG9vbiggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfVG9vblxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX1Rvb25cIjtcblxudmFyIGxpZ2h0c19waG9uZ19mcmFnbWVudCA9IFwiQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyO1xcbm1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzID0gc2hpbmluZXNzO1xcbm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO1wiO1xuXG52YXIgbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbnN0cnVjdCBCbGlublBob25nTWF0ZXJpYWwge1xcblxcdHZlYzMgZGlmZnVzZUNvbG9yO1xcblxcdHZlYzMgc3BlY3VsYXJDb2xvcjtcXG5cXHRmbG9hdCBzcGVjdWxhclNoaW5pbmVzcztcXG5cXHRmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbn07XFxudm9pZCBSRV9EaXJlY3RfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9CbGlublBob25nKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzICkgKiBtYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9CbGlublBob25nXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZ1wiO1xuXG52YXIgbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50ID0gXCJQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xcbnZlYzMgZHh5ID0gbWF4KCBhYnMoIGRGZHgoIG5vblBlcnR1cmJlZE5vcm1hbCApICksIGFicyggZEZkeSggbm9uUGVydHVyYmVkTm9ybWFsICkgKSApO1xcbmZsb2F0IGdlb21ldHJ5Um91Z2huZXNzID0gbWF4KCBtYXgoIGR4eS54LCBkeHkueSApLCBkeHkueiApO1xcbm1hdGVyaWFsLnJvdWdobmVzcyA9IG1heCggcm91Z2huZXNzRmFjdG9yLCAwLjA1MjUgKTttYXRlcmlhbC5yb3VnaG5lc3MgKz0gZ2VvbWV0cnlSb3VnaG5lc3M7XFxubWF0ZXJpYWwucm91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5yb3VnaG5lc3MsIDEuMCApO1xcbiNpZmRlZiBJT1JcXG5cXHRtYXRlcmlhbC5pb3IgPSBpb3I7XFxuXFx0I2lmZGVmIFVTRV9TUEVDVUxBUlxcblxcdFxcdGZsb2F0IHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yID0gc3BlY3VsYXJJbnRlbnNpdHk7XFxuXFx0XFx0dmVjMyBzcGVjdWxhckNvbG9yRmFjdG9yID0gc3BlY3VsYXJDb2xvcjtcXG5cXHRcXHQjaWZkZWYgVVNFX1NQRUNVTEFSX0NPTE9STUFQXFxuXFx0XFx0XFx0c3BlY3VsYXJDb2xvckZhY3RvciAqPSB0ZXh0dXJlMkQoIHNwZWN1bGFyQ29sb3JNYXAsIHZTcGVjdWxhckNvbG9yTWFwVXYgKS5yZ2I7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0I2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVBcXG5cXHRcXHRcXHRzcGVjdWxhckludGVuc2l0eUZhY3RvciAqPSB0ZXh0dXJlMkQoIHNwZWN1bGFySW50ZW5zaXR5TWFwLCB2U3BlY3VsYXJJbnRlbnNpdHlNYXBVdiApLmE7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSBtaXgoIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yLCAxLjAsIG1ldGFsbmVzc0ZhY3RvciApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSAxLjA7XFxuXFx0XFx0dmVjMyBzcGVjdWxhckNvbG9yRmFjdG9yID0gdmVjMyggMS4wICk7XFxuXFx0XFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7XFxuXFx0I2VuZGlmXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggbWluKCBwb3cyKCAoIG1hdGVyaWFsLmlvciAtIDEuMCApIC8gKCBtYXRlcmlhbC5pb3IgKyAxLjAgKSApICogc3BlY3VsYXJDb2xvckZhY3RvciwgdmVjMyggMS4wICkgKSAqIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG4jZWxzZVxcblxcdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIDAuMDQgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7XFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXQgPSBjbGVhcmNvYXQ7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gY2xlYXJjb2F0Um91Z2huZXNzO1xcblxcdG1hdGVyaWFsLmNsZWFyY29hdEYwID0gdmVjMyggMC4wNCApO1xcblxcdG1hdGVyaWFsLmNsZWFyY29hdEY5MCA9IDEuMDtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVE1BUFxcblxcdFxcdG1hdGVyaWFsLmNsZWFyY29hdCAqPSB0ZXh0dXJlMkQoIGNsZWFyY29hdE1hcCwgdkNsZWFyY29hdE1hcFV2ICkueDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVBcXG5cXHRcXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBjbGVhcmNvYXRSb3VnaG5lc3NNYXAsIHZDbGVhcmNvYXRSb3VnaG5lc3NNYXBVdiApLnk7XFxuXFx0I2VuZGlmXFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0ID0gc2F0dXJhdGUoIG1hdGVyaWFsLmNsZWFyY29hdCApO1xcdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IG1heCggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzLCAwLjA1MjUgKTtcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKz0gZ2VvbWV0cnlSb3VnaG5lc3M7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDEuMCApO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfRElTUEVSU0lPTlxcblxcdG1hdGVyaWFsLmRpc3BlcnNpb24gPSBkaXNwZXJzaW9uO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRtYXRlcmlhbC5pcmlkZXNjZW5jZSA9IGlyaWRlc2NlbmNlO1xcblxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlSU9SID0gaXJpZGVzY2VuY2VJT1I7XFxuXFx0I2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUFxcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlICo9IHRleHR1cmUyRCggaXJpZGVzY2VuY2VNYXAsIHZJcmlkZXNjZW5jZU1hcFV2ICkucjtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUFxcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzID0gKGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSAtIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSkgKiB0ZXh0dXJlMkQoIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLCB2SXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdiApLmcgKyBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW07XFxuXFx0I2Vsc2VcXG5cXHRcXHRtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIRUVOXFxuXFx0bWF0ZXJpYWwuc2hlZW5Db2xvciA9IHNoZWVuQ29sb3I7XFxuXFx0I2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUFxcblxcdFxcdG1hdGVyaWFsLnNoZWVuQ29sb3IgKj0gdGV4dHVyZTJEKCBzaGVlbkNvbG9yTWFwLCB2U2hlZW5Db2xvck1hcFV2ICkucmdiO1xcblxcdCNlbmRpZlxcblxcdG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzID0gY2xhbXAoIHNoZWVuUm91Z2huZXNzLCAwLjA3LCAxLjAgKTtcXG5cXHQjaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUFxcblxcdFxcdG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzICo9IHRleHR1cmUyRCggc2hlZW5Sb3VnaG5lc3NNYXAsIHZTaGVlblJvdWdobmVzc01hcFV2ICkuYTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FOSVNPVFJPUFlcXG5cXHQjaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVBcXG5cXHRcXHRtYXQyIGFuaXNvdHJvcHlNYXQgPSBtYXQyKCBhbmlzb3Ryb3B5VmVjdG9yLngsIGFuaXNvdHJvcHlWZWN0b3IueSwgLSBhbmlzb3Ryb3B5VmVjdG9yLnksIGFuaXNvdHJvcHlWZWN0b3IueCApO1xcblxcdFxcdHZlYzMgYW5pc290cm9weVBvbGFyID0gdGV4dHVyZTJEKCBhbmlzb3Ryb3B5TWFwLCB2QW5pc290cm9weU1hcFV2ICkucmdiO1xcblxcdFxcdHZlYzIgYW5pc290cm9weVYgPSBhbmlzb3Ryb3B5TWF0ICogbm9ybWFsaXplKCAyLjAgKiBhbmlzb3Ryb3B5UG9sYXIucmcgLSB2ZWMyKCAxLjAgKSApICogYW5pc290cm9weVBvbGFyLmI7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMyIGFuaXNvdHJvcHlWID0gYW5pc290cm9weVZlY3RvcjtcXG5cXHQjZW5kaWZcXG5cXHRtYXRlcmlhbC5hbmlzb3Ryb3B5ID0gbGVuZ3RoKCBhbmlzb3Ryb3B5ViApO1xcblxcdGlmKCBtYXRlcmlhbC5hbmlzb3Ryb3B5ID09IDAuMCApIHtcXG5cXHRcXHRhbmlzb3Ryb3B5ViA9IHZlYzIoIDEuMCwgMC4wICk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRhbmlzb3Ryb3B5ViAvPSBtYXRlcmlhbC5hbmlzb3Ryb3B5O1xcblxcdFxcdG1hdGVyaWFsLmFuaXNvdHJvcHkgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuYW5pc290cm9weSApO1xcblxcdH1cXG5cXHRtYXRlcmlhbC5hbHBoYVQgPSBtaXgoIHBvdzIoIG1hdGVyaWFsLnJvdWdobmVzcyApLCAxLjAsIHBvdzIoIG1hdGVyaWFsLmFuaXNvdHJvcHkgKSApO1xcblxcdG1hdGVyaWFsLmFuaXNvdHJvcHlUID0gdGJuWyAwIF0gKiBhbmlzb3Ryb3B5Vi54ICsgdGJuWyAxIF0gKiBhbmlzb3Ryb3B5Vi55O1xcblxcdG1hdGVyaWFsLmFuaXNvdHJvcHlCID0gdGJuWyAxIF0gKiBhbmlzb3Ryb3B5Vi54IC0gdGJuWyAwIF0gKiBhbmlzb3Ryb3B5Vi55O1xcbiNlbmRpZlwiO1xuXG52YXIgbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQgPSBcInN0cnVjdCBQaHlzaWNhbE1hdGVyaWFsIHtcXG5cXHR2ZWMzIGRpZmZ1c2VDb2xvcjtcXG5cXHRmbG9hdCByb3VnaG5lc3M7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yO1xcblxcdGZsb2F0IHNwZWN1bGFyRjkwO1xcblxcdGZsb2F0IGRpc3BlcnNpb247XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRmbG9hdCBjbGVhcmNvYXQ7XFxuXFx0XFx0ZmxvYXQgY2xlYXJjb2F0Um91Z2huZXNzO1xcblxcdFxcdHZlYzMgY2xlYXJjb2F0RjA7XFxuXFx0XFx0ZmxvYXQgY2xlYXJjb2F0RjkwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRcXHRmbG9hdCBpcmlkZXNjZW5jZTtcXG5cXHRcXHRmbG9hdCBpcmlkZXNjZW5jZUlPUjtcXG5cXHRcXHRmbG9hdCBpcmlkZXNjZW5jZVRoaWNrbmVzcztcXG5cXHRcXHR2ZWMzIGlyaWRlc2NlbmNlRnJlc25lbDtcXG5cXHRcXHR2ZWMzIGlyaWRlc2NlbmNlRjA7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TSEVFTlxcblxcdFxcdHZlYzMgc2hlZW5Db2xvcjtcXG5cXHRcXHRmbG9hdCBzaGVlblJvdWdobmVzcztcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgSU9SXFxuXFx0XFx0ZmxvYXQgaW9yO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0XFx0ZmxvYXQgdHJhbnNtaXNzaW9uO1xcblxcdFxcdGZsb2F0IHRyYW5zbWlzc2lvbkFscGhhO1xcblxcdFxcdGZsb2F0IHRoaWNrbmVzcztcXG5cXHRcXHRmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlO1xcblxcdFxcdHZlYzMgYXR0ZW51YXRpb25Db2xvcjtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX0FOSVNPVFJPUFlcXG5cXHRcXHRmbG9hdCBhbmlzb3Ryb3B5O1xcblxcdFxcdGZsb2F0IGFscGhhVDtcXG5cXHRcXHR2ZWMzIGFuaXNvdHJvcHlUO1xcblxcdFxcdHZlYzMgYW5pc290cm9weUI7XFxuXFx0I2VuZGlmXFxufTtcXG52ZWMzIGNsZWFyY29hdFNwZWN1bGFyRGlyZWN0ID0gdmVjMyggMC4wICk7XFxudmVjMyBjbGVhcmNvYXRTcGVjdWxhckluZGlyZWN0ID0gdmVjMyggMC4wICk7XFxudmVjMyBzaGVlblNwZWN1bGFyRGlyZWN0ID0gdmVjMyggMC4wICk7XFxudmVjMyBzaGVlblNwZWN1bGFySW5kaXJlY3QgPSB2ZWMzKDAuMCApO1xcbnZlYzMgU2NobGlja190b19GMCggY29uc3QgaW4gdmVjMyBmLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkge1xcbiAgICBmbG9hdCB4ID0gY2xhbXAoIDEuMCAtIGRvdFZILCAwLjAsIDEuMCApO1xcbiAgICBmbG9hdCB4MiA9IHggKiB4O1xcbiAgICBmbG9hdCB4NSA9IGNsYW1wKCB4ICogeDIgKiB4MiwgMC4wLCAwLjk5OTkgKTtcXG4gICAgcmV0dXJuICggZiAtIHZlYzMoIGY5MCApICogeDUgKSAvICggMS4wIC0geDUgKTtcXG59XFxuZmxvYXQgVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICkge1xcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXG5cXHRmbG9hdCBndiA9IGRvdE5MICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7XFxuXFx0ZmxvYXQgZ2wgPSBkb3ROViAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TkwgKSApO1xcblxcdHJldHVybiAwLjUgLyBtYXgoIGd2ICsgZ2wsIEVQU0lMT04gKTtcXG59XFxuZmxvYXQgRF9HR1goIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxuXFx0ZmxvYXQgZGVub20gPSBwb3cyKCBkb3ROSCApICogKCBhMiAtIDEuMCApICsgMS4wO1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgLyBwb3cyKCBkZW5vbSApO1xcbn1cXG4jaWZkZWYgVVNFX0FOSVNPVFJPUFlcXG5cXHRmbG9hdCBWX0dHWF9TbWl0aENvcnJlbGF0ZWRfQW5pc290cm9waWMoIGNvbnN0IGluIGZsb2F0IGFscGhhVCwgY29uc3QgaW4gZmxvYXQgYWxwaGFCLCBjb25zdCBpbiBmbG9hdCBkb3RUViwgY29uc3QgaW4gZmxvYXQgZG90QlYsIGNvbnN0IGluIGZsb2F0IGRvdFRMLCBjb25zdCBpbiBmbG9hdCBkb3RCTCwgY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGRvdE5MICkge1xcblxcdFxcdGZsb2F0IGd2ID0gZG90TkwgKiBsZW5ndGgoIHZlYzMoIGFscGhhVCAqIGRvdFRWLCBhbHBoYUIgKiBkb3RCViwgZG90TlYgKSApO1xcblxcdFxcdGZsb2F0IGdsID0gZG90TlYgKiBsZW5ndGgoIHZlYzMoIGFscGhhVCAqIGRvdFRMLCBhbHBoYUIgKiBkb3RCTCwgZG90TkwgKSApO1xcblxcdFxcdGZsb2F0IHYgPSAwLjUgLyAoIGd2ICsgZ2wgKTtcXG5cXHRcXHRyZXR1cm4gc2F0dXJhdGUodik7XFxuXFx0fVxcblxcdGZsb2F0IERfR0dYX0FuaXNvdHJvcGljKCBjb25zdCBpbiBmbG9hdCBhbHBoYVQsIGNvbnN0IGluIGZsb2F0IGFscGhhQiwgY29uc3QgaW4gZmxvYXQgZG90TkgsIGNvbnN0IGluIGZsb2F0IGRvdFRILCBjb25zdCBpbiBmbG9hdCBkb3RCSCApIHtcXG5cXHRcXHRmbG9hdCBhMiA9IGFscGhhVCAqIGFscGhhQjtcXG5cXHRcXHRoaWdocCB2ZWMzIHYgPSB2ZWMzKCBhbHBoYUIgKiBkb3RUSCwgYWxwaGFUICogZG90QkgsIGEyICogZG90TkggKTtcXG5cXHRcXHRoaWdocCBmbG9hdCB2MiA9IGRvdCggdiwgdiApO1xcblxcdFxcdGZsb2F0IHcyID0gYTIgLyB2MjtcXG5cXHRcXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyICogcG93MiAoIHcyICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0dmVjMyBCUkRGX0dHWF9DbGVhcmNvYXQoIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwpIHtcXG5cXHRcXHR2ZWMzIGYwID0gbWF0ZXJpYWwuY2xlYXJjb2F0RjA7XFxuXFx0XFx0ZmxvYXQgZjkwID0gbWF0ZXJpYWwuY2xlYXJjb2F0RjkwO1xcblxcdFxcdGZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcztcXG5cXHRcXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdFxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXHRcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0XFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdFxcdGZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7XFxuXFx0XFx0dmVjMyBGID0gRl9TY2hsaWNrKCBmMCwgZjkwLCBkb3RWSCApO1xcblxcdFxcdGZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGFscGhhLCBkb3ROTCwgZG90TlYgKTtcXG5cXHRcXHRmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApO1xcblxcdFxcdHJldHVybiBGICogKCBWICogRCApO1xcblxcdH1cXG4jZW5kaWZcXG52ZWMzIEJSREZfR0dYKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsICkge1xcblxcdHZlYzMgZjAgPSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yO1xcblxcdGZsb2F0IGY5MCA9IG1hdGVyaWFsLnNwZWN1bGFyRjkwO1xcblxcdGZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnJvdWdobmVzcztcXG5cXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7XFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBmMCwgZjkwLCBkb3RWSCApO1xcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRcXHRGID0gbWl4KCBGLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIG1hdGVyaWFsLmlyaWRlc2NlbmNlICk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9BTklTT1RST1BZXFxuXFx0XFx0ZmxvYXQgZG90VEwgPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlULCBsaWdodERpciApO1xcblxcdFxcdGZsb2F0IGRvdFRWID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5VCwgdmlld0RpciApO1xcblxcdFxcdGZsb2F0IGRvdFRIID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5VCwgaGFsZkRpciApO1xcblxcdFxcdGZsb2F0IGRvdEJMID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5QiwgbGlnaHREaXIgKTtcXG5cXHRcXHRmbG9hdCBkb3RCViA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weUIsIHZpZXdEaXIgKTtcXG5cXHRcXHRmbG9hdCBkb3RCSCA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weUIsIGhhbGZEaXIgKTtcXG5cXHRcXHRmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkX0FuaXNvdHJvcGljKCBtYXRlcmlhbC5hbHBoYVQsIGFscGhhLCBkb3RUViwgZG90QlYsIGRvdFRMLCBkb3RCTCwgZG90TlYsIGRvdE5MICk7XFxuXFx0XFx0ZmxvYXQgRCA9IERfR0dYX0FuaXNvdHJvcGljKCBtYXRlcmlhbC5hbHBoYVQsIGFscGhhLCBkb3ROSCwgZG90VEgsIGRvdEJIICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XFxuXFx0XFx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXG5cXHQjZW5kaWZcXG5cXHRyZXR1cm4gRiAqICggViAqIEQgKTtcXG59XFxudmVjMiBMVENfVXYoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NJWkUgPSA2NC4wO1xcblxcdGNvbnN0IGZsb2F0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFO1xcblxcdGNvbnN0IGZsb2F0IExVVF9CSUFTID0gMC41IC8gTFVUX1NJWkU7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBOLCBWICkgKTtcXG5cXHR2ZWMyIHV2ID0gdmVjMiggcm91Z2huZXNzLCBzcXJ0KCAxLjAgLSBkb3ROViApICk7XFxuXFx0dXYgPSB1diAqIExVVF9TQ0FMRSArIExVVF9CSUFTO1xcblxcdHJldHVybiB1djtcXG59XFxuZmxvYXQgTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIGYgKSB7XFxuXFx0ZmxvYXQgbCA9IGxlbmd0aCggZiApO1xcblxcdHJldHVybiBtYXgoICggbCAqIGwgKyBmLnogKSAvICggbCArIDEuMCApLCAwLjAgKTtcXG59XFxudmVjMyBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgdjEsIGNvbnN0IGluIHZlYzMgdjIgKSB7XFxuXFx0ZmxvYXQgeCA9IGRvdCggdjEsIHYyICk7XFxuXFx0ZmxvYXQgeSA9IGFicyggeCApO1xcblxcdGZsb2F0IGEgPSAwLjg1NDM5ODUgKyAoIDAuNDk2NTE1NSArIDAuMDE0NTIwNiAqIHkgKSAqIHk7XFxuXFx0ZmxvYXQgYiA9IDMuNDE3NTk0MCArICggNC4xNjE2NzI0ICsgeSApICogeTtcXG5cXHRmbG9hdCB2ID0gYSAvIGI7XFxuXFx0ZmxvYXQgdGhldGFfc2ludGhldGEgPSAoIHggPiAwLjAgKSA/IHYgOiAwLjUgKiBpbnZlcnNlc3FydCggbWF4KCAxLjAgLSB4ICogeCwgMWUtNyApICkgLSB2O1xcblxcdHJldHVybiBjcm9zcyggdjEsIHYyICkgKiB0aGV0YV9zaW50aGV0YTtcXG59XFxudmVjMyBMVENfRXZhbHVhdGUoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiB2ZWMzIFAsIGNvbnN0IGluIG1hdDMgbUludiwgY29uc3QgaW4gdmVjMyByZWN0Q29vcmRzWyA0IF0gKSB7XFxuXFx0dmVjMyB2MSA9IHJlY3RDb29yZHNbIDEgXSAtIHJlY3RDb29yZHNbIDAgXTtcXG5cXHR2ZWMzIHYyID0gcmVjdENvb3Jkc1sgMyBdIC0gcmVjdENvb3Jkc1sgMCBdO1xcblxcdHZlYzMgbGlnaHROb3JtYWwgPSBjcm9zcyggdjEsIHYyICk7XFxuXFx0aWYoIGRvdCggbGlnaHROb3JtYWwsIFAgLSByZWN0Q29vcmRzWyAwIF0gKSA8IDAuMCApIHJldHVybiB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIFQxLCBUMjtcXG5cXHRUMSA9IG5vcm1hbGl6ZSggViAtIE4gKiBkb3QoIFYsIE4gKSApO1xcblxcdFQyID0gLSBjcm9zcyggTiwgVDEgKTtcXG5cXHRtYXQzIG1hdCA9IG1JbnYgKiB0cmFuc3Bvc2VNYXQzKCBtYXQzKCBUMSwgVDIsIE4gKSApO1xcblxcdHZlYzMgY29vcmRzWyA0IF07XFxuXFx0Y29vcmRzWyAwIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDAgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDEgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMSBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMiBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAyIF0gLSBQICk7XFxuXFx0Y29vcmRzWyAzIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDMgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDAgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAwIF0gKTtcXG5cXHRjb29yZHNbIDEgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAxIF0gKTtcXG5cXHRjb29yZHNbIDIgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAyIF0gKTtcXG5cXHRjb29yZHNbIDMgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAzIF0gKTtcXG5cXHR2ZWMzIHZlY3RvckZvcm1GYWN0b3IgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAwIF0sIGNvb3Jkc1sgMSBdICk7XFxuXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMSBdLCBjb29yZHNbIDIgXSApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDIgXSwgY29vcmRzWyAzIF0gKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAzIF0sIGNvb3Jkc1sgMCBdICk7XFxuXFx0ZmxvYXQgcmVzdWx0ID0gTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCB2ZWN0b3JGb3JtRmFjdG9yICk7XFxuXFx0cmV0dXJuIHZlYzMoIHJlc3VsdCApO1xcbn1cXG4jaWYgZGVmaW5lZCggVVNFX1NIRUVOIClcXG5mbG9hdCBEX0NoYXJsaWUoIGZsb2F0IHJvdWdobmVzcywgZmxvYXQgZG90TkggKSB7XFxuXFx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTtcXG5cXHRmbG9hdCBpbnZBbHBoYSA9IDEuMCAvIGFscGhhO1xcblxcdGZsb2F0IGNvczJoID0gZG90TkggKiBkb3ROSDtcXG5cXHRmbG9hdCBzaW4yaCA9IG1heCggMS4wIC0gY29zMmgsIDAuMDA3ODEyNSApO1xcblxcdHJldHVybiAoIDIuMCArIGludkFscGhhICkgKiBwb3coIHNpbjJoLCBpbnZBbHBoYSAqIDAuNSApIC8gKCAyLjAgKiBQSSApO1xcbn1cXG5mbG9hdCBWX05ldWJlbHQoIGZsb2F0IGRvdE5WLCBmbG9hdCBkb3ROTCApIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIDEuMCAvICggNC4wICogKCBkb3ROTCArIGRvdE5WIC0gZG90TkwgKiBkb3ROViApICkgKTtcXG59XFxudmVjMyBCUkRGX1NoZWVuKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCB2ZWMzIHNoZWVuQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoZWVuUm91Z2huZXNzICkge1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IEQgPSBEX0NoYXJsaWUoIHNoZWVuUm91Z2huZXNzLCBkb3ROSCApO1xcblxcdGZsb2F0IFYgPSBWX05ldWJlbHQoIGRvdE5WLCBkb3ROTCApO1xcblxcdHJldHVybiBzaGVlbkNvbG9yICogKCBEICogViApO1xcbn1cXG4jZW5kaWZcXG5mbG9hdCBJQkxTaGVlbkJSREYoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0ZmxvYXQgcjIgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XFxuXFx0ZmxvYXQgYSA9IHJvdWdobmVzcyA8IDAuMjUgPyAtMzM5LjIgKiByMiArIDE2MS40ICogcm91Z2huZXNzIC0gMjUuOSA6IC04LjQ4ICogcjIgKyAxNC4zICogcm91Z2huZXNzIC0gOS45NTtcXG5cXHRmbG9hdCBiID0gcm91Z2huZXNzIDwgMC4yNSA/IDQ0LjAgKiByMiAtIDIzLjcgKiByb3VnaG5lc3MgKyAzLjI2IDogMS45NyAqIHIyIC0gMy4yNyAqIHJvdWdobmVzcyArIDAuNzI7XFxuXFx0ZmxvYXQgREcgPSBleHAoIGEgKiBkb3ROViArIGIgKSArICggcm91Z2huZXNzIDwgMC4yNSA/IDAuMCA6IDAuMSAqICggcm91Z2huZXNzIC0gMC4yNSApICk7XFxuXFx0cmV0dXJuIHNhdHVyYXRlKCBERyAqIFJFQ0lQUk9DQUxfUEkgKTtcXG59XFxudmVjMiBERkdBcHByb3goIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0Y29uc3QgdmVjNCBjMCA9IHZlYzQoIC0gMSwgLSAwLjAyNzUsIC0gMC41NzIsIDAuMDIyICk7XFxuXFx0Y29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7XFxuXFx0dmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcXG5cXHRmbG9hdCBhMDA0ID0gbWluKCByLnggKiByLngsIGV4cDIoIC0gOS4yOCAqIGRvdE5WICkgKSAqIHIueCArIHIueTtcXG5cXHR2ZWMyIGZhYiA9IHZlYzIoIC0gMS4wNCwgMS4wNCApICogYTAwNCArIHIuenc7XFxuXFx0cmV0dXJuIGZhYjtcXG59XFxudmVjMyBFbnZpcm9ubWVudEJSREYoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHR2ZWMyIGZhYiA9IERGR0FwcHJveCggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcXG5cXHRyZXR1cm4gc3BlY3VsYXJDb2xvciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTtcXG59XFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRVxcbnZvaWQgY29tcHV0ZU11bHRpc2NhdHRlcmluZ0lyaWRlc2NlbmNlKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCBpcmlkZXNjZW5jZSwgY29uc3QgaW4gdmVjMyBpcmlkZXNjZW5jZUYwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGlub3V0IHZlYzMgc2luZ2xlU2NhdHRlciwgaW5vdXQgdmVjMyBtdWx0aVNjYXR0ZXIgKSB7XFxuI2Vsc2VcXG52b2lkIGNvbXB1dGVNdWx0aXNjYXR0ZXJpbmcoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgaW5vdXQgdmVjMyBzaW5nbGVTY2F0dGVyLCBpbm91dCB2ZWMzIG11bHRpU2NhdHRlciApIHtcXG4jZW5kaWZcXG5cXHR2ZWMyIGZhYiA9IERGR0FwcHJveCggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcXG5cXHQjaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxuXFx0XFx0dmVjMyBGciA9IG1peCggc3BlY3VsYXJDb2xvciwgaXJpZGVzY2VuY2VGMCwgaXJpZGVzY2VuY2UgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgRnIgPSBzcGVjdWxhckNvbG9yO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgRnNzRXNzID0gRnIgKiBmYWIueCArIHNwZWN1bGFyRjkwICogZmFiLnk7XFxuXFx0ZmxvYXQgRXNzID0gZmFiLnggKyBmYWIueTtcXG5cXHRmbG9hdCBFbXMgPSAxLjAgLSBFc3M7XFxuXFx0dmVjMyBGYXZnID0gRnIgKyAoIDEuMCAtIEZyICkgKiAwLjA0NzYxOTtcXHR2ZWMzIEZtcyA9IEZzc0VzcyAqIEZhdmcgLyAoIDEuMCAtIEVtcyAqIEZhdmcgKTtcXG5cXHRzaW5nbGVTY2F0dGVyICs9IEZzc0VzcztcXG5cXHRtdWx0aVNjYXR0ZXIgKz0gRm1zICogRW1zO1xcbn1cXG4jaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXFxuXFx0dm9pZCBSRV9EaXJlY3RfUmVjdEFyZWFfUGh5c2ljYWwoIGNvbnN0IGluIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0XFx0dmVjMyBub3JtYWwgPSBnZW9tZXRyeU5vcm1hbDtcXG5cXHRcXHR2ZWMzIHZpZXdEaXIgPSBnZW9tZXRyeVZpZXdEaXI7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbiA9IGdlb21ldHJ5UG9zaXRpb247XFxuXFx0XFx0dmVjMyBsaWdodFBvcyA9IHJlY3RBcmVhTGlnaHQucG9zaXRpb247XFxuXFx0XFx0dmVjMyBoYWxmV2lkdGggPSByZWN0QXJlYUxpZ2h0LmhhbGZXaWR0aDtcXG5cXHRcXHR2ZWMzIGhhbGZIZWlnaHQgPSByZWN0QXJlYUxpZ2h0LmhhbGZIZWlnaHQ7XFxuXFx0XFx0dmVjMyBsaWdodENvbG9yID0gcmVjdEFyZWFMaWdodC5jb2xvcjtcXG5cXHRcXHRmbG9hdCByb3VnaG5lc3MgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XFxuXFx0XFx0dmVjMyByZWN0Q29vcmRzWyA0IF07XFxuXFx0XFx0cmVjdENvb3Jkc1sgMCBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0O1xcdFxcdHJlY3RDb29yZHNbIDEgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoIC0gaGFsZkhlaWdodDtcXG5cXHRcXHRyZWN0Q29vcmRzWyAyIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxuXFx0XFx0cmVjdENvb3Jkc1sgMyBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0O1xcblxcdFxcdHZlYzIgdXYgPSBMVENfVXYoIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7XFxuXFx0XFx0dmVjNCB0MSA9IHRleHR1cmUyRCggbHRjXzEsIHV2ICk7XFxuXFx0XFx0dmVjNCB0MiA9IHRleHR1cmUyRCggbHRjXzIsIHV2ICk7XFxuXFx0XFx0bWF0MyBtSW52ID0gbWF0MyhcXG5cXHRcXHRcXHR2ZWMzKCB0MS54LCAwLCB0MS55ICksXFxuXFx0XFx0XFx0dmVjMyggICAgMCwgMSwgICAgMCApLFxcblxcdFxcdFxcdHZlYzMoIHQxLnosIDAsIHQxLncgKVxcblxcdFxcdCk7XFxuXFx0XFx0dmVjMyBmcmVzbmVsID0gKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICogdDIueCArICggdmVjMyggMS4wICkgLSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICkgKiB0Mi55ICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gbGlnaHRDb2xvciAqIGZyZXNuZWwgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1JbnYsIHJlY3RDb29yZHMgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGxpZ2h0Q29sb3IgKiBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1hdDMoIDEuMCApLCByZWN0Q29vcmRzICk7XFxuXFx0fVxcbiNlbmRpZlxcbnZvaWQgUkVfRGlyZWN0X1BoeXNpY2FsKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRmbG9hdCBkb3ROTGNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0XFx0dmVjMyBjY0lycmFkaWFuY2UgPSBkb3ROTGNjICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0XFx0Y2xlYXJjb2F0U3BlY3VsYXJEaXJlY3QgKz0gY2NJcnJhZGlhbmNlICogQlJERl9HR1hfQ2xlYXJjb2F0KCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsICk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TSEVFTlxcblxcdFxcdHNoZWVuU3BlY3VsYXJEaXJlY3QgKz0gaXJyYWRpYW5jZSAqIEJSREZfU2hlZW4oIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeU5vcm1hbCwgbWF0ZXJpYWwuc2hlZW5Db2xvciwgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9HR1goIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeU5vcm1hbCwgbWF0ZXJpYWwgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyByYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGNsZWFyY29hdFJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCkge1xcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0XFx0Y2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCArPSBjbGVhcmNvYXRSYWRpYW5jZSAqIEVudmlyb25tZW50QlJERiggZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TSEVFTlxcblxcdFxcdHNoZWVuU3BlY3VsYXJJbmRpcmVjdCArPSBpcnJhZGlhbmNlICogbWF0ZXJpYWwuc2hlZW5Db2xvciAqIElCTFNoZWVuQlJERiggZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG5cXHR2ZWMzIHNpbmdsZVNjYXR0ZXJpbmcgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIG11bHRpU2NhdHRlcmluZyA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzMgY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlID0gaXJyYWRpYW5jZSAqIFJFQ0lQUk9DQUxfUEk7XFxuXFx0I2lmZGVmIFVTRV9JUklERVNDRU5DRVxcblxcdFxcdGNvbXB1dGVNdWx0aXNjYXR0ZXJpbmdJcmlkZXNjZW5jZSggZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsIG1hdGVyaWFsLmlyaWRlc2NlbmNlLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIG1hdGVyaWFsLnJvdWdobmVzcywgc2luZ2xlU2NhdHRlcmluZywgbXVsdGlTY2F0dGVyaW5nICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwucm91Z2huZXNzLCBzaW5nbGVTY2F0dGVyaW5nLCBtdWx0aVNjYXR0ZXJpbmcgKTtcXG5cXHQjZW5kaWZcXG5cXHR2ZWMzIHRvdGFsU2NhdHRlcmluZyA9IHNpbmdsZVNjYXR0ZXJpbmcgKyBtdWx0aVNjYXR0ZXJpbmc7XFxuXFx0dmVjMyBkaWZmdXNlID0gbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICogKCAxLjAgLSBtYXgoIG1heCggdG90YWxTY2F0dGVyaW5nLnIsIHRvdGFsU2NhdHRlcmluZy5nICksIHRvdGFsU2NhdHRlcmluZy5iICkgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IHJhZGlhbmNlICogc2luZ2xlU2NhdHRlcmluZztcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IG11bHRpU2NhdHRlcmluZyAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gZGlmZnVzZSAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0RpcmVjdF9SZWN0QXJlYVxcdFxcdFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsXFxuI2RlZmluZSBSRV9JbmRpcmVjdFNwZWN1bGFyXFx0XFx0UkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbFxcbmZsb2F0IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGFtYmllbnRPY2NsdXNpb24sIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIHBvdyggZG90TlYgKyBhbWJpZW50T2NjbHVzaW9uLCBleHAyKCAtIDE2LjAgKiByb3VnaG5lc3MgLSAxLjAgKSApIC0gMS4wICsgYW1iaWVudE9jY2x1c2lvbiApO1xcbn1cIjtcblxudmFyIGxpZ2h0c19mcmFnbWVudF9iZWdpbiA9IFwiXFxudmVjMyBnZW9tZXRyeVBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uO1xcbnZlYzMgZ2VvbWV0cnlOb3JtYWwgPSBub3JtYWw7XFxudmVjMyBnZW9tZXRyeVZpZXdEaXIgPSAoIGlzT3J0aG9ncmFwaGljICkgPyB2ZWMzKCAwLCAwLCAxICkgOiBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG52ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsID0gdmVjMyggMC4wICk7XFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCA9IGNsZWFyY29hdE5vcm1hbDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxuXFx0ZmxvYXQgZG90TlZpID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIgKSApO1xcblxcdGlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MgPT0gMC4wICkge1xcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlID0gMC4wO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2UgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuaXJpZGVzY2VuY2UgKTtcXG5cXHR9XFxuXFx0aWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSA+IDAuMCApIHtcXG5cXHRcXHRtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwgPSBldmFsSXJpZGVzY2VuY2UoIDEuMCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1IsIGRvdE5WaSwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKTtcXG5cXHRcXHRtYXRlcmlhbC5pcmlkZXNjZW5jZUYwID0gU2NobGlja190b19GMCggbWF0ZXJpYWwuaXJpZGVzY2VuY2VGcmVzbmVsLCAxLjAsIGRvdE5WaSApO1xcblxcdH1cXG4jZW5kaWZcXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcbiNpZiAoIE5VTV9QT0lOVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXHRQb2ludExpZ2h0IHBvaW50TGlnaHQ7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3c7XFxuXFx0I2VuZGlmXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0UG9pbnRMaWdodEluZm8oIHBvaW50TGlnaHQsIGdlb21ldHJ5UG9zaXRpb24sIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0cG9pbnRMaWdodFNoYWRvdyA9IHBvaW50TGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gKCBkaXJlY3RMaWdodC52aXNpYmxlICYmIHJlY2VpdmVTaGFkb3cgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93QmlhcywgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXG5cXHR2ZWM0IHNwb3RDb2xvcjtcXG5cXHR2ZWMzIHNwb3RMaWdodENvb3JkO1xcblxcdGJvb2wgaW5TcG90TGlnaHRNYXA7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3c7XFxuXFx0I2VuZGlmXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRzcG90TGlnaHQgPSBzcG90TGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0U3BvdExpZ2h0SW5mbyggc3BvdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTX1dJVEhfTUFQUyApXFxuXFx0XFx0I2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCBVTlJPTExFRF9MT09QX0lOREVYXFxuXFx0XFx0I2VsaWYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0I2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCBOVU1fU1BPVF9MSUdIVF9NQVBTXFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHQjZGVmaW5lIFNQT1RfTElHSFRfTUFQX0lOREVYICggVU5ST0xMRURfTE9PUF9JTkRFWCAtIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTX1dJVEhfTUFQUyApXFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0I2lmICggU1BPVF9MSUdIVF9NQVBfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9NQVBTIClcXG5cXHRcXHRcXHRzcG90TGlnaHRDb29yZCA9IHZTcG90TGlnaHRDb29yZFsgaSBdLnh5eiAvIHZTcG90TGlnaHRDb29yZFsgaSBdLnc7XFxuXFx0XFx0XFx0aW5TcG90TGlnaHRNYXAgPSBhbGwoIGxlc3NUaGFuKCBhYnMoIHNwb3RMaWdodENvb3JkICogMi4gLSAxLiApLCB2ZWMzKCAxLjAgKSApICk7XFxuXFx0XFx0XFx0c3BvdENvbG9yID0gdGV4dHVyZTJEKCBzcG90TGlnaHRNYXBbIFNQT1RfTElHSFRfTUFQX0lOREVYIF0sIHNwb3RMaWdodENvb3JkLnh5ICk7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBpblNwb3RMaWdodE1hcCA/IGRpcmVjdExpZ2h0LmNvbG9yICogc3BvdENvbG9yLnJnYiA6IGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdCN1bmRlZiBTUE9UX0xJR0hUX01BUF9JTkRFWFxcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0c3BvdExpZ2h0U2hhZG93ID0gc3BvdExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9ICggZGlyZWN0TGlnaHQudmlzaWJsZSAmJiByZWNlaXZlU2hhZG93ICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2U3BvdExpZ2h0Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5UG9zaXRpb24sIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgKCBOVU1fRElSX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHREaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3c7XFxuXFx0I2VuZGlmXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldERpcmVjdGlvbmFsTGlnaHRJbmZvKCBkaXJlY3Rpb25hbExpZ2h0LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHRkaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSAoIGRpcmVjdExpZ2h0LnZpc2libGUgJiYgcmVjZWl2ZVNoYWRvdyApID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmICggTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0X1JlY3RBcmVhIClcXG5cXHRSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9SRUNUX0FSRUFfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHJlY3RBcmVhTGlnaHQgPSByZWN0QXJlYUxpZ2h0c1sgaSBdO1xcblxcdFxcdFJFX0RpcmVjdF9SZWN0QXJlYSggcmVjdEFyZWFMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxcblxcdHZlYzMgaWJsSXJyYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9MSUdIVF9QUk9CRVMgKVxcblxcdFxcdGlycmFkaWFuY2UgKz0gZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGxpZ2h0UHJvYmUsIGdlb21ldHJ5Tm9ybWFsICk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmICggTlVNX0hFTUlfTElHSFRTID4gMCApXFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRcXHRpcnJhZGlhbmNlICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnlOb3JtYWwgKTtcXG5cXHRcXHR9XFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxuXFx0dmVjMyByYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzMgY2xlYXJjb2F0UmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXG4jZW5kaWZcIjtcblxudmFyIGxpZ2h0c19mcmFnbWVudF9tYXBzID0gXCIjaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcXG5cXHQjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0XFx0dmVjNCBsaWdodE1hcFRleGVsID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdkxpZ2h0TWFwVXYgKTtcXG5cXHRcXHR2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IGxpZ2h0TWFwVGV4ZWwucmdiICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFx0XFx0aXJyYWRpYW5jZSArPSBsaWdodE1hcElycmFkaWFuY2U7XFxuXFx0I2VuZGlmXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBTVEFOREFSRCApICYmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdFxcdGlibElycmFkaWFuY2UgKz0gZ2V0SUJMSXJyYWRpYW5jZSggZ2VvbWV0cnlOb3JtYWwgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdCNpZmRlZiBVU0VfQU5JU09UUk9QWVxcblxcdFxcdHJhZGlhbmNlICs9IGdldElCTEFuaXNvdHJvcHlSYWRpYW5jZSggZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeU5vcm1hbCwgbWF0ZXJpYWwucm91Z2huZXNzLCBtYXRlcmlhbC5hbmlzb3Ryb3B5QiwgbWF0ZXJpYWwuYW5pc290cm9weSApO1xcblxcdCNlbHNlXFxuXFx0XFx0cmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0XFx0Y2xlYXJjb2F0UmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgbGlnaHRzX2ZyYWdtZW50X2VuZCA9IFwiI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXFx0UkVfSW5kaXJlY3REaWZmdXNlKCBpcnJhZGlhbmNlLCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdFJFX0luZGlyZWN0U3BlY3VsYXIoIHJhZGlhbmNlLCBpYmxJcnJhZGlhbmNlLCBjbGVhcmNvYXRSYWRpYW5jZSwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlwiO1xuXG52YXIgbG9nZGVwdGhidWZfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKVxcblxcdGdsX0ZyYWdEZXB0aCA9IHZJc1BlcnNwZWN0aXZlID09IDAuMCA/IGdsX0ZyYWdDb29yZC56IDogbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG4jZW5kaWZcIjtcblxudmFyIGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKVxcblxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFx0dmFyeWluZyBmbG9hdCB2SXNQZXJzcGVjdGl2ZTtcXG4jZW5kaWZcIjtcblxudmFyIGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdHZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7XFxuI2VuZGlmXCI7XG5cbnZhciBsb2dkZXB0aGJ1Zl92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXHR2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXHR2SXNQZXJzcGVjdGl2ZSA9IGZsb2F0KCBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICkgKTtcXG4jZW5kaWZcIjtcblxudmFyIG1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR2ZWM0IHNhbXBsZWREaWZmdXNlQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdk1hcFV2ICk7XFxuXFx0I2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFXFxuXFx0XFx0c2FtcGxlZERpZmZ1c2VDb2xvciA9IHZlYzQoIG1peCggcG93KCBzYW1wbGVkRGlmZnVzZUNvbG9yLnJnYiAqIDAuOTQ3ODY3Mjk4NiArIHZlYzMoIDAuMDUyMTMyNzAxNCApLCB2ZWMzKCAyLjQgKSApLCBzYW1wbGVkRGlmZnVzZUNvbG9yLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggc2FtcGxlZERpZmZ1c2VDb2xvci5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgc2FtcGxlZERpZmZ1c2VDb2xvci53ICk7XFxuXFx0XFxuXFx0I2VuZGlmXFxuXFx0ZGlmZnVzZUNvbG9yICo9IHNhbXBsZWREaWZmdXNlQ29sb3I7XFxuI2VuZGlmXCI7XG5cbnZhciBtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBtYXBfcGFydGljbGVfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcXG5cXHQjaWYgZGVmaW5lZCggVVNFX1BPSU5UU19VViApXFxuXFx0XFx0dmVjMiB1diA9IHZVdjtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzIgdXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnksIDEgKSApLnh5O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUFQXFxuXFx0ZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB1diApO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB1diApLmc7XFxuI2VuZGlmXCI7XG5cbnZhciBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9QT0lOVFNfVVYgKVxcblxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuI2Vsc2VcXG5cXHQjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFx0XFx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXG4jZW5kaWZcIjtcblxudmFyIG1ldGFsbmVzc21hcF9mcmFnbWVudCA9IFwiZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dmVjNCB0ZXhlbE1ldGFsbmVzcyA9IHRleHR1cmUyRCggbWV0YWxuZXNzTWFwLCB2TWV0YWxuZXNzTWFwVXYgKTtcXG5cXHRtZXRhbG5lc3NGYWN0b3IgKj0gdGV4ZWxNZXRhbG5lc3MuYjtcXG4jZW5kaWZcIjtcblxudmFyIG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbmVzc01hcDtcXG4jZW5kaWZcIjtcblxudmFyIG1vcnBoaW5zdGFuY2VfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0lOU1RBTkNJTkdfTU9SUEhcXG5cXHRmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIE1PUlBIVEFSR0VUU19DT1VOVCBdO1xcblxcdGZsb2F0IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZSA9IHRleGVsRmV0Y2goIG1vcnBoVGV4dHVyZSwgaXZlYzIoIDAsIGdsX0luc3RhbmNlSUQgKSwgMCApLnI7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkge1xcblxcdFxcdG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9ICB0ZXhlbEZldGNoKCBtb3JwaFRleHR1cmUsIGl2ZWMyKCBpICsgMSwgZ2xfSW5zdGFuY2VJRCApLCAwICkucjtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBtb3JwaGNvbG9yX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9NT1JQSENPTE9SUyApXFxuXFx0dkNvbG9yICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXFxuXFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB2Q29sb3IgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAyICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKVxcblxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgdkNvbG9yICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMiApLnJnYiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIG1vcnBobm9ybWFsX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXHRvYmplY3ROb3JtYWwgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE1PUlBIVEFSR0VUU19DT1VOVDsgaSArKyApIHtcXG5cXHRcXHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIG9iamVjdE5vcm1hbCArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDEgKS54eXogKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXHQjaWZuZGVmIFVTRV9JTlNUQU5DSU5HX01PUlBIXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIE1PUlBIVEFSR0VUU19DT1VOVCBdO1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gc2FtcGxlcjJEQXJyYXkgbW9ycGhUYXJnZXRzVGV4dHVyZTtcXG5cXHR1bmlmb3JtIGl2ZWMyIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplO1xcblxcdHZlYzQgZ2V0TW9ycGgoIGNvbnN0IGluIGludCB2ZXJ0ZXhJbmRleCwgY29uc3QgaW4gaW50IG1vcnBoVGFyZ2V0SW5kZXgsIGNvbnN0IGluIGludCBvZmZzZXQgKSB7XFxuXFx0XFx0aW50IHRleGVsSW5kZXggPSB2ZXJ0ZXhJbmRleCAqIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSArIG9mZnNldDtcXG5cXHRcXHRpbnQgeSA9IHRleGVsSW5kZXggLyBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54O1xcblxcdFxcdGludCB4ID0gdGV4ZWxJbmRleCAtIHkgKiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54O1xcblxcdFxcdGl2ZWMzIG1vcnBoVVYgPSBpdmVjMyggeCwgeSwgbW9ycGhUYXJnZXRJbmRleCApO1xcblxcdFxcdHJldHVybiB0ZXhlbEZldGNoKCBtb3JwaFRhcmdldHNUZXh0dXJlLCBtb3JwaFVWLCAwICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgbW9ycGh0YXJnZXRfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHRyYW5zZm9ybWVkICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XFxuXFx0XFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB0cmFuc2Zvcm1lZCArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDAgKS54eXogKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBub3JtYWxfZnJhZ21lbnRfYmVnaW4gPSBcImZsb2F0IGZhY2VEaXJlY3Rpb24gPSBnbF9Gcm9udEZhY2luZyA/IDEuMCA6IC0gMS4wO1xcbiNpZmRlZiBGTEFUX1NIQURFRFxcblxcdHZlYzMgZmR4ID0gZEZkeCggdlZpZXdQb3NpdGlvbiApO1xcblxcdHZlYzMgZmR5ID0gZEZkeSggdlZpZXdQb3NpdGlvbiApO1xcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcbiNlbHNlXFxuXFx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHZOb3JtYWwgKTtcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0bm9ybWFsICo9IGZhY2VEaXJlY3Rpb247XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkgfHwgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApXFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0bWF0MyB0Ym4gPSBtYXQzKCBub3JtYWxpemUoIHZUYW5nZW50ICksIG5vcm1hbGl6ZSggdkJpdGFuZ2VudCApLCBub3JtYWwgKTtcXG5cXHQjZWxzZVxcblxcdFxcdG1hdDMgdGJuID0gZ2V0VGFuZ2VudEZyYW1lKCAtIHZWaWV3UG9zaXRpb24sIG5vcm1hbCxcXG5cXHRcXHQjaWYgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxuXFx0XFx0XFx0dk5vcm1hbE1hcFV2XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKVxcblxcdFxcdFxcdHZDbGVhcmNvYXROb3JtYWxNYXBVdlxcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dlV2XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0KTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggRE9VQkxFX1NJREVEICkgJiYgISBkZWZpbmVkKCBGTEFUX1NIQURFRCApXFxuXFx0XFx0dGJuWzBdICo9IGZhY2VEaXJlY3Rpb247XFxuXFx0XFx0dGJuWzFdICo9IGZhY2VEaXJlY3Rpb247XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0bWF0MyB0Ym4yID0gbWF0Myggbm9ybWFsaXplKCB2VGFuZ2VudCApLCBub3JtYWxpemUoIHZCaXRhbmdlbnQgKSwgbm9ybWFsICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRtYXQzIHRibjIgPSBnZXRUYW5nZW50RnJhbWUoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXYgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggRE9VQkxFX1NJREVEICkgJiYgISBkZWZpbmVkKCBGTEFUX1NIQURFRCApXFxuXFx0XFx0dGJuMlswXSAqPSBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdHRibjJbMV0gKj0gZmFjZURpcmVjdGlvbjtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG52ZWMzIG5vblBlcnR1cmJlZE5vcm1hbCA9IG5vcm1hbDtcIjtcblxudmFyIG5vcm1hbF9mcmFnbWVudF9tYXBzID0gXCIjaWZkZWYgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRVxcblxcdG5vcm1hbCA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2Tm9ybWFsTWFwVXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXFx0I2lmZGVmIEZMSVBfU0lERURcXG5cXHRcXHRub3JtYWwgPSAtIG5vcm1hbDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0bm9ybWFsID0gbm9ybWFsICogZmFjZURpcmVjdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHRub3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFIClcXG5cXHR2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdk5vcm1hbE1hcFV2ICkueHl6ICogMi4wIC0gMS4wO1xcblxcdG1hcE4ueHkgKj0gbm9ybWFsU2NhbGU7XFxuXFx0bm9ybWFsID0gbm9ybWFsaXplKCB0Ym4gKiBtYXBOICk7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSwgZmFjZURpcmVjdGlvbiApO1xcbiNlbmRpZlwiO1xuXG52YXIgbm9ybWFsX3BhcnNfZnJhZ21lbnQgPSBcIiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBub3JtYWxfcGFyc192ZXJ0ZXggPSBcIiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBub3JtYWxfdmVydGV4ID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2VGFuZ2VudCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWRUYW5nZW50ICk7XFxuXFx0XFx0dkJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXG5cXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9OT1JNQUxNQVBfT0JKRUNUU1BBQ0VcXG5cXHR1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4O1xcbiNlbmRpZlxcbiNpZiAhIGRlZmluZWQgKCBVU0VfVEFOR0VOVCApICYmICggZGVmaW5lZCAoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkgfHwgZGVmaW5lZCAoIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKSApXFxuXFx0bWF0MyBnZXRUYW5nZW50RnJhbWUoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgdXYgKSB7XFxuXFx0XFx0dmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7XFxuXFx0XFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXFx0XFx0dmVjMiBzdDAgPSBkRmR4KCB1di5zdCApO1xcblxcdFxcdHZlYzIgc3QxID0gZEZkeSggdXYuc3QgKTtcXG5cXHRcXHR2ZWMzIE4gPSBzdXJmX25vcm07XFxuXFx0XFx0dmVjMyBxMXBlcnAgPSBjcm9zcyggcTEsIE4gKTtcXG5cXHRcXHR2ZWMzIHEwcGVycCA9IGNyb3NzKCBOLCBxMCApO1xcblxcdFxcdHZlYzMgVCA9IHExcGVycCAqIHN0MC54ICsgcTBwZXJwICogc3QxLng7XFxuXFx0XFx0dmVjMyBCID0gcTFwZXJwICogc3QwLnkgKyBxMHBlcnAgKiBzdDEueTtcXG5cXHRcXHRmbG9hdCBkZXQgPSBtYXgoIGRvdCggVCwgVCApLCBkb3QoIEIsIEIgKSApO1xcblxcdFxcdGZsb2F0IHNjYWxlID0gKCBkZXQgPT0gMC4wICkgPyAwLjAgOiBpbnZlcnNlc3FydCggZGV0ICk7XFxuXFx0XFx0cmV0dXJuIG1hdDMoIFQgKiBzY2FsZSwgQiAqIHNjYWxlLCBOICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbiA9IFwiI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHR2ZWMzIGNsZWFyY29hdE5vcm1hbCA9IG5vblBlcnR1cmJlZE5vcm1hbDtcXG4jZW5kaWZcIjtcblxudmFyIGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcyA9IFwiI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXFxuXFx0dmVjMyBjbGVhcmNvYXRNYXBOID0gdGV4dHVyZTJEKCBjbGVhcmNvYXROb3JtYWxNYXAsIHZDbGVhcmNvYXROb3JtYWxNYXBVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cXHRjbGVhcmNvYXRNYXBOLnh5ICo9IGNsZWFyY29hdE5vcm1hbFNjYWxlO1xcblxcdGNsZWFyY29hdE5vcm1hbCA9IG5vcm1hbGl6ZSggdGJuMiAqIGNsZWFyY29hdE1hcE4gKTtcXG4jZW5kaWZcIjtcblxudmFyIGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0NMRUFSQ09BVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdE1hcDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXROb3JtYWxNYXA7XFxuXFx0dW5pZm9ybSB2ZWMyIGNsZWFyY29hdE5vcm1hbFNjYWxlO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdFJvdWdobmVzc01hcDtcXG4jZW5kaWZcIjtcblxudmFyIGlyaWRlc2NlbmNlX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBpcmlkZXNjZW5jZU1hcDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwO1xcbiNlbmRpZlwiO1xuXG52YXIgb3BhcXVlX2ZyYWdtZW50ID0gXCIjaWZkZWYgT1BBUVVFXFxuZGlmZnVzZUNvbG9yLmEgPSAxLjA7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5kaWZmdXNlQ29sb3IuYSAqPSBtYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYTtcXG4jZW5kaWZcXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiO1xuXG52YXIgcGFja2luZyA9IFwidmVjMyBwYWNrTm9ybWFsVG9SR0IoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdHJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41O1xcbn1cXG52ZWMzIHVucGFja1JHQlRvTm9ybWFsKCBjb25zdCBpbiB2ZWMzIHJnYiApIHtcXG5cXHRyZXR1cm4gMi4wICogcmdiLnh5eiAtIDEuMDtcXG59XFxuY29uc3QgZmxvYXQgUGFja1Vwc2NhbGUgPSAyNTYuIC8gMjU1Ljtjb25zdCBmbG9hdCBVbnBhY2tEb3duc2NhbGUgPSAyNTUuIC8gMjU2LjtcXG5jb25zdCB2ZWMzIFBhY2tGYWN0b3JzID0gdmVjMyggMjU2LiAqIDI1Ni4gKiAyNTYuLCAyNTYuICogMjU2LiwgMjU2LiApO1xcbmNvbnN0IHZlYzQgVW5wYWNrRmFjdG9ycyA9IFVucGFja0Rvd25zY2FsZSAvIHZlYzQoIFBhY2tGYWN0b3JzLCAxLiApO1xcbmNvbnN0IGZsb2F0IFNoaWZ0UmlnaHQ4ID0gMS4gLyAyNTYuO1xcbnZlYzQgcGFja0RlcHRoVG9SR0JBKCBjb25zdCBpbiBmbG9hdCB2ICkge1xcblxcdHZlYzQgciA9IHZlYzQoIGZyYWN0KCB2ICogUGFja0ZhY3RvcnMgKSwgdiApO1xcblxcdHIueXp3IC09IHIueHl6ICogU2hpZnRSaWdodDg7XFx0cmV0dXJuIHIgKiBQYWNrVXBzY2FsZTtcXG59XFxuZmxvYXQgdW5wYWNrUkdCQVRvRGVwdGgoIGNvbnN0IGluIHZlYzQgdiApIHtcXG5cXHRyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzICk7XFxufVxcbnZlYzIgcGFja0RlcHRoVG9SRyggaW4gaGlnaHAgZmxvYXQgdiApIHtcXG5cXHRyZXR1cm4gcGFja0RlcHRoVG9SR0JBKCB2ICkueXg7XFxufVxcbmZsb2F0IHVucGFja1JHVG9EZXB0aCggY29uc3QgaW4gaGlnaHAgdmVjMiB2ICkge1xcblxcdHJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCggdmVjNCggdi54eSwgMC4wLCAwLjAgKSApO1xcbn1cXG52ZWM0IHBhY2sySGFsZlRvUkdCQSggdmVjMiB2ICkge1xcblxcdHZlYzQgciA9IHZlYzQoIHYueCwgZnJhY3QoIHYueCAqIDI1NS4wICksIHYueSwgZnJhY3QoIHYueSAqIDI1NS4wICkgKTtcXG5cXHRyZXR1cm4gdmVjNCggci54IC0gci55IC8gMjU1LjAsIHIueSwgci56IC0gci53IC8gMjU1LjAsIHIudyApO1xcbn1cXG52ZWMyIHVucGFja1JHQkFUbzJIYWxmKCB2ZWM0IHYgKSB7XFxuXFx0cmV0dXJuIHZlYzIoIHYueCArICggdi55IC8gMjU1LjAgKSwgdi56ICsgKCB2LncgLyAyNTUuMCApICk7XFxufVxcbmZsb2F0IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gKCB2aWV3WiArIG5lYXIgKSAvICggbmVhciAtIGZhciApO1xcbn1cXG5mbG9hdCBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGRlcHRoLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuIGRlcHRoICogKCBuZWFyIC0gZmFyICkgLSBuZWFyO1xcbn1cXG5mbG9hdCB2aWV3WlRvUGVyc3BlY3RpdmVEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gKCAoIG5lYXIgKyB2aWV3WiApICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogdmlld1ogKTtcXG59XFxuZmxvYXQgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGRlcHRoLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuICggbmVhciAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIGRlcHRoIC0gZmFyICk7XFxufVwiO1xuXG52YXIgcHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudCA9IFwiI2lmZGVmIFBSRU1VTFRJUExJRURfQUxQSEFcXG5cXHRnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hO1xcbiNlbmRpZlwiO1xuXG52YXIgcHJvamVjdF92ZXJ0ZXggPSBcInZlYzQgbXZQb3NpdGlvbiA9IHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG4jaWZkZWYgVVNFX0JBVENISU5HXFxuXFx0bXZQb3NpdGlvbiA9IGJhdGNoaW5nTWF0cml4ICogbXZQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5cXHRtdlBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiBtdlBvc2l0aW9uO1xcbiNlbmRpZlxcbm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBtdlBvc2l0aW9uO1xcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCI7XG5cbnZhciBkaXRoZXJpbmdfZnJhZ21lbnQgPSBcIiNpZmRlZiBESVRIRVJJTkdcXG5cXHRnbF9GcmFnQ29sb3IucmdiID0gZGl0aGVyaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XFxuI2VuZGlmXCI7XG5cbnZhciBkaXRoZXJpbmdfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIERJVEhFUklOR1xcblxcdHZlYzMgZGl0aGVyaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdFxcdGZsb2F0IGdyaWRfcG9zaXRpb24gPSByYW5kKCBnbF9GcmFnQ29vcmQueHkgKTtcXG5cXHRcXHR2ZWMzIGRpdGhlcl9zaGlmdF9SR0IgPSB2ZWMzKCAwLjI1IC8gMjU1LjAsIC0wLjI1IC8gMjU1LjAsIDAuMjUgLyAyNTUuMCApO1xcblxcdFxcdGRpdGhlcl9zaGlmdF9SR0IgPSBtaXgoIDIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIC0yLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCBncmlkX3Bvc2l0aW9uICk7XFxuXFx0XFx0cmV0dXJuIGNvbG9yICsgZGl0aGVyX3NoaWZ0X1JHQjtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciByb3VnaG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlJvdWdobmVzc01hcFV2ICk7XFxuXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLmc7XFxuI2VuZGlmXCI7XG5cbnZhciByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBzaGFkb3dtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzQgdlNwb3RMaWdodENvb3JkWyBOVU1fU1BPVF9MSUdIVF9DT09SRFMgXTtcXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRfTUFQUyA+IDBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90TGlnaHRNYXBbIE5VTV9TUE9UX0xJR0hUX01BUFMgXTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90U2hhZG93TWFwWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IFNwb3RMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHBvaW50U2hhZG93TWFwWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHRzdHJ1Y3QgUG9pbnRMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dDYW1lcmFGYXI7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIFBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodFNoYWRvd3NbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuXFx0ZmxvYXQgdGV4dHVyZTJEQ29tcGFyZSggc2FtcGxlcjJEIGRlcHRocywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXG5cXHRcXHRyZXR1cm4gc3RlcCggY29tcGFyZSwgdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggZGVwdGhzLCB1diApICkgKTtcXG5cXHR9XFxuXFx0dmVjMiB0ZXh0dXJlMkREaXN0cmlidXRpb24oIHNhbXBsZXIyRCBzaGFkb3csIHZlYzIgdXYgKSB7XFxuXFx0XFx0cmV0dXJuIHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvdywgdXYgKSApO1xcblxcdH1cXG5cXHRmbG9hdCBWU01TaGFkb3cgKHNhbXBsZXIyRCBzaGFkb3csIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKXtcXG5cXHRcXHRmbG9hdCBvY2NsdXNpb24gPSAxLjA7XFxuXFx0XFx0dmVjMiBkaXN0cmlidXRpb24gPSB0ZXh0dXJlMkREaXN0cmlidXRpb24oIHNoYWRvdywgdXYgKTtcXG5cXHRcXHRmbG9hdCBoYXJkX3NoYWRvdyA9IHN0ZXAoIGNvbXBhcmUgLCBkaXN0cmlidXRpb24ueCApO1xcblxcdFxcdGlmIChoYXJkX3NoYWRvdyAhPSAxLjAgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgZGlzdGFuY2UgPSBjb21wYXJlIC0gZGlzdHJpYnV0aW9uLnggO1xcblxcdFxcdFxcdGZsb2F0IHZhcmlhbmNlID0gbWF4KCAwLjAwMDAwLCBkaXN0cmlidXRpb24ueSAqIGRpc3RyaWJ1dGlvbi55ICk7XFxuXFx0XFx0XFx0ZmxvYXQgc29mdG5lc3NfcHJvYmFiaWxpdHkgPSB2YXJpYW5jZSAvICh2YXJpYW5jZSArIGRpc3RhbmNlICogZGlzdGFuY2UgKTtcXHRcXHRcXHRzb2Z0bmVzc19wcm9iYWJpbGl0eSA9IGNsYW1wKCAoIHNvZnRuZXNzX3Byb2JhYmlsaXR5IC0gMC4zICkgLyAoIDAuOTUgLSAwLjMgKSwgMC4wLCAxLjAgKTtcXHRcXHRcXHRvY2NsdXNpb24gPSBjbGFtcCggbWF4KCBoYXJkX3NoYWRvdywgc29mdG5lc3NfcHJvYmFiaWxpdHkgKSwgMC4wLCAxLjAgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIG9jY2x1c2lvbjtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCApIHtcXG5cXHRcXHRmbG9hdCBzaGFkb3cgPSAxLjA7XFxuXFx0XFx0c2hhZG93Q29vcmQueHl6IC89IHNoYWRvd0Nvb3JkLnc7XFxuXFx0XFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzO1xcblxcdFxcdGJvb2wgaW5GcnVzdHVtID0gc2hhZG93Q29vcmQueCA+PSAwLjAgJiYgc2hhZG93Q29vcmQueCA8PSAxLjAgJiYgc2hhZG93Q29vcmQueSA+PSAwLjAgJiYgc2hhZG93Q29vcmQueSA8PSAxLjA7XFxuXFx0XFx0Ym9vbCBmcnVzdHVtVGVzdCA9IGluRnJ1c3R1bSAmJiBzaGFkb3dDb29yZC56IDw9IDEuMDtcXG5cXHRcXHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IGR4MCA9IC0gdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkwID0gLSB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MSA9ICsgdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHgyID0gZHgwIC8gMi4wO1xcblxcdFxcdFxcdGZsb2F0IGR5MiA9IGR5MCAvIDIuMDtcXG5cXHRcXHRcXHRmbG9hdCBkeDMgPSBkeDEgLyAyLjA7XFxuXFx0XFx0XFx0ZmxvYXQgZHkzID0gZHkxIC8gMi4wO1xcblxcdFxcdFxcdHNoYWRvdyA9IChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgyLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgyLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56IClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyAxNy4wICk7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IGR4ID0gdGV4ZWxTaXplLng7XFxuXFx0XFx0XFx0ZmxvYXQgZHkgPSB0ZXhlbFNpemUueTtcXG5cXHRcXHRcXHR2ZWMyIHV2ID0gc2hhZG93Q29vcmQueHk7XFxuXFx0XFx0XFx0dmVjMiBmID0gZnJhY3QoIHV2ICogc2hhZG93TWFwU2l6ZSArIDAuNSApO1xcblxcdFxcdFxcdHV2IC09IGYgKiB0ZXhlbFNpemU7XFxuXFx0XFx0XFx0c2hhZG93ID0gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYsIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCBkeSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB0ZXhlbFNpemUsIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IGYueCApICtcXG5cXHRcXHRcXHRcXHRtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCBkeSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IGYueCApICtcXG5cXHRcXHRcXHRcXHRtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAwLjAsIC1keSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAwLjAsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi55ICkgK1xcblxcdFxcdFxcdFxcdG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi55ICkgK1xcblxcdFxcdFxcdFxcdG1peCggbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdFxcdCAgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdFxcdCAgZi54ICksXFxuXFx0XFx0XFx0XFx0XFx0IG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgMi4wICogZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdFxcdCAgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICBmLnggKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi55IClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9WU00gKVxcblxcdFxcdFxcdHNoYWRvdyA9IFZTTVNoYWRvdyggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0c2hhZG93ID0gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gc2hhZG93O1xcblxcdH1cXG5cXHR2ZWMyIGN1YmVUb1VWKCB2ZWMzIHYsIGZsb2F0IHRleGVsU2l6ZVkgKSB7XFxuXFx0XFx0dmVjMyBhYnNWID0gYWJzKCB2ICk7XFxuXFx0XFx0ZmxvYXQgc2NhbGVUb0N1YmUgPSAxLjAgLyBtYXgoIGFic1YueCwgbWF4KCBhYnNWLnksIGFic1YueiApICk7XFxuXFx0XFx0YWJzViAqPSBzY2FsZVRvQ3ViZTtcXG5cXHRcXHR2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7XFxuXFx0XFx0dmVjMiBwbGFuYXIgPSB2Lnh5O1xcblxcdFxcdGZsb2F0IGFsbW9zdEFUZXhlbCA9IDEuNSAqIHRleGVsU2l6ZVk7XFxuXFx0XFx0ZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsO1xcblxcdFxcdGlmICggYWJzVi56ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRpZiAoIHYueiA+IDAuMCApXFxuXFx0XFx0XFx0XFx0cGxhbmFyLnggPSA0LjAgLSB2Lng7XFxuXFx0XFx0fSBlbHNlIGlmICggYWJzVi54ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRmbG9hdCBzaWduWCA9IHNpZ24oIHYueCApO1xcblxcdFxcdFxcdHBsYW5hci54ID0gdi56ICogc2lnblggKyAyLjAgKiBzaWduWDtcXG5cXHRcXHR9IGVsc2UgaWYgKCBhYnNWLnkgPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGZsb2F0IHNpZ25ZID0gc2lnbiggdi55ICk7XFxuXFx0XFx0XFx0cGxhbmFyLnggPSB2LnggKyAyLjAgKiBzaWduWSArIDIuMDtcXG5cXHRcXHRcXHRwbGFuYXIueSA9IHYueiAqIHNpZ25ZIC0gMi4wO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdmVjMiggMC4xMjUsIDAuMjUgKSAqIHBsYW5hciArIHZlYzIoIDAuMzc1LCAwLjc1ICk7XFxuXFx0fVxcblxcdGZsb2F0IGdldFBvaW50U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCwgZmxvYXQgc2hhZG93Q2FtZXJhTmVhciwgZmxvYXQgc2hhZG93Q2FtZXJhRmFyICkge1xcblxcdFxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHRcXHR2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ejtcXG5cXHRcXHRcXG5cXHRcXHRmbG9hdCBsaWdodFRvUG9zaXRpb25MZW5ndGggPSBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblxcdFxcdGlmICggbGlnaHRUb1Bvc2l0aW9uTGVuZ3RoIC0gc2hhZG93Q2FtZXJhRmFyIDw9IDAuMCAmJiBsaWdodFRvUG9zaXRpb25MZW5ndGggLSBzaGFkb3dDYW1lcmFOZWFyID49IDAuMCApIHtcXG5cXHRcXHRcXHRmbG9hdCBkcCA9ICggbGlnaHRUb1Bvc2l0aW9uTGVuZ3RoIC0gc2hhZG93Q2FtZXJhTmVhciApIC8gKCBzaGFkb3dDYW1lcmFGYXIgLSBzaGFkb3dDYW1lcmFOZWFyICk7XFx0XFx0XFx0ZHAgKz0gc2hhZG93QmlhcztcXG5cXHRcXHRcXHR2ZWMzIGJkM0QgPSBub3JtYWxpemUoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyAoIHNoYWRvd01hcFNpemUgKiB2ZWMyKCA0LjAsIDIuMCApICk7XFxuXFx0XFx0XFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNIClcXG5cXHRcXHRcXHRcXHR2ZWMyIG9mZnNldCA9IHZlYzIoIC0gMSwgMSApICogc2hhZG93UmFkaXVzICogdGV4ZWxTaXplLnk7XFxuXFx0XFx0XFx0XFx0c2hhZG93ID0gKFxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcblxcdFxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0c2hhZG93ID0gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHNoYWRvdztcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBzaGFkb3dtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZiBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwXFxuXFx0dW5pZm9ybSBtYXQ0IHNwb3RMaWdodE1hdHJpeFsgTlVNX1NQT1RfTElHSFRfQ09PUkRTIF07XFxuXFx0dmFyeWluZyB2ZWM0IHZTcG90TGlnaHRDb29yZFsgTlVNX1NQT1RfTElHSFRfQ09PUkRTIF07XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHVuaWZvcm0gbWF0NCBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHN0cnVjdCBTcG90TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93c1sgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgcG9pbnRTaGFkb3dNYXRyaXhbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dDYW1lcmFOZWFyO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYUZhcjtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gUG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93c1sgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIHNoYWRvd21hcF92ZXJ0ZXggPSBcIiNpZiAoIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAgfHwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwICkgKSB8fCAoIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDAgKVxcblxcdHZlYzMgc2hhZG93V29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdHZlYzQgc2hhZG93V29ybGRQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdFxcdHNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uICsgdmVjNCggc2hhZG93V29ybGROb3JtYWwgKiBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTtcXG5cXHRcXHRcXHR2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdID0gZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247XFxuXFx0XFx0fVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcXG5cXHRcXHRcXHRzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogcG9pbnRMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzLCAwICk7XFxuXFx0XFx0XFx0dlBvaW50U2hhZG93Q29vcmRbIGkgXSA9IHBvaW50U2hhZG93TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvc2l0aW9uO1xcblxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZiBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUX0NPT1JEUzsgaSArKyApIHtcXG5cXHRcXHRzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcXG5cXHRcXHQjaWYgKCBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKVxcblxcdFxcdFxcdHNoYWRvd1dvcmxkUG9zaXRpb24ueHl6ICs9IHNoYWRvd1dvcmxkTm9ybWFsICogc3BvdExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0dlNwb3RMaWdodENvb3JkWyBpIF0gPSBzcG90TGlnaHRNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXCI7XG5cbnZhciBzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQgPSBcImZsb2F0IGdldFNoYWRvd01hc2soKSB7XFxuXFx0ZmxvYXQgc2hhZG93ID0gMS4wO1xcblxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHREaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcXG5cXHRcXHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0U3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodDtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcXG5cXHRcXHRzcG90TGlnaHQgPSBzcG90TGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IHJlY2VpdmVTaGFkb3cgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdExpZ2h0Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYUZhciApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNlbmRpZlxcblxcdHJldHVybiBzaGFkb3c7XFxufVwiO1xuXG52YXIgc2tpbmJhc2VfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0bWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxuXFx0bWF0NCBib25lTWF0WSA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC55ICk7XFxuXFx0bWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XFxuXFx0bWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxuI2VuZGlmXCI7XG5cbnZhciBza2lubmluZ19wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXHR1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG5cXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0aW50IHNpemUgPSB0ZXh0dXJlU2l6ZSggYm9uZVRleHR1cmUsIDAgKS54O1xcblxcdFxcdGludCBqID0gaW50KCBpICkgKiA0O1xcblxcdFxcdGludCB4ID0gaiAlIHNpemU7XFxuXFx0XFx0aW50IHkgPSBqIC8gc2l6ZTtcXG5cXHRcXHR2ZWM0IHYxID0gdGV4ZWxGZXRjaCggYm9uZVRleHR1cmUsIGl2ZWMyKCB4LCB5ICksIDAgKTtcXG5cXHRcXHR2ZWM0IHYyID0gdGV4ZWxGZXRjaCggYm9uZVRleHR1cmUsIGl2ZWMyKCB4ICsgMSwgeSApLCAwICk7XFxuXFx0XFx0dmVjNCB2MyA9IHRleGVsRmV0Y2goIGJvbmVUZXh0dXJlLCBpdmVjMiggeCArIDIsIHkgKSwgMCApO1xcblxcdFxcdHZlYzQgdjQgPSB0ZXhlbEZldGNoKCBib25lVGV4dHVyZSwgaXZlYzIoIHggKyAzLCB5ICksIDAgKTtcXG5cXHRcXHRyZXR1cm4gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBza2lubmluZ192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1xcblxcdHRyYW5zZm9ybWVkID0gKCBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQgKS54eXo7XFxuI2VuZGlmXCI7XG5cbnZhciBza2lubm9ybWFsX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC53ICogYm9uZU1hdFc7XFxuXFx0c2tpbk1hdHJpeCA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbk1hdHJpeCAqIGJpbmRNYXRyaXg7XFxuXFx0b2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0b2JqZWN0VGFuZ2VudCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3RUYW5nZW50LCAwLjAgKSApLnh5ejtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIHNwZWN1bGFybWFwX2ZyYWdtZW50ID0gXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2U3BlY3VsYXJNYXBVdiApO1xcblxcdHNwZWN1bGFyU3RyZW5ndGggPSB0ZXhlbFNwZWN1bGFyLnI7XFxuI2Vsc2VcXG5cXHRzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcbiNlbmRpZlwiO1xuXG52YXIgc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcbiNlbmRpZlwiO1xuXG52YXIgdG9uZW1hcHBpbmdfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBUT05FX01BUFBJTkcgKVxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSB0b25lTWFwcGluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcbiNlbmRpZlwiO1xuXG52YXIgdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCA9IFwiI2lmbmRlZiBzYXR1cmF0ZVxcbiNkZWZpbmUgc2F0dXJhdGUoIGEgKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNlbmRpZlxcbnVuaWZvcm0gZmxvYXQgdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG52ZWMzIExpbmVhclRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdHJldHVybiBzYXR1cmF0ZSggdG9uZU1hcHBpbmdFeHBvc3VyZSAqIGNvbG9yICk7XFxufVxcbnZlYzMgUmVpbmhhcmRUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcblxcdHJldHVybiBzYXR1cmF0ZSggY29sb3IgLyAoIHZlYzMoIDEuMCApICsgY29sb3IgKSApO1xcbn1cXG52ZWMzIE9wdGltaXplZENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuXFx0Y29sb3IgPSBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciAtIDAuMDA0ICk7XFxuXFx0cmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTtcXG59XFxudmVjMyBSUlRBbmRPRFRGaXQoIHZlYzMgdiApIHtcXG5cXHR2ZWMzIGEgPSB2ICogKCB2ICsgMC4wMjQ1Nzg2ICkgLSAwLjAwMDA5MDUzNztcXG5cXHR2ZWMzIGIgPSB2ICogKCAwLjk4MzcyOSAqIHYgKyAwLjQzMjk1MTAgKSArIDAuMjM4MDgxO1xcblxcdHJldHVybiBhIC8gYjtcXG59XFxudmVjMyBBQ0VTRmlsbWljVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29uc3QgbWF0MyBBQ0VTSW5wdXRNYXQgPSBtYXQzKFxcblxcdFxcdHZlYzMoIDAuNTk3MTksIDAuMDc2MDAsIDAuMDI4NDAgKSxcXHRcXHR2ZWMzKCAwLjM1NDU4LCAwLjkwODM0LCAwLjEzMzgzICksXFxuXFx0XFx0dmVjMyggMC4wNDgyMywgMC4wMTU2NiwgMC44Mzc3NyApXFxuXFx0KTtcXG5cXHRjb25zdCBtYXQzIEFDRVNPdXRwdXRNYXQgPSBtYXQzKFxcblxcdFxcdHZlYzMoICAxLjYwNDc1LCAtMC4xMDIwOCwgLTAuMDAzMjcgKSxcXHRcXHR2ZWMzKCAtMC41MzEwOCwgIDEuMTA4MTMsIC0wLjA3Mjc2ICksXFxuXFx0XFx0dmVjMyggLTAuMDczNjcsIC0wLjAwNjA1LCAgMS4wNzYwMiApXFxuXFx0KTtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlIC8gMC42O1xcblxcdGNvbG9yID0gQUNFU0lucHV0TWF0ICogY29sb3I7XFxuXFx0Y29sb3IgPSBSUlRBbmRPRFRGaXQoIGNvbG9yICk7XFxuXFx0Y29sb3IgPSBBQ0VTT3V0cHV0TWF0ICogY29sb3I7XFxuXFx0cmV0dXJuIHNhdHVyYXRlKCBjb2xvciApO1xcbn1cXG5jb25zdCBtYXQzIExJTkVBUl9SRUMyMDIwX1RPX0xJTkVBUl9TUkdCID0gbWF0MyhcXG5cXHR2ZWMzKCAxLjY2MDUsIC0gMC4xMjQ2LCAtIDAuMDE4MiApLFxcblxcdHZlYzMoIC0gMC41ODc2LCAxLjEzMjksIC0gMC4xMDA2ICksXFxuXFx0dmVjMyggLSAwLjA3MjgsIC0gMC4wMDgzLCAxLjExODcgKVxcbik7XFxuY29uc3QgbWF0MyBMSU5FQVJfU1JHQl9UT19MSU5FQVJfUkVDMjAyMCA9IG1hdDMoXFxuXFx0dmVjMyggMC42Mjc0LCAwLjA2OTEsIDAuMDE2NCApLFxcblxcdHZlYzMoIDAuMzI5MywgMC45MTk1LCAwLjA4ODAgKSxcXG5cXHR2ZWMzKCAwLjA0MzMsIDAuMDExMywgMC44OTU2IClcXG4pO1xcbnZlYzMgYWd4RGVmYXVsdENvbnRyYXN0QXBwcm94KCB2ZWMzIHggKSB7XFxuXFx0dmVjMyB4MiA9IHggKiB4O1xcblxcdHZlYzMgeDQgPSB4MiAqIHgyO1xcblxcdHJldHVybiArIDE1LjUgKiB4NCAqIHgyXFxuXFx0XFx0LSA0MC4xNCAqIHg0ICogeFxcblxcdFxcdCsgMzEuOTYgKiB4NFxcblxcdFxcdC0gNi44NjggKiB4MiAqIHhcXG5cXHRcXHQrIDAuNDI5OCAqIHgyXFxuXFx0XFx0KyAwLjExOTEgKiB4XFxuXFx0XFx0LSAwLjAwMjMyO1xcbn1cXG52ZWMzIEFnWFRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbnN0IG1hdDMgQWdYSW5zZXRNYXRyaXggPSBtYXQzKFxcblxcdFxcdHZlYzMoIDAuODU2NjI3MTUzMzE1OTgzLCAwLjEzNzMxODk3MjkyOTg0NywgMC4xMTE4OTgyMTI5OTk5NSApLFxcblxcdFxcdHZlYzMoIDAuMDk1MTIxMjQwNTM4MTU4OCwgMC43NjEyNDE5OTA2MDI1OTEsIDAuMDc2Nzk5NDE4NjAzMTkwMyApLFxcblxcdFxcdHZlYzMoIDAuMDQ4MjUxNjA2MTQ1ODU4MywgMC4xMDE0MzkwMzY0Njc1NjIsIDAuODExMzAyMzY4Mzk2ODU5IClcXG5cXHQpO1xcblxcdGNvbnN0IG1hdDMgQWdYT3V0c2V0TWF0cml4ID0gbWF0MyhcXG5cXHRcXHR2ZWMzKCAxLjEyNzEwMDU4MTgxNDQzNjgsIC0gMC4xNDEzMjk3NjM0OTg0MzgzLCAtIDAuMTQxMzI5NzYzNDk4NDM4MjYgKSxcXG5cXHRcXHR2ZWMzKCAtIDAuMTEwNjA2NjQzMDk2NjAzMjMsIDEuMTU3ODIzNzAyMjE2MjcyLCAtIDAuMTEwNjA2NjQzMDk2NjAyOTQgKSxcXG5cXHRcXHR2ZWMzKCAtIDAuMDE2NDkzOTM4NzE3ODM0NTczLCAtIDAuMDE2NDkzOTM4NzE3ODM0MjU3LCAxLjI1MTkzNjQwNjU5NTA0MDUgKVxcblxcdCk7XFxuXFx0Y29uc3QgZmxvYXQgQWd4TWluRXYgPSAtIDEyLjQ3MzkzO1xcdGNvbnN0IGZsb2F0IEFneE1heEV2ID0gNC4wMjYwNjk7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG5cXHRjb2xvciA9IExJTkVBUl9TUkdCX1RPX0xJTkVBUl9SRUMyMDIwICogY29sb3I7XFxuXFx0Y29sb3IgPSBBZ1hJbnNldE1hdHJpeCAqIGNvbG9yO1xcblxcdGNvbG9yID0gbWF4KCBjb2xvciwgMWUtMTAgKTtcXHRjb2xvciA9IGxvZzIoIGNvbG9yICk7XFxuXFx0Y29sb3IgPSAoIGNvbG9yIC0gQWd4TWluRXYgKSAvICggQWd4TWF4RXYgLSBBZ3hNaW5FdiApO1xcblxcdGNvbG9yID0gY2xhbXAoIGNvbG9yLCAwLjAsIDEuMCApO1xcblxcdGNvbG9yID0gYWd4RGVmYXVsdENvbnRyYXN0QXBwcm94KCBjb2xvciApO1xcblxcdGNvbG9yID0gQWdYT3V0c2V0TWF0cml4ICogY29sb3I7XFxuXFx0Y29sb3IgPSBwb3coIG1heCggdmVjMyggMC4wICksIGNvbG9yICksIHZlYzMoIDIuMiApICk7XFxuXFx0Y29sb3IgPSBMSU5FQVJfUkVDMjAyMF9UT19MSU5FQVJfU1JHQiAqIGNvbG9yO1xcblxcdGNvbG9yID0gY2xhbXAoIGNvbG9yLCAwLjAsIDEuMCApO1xcblxcdHJldHVybiBjb2xvcjtcXG59XFxudmVjMyBOZXV0cmFsVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29uc3QgZmxvYXQgU3RhcnRDb21wcmVzc2lvbiA9IDAuOCAtIDAuMDQ7XFxuXFx0Y29uc3QgZmxvYXQgRGVzYXR1cmF0aW9uID0gMC4xNTtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcblxcdGZsb2F0IHggPSBtaW4oIGNvbG9yLnIsIG1pbiggY29sb3IuZywgY29sb3IuYiApICk7XFxuXFx0ZmxvYXQgb2Zmc2V0ID0geCA8IDAuMDggPyB4IC0gNi4yNSAqIHggKiB4IDogMC4wNDtcXG5cXHRjb2xvciAtPSBvZmZzZXQ7XFxuXFx0ZmxvYXQgcGVhayA9IG1heCggY29sb3IuciwgbWF4KCBjb2xvci5nLCBjb2xvci5iICkgKTtcXG5cXHRpZiAoIHBlYWsgPCBTdGFydENvbXByZXNzaW9uICkgcmV0dXJuIGNvbG9yO1xcblxcdGZsb2F0IGQgPSAxLiAtIFN0YXJ0Q29tcHJlc3Npb247XFxuXFx0ZmxvYXQgbmV3UGVhayA9IDEuIC0gZCAqIGQgLyAoIHBlYWsgKyBkIC0gU3RhcnRDb21wcmVzc2lvbiApO1xcblxcdGNvbG9yICo9IG5ld1BlYWsgLyBwZWFrO1xcblxcdGZsb2F0IGcgPSAxLiAtIDEuIC8gKCBEZXNhdHVyYXRpb24gKiAoIHBlYWsgLSBuZXdQZWFrICkgKyAxLiApO1xcblxcdHJldHVybiBtaXgoIGNvbG9yLCB2ZWMzKCBuZXdQZWFrICksIGcgKTtcXG59XFxudmVjMyBDdXN0b21Ub25lTWFwcGluZyggdmVjMyBjb2xvciApIHsgcmV0dXJuIGNvbG9yOyB9XCI7XG5cbnZhciB0cmFuc21pc3Npb25fZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0bWF0ZXJpYWwudHJhbnNtaXNzaW9uID0gdHJhbnNtaXNzaW9uO1xcblxcdG1hdGVyaWFsLnRyYW5zbWlzc2lvbkFscGhhID0gMS4wO1xcblxcdG1hdGVyaWFsLnRoaWNrbmVzcyA9IHRoaWNrbmVzcztcXG5cXHRtYXRlcmlhbC5hdHRlbnVhdGlvbkRpc3RhbmNlID0gYXR0ZW51YXRpb25EaXN0YW5jZTtcXG5cXHRtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yID0gYXR0ZW51YXRpb25Db2xvcjtcXG5cXHQjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUFxcblxcdFxcdG1hdGVyaWFsLnRyYW5zbWlzc2lvbiAqPSB0ZXh0dXJlMkQoIHRyYW5zbWlzc2lvbk1hcCwgdlRyYW5zbWlzc2lvbk1hcFV2ICkucjtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1RISUNLTkVTU01BUFxcblxcdFxcdG1hdGVyaWFsLnRoaWNrbmVzcyAqPSB0ZXh0dXJlMkQoIHRoaWNrbmVzc01hcCwgdlRoaWNrbmVzc01hcFV2ICkuZztcXG5cXHQjZW5kaWZcXG5cXHR2ZWMzIHBvcyA9IHZXb3JsZFBvc2l0aW9uO1xcblxcdHZlYzMgdiA9IG5vcm1hbGl6ZSggY2FtZXJhUG9zaXRpb24gLSBwb3MgKTtcXG5cXHR2ZWMzIG4gPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHR2ZWM0IHRyYW5zbWl0dGVkID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcXG5cXHRcXHRuLCB2LCBtYXRlcmlhbC5yb3VnaG5lc3MsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsXFxuXFx0XFx0cG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgbWF0ZXJpYWwuZGlzcGVyc2lvbiwgbWF0ZXJpYWwuaW9yLCBtYXRlcmlhbC50aGlja25lc3MsXFxuXFx0XFx0bWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciwgbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZSApO1xcblxcdG1hdGVyaWFsLnRyYW5zbWlzc2lvbkFscGhhID0gbWl4KCBtYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYSwgdHJhbnNtaXR0ZWQuYSwgbWF0ZXJpYWwudHJhbnNtaXNzaW9uICk7XFxuXFx0dG90YWxEaWZmdXNlID0gbWl4KCB0b3RhbERpZmZ1c2UsIHRyYW5zbWl0dGVkLnJnYiwgbWF0ZXJpYWwudHJhbnNtaXNzaW9uICk7XFxuI2VuZGlmXCI7XG5cbnZhciB0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHR1bmlmb3JtIGZsb2F0IHRyYW5zbWlzc2lvbjtcXG5cXHR1bmlmb3JtIGZsb2F0IHRoaWNrbmVzcztcXG5cXHR1bmlmb3JtIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuXFx0dW5pZm9ybSB2ZWMzIGF0dGVudWF0aW9uQ29sb3I7XFxuXFx0I2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25NYXA7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9USElDS05FU1NNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCB0aGlja25lc3NNYXA7XFxuXFx0I2VuZGlmXFxuXFx0dW5pZm9ybSB2ZWMyIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplO1xcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvblNhbXBsZXJNYXA7XFxuXFx0dW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xcblxcdHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcblxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXHRmbG9hdCB3MCggZmxvYXQgYSApIHtcXG5cXHRcXHRyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqICggYSAqICggLSBhICsgMy4wICkgLSAzLjAgKSArIDEuMCApO1xcblxcdH1cXG5cXHRmbG9hdCB3MSggZmxvYXQgYSApIHtcXG5cXHRcXHRyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqICBhICogKCAzLjAgKiBhIC0gNi4wICkgKyA0LjAgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgdzIoIGZsb2F0IGEgKXtcXG5cXHRcXHRyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqICggYSAqICggLSAzLjAgKiBhICsgMy4wICkgKyAzLjAgKSArIDEuMCApO1xcblxcdH1cXG5cXHRmbG9hdCB3MyggZmxvYXQgYSApIHtcXG5cXHRcXHRyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqIGEgKiBhICk7XFxuXFx0fVxcblxcdGZsb2F0IGcwKCBmbG9hdCBhICkge1xcblxcdFxcdHJldHVybiB3MCggYSApICsgdzEoIGEgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgZzEoIGZsb2F0IGEgKSB7XFxuXFx0XFx0cmV0dXJuIHcyKCBhICkgKyB3MyggYSApO1xcblxcdH1cXG5cXHRmbG9hdCBoMCggZmxvYXQgYSApIHtcXG5cXHRcXHRyZXR1cm4gLSAxLjAgKyB3MSggYSApIC8gKCB3MCggYSApICsgdzEoIGEgKSApO1xcblxcdH1cXG5cXHRmbG9hdCBoMSggZmxvYXQgYSApIHtcXG5cXHRcXHRyZXR1cm4gMS4wICsgdzMoIGEgKSAvICggdzIoIGEgKSArIHczKCBhICkgKTtcXG5cXHR9XFxuXFx0dmVjNCBiaWN1YmljKCBzYW1wbGVyMkQgdGV4LCB2ZWMyIHV2LCB2ZWM0IHRleGVsU2l6ZSwgZmxvYXQgbG9kICkge1xcblxcdFxcdHV2ID0gdXYgKiB0ZXhlbFNpemUuencgKyAwLjU7XFxuXFx0XFx0dmVjMiBpdXYgPSBmbG9vciggdXYgKTtcXG5cXHRcXHR2ZWMyIGZ1diA9IGZyYWN0KCB1diApO1xcblxcdFxcdGZsb2F0IGcweCA9IGcwKCBmdXYueCApO1xcblxcdFxcdGZsb2F0IGcxeCA9IGcxKCBmdXYueCApO1xcblxcdFxcdGZsb2F0IGgweCA9IGgwKCBmdXYueCApO1xcblxcdFxcdGZsb2F0IGgxeCA9IGgxKCBmdXYueCApO1xcblxcdFxcdGZsb2F0IGgweSA9IGgwKCBmdXYueSApO1xcblxcdFxcdGZsb2F0IGgxeSA9IGgxKCBmdXYueSApO1xcblxcdFxcdHZlYzIgcDAgPSAoIHZlYzIoIGl1di54ICsgaDB4LCBpdXYueSArIGgweSApIC0gMC41ICkgKiB0ZXhlbFNpemUueHk7XFxuXFx0XFx0dmVjMiBwMSA9ICggdmVjMiggaXV2LnggKyBoMXgsIGl1di55ICsgaDB5ICkgLSAwLjUgKSAqIHRleGVsU2l6ZS54eTtcXG5cXHRcXHR2ZWMyIHAyID0gKCB2ZWMyKCBpdXYueCArIGgweCwgaXV2LnkgKyBoMXkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5O1xcblxcdFxcdHZlYzIgcDMgPSAoIHZlYzIoIGl1di54ICsgaDF4LCBpdXYueSArIGgxeSApIC0gMC41ICkgKiB0ZXhlbFNpemUueHk7XFxuXFx0XFx0cmV0dXJuIGcwKCBmdXYueSApICogKCBnMHggKiB0ZXh0dXJlTG9kKCB0ZXgsIHAwLCBsb2QgKSArIGcxeCAqIHRleHR1cmVMb2QoIHRleCwgcDEsIGxvZCApICkgK1xcblxcdFxcdFxcdGcxKCBmdXYueSApICogKCBnMHggKiB0ZXh0dXJlTG9kKCB0ZXgsIHAyLCBsb2QgKSArIGcxeCAqIHRleHR1cmVMb2QoIHRleCwgcDMsIGxvZCApICk7XFxuXFx0fVxcblxcdHZlYzQgdGV4dHVyZUJpY3ViaWMoIHNhbXBsZXIyRCBzYW1wbGVyLCB2ZWMyIHV2LCBmbG9hdCBsb2QgKSB7XFxuXFx0XFx0dmVjMiBmTG9kU2l6ZSA9IHZlYzIoIHRleHR1cmVTaXplKCBzYW1wbGVyLCBpbnQoIGxvZCApICkgKTtcXG5cXHRcXHR2ZWMyIGNMb2RTaXplID0gdmVjMiggdGV4dHVyZVNpemUoIHNhbXBsZXIsIGludCggbG9kICsgMS4wICkgKSApO1xcblxcdFxcdHZlYzIgZkxvZFNpemVJbnYgPSAxLjAgLyBmTG9kU2l6ZTtcXG5cXHRcXHR2ZWMyIGNMb2RTaXplSW52ID0gMS4wIC8gY0xvZFNpemU7XFxuXFx0XFx0dmVjNCBmU2FtcGxlID0gYmljdWJpYyggc2FtcGxlciwgdXYsIHZlYzQoIGZMb2RTaXplSW52LCBmTG9kU2l6ZSApLCBmbG9vciggbG9kICkgKTtcXG5cXHRcXHR2ZWM0IGNTYW1wbGUgPSBiaWN1YmljKCBzYW1wbGVyLCB1diwgdmVjNCggY0xvZFNpemVJbnYsIGNMb2RTaXplICksIGNlaWwoIGxvZCApICk7XFxuXFx0XFx0cmV0dXJuIG1peCggZlNhbXBsZSwgY1NhbXBsZSwgZnJhY3QoIGxvZCApICk7XFxuXFx0fVxcblxcdHZlYzMgZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBjb25zdCBpbiB2ZWMzIG4sIGNvbnN0IGluIHZlYzMgdiwgY29uc3QgaW4gZmxvYXQgdGhpY2tuZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IsIGNvbnN0IGluIG1hdDQgbW9kZWxNYXRyaXggKSB7XFxuXFx0XFx0dmVjMyByZWZyYWN0aW9uVmVjdG9yID0gcmVmcmFjdCggLSB2LCBub3JtYWxpemUoIG4gKSwgMS4wIC8gaW9yICk7XFxuXFx0XFx0dmVjMyBtb2RlbFNjYWxlO1xcblxcdFxcdG1vZGVsU2NhbGUueCA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDAgXS54eXogKSApO1xcblxcdFxcdG1vZGVsU2NhbGUueSA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDEgXS54eXogKSApO1xcblxcdFxcdG1vZGVsU2NhbGUueiA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDIgXS54eXogKSApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIHJlZnJhY3Rpb25WZWN0b3IgKSAqIHRoaWNrbmVzcyAqIG1vZGVsU2NhbGU7XFxuXFx0fVxcblxcdGZsb2F0IGFwcGx5SW9yVG9Sb3VnaG5lc3MoIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgaW9yICkge1xcblxcdFxcdHJldHVybiByb3VnaG5lc3MgKiBjbGFtcCggaW9yICogMi4wIC0gMi4wLCAwLjAsIDEuMCApO1xcblxcdH1cXG5cXHR2ZWM0IGdldFRyYW5zbWlzc2lvblNhbXBsZSggY29uc3QgaW4gdmVjMiBmcmFnQ29vcmQsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgaW9yICkge1xcblxcdFxcdGZsb2F0IGxvZCA9IGxvZzIoIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplLnggKSAqIGFwcGx5SW9yVG9Sb3VnaG5lc3MoIHJvdWdobmVzcywgaW9yICk7XFxuXFx0XFx0cmV0dXJuIHRleHR1cmVCaWN1YmljKCB0cmFuc21pc3Npb25TYW1wbGVyTWFwLCBmcmFnQ29vcmQueHksIGxvZCApO1xcblxcdH1cXG5cXHR2ZWMzIHZvbHVtZUF0dGVudWF0aW9uKCBjb25zdCBpbiBmbG9hdCB0cmFuc21pc3Npb25EaXN0YW5jZSwgY29uc3QgaW4gdmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlICkge1xcblxcdFxcdGlmICggaXNpbmYoIGF0dGVudWF0aW9uRGlzdGFuY2UgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMyggMS4wICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR2ZWMzIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgPSAtbG9nKCBhdHRlbnVhdGlvbkNvbG9yICkgLyBhdHRlbnVhdGlvbkRpc3RhbmNlO1xcblxcdFxcdFxcdHZlYzMgdHJhbnNtaXR0YW5jZSA9IGV4cCggLSBhdHRlbnVhdGlvbkNvZWZmaWNpZW50ICogdHJhbnNtaXNzaW9uRGlzdGFuY2UgKTtcXHRcXHRcXHRyZXR1cm4gdHJhbnNtaXR0YW5jZTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdHZlYzQgZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbiggY29uc3QgaW4gdmVjMyBuLCBjb25zdCBpbiB2ZWMzIHYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IsXFxuXFx0XFx0Y29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gdmVjMyBwb3NpdGlvbiwgY29uc3QgaW4gbWF0NCBtb2RlbE1hdHJpeCxcXG5cXHRcXHRjb25zdCBpbiBtYXQ0IHZpZXdNYXRyaXgsIGNvbnN0IGluIG1hdDQgcHJvak1hdHJpeCwgY29uc3QgaW4gZmxvYXQgZGlzcGVyc2lvbiwgY29uc3QgaW4gZmxvYXQgaW9yLCBjb25zdCBpbiBmbG9hdCB0aGlja25lc3MsXFxuXFx0XFx0Y29uc3QgaW4gdmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlICkge1xcblxcdFxcdHZlYzQgdHJhbnNtaXR0ZWRMaWdodDtcXG5cXHRcXHR2ZWMzIHRyYW5zbWl0dGFuY2U7XFxuXFx0XFx0I2lmZGVmIFVTRV9ESVNQRVJTSU9OXFxuXFx0XFx0XFx0ZmxvYXQgaGFsZlNwcmVhZCA9ICggaW9yIC0gMS4wICkgKiAwLjAyNSAqIGRpc3BlcnNpb247XFxuXFx0XFx0XFx0dmVjMyBpb3JzID0gdmVjMyggaW9yIC0gaGFsZlNwcmVhZCwgaW9yLCBpb3IgKyBoYWxmU3ByZWFkICk7XFxuXFx0XFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcXG5cXHRcXHRcXHRcXHR2ZWMzIHRyYW5zbWlzc2lvblJheSA9IGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggbiwgdiwgdGhpY2tuZXNzLCBpb3JzWyBpIF0sIG1vZGVsTWF0cml4ICk7XFxuXFx0XFx0XFx0XFx0dmVjMyByZWZyYWN0ZWRSYXlFeGl0ID0gcG9zaXRpb24gKyB0cmFuc21pc3Npb25SYXk7XFxuXFx0XFx0XFxuXFx0XFx0XFx0XFx0dmVjNCBuZGNQb3MgPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzQoIHJlZnJhY3RlZFJheUV4aXQsIDEuMCApO1xcblxcdFxcdFxcdFxcdHZlYzIgcmVmcmFjdGlvbkNvb3JkcyA9IG5kY1Bvcy54eSAvIG5kY1Bvcy53O1xcblxcdFxcdFxcdFxcdHJlZnJhY3Rpb25Db29yZHMgKz0gMS4wO1xcblxcdFxcdFxcdFxcdHJlZnJhY3Rpb25Db29yZHMgLz0gMi4wO1xcblxcdFxcdFxcblxcdFxcdFxcdFxcdHZlYzQgdHJhbnNtaXNzaW9uU2FtcGxlID0gZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCByZWZyYWN0aW9uQ29vcmRzLCByb3VnaG5lc3MsIGlvcnNbIGkgXSApO1xcblxcdFxcdFxcdFxcdHRyYW5zbWl0dGVkTGlnaHRbIGkgXSA9IHRyYW5zbWlzc2lvblNhbXBsZVsgaSBdO1xcblxcdFxcdFxcdFxcdHRyYW5zbWl0dGVkTGlnaHQuYSArPSB0cmFuc21pc3Npb25TYW1wbGUuYTtcXG5cXHRcXHRcXHRcXHR0cmFuc21pdHRhbmNlWyBpIF0gPSBkaWZmdXNlQ29sb3JbIGkgXSAqIHZvbHVtZUF0dGVudWF0aW9uKCBsZW5ndGgoIHRyYW5zbWlzc2lvblJheSApLCBhdHRlbnVhdGlvbkNvbG9yLCBhdHRlbnVhdGlvbkRpc3RhbmNlIClbIGkgXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dHJhbnNtaXR0ZWRMaWdodC5hIC89IDMuMDtcXG5cXHRcXHRcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcblxcdFxcdFxcdHZlYzMgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBuLCB2LCB0aGlja25lc3MsIGlvciwgbW9kZWxNYXRyaXggKTtcXG5cXHRcXHRcXHR2ZWMzIHJlZnJhY3RlZFJheUV4aXQgPSBwb3NpdGlvbiArIHRyYW5zbWlzc2lvblJheTtcXG5cXHRcXHRcXHR2ZWM0IG5kY1BvcyA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogdmVjNCggcmVmcmFjdGVkUmF5RXhpdCwgMS4wICk7XFxuXFx0XFx0XFx0dmVjMiByZWZyYWN0aW9uQ29vcmRzID0gbmRjUG9zLnh5IC8gbmRjUG9zLnc7XFxuXFx0XFx0XFx0cmVmcmFjdGlvbkNvb3JkcyArPSAxLjA7XFxuXFx0XFx0XFx0cmVmcmFjdGlvbkNvb3JkcyAvPSAyLjA7XFxuXFx0XFx0XFx0dHJhbnNtaXR0ZWRMaWdodCA9IGdldFRyYW5zbWlzc2lvblNhbXBsZSggcmVmcmFjdGlvbkNvb3Jkcywgcm91Z2huZXNzLCBpb3IgKTtcXG5cXHRcXHRcXHR0cmFuc21pdHRhbmNlID0gZGlmZnVzZUNvbG9yICogdm9sdW1lQXR0ZW51YXRpb24oIGxlbmd0aCggdHJhbnNtaXNzaW9uUmF5ICksIGF0dGVudWF0aW9uQ29sb3IsIGF0dGVudWF0aW9uRGlzdGFuY2UgKTtcXG5cXHRcXHRcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHR2ZWMzIGF0dGVudWF0ZWRDb2xvciA9IHRyYW5zbWl0dGFuY2UgKiB0cmFuc21pdHRlZExpZ2h0LnJnYjtcXG5cXHRcXHR2ZWMzIEYgPSBFbnZpcm9ubWVudEJSREYoIG4sIHYsIHNwZWN1bGFyQ29sb3IsIHNwZWN1bGFyRjkwLCByb3VnaG5lc3MgKTtcXG5cXHRcXHRmbG9hdCB0cmFuc21pdHRhbmNlRmFjdG9yID0gKCB0cmFuc21pdHRhbmNlLnIgKyB0cmFuc21pdHRhbmNlLmcgKyB0cmFuc21pdHRhbmNlLmIgKSAvIDMuMDtcXG5cXHRcXHRyZXR1cm4gdmVjNCggKCAxLjAgLSBGICkgKiBhdHRlbnVhdGVkQ29sb3IsIDEuMCAtICggMS4wIC0gdHJhbnNtaXR0ZWRMaWdodC5hICkgKiB0cmFuc21pdHRhbmNlRmFjdG9yICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgdXZfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9VViApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZIClcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZBbHBoYU1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdkxpZ2h0TWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9BT01BUFxcblxcdHZhcnlpbmcgdmVjMiB2QW9NYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0JVTVBNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdkJ1bXBNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcdHZhcnlpbmcgdmVjMiB2Tm9ybWFsTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcdHZhcnlpbmcgdmVjMiB2RW1pc3NpdmVNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHZhcnlpbmcgdmVjMiB2TWV0YWxuZXNzTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdlJvdWdobmVzc01hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUFxcblxcdHZhcnlpbmcgdmVjMiB2QW5pc290cm9weU1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZDbGVhcmNvYXRNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdE5vcm1hbE1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxcblxcdHZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUFxcblxcdHZhcnlpbmcgdmVjMiB2SXJpZGVzY2VuY2VNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUFxcblxcdHZhcnlpbmcgdmVjMiB2SXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZTaGVlbkNvbG9yTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TSEVFTl9ST1VHSE5FU1NNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdlNoZWVuUm91Z2huZXNzTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcdHZhcnlpbmcgdmVjMiB2U3BlY3VsYXJNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NQRUNVTEFSX0NPTE9STUFQXFxuXFx0dmFyeWluZyB2ZWMyIHZTcGVjdWxhckNvbG9yTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVBcXG5cXHR2YXJ5aW5nIHZlYzIgdlNwZWN1bGFySW50ZW5zaXR5TWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcXG5cXHR1bmlmb3JtIG1hdDMgdHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2VHJhbnNtaXNzaW9uTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9USElDS05FU1NNQVBcXG5cXHR1bmlmb3JtIG1hdDMgdGhpY2tuZXNzTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2VGhpY2tuZXNzTWFwVXY7XFxuI2VuZGlmXCI7XG5cbnZhciB1dl9wYXJzX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9VViApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZIClcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSBtYXQzIG1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdk1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHR1bmlmb3JtIG1hdDMgYWxwaGFNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZBbHBoYU1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHR1bmlmb3JtIG1hdDMgbGlnaHRNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZMaWdodE1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQU9NQVBcXG5cXHR1bmlmb3JtIG1hdDMgYW9NYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZBb01hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcdHVuaWZvcm0gbWF0MyBidW1wTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2QnVtcE1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFx0dW5pZm9ybSBtYXQzIG5vcm1hbE1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdk5vcm1hbE1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0dW5pZm9ybSBtYXQzIGRpc3BsYWNlbWVudE1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdkRpc3BsYWNlbWVudE1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXHR1bmlmb3JtIG1hdDMgZW1pc3NpdmVNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZFbWlzc2l2ZU1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dW5pZm9ybSBtYXQzIG1ldGFsbmVzc01hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdk1ldGFsbmVzc01hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxuXFx0dW5pZm9ybSBtYXQzIHJvdWdobmVzc01hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdlJvdWdobmVzc01hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUFxcblxcdHVuaWZvcm0gbWF0MyBhbmlzb3Ryb3B5TWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2QW5pc290cm9weU1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXFxuXFx0dW5pZm9ybSBtYXQzIGNsZWFyY29hdE1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdE1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUFxcblxcdHVuaWZvcm0gbWF0MyBjbGVhcmNvYXROb3JtYWxNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZDbGVhcmNvYXROb3JtYWxNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVBcXG5cXHR1bmlmb3JtIG1hdDMgY2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUFxcblxcdHVuaWZvcm0gbWF0MyBzaGVlbkNvbG9yTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2U2hlZW5Db2xvck1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQXFxuXFx0dW5pZm9ybSBtYXQzIHNoZWVuUm91Z2huZXNzTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2U2hlZW5Sb3VnaG5lc3NNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFTUFQXFxuXFx0dW5pZm9ybSBtYXQzIGlyaWRlc2NlbmNlTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2SXJpZGVzY2VuY2VNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUFxcblxcdHVuaWZvcm0gbWF0MyBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcdHVuaWZvcm0gbWF0MyBzcGVjdWxhck1hcFRyYW5zZm9ybTtcXG5cXHR2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyTWFwVXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUFxcblxcdHVuaWZvcm0gbWF0MyBzcGVjdWxhckNvbG9yTWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2U3BlY3VsYXJDb2xvck1hcFV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQXFxuXFx0dW5pZm9ybSBtYXQzIHNwZWN1bGFySW50ZW5zaXR5TWFwVHJhbnNmb3JtO1xcblxcdHZhcnlpbmcgdmVjMiB2U3BlY3VsYXJJbnRlbnNpdHlNYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUFxcblxcdHVuaWZvcm0gbWF0MyB0cmFuc21pc3Npb25NYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZUcmFuc21pc3Npb25NYXBVdjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1RISUNLTkVTU01BUFxcblxcdHVuaWZvcm0gbWF0MyB0aGlja25lc3NNYXBUcmFuc2Zvcm07XFxuXFx0dmFyeWluZyB2ZWMyIHZUaGlja25lc3NNYXBVdjtcXG4jZW5kaWZcIjtcblxudmFyIHV2X3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9VViApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZIClcXG5cXHR2VXYgPSB2ZWMzKCB1diwgMSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUFQXFxuXFx0dk1hcFV2ID0gKCBtYXBUcmFuc2Zvcm0gKiB2ZWMzKCBNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHR2QWxwaGFNYXBVdiA9ICggYWxwaGFNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBBTFBIQU1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdHZMaWdodE1hcFV2ID0gKCBsaWdodE1hcFRyYW5zZm9ybSAqIHZlYzMoIExJR0hUTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FPTUFQXFxuXFx0dkFvTWFwVXYgPSAoIGFvTWFwVHJhbnNmb3JtICogdmVjMyggQU9NQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcdHZCdW1wTWFwVXYgPSAoIGJ1bXBNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBCVU1QTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcdHZOb3JtYWxNYXBVdiA9ICggbm9ybWFsTWFwVHJhbnNmb3JtICogdmVjMyggTk9STUFMTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdHZEaXNwbGFjZW1lbnRNYXBVdiA9ICggZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtICogdmVjMyggRElTUExBQ0VNRU5UTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dkVtaXNzaXZlTWFwVXYgPSAoIGVtaXNzaXZlTWFwVHJhbnNmb3JtICogdmVjMyggRU1JU1NJVkVNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dk1ldGFsbmVzc01hcFV2ID0gKCBtZXRhbG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBNRVRBTE5FU1NNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxuXFx0dlJvdWdobmVzc01hcFV2ID0gKCByb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBST1VHSE5FU1NNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUFxcblxcdHZBbmlzb3Ryb3B5TWFwVXYgPSAoIGFuaXNvdHJvcHlNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBBTklTT1RST1BZTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVE1BUFxcblxcdHZDbGVhcmNvYXRNYXBVdiA9ICggY2xlYXJjb2F0TWFwVHJhbnNmb3JtICogdmVjMyggQ0xFQVJDT0FUTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcXG5cXHR2Q2xlYXJjb2F0Tm9ybWFsTWFwVXYgPSAoIGNsZWFyY29hdE5vcm1hbE1hcFRyYW5zZm9ybSAqIHZlYzMoIENMRUFSQ09BVF9OT1JNQUxNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxcblxcdHZDbGVhcmNvYXRSb3VnaG5lc3NNYXBVdiA9ICggY2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtICogdmVjMyggQ0xFQVJDT0FUX1JPVUdITkVTU01BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUFxcblxcdHZJcmlkZXNjZW5jZU1hcFV2ID0gKCBpcmlkZXNjZW5jZU1hcFRyYW5zZm9ybSAqIHZlYzMoIElSSURFU0NFTkNFTUFQX1VWLCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUFxcblxcdHZJcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2ID0gKCBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIElSSURFU0NFTkNFX1RISUNLTkVTU01BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUFxcblxcdHZTaGVlbkNvbG9yTWFwVXYgPSAoIHNoZWVuQ29sb3JNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTSEVFTl9DT0xPUk1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TSEVFTl9ST1VHSE5FU1NNQVBcXG5cXHR2U2hlZW5Sb3VnaG5lc3NNYXBVdiA9ICggc2hlZW5Sb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTSEVFTl9ST1VHSE5FU1NNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR2U3BlY3VsYXJNYXBVdiA9ICggc3BlY3VsYXJNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTUEVDVUxBUk1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUFxcblxcdHZTcGVjdWxhckNvbG9yTWFwVXYgPSAoIHNwZWN1bGFyQ29sb3JNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTUEVDVUxBUl9DT0xPUk1BUF9VViwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVBcXG5cXHR2U3BlY3VsYXJJbnRlbnNpdHlNYXBVdiA9ICggc3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTUEVDVUxBUl9JTlRFTlNJVFlNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuXFx0dlRyYW5zbWlzc2lvbk1hcFV2ID0gKCB0cmFuc21pc3Npb25NYXBUcmFuc2Zvcm0gKiB2ZWMzKCBUUkFOU01JU1NJT05NQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuXFx0dlRoaWNrbmVzc01hcFV2ID0gKCB0aGlja25lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBUSElDS05FU1NNQVBfVVYsIDEgKSApLnh5O1xcbiNlbmRpZlwiO1xuXG52YXIgd29ybGRwb3NfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIERJU1RBTkNFICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKSB8fCBkZWZpbmVkICggVVNFX1RSQU5TTUlTU0lPTiApIHx8IE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDBcXG5cXHR2ZWM0IHdvcmxkUG9zaXRpb24gPSB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFx0I2lmZGVmIFVTRV9CQVRDSElOR1xcblxcdFxcdHdvcmxkUG9zaXRpb24gPSBiYXRjaGluZ01hdHJpeCAqIHdvcmxkUG9zaXRpb247XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuXFx0XFx0d29ybGRQb3NpdGlvbiA9IGluc3RhbmNlTWF0cml4ICogd29ybGRQb3NpdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHR3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xcbiNlbmRpZlwiO1xuXG5jb25zdCB2ZXJ0ZXgkaCA9IFwidmFyeWluZyB2ZWMyIHZVdjtcXG51bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07XFxudm9pZCBtYWluKCkge1xcblxcdHZVdiA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCB1diwgMSApICkueHk7XFxuXFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbi54eSwgMS4wLCAxLjAgKTtcXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JGggPSBcInVuaWZvcm0gc2FtcGxlcjJEIHQyRDtcXG51bmlmb3JtIGZsb2F0IGJhY2tncm91bmRJbnRlbnNpdHk7XFxudmFyeWluZyB2ZWMyIHZVdjtcXG52b2lkIG1haW4oKSB7XFxuXFx0dmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCggdDJELCB2VXYgKTtcXG5cXHQjaWZkZWYgREVDT0RFX1ZJREVPX1RFWFRVUkVcXG5cXHRcXHR0ZXhDb2xvciA9IHZlYzQoIG1peCggcG93KCB0ZXhDb2xvci5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdGV4Q29sb3IucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB0ZXhDb2xvci5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdGV4Q29sb3IudyApO1xcblxcdCNlbmRpZlxcblxcdHRleENvbG9yLnJnYiAqPSBiYWNrZ3JvdW5kSW50ZW5zaXR5O1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleENvbG9yO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IHZlcnRleCRnID0gXCJ2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0Z2xfUG9zaXRpb24ueiA9IGdsX1Bvc2l0aW9uLnc7XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCRnID0gXCIjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xcbiNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxudW5pZm9ybSBmbG9hdCBiYWNrZ3JvdW5kQmx1cnJpbmVzcztcXG51bmlmb3JtIGZsb2F0IGJhY2tncm91bmRJbnRlbnNpdHk7XFxudW5pZm9ybSBtYXQzIGJhY2tncm91bmRSb3RhdGlvbjtcXG52YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0dmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGJhY2tncm91bmRSb3RhdGlvbiAqIHZlYzMoIGZsaXBFbnZNYXAgKiB2V29ybGREaXJlY3Rpb24ueCwgdldvcmxkRGlyZWN0aW9uLnl6ICkgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHR2ZWM0IHRleENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCBiYWNrZ3JvdW5kUm90YXRpb24gKiB2V29ybGREaXJlY3Rpb24sIGJhY2tncm91bmRCbHVycmluZXNzICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWM0IHRleENvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XFxuXFx0I2VuZGlmXFxuXFx0dGV4Q29sb3IucmdiICo9IGJhY2tncm91bmRJbnRlbnNpdHk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdGV4Q29sb3I7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JGYgPSBcInZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG52b2lkIG1haW4oKSB7XFxuXFx0dldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHRnbF9Qb3NpdGlvbi56ID0gZ2xfUG9zaXRpb24udztcXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JGYgPSBcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XFxudW5pZm9ybSBmbG9hdCB0RmxpcDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG52b2lkIG1haW4oKSB7XFxuXFx0dmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGREaXJlY3Rpb24ueCwgdldvcmxkRGlyZWN0aW9uLnl6ICkgKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvcjtcXG5cXHRnbF9GcmFnQ29sb3IuYSAqPSBvcGFjaXR5O1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IHZlcnRleCRlID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXO1xcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZIaWdoUHJlY2lzaW9uWlcgPSBnbF9Qb3NpdGlvbi56dztcXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JGUgPSBcIiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXG5cXHR1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMS4wICk7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0ZmxvYXQgZnJhZ0Nvb3JkWiA9IDAuNSAqIHZIaWdoUHJlY2lzaW9uWldbMF0gLyB2SGlnaFByZWNpc2lvblpXWzFdICsgMC41O1xcblxcdCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCAxLjAgLSBmcmFnQ29vcmRaICksIG9wYWNpdHkgKTtcXG5cXHQjZWxpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGZyYWdDb29yZFogKTtcXG5cXHQjZW5kaWZcXG59XCI7XG5cbmNvbnN0IHZlcnRleCRkID0gXCIjZGVmaW5lIERJU1RBTkNFXFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0XFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcbn1cIjtcblxuY29uc3QgZnJhZ21lbnQkZCA9IFwiI2RlZmluZSBESVNUQU5DRVxcbnVuaWZvcm0gdmVjMyByZWZlcmVuY2VQb3NpdGlvbjtcXG51bmlmb3JtIGZsb2F0IG5lYXJEaXN0YW5jZTtcXG51bmlmb3JtIGZsb2F0IGZhckRpc3RhbmNlO1xcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4gKCkge1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMS4wICk7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XFxuXFx0ZmxvYXQgZGlzdCA9IGxlbmd0aCggdldvcmxkUG9zaXRpb24gLSByZWZlcmVuY2VQb3NpdGlvbiApO1xcblxcdGRpc3QgPSAoIGRpc3QgLSBuZWFyRGlzdGFuY2UgKSAvICggZmFyRGlzdGFuY2UgLSBuZWFyRGlzdGFuY2UgKTtcXG5cXHRkaXN0ID0gc2F0dXJhdGUoIGRpc3QgKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGRpc3QgKTtcXG59XCI7XG5cbmNvbnN0IHZlcnRleCRjID0gXCJ2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCRjID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XFxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkRGlyZWN0aW9uICk7XFxuXFx0dmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IHZlcnRleCRiID0gXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1xcbmF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JGIgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IGRhc2hTaXplO1xcbnVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1xcblxcdFxcdGRpc2NhcmQ7XFxuXFx0fVxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHQjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JGEgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+XFxuXFx0I2lmIGRlZmluZWQgKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCAoIFVTRV9TS0lOTklORyApXFxuXFx0XFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblxuY29uc3QgZnJhZ21lbnQkYSA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdCNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHRcXHR2ZWM0IGxpZ2h0TWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2TGlnaHRNYXBVdiApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5ICogUkVDSVBST0NBTF9QSTtcXG5cXHQjZWxzZVxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSB2ZWMzKCAxLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlO1xcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JDkgPSBcIiNkZWZpbmUgTEFNQkVSVFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblxuY29uc3QgZnJhZ21lbnQkOSA9IFwiI2RlZmluZSBMQU1CRVJUXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19sYW1iZXJ0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2xhbWJlcnRfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkOCA9IFwiI2RlZmluZSBNQVRDQVBcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JDggPSBcIiNkZWZpbmUgTUFUQ0FQXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hdGNhcDtcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHR2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5cXHR2ZWMzIHggPSBub3JtYWxpemUoIHZlYzMoIHZpZXdEaXIueiwgMC4wLCAtIHZpZXdEaXIueCApICk7XFxuXFx0dmVjMyB5ID0gY3Jvc3MoIHZpZXdEaXIsIHggKTtcXG5cXHR2ZWMyIHV2ID0gdmVjMiggZG90KCB4LCBub3JtYWwgKSwgZG90KCB5LCBub3JtYWwgKSApICogMC40OTUgKyAwLjU7XFxuXFx0I2lmZGVmIFVTRV9NQVRDQVBcXG5cXHRcXHR2ZWM0IG1hdGNhcENvbG9yID0gdGV4dHVyZTJEKCBtYXRjYXAsIHV2ICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWM0IG1hdGNhcENvbG9yID0gdmVjNCggdmVjMyggbWl4KCAwLjIsIDAuOCwgdXYueSApICksIDEuMCApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBtYXRjYXBDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JDcgPSBcIiNkZWZpbmUgTk9STUFMXFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApXFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCQ3ID0gXCIjZGVmaW5lIE5PUk1BTFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFIClcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwYWNrTm9ybWFsVG9SR0IoIG5vcm1hbCApLCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpZmRlZiBPUEFRVUVcXG5cXHRcXHRnbF9GcmFnQ29sb3IuYSA9IDEuMDtcXG5cXHQjZW5kaWZcXG59XCI7XG5cbmNvbnN0IHZlcnRleCQ2ID0gXCIjZGVmaW5lIFBIT05HXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCQ2ID0gXCIjZGVmaW5lIFBIT05HXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcXG51bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkNSA9IFwiI2RlZmluZSBTVEFOREFSRFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG4jaWZkZWYgVVNFX1RSQU5TTUlTU0lPTlxcblxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxuI2VuZGlmXFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCQ1ID0gXCIjZGVmaW5lIFNUQU5EQVJEXFxuI2lmZGVmIFBIWVNJQ0FMXFxuXFx0I2RlZmluZSBJT1JcXG5cXHQjZGVmaW5lIFVTRV9TUEVDVUxBUlxcbiNlbmRpZlxcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXG51bmlmb3JtIGZsb2F0IHJvdWdobmVzcztcXG51bmlmb3JtIGZsb2F0IG1ldGFsbmVzcztcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2lmZGVmIElPUlxcblxcdHVuaWZvcm0gZmxvYXQgaW9yO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJcXG5cXHR1bmlmb3JtIGZsb2F0IHNwZWN1bGFySW50ZW5zaXR5O1xcblxcdHVuaWZvcm0gdmVjMyBzcGVjdWxhckNvbG9yO1xcblxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhckNvbG9yTWFwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJJbnRlbnNpdHlNYXA7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHR1bmlmb3JtIGZsb2F0IGNsZWFyY29hdDtcXG5cXHR1bmlmb3JtIGZsb2F0IGNsZWFyY29hdFJvdWdobmVzcztcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0RJU1BFUlNJT05cXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BlcnNpb247XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRVxcblxcdHVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2U7XFxuXFx0dW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZUlPUjtcXG5cXHR1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTtcXG5cXHR1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIRUVOXFxuXFx0dW5pZm9ybSB2ZWMzIHNoZWVuQ29sb3I7XFxuXFx0dW5pZm9ybSBmbG9hdCBzaGVlblJvdWdobmVzcztcXG5cXHQjaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgc2hlZW5Db2xvck1hcDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNoZWVuUm91Z2huZXNzTWFwO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQU5JU09UUk9QWVxcblxcdHVuaWZvcm0gdmVjMiBhbmlzb3Ryb3B5VmVjdG9yO1xcblxcdCNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGFuaXNvdHJvcHlNYXA7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGlyaWRlc2NlbmNlX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxpcmlkZXNjZW5jZV9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cm91Z2huZXNzbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyB0b3RhbERpZmZ1c2UgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlO1xcblxcdHZlYzMgdG90YWxTcGVjdWxhciA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhcjtcXG5cXHQjaW5jbHVkZSA8dHJhbnNtaXNzaW9uX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHRvdGFsRGlmZnVzZSArIHRvdGFsU3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2lmZGVmIFVTRV9TSEVFTlxcblxcdFxcdGZsb2F0IHNoZWVuRW5lcmd5Q29tcCA9IDEuMCAtIDAuMTU3ICogbWF4MyggbWF0ZXJpYWwuc2hlZW5Db2xvciApO1xcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogc2hlZW5FbmVyZ3lDb21wICsgc2hlZW5TcGVjdWxhckRpcmVjdCArIHNoZWVuU3BlY3VsYXJJbmRpcmVjdDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGZsb2F0IGRvdE5WY2MgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyICkgKTtcXG5cXHRcXHR2ZWMzIEZjYyA9IEZfU2NobGljayggbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgZG90TlZjYyApO1xcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogKCAxLjAgLSBtYXRlcmlhbC5jbGVhcmNvYXQgKiBGY2MgKSArICggY2xlYXJjb2F0U3BlY3VsYXJEaXJlY3QgKyBjbGVhcmNvYXRTcGVjdWxhckluZGlyZWN0ICkgKiBtYXRlcmlhbC5jbGVhcmNvYXQ7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JDQgPSBcIiNkZWZpbmUgVE9PTlxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoaW5zdGFuY2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JDQgPSBcIiNkZWZpbmUgVE9PTlxcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3Rvb25fZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JDMgPSBcInVuaWZvcm0gZmxvYXQgc2l6ZTtcXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbiNpZmRlZiBVU0VfUE9JTlRTX1VWXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cXHR1bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07XFxuI2VuZGlmXFxudm9pZCBtYWluKCkge1xcblxcdCNpZmRlZiBVU0VfUE9JTlRTX1VWXFxuXFx0XFx0dlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGluc3RhbmNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHRnbF9Qb2ludFNpemUgPSBzaXplO1xcblxcdCNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXFxuXFx0XFx0Ym9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApO1xcblxcdFxcdGlmICggaXNQZXJzcGVjdGl2ZSApIGdsX1BvaW50U2l6ZSAqPSAoIHNjYWxlIC8gLSBtdlBvc2l0aW9uLnogKTtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCQzID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX3BhcnRpY2xlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IHZlcnRleCQyID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhpbnN0YW5jZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50JDIgPSBcInVuaWZvcm0gdmVjMyBjb2xvcjtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCBvcGFjaXR5ICogKCAxLjAgLSBnZXRTaGFkb3dNYXNrKCkgKSApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JDEgPSBcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XFxudW5pZm9ybSB2ZWMyIGNlbnRlcjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xcblxcdHZlYzIgc2NhbGU7XFxuXFx0c2NhbGUueCA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDAgXS54LCBtb2RlbE1hdHJpeFsgMCBdLnksIG1vZGVsTWF0cml4WyAwIF0ueiApICk7XFxuXFx0c2NhbGUueSA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDEgXS54LCBtb2RlbE1hdHJpeFsgMSBdLnksIG1vZGVsTWF0cml4WyAxIF0ueiApICk7XFxuXFx0I2lmbmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXFxuXFx0XFx0Ym9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApO1xcblxcdFxcdGlmICggaXNQZXJzcGVjdGl2ZSApIHNjYWxlICo9IC0gbXZQb3NpdGlvbi56O1xcblxcdCNlbmRpZlxcblxcdHZlYzIgYWxpZ25lZFBvc2l0aW9uID0gKCBwb3NpdGlvbi54eSAtICggY2VudGVyIC0gdmVjMiggMC41ICkgKSApICogc2NhbGU7XFxuXFx0dmVjMiByb3RhdGVkUG9zaXRpb247XFxuXFx0cm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xcblxcdHJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTtcXG5cXHRtdlBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuXG5jb25zdCBmcmFnbWVudCQxID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IFNoYWRlckNodW5rID0ge1xuXHRhbHBoYWhhc2hfZnJhZ21lbnQ6IGFscGhhaGFzaF9mcmFnbWVudCxcblx0YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ6IGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50LFxuXHRhbHBoYW1hcF9mcmFnbWVudDogYWxwaGFtYXBfZnJhZ21lbnQsXG5cdGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ6IGFscGhhbWFwX3BhcnNfZnJhZ21lbnQsXG5cdGFscGhhdGVzdF9mcmFnbWVudDogYWxwaGF0ZXN0X2ZyYWdtZW50LFxuXHRhbHBoYXRlc3RfcGFyc19mcmFnbWVudDogYWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQsXG5cdGFvbWFwX2ZyYWdtZW50OiBhb21hcF9mcmFnbWVudCxcblx0YW9tYXBfcGFyc19mcmFnbWVudDogYW9tYXBfcGFyc19mcmFnbWVudCxcblx0YmF0Y2hpbmdfcGFyc192ZXJ0ZXg6IGJhdGNoaW5nX3BhcnNfdmVydGV4LFxuXHRiYXRjaGluZ192ZXJ0ZXg6IGJhdGNoaW5nX3ZlcnRleCxcblx0YmVnaW5fdmVydGV4OiBiZWdpbl92ZXJ0ZXgsXG5cdGJlZ2lubm9ybWFsX3ZlcnRleDogYmVnaW5ub3JtYWxfdmVydGV4LFxuXHRic2RmczogYnNkZnMsXG5cdGlyaWRlc2NlbmNlX2ZyYWdtZW50OiBpcmlkZXNjZW5jZV9mcmFnbWVudCxcblx0YnVtcG1hcF9wYXJzX2ZyYWdtZW50OiBidW1wbWFwX3BhcnNfZnJhZ21lbnQsXG5cdGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50LFxuXHRjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQsXG5cdGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4LFxuXHRjbGlwcGluZ19wbGFuZXNfdmVydGV4OiBjbGlwcGluZ19wbGFuZXNfdmVydGV4LFxuXHRjb2xvcl9mcmFnbWVudDogY29sb3JfZnJhZ21lbnQsXG5cdGNvbG9yX3BhcnNfZnJhZ21lbnQ6IGNvbG9yX3BhcnNfZnJhZ21lbnQsXG5cdGNvbG9yX3BhcnNfdmVydGV4OiBjb2xvcl9wYXJzX3ZlcnRleCxcblx0Y29sb3JfdmVydGV4OiBjb2xvcl92ZXJ0ZXgsXG5cdGNvbW1vbjogY29tbW9uLFxuXHRjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ6IGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudCxcblx0ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg6IGRlZmF1bHRub3JtYWxfdmVydGV4LFxuXHRkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCxcblx0ZGlzcGxhY2VtZW50bWFwX3ZlcnRleDogZGlzcGxhY2VtZW50bWFwX3ZlcnRleCxcblx0ZW1pc3NpdmVtYXBfZnJhZ21lbnQ6IGVtaXNzaXZlbWFwX2ZyYWdtZW50LFxuXHRlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50LFxuXHRjb2xvcnNwYWNlX2ZyYWdtZW50OiBjb2xvcnNwYWNlX2ZyYWdtZW50LFxuXHRjb2xvcnNwYWNlX3BhcnNfZnJhZ21lbnQ6IGNvbG9yc3BhY2VfcGFyc19mcmFnbWVudCxcblx0ZW52bWFwX2ZyYWdtZW50OiBlbnZtYXBfZnJhZ21lbnQsXG5cdGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudDogZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50LFxuXHRlbnZtYXBfcGFyc19mcmFnbWVudDogZW52bWFwX3BhcnNfZnJhZ21lbnQsXG5cdGVudm1hcF9wYXJzX3ZlcnRleDogZW52bWFwX3BhcnNfdmVydGV4LFxuXHRlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudDogZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQsXG5cdGVudm1hcF92ZXJ0ZXg6IGVudm1hcF92ZXJ0ZXgsXG5cdGZvZ192ZXJ0ZXg6IGZvZ192ZXJ0ZXgsXG5cdGZvZ19wYXJzX3ZlcnRleDogZm9nX3BhcnNfdmVydGV4LFxuXHRmb2dfZnJhZ21lbnQ6IGZvZ19mcmFnbWVudCxcblx0Zm9nX3BhcnNfZnJhZ21lbnQ6IGZvZ19wYXJzX2ZyYWdtZW50LFxuXHRncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50OiBncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodG1hcF9wYXJzX2ZyYWdtZW50OiBsaWdodG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfbGFtYmVydF9mcmFnbWVudDogbGlnaHRzX2xhbWJlcnRfZnJhZ21lbnQsXG5cdGxpZ2h0c19sYW1iZXJ0X3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19sYW1iZXJ0X3BhcnNfZnJhZ21lbnQsXG5cdGxpZ2h0c19wYXJzX2JlZ2luOiBsaWdodHNfcGFyc19iZWdpbixcblx0bGlnaHRzX3Rvb25fZnJhZ21lbnQ6IGxpZ2h0c190b29uX2ZyYWdtZW50LFxuXHRsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50OiBsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfcGhvbmdfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19mcmFnbWVudCxcblx0bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudCxcblx0bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfZnJhZ21lbnRfYmVnaW46IGxpZ2h0c19mcmFnbWVudF9iZWdpbixcblx0bGlnaHRzX2ZyYWdtZW50X21hcHM6IGxpZ2h0c19mcmFnbWVudF9tYXBzLFxuXHRsaWdodHNfZnJhZ21lbnRfZW5kOiBsaWdodHNfZnJhZ21lbnRfZW5kLFxuXHRsb2dkZXB0aGJ1Zl9mcmFnbWVudDogbG9nZGVwdGhidWZfZnJhZ21lbnQsXG5cdGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ6IGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXG5cdGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4OiBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcblx0bG9nZGVwdGhidWZfdmVydGV4OiBsb2dkZXB0aGJ1Zl92ZXJ0ZXgsXG5cdG1hcF9mcmFnbWVudDogbWFwX2ZyYWdtZW50LFxuXHRtYXBfcGFyc19mcmFnbWVudDogbWFwX3BhcnNfZnJhZ21lbnQsXG5cdG1hcF9wYXJ0aWNsZV9mcmFnbWVudDogbWFwX3BhcnRpY2xlX2ZyYWdtZW50LFxuXHRtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudDogbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQsXG5cdG1ldGFsbmVzc21hcF9mcmFnbWVudDogbWV0YWxuZXNzbWFwX2ZyYWdtZW50LFxuXHRtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDogbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQsXG5cdG1vcnBoaW5zdGFuY2VfdmVydGV4OiBtb3JwaGluc3RhbmNlX3ZlcnRleCxcblx0bW9ycGhjb2xvcl92ZXJ0ZXg6IG1vcnBoY29sb3JfdmVydGV4LFxuXHRtb3JwaG5vcm1hbF92ZXJ0ZXg6IG1vcnBobm9ybWFsX3ZlcnRleCxcblx0bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFxuXHRtb3JwaHRhcmdldF92ZXJ0ZXg6IG1vcnBodGFyZ2V0X3ZlcnRleCxcblx0bm9ybWFsX2ZyYWdtZW50X2JlZ2luOiBub3JtYWxfZnJhZ21lbnRfYmVnaW4sXG5cdG5vcm1hbF9mcmFnbWVudF9tYXBzOiBub3JtYWxfZnJhZ21lbnRfbWFwcyxcblx0bm9ybWFsX3BhcnNfZnJhZ21lbnQ6IG5vcm1hbF9wYXJzX2ZyYWdtZW50LFxuXHRub3JtYWxfcGFyc192ZXJ0ZXg6IG5vcm1hbF9wYXJzX3ZlcnRleCxcblx0bm9ybWFsX3ZlcnRleDogbm9ybWFsX3ZlcnRleCxcblx0bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ6IG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luOiBjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luLFxuXHRjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHM6IGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcyxcblx0Y2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQ6IGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50LFxuXHRpcmlkZXNjZW5jZV9wYXJzX2ZyYWdtZW50OiBpcmlkZXNjZW5jZV9wYXJzX2ZyYWdtZW50LFxuXHRvcGFxdWVfZnJhZ21lbnQ6IG9wYXF1ZV9mcmFnbWVudCxcblx0cGFja2luZzogcGFja2luZyxcblx0cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudDogcHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudCxcblx0cHJvamVjdF92ZXJ0ZXg6IHByb2plY3RfdmVydGV4LFxuXHRkaXRoZXJpbmdfZnJhZ21lbnQ6IGRpdGhlcmluZ19mcmFnbWVudCxcblx0ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ6IGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50LFxuXHRyb3VnaG5lc3NtYXBfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9mcmFnbWVudCxcblx0cm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50LFxuXHRzaGFkb3dtYXBfcGFyc19mcmFnbWVudDogc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQsXG5cdHNoYWRvd21hcF9wYXJzX3ZlcnRleDogc2hhZG93bWFwX3BhcnNfdmVydGV4LFxuXHRzaGFkb3dtYXBfdmVydGV4OiBzaGFkb3dtYXBfdmVydGV4LFxuXHRzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ6IHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCxcblx0c2tpbmJhc2VfdmVydGV4OiBza2luYmFzZV92ZXJ0ZXgsXG5cdHNraW5uaW5nX3BhcnNfdmVydGV4OiBza2lubmluZ19wYXJzX3ZlcnRleCxcblx0c2tpbm5pbmdfdmVydGV4OiBza2lubmluZ192ZXJ0ZXgsXG5cdHNraW5ub3JtYWxfdmVydGV4OiBza2lubm9ybWFsX3ZlcnRleCxcblx0c3BlY3VsYXJtYXBfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX2ZyYWdtZW50LFxuXHRzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50OiBzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50LFxuXHR0b25lbWFwcGluZ19mcmFnbWVudDogdG9uZW1hcHBpbmdfZnJhZ21lbnQsXG5cdHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQsXG5cdHRyYW5zbWlzc2lvbl9mcmFnbWVudDogdHJhbnNtaXNzaW9uX2ZyYWdtZW50LFxuXHR0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudDogdHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQsXG5cdHV2X3BhcnNfZnJhZ21lbnQ6IHV2X3BhcnNfZnJhZ21lbnQsXG5cdHV2X3BhcnNfdmVydGV4OiB1dl9wYXJzX3ZlcnRleCxcblx0dXZfdmVydGV4OiB1dl92ZXJ0ZXgsXG5cdHdvcmxkcG9zX3ZlcnRleDogd29ybGRwb3NfdmVydGV4LFxuXG5cdGJhY2tncm91bmRfdmVydDogdmVydGV4JGgsXG5cdGJhY2tncm91bmRfZnJhZzogZnJhZ21lbnQkaCxcblx0YmFja2dyb3VuZEN1YmVfdmVydDogdmVydGV4JGcsXG5cdGJhY2tncm91bmRDdWJlX2ZyYWc6IGZyYWdtZW50JGcsXG5cdGN1YmVfdmVydDogdmVydGV4JGYsXG5cdGN1YmVfZnJhZzogZnJhZ21lbnQkZixcblx0ZGVwdGhfdmVydDogdmVydGV4JGUsXG5cdGRlcHRoX2ZyYWc6IGZyYWdtZW50JGUsXG5cdGRpc3RhbmNlUkdCQV92ZXJ0OiB2ZXJ0ZXgkZCxcblx0ZGlzdGFuY2VSR0JBX2ZyYWc6IGZyYWdtZW50JGQsXG5cdGVxdWlyZWN0X3ZlcnQ6IHZlcnRleCRjLFxuXHRlcXVpcmVjdF9mcmFnOiBmcmFnbWVudCRjLFxuXHRsaW5lZGFzaGVkX3ZlcnQ6IHZlcnRleCRiLFxuXHRsaW5lZGFzaGVkX2ZyYWc6IGZyYWdtZW50JGIsXG5cdG1lc2hiYXNpY192ZXJ0OiB2ZXJ0ZXgkYSxcblx0bWVzaGJhc2ljX2ZyYWc6IGZyYWdtZW50JGEsXG5cdG1lc2hsYW1iZXJ0X3ZlcnQ6IHZlcnRleCQ5LFxuXHRtZXNobGFtYmVydF9mcmFnOiBmcmFnbWVudCQ5LFxuXHRtZXNobWF0Y2FwX3ZlcnQ6IHZlcnRleCQ4LFxuXHRtZXNobWF0Y2FwX2ZyYWc6IGZyYWdtZW50JDgsXG5cdG1lc2hub3JtYWxfdmVydDogdmVydGV4JDcsXG5cdG1lc2hub3JtYWxfZnJhZzogZnJhZ21lbnQkNyxcblx0bWVzaHBob25nX3ZlcnQ6IHZlcnRleCQ2LFxuXHRtZXNocGhvbmdfZnJhZzogZnJhZ21lbnQkNixcblx0bWVzaHBoeXNpY2FsX3ZlcnQ6IHZlcnRleCQ1LFxuXHRtZXNocGh5c2ljYWxfZnJhZzogZnJhZ21lbnQkNSxcblx0bWVzaHRvb25fdmVydDogdmVydGV4JDQsXG5cdG1lc2h0b29uX2ZyYWc6IGZyYWdtZW50JDQsXG5cdHBvaW50c192ZXJ0OiB2ZXJ0ZXgkMyxcblx0cG9pbnRzX2ZyYWc6IGZyYWdtZW50JDMsXG5cdHNoYWRvd192ZXJ0OiB2ZXJ0ZXgkMixcblx0c2hhZG93X2ZyYWc6IGZyYWdtZW50JDIsXG5cdHNwcml0ZV92ZXJ0OiB2ZXJ0ZXgkMSxcblx0c3ByaXRlX2ZyYWc6IGZyYWdtZW50JDFcbn07XG5cbi8qKlxuICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcbiAqL1xuXG5jb25zdCBVbmlmb3Jtc0xpYiA9IHtcblxuXHRjb21tb246IHtcblxuXHRcdGRpZmZ1c2U6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXG5cblx0XHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRtYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXG5cdFx0YWxwaGFNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRhbHBoYU1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cblx0XHRhbHBoYVRlc3Q6IHsgdmFsdWU6IDAgfVxuXG5cdH0sXG5cblx0c3BlY3VsYXJtYXA6IHtcblxuXHRcdHNwZWN1bGFyTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0c3BlY3VsYXJNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XG5cblx0fSxcblxuXHRlbnZtYXA6IHtcblxuXHRcdGVudk1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGVudk1hcFJvdGF0aW9uOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRmbGlwRW52TWFwOiB7IHZhbHVlOiAtIDEgfSxcblx0XHRyZWZsZWN0aXZpdHk6IHsgdmFsdWU6IDEuMCB9LCAvLyBiYXNpYywgbGFtYmVydCwgcGhvbmdcblx0XHRpb3I6IHsgdmFsdWU6IDEuNSB9LCAvLyBwaHlzaWNhbFxuXHRcdHJlZnJhY3Rpb25SYXRpbzogeyB2YWx1ZTogMC45OCB9LCAvLyBiYXNpYywgbGFtYmVydCwgcGhvbmdcblxuXHR9LFxuXG5cdGFvbWFwOiB7XG5cblx0XHRhb01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGFvTWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0sXG5cdFx0YW9NYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XG5cblx0fSxcblxuXHRsaWdodG1hcDoge1xuXG5cdFx0bGlnaHRNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRsaWdodE1hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9LFxuXHRcdGxpZ2h0TWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfVxuXG5cdH0sXG5cblx0YnVtcG1hcDoge1xuXG5cdFx0YnVtcE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGJ1bXBNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdGJ1bXBTY2FsZTogeyB2YWx1ZTogMSB9XG5cblx0fSxcblxuXHRub3JtYWxtYXA6IHtcblxuXHRcdG5vcm1hbE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdG5vcm1hbE1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cdFx0bm9ybWFsU2NhbGU6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoIDEsIDEgKSB9XG5cblx0fSxcblxuXHRkaXNwbGFjZW1lbnRtYXA6IHtcblxuXHRcdGRpc3BsYWNlbWVudE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGRpc3BsYWNlbWVudE1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cdFx0ZGlzcGxhY2VtZW50U2NhbGU6IHsgdmFsdWU6IDEgfSxcblx0XHRkaXNwbGFjZW1lbnRCaWFzOiB7IHZhbHVlOiAwIH1cblxuXHR9LFxuXG5cdGVtaXNzaXZlbWFwOiB7XG5cblx0XHRlbWlzc2l2ZU1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGVtaXNzaXZlTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfVxuXG5cdH0sXG5cblx0bWV0YWxuZXNzbWFwOiB7XG5cblx0XHRtZXRhbG5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRtZXRhbG5lc3NNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XG5cblx0fSxcblxuXHRyb3VnaG5lc3NtYXA6IHtcblxuXHRcdHJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdHJvdWdobmVzc01hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH1cblxuXHR9LFxuXG5cdGdyYWRpZW50bWFwOiB7XG5cblx0XHRncmFkaWVudE1hcDogeyB2YWx1ZTogbnVsbCB9XG5cblx0fSxcblxuXHRmb2c6IHtcblxuXHRcdGZvZ0RlbnNpdHk6IHsgdmFsdWU6IDAuMDAwMjUgfSxcblx0XHRmb2dOZWFyOiB7IHZhbHVlOiAxIH0sXG5cdFx0Zm9nRmFyOiB7IHZhbHVlOiAyMDAwIH0sXG5cdFx0Zm9nQ29sb3I6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweGZmZmZmZiApIH1cblxuXHR9LFxuXG5cdGxpZ2h0czoge1xuXG5cdFx0YW1iaWVudExpZ2h0Q29sb3I6IHsgdmFsdWU6IFtdIH0sXG5cblx0XHRsaWdodFByb2JlOiB7IHZhbHVlOiBbXSB9LFxuXG5cdFx0ZGlyZWN0aW9uYWxMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG5cdFx0XHRkaXJlY3Rpb246IHt9LFxuXHRcdFx0Y29sb3I6IHt9XG5cdFx0fSB9LFxuXG5cdFx0ZGlyZWN0aW9uYWxMaWdodFNoYWRvd3M6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG5cdFx0XHRzaGFkb3dCaWFzOiB7fSxcblx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IHt9LFxuXHRcdFx0c2hhZG93UmFkaXVzOiB7fSxcblx0XHRcdHNoYWRvd01hcFNpemU6IHt9XG5cdFx0fSB9LFxuXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IHsgdmFsdWU6IFtdIH0sXG5cblx0XHRzcG90TGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuXHRcdFx0Y29sb3I6IHt9LFxuXHRcdFx0cG9zaXRpb246IHt9LFxuXHRcdFx0ZGlyZWN0aW9uOiB7fSxcblx0XHRcdGRpc3RhbmNlOiB7fSxcblx0XHRcdGNvbmVDb3M6IHt9LFxuXHRcdFx0cGVudW1icmFDb3M6IHt9LFxuXHRcdFx0ZGVjYXk6IHt9XG5cdFx0fSB9LFxuXG5cdFx0c3BvdExpZ2h0U2hhZG93czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdHNoYWRvd0JpYXM6IHt9LFxuXHRcdFx0c2hhZG93Tm9ybWFsQmlhczoge30sXG5cdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuXHRcdFx0c2hhZG93TWFwU2l6ZToge31cblx0XHR9IH0sXG5cblx0XHRzcG90TGlnaHRNYXA6IHsgdmFsdWU6IFtdIH0sXG5cdFx0c3BvdFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcblx0XHRzcG90TGlnaHRNYXRyaXg6IHsgdmFsdWU6IFtdIH0sXG5cblx0XHRwb2ludExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdGNvbG9yOiB7fSxcblx0XHRcdHBvc2l0aW9uOiB7fSxcblx0XHRcdGRlY2F5OiB7fSxcblx0XHRcdGRpc3RhbmNlOiB7fVxuXHRcdH0gfSxcblxuXHRcdHBvaW50TGlnaHRTaGFkb3dzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuXHRcdFx0c2hhZG93Qmlhczoge30sXG5cdFx0XHRzaGFkb3dOb3JtYWxCaWFzOiB7fSxcblx0XHRcdHNoYWRvd1JhZGl1czoge30sXG5cdFx0XHRzaGFkb3dNYXBTaXplOiB7fSxcblx0XHRcdHNoYWRvd0NhbWVyYU5lYXI6IHt9LFxuXHRcdFx0c2hhZG93Q2FtZXJhRmFyOiB7fVxuXHRcdH0gfSxcblxuXHRcdHBvaW50U2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxuXHRcdHBvaW50U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxuXG5cdFx0aGVtaXNwaGVyZUxpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdGRpcmVjdGlvbjoge30sXG5cdFx0XHRza3lDb2xvcjoge30sXG5cdFx0XHRncm91bmRDb2xvcjoge31cblx0XHR9IH0sXG5cblx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogUmVjdEFyZWFMaWdodCBCUkRGIGRhdGEgbmVlZHMgdG8gYmUgbW92ZWQgZnJvbSBleGFtcGxlIHRvIG1haW4gc3JjXG5cdFx0cmVjdEFyZWFMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG5cdFx0XHRjb2xvcjoge30sXG5cdFx0XHRwb3NpdGlvbjoge30sXG5cdFx0XHR3aWR0aDoge30sXG5cdFx0XHRoZWlnaHQ6IHt9XG5cdFx0fSB9LFxuXG5cdFx0bHRjXzE6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRsdGNfMjogeyB2YWx1ZTogbnVsbCB9XG5cblx0fSxcblxuXHRwb2ludHM6IHtcblxuXHRcdGRpZmZ1c2U6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXG5cdFx0c2l6ZTogeyB2YWx1ZTogMS4wIH0sXG5cdFx0c2NhbGU6IHsgdmFsdWU6IDEuMCB9LFxuXHRcdG1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGFscGhhTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0YWxwaGFNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdGFscGhhVGVzdDogeyB2YWx1ZTogMCB9LFxuXHRcdHV2VHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfVxuXG5cdH0sXG5cblx0c3ByaXRlOiB7XG5cblx0XHRkaWZmdXNlOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMHhmZmZmZmYgKSB9LFxuXHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9LFxuXHRcdGNlbnRlcjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMiggMC41LCAwLjUgKSB9LFxuXHRcdHJvdGF0aW9uOiB7IHZhbHVlOiAwLjAgfSxcblx0XHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRtYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdGFscGhhTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0YWxwaGFNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdGFscGhhVGVzdDogeyB2YWx1ZTogMCB9XG5cblx0fVxuXG59O1xuXG5jb25zdCBTaGFkZXJMaWIgPSB7XG5cblx0YmFzaWM6IHtcblxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuZW52bWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmZvZ1xuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGJhc2ljX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY19mcmFnXG5cblx0fSxcblxuXHRsYW1iZXJ0OiB7XG5cblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qLyBtZXJnZVVuaWZvcm1zKCBbXG5cdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXG5cdFx0XHRVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmVudm1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2csXG5cdFx0XHRVbmlmb3Jtc0xpYi5saWdodHMsXG5cdFx0XHR7XG5cdFx0XHRcdGVtaXNzaXZlOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMHgwMDAwMDAgKSB9XG5cdFx0XHR9XG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF9mcmFnXG5cblx0fSxcblxuXHRwaG9uZzoge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbnZtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5hb21hcCxcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxuXHRcdFx0e1xuXHRcdFx0XHRlbWlzc2l2ZTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfSxcblx0XHRcdFx0c3BlY3VsYXI6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDExMTExMSApIH0sXG5cdFx0XHRcdHNoaW5pbmVzczogeyB2YWx1ZTogMzAgfVxuXHRcdFx0fVxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBob25nX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ19mcmFnXG5cblx0fSxcblxuXHRzdGFuZGFyZDoge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuZW52bWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLnJvdWdobmVzc21hcCxcblx0XHRcdFVuaWZvcm1zTGliLm1ldGFsbmVzc21hcCxcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcblx0XHRcdHtcblx0XHRcdFx0ZW1pc3NpdmU6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDAwMDAwMCApIH0sXG5cdFx0XHRcdHJvdWdobmVzczogeyB2YWx1ZTogMS4wIH0sXG5cdFx0XHRcdG1ldGFsbmVzczogeyB2YWx1ZTogMC4wIH0sXG5cdFx0XHRcdGVudk1hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9XG5cdFx0XHR9XG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcblxuXHR9LFxuXG5cdHRvb246IHtcblxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ncmFkaWVudG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcblx0XHRcdHtcblx0XHRcdFx0ZW1pc3NpdmU6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDAwMDAwMCApIH1cblx0XHRcdH1cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2h0b29uX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2h0b29uX2ZyYWdcblxuXHR9LFxuXG5cdG1hdGNhcDoge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdHtcblx0XHRcdFx0bWF0Y2FwOiB7IHZhbHVlOiBudWxsIH1cblx0XHRcdH1cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2htYXRjYXBfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaG1hdGNhcF9mcmFnXG5cblx0fSxcblxuXHRwb2ludHM6IHtcblxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRcdFVuaWZvcm1zTGliLnBvaW50cyxcblx0XHRcdFVuaWZvcm1zTGliLmZvZ1xuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLnBvaW50c19mcmFnXG5cblx0fSxcblxuXHRkYXNoZWQ6IHtcblxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdHtcblx0XHRcdFx0c2NhbGU6IHsgdmFsdWU6IDEgfSxcblx0XHRcdFx0ZGFzaFNpemU6IHsgdmFsdWU6IDEgfSxcblx0XHRcdFx0dG90YWxTaXplOiB7IHZhbHVlOiAyIH1cblx0XHRcdH1cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmxpbmVkYXNoZWRfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubGluZWRhc2hlZF9mcmFnXG5cblx0fSxcblxuXHRkZXB0aDoge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwXG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF9mcmFnXG5cblx0fSxcblxuXHRub3JtYWw6IHtcblxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG5cdFx0XHR7XG5cdFx0XHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XG5cdFx0XHR9XG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobm9ybWFsX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hub3JtYWxfZnJhZ1xuXG5cdH0sXG5cblx0c3ByaXRlOiB7XG5cblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qLyBtZXJnZVVuaWZvcm1zKCBbXG5cdFx0XHRVbmlmb3Jtc0xpYi5zcHJpdGUsXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2dcblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnNwcml0ZV92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5zcHJpdGVfZnJhZ1xuXG5cdH0sXG5cblx0YmFja2dyb3VuZDoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdHV2VHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRcdHQyRDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0YmFja2dyb3VuZEludGVuc2l0eTogeyB2YWx1ZTogMSB9XG5cdFx0fSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuYmFja2dyb3VuZF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5iYWNrZ3JvdW5kX2ZyYWdcblxuXHR9LFxuXG5cdGJhY2tncm91bmRDdWJlOiB7XG5cblx0XHR1bmlmb3Jtczoge1xuXHRcdFx0ZW52TWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHRmbGlwRW52TWFwOiB7IHZhbHVlOiAtIDEgfSxcblx0XHRcdGJhY2tncm91bmRCbHVycmluZXNzOiB7IHZhbHVlOiAwIH0sXG5cdFx0XHRiYWNrZ3JvdW5kSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0sXG5cdFx0XHRiYWNrZ3JvdW5kUm90YXRpb246IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XG5cdFx0fSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuYmFja2dyb3VuZEN1YmVfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuYmFja2dyb3VuZEN1YmVfZnJhZ1xuXG5cdH0sXG5cblx0Y3ViZToge1xuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdHRDdWJlOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHR0RmxpcDogeyB2YWx1ZTogLSAxIH0sXG5cdFx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxuXHRcdH0sXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuY3ViZV9mcmFnXG5cblx0fSxcblxuXHRlcXVpcmVjdDoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdHRFcXVpcmVjdDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdH0sXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X2ZyYWdcblxuXHR9LFxuXG5cdGRpc3RhbmNlUkdCQToge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxuXHRcdFx0e1xuXHRcdFx0XHRyZWZlcmVuY2VQb3NpdGlvbjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpIH0sXG5cdFx0XHRcdG5lYXJEaXN0YW5jZTogeyB2YWx1ZTogMSB9LFxuXHRcdFx0XHRmYXJEaXN0YW5jZTogeyB2YWx1ZTogMTAwMCB9XG5cdFx0XHR9XG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kaXN0YW5jZVJHQkFfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX2ZyYWdcblxuXHR9LFxuXG5cdHNoYWRvdzoge1xuXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxuXHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxuXHRcdFx0e1xuXHRcdFx0XHRjb2xvcjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgQ29sb3IoIDB4MDAwMDAgKSB9LFxuXHRcdFx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxuXHRcdFx0fSxcblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnNoYWRvd192ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfZnJhZ1xuXG5cdH1cblxufTtcblxuU2hhZGVyTGliLnBoeXNpY2FsID0ge1xuXG5cdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcblx0XHRTaGFkZXJMaWIuc3RhbmRhcmQudW5pZm9ybXMsXG5cdFx0e1xuXHRcdFx0Y2xlYXJjb2F0OiB7IHZhbHVlOiAwIH0sXG5cdFx0XHRjbGVhcmNvYXRNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdGNsZWFyY29hdE1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cdFx0XHRjbGVhcmNvYXROb3JtYWxNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdGNsZWFyY29hdE5vcm1hbE1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cdFx0XHRjbGVhcmNvYXROb3JtYWxTY2FsZTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMiggMSwgMSApIH0sXG5cdFx0XHRjbGVhcmNvYXRSb3VnaG5lc3M6IHsgdmFsdWU6IDAgfSxcblx0XHRcdGNsZWFyY29hdFJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRcdGRpc3BlcnNpb246IHsgdmFsdWU6IDAgfSxcblx0XHRcdGlyaWRlc2NlbmNlOiB7IHZhbHVlOiAwIH0sXG5cdFx0XHRpcmlkZXNjZW5jZU1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0aXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdFx0aXJpZGVzY2VuY2VJT1I6IHsgdmFsdWU6IDEuMyB9LFxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtOiB7IHZhbHVlOiAxMDAgfSxcblx0XHRcdGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTogeyB2YWx1ZTogNDAwIH0sXG5cdFx0XHRpcmlkZXNjZW5jZVRoaWNrbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdFx0c2hlZW46IHsgdmFsdWU6IDAgfSxcblx0XHRcdHNoZWVuQ29sb3I6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDAwMDAwMCApIH0sXG5cdFx0XHRzaGVlbkNvbG9yTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHRzaGVlbkNvbG9yTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRcdHNoZWVuUm91Z2huZXNzOiB7IHZhbHVlOiAxIH0sXG5cdFx0XHRzaGVlblJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0c2hlZW5Sb3VnaG5lc3NNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdFx0dHJhbnNtaXNzaW9uOiB7IHZhbHVlOiAwIH0sXG5cdFx0XHR0cmFuc21pc3Npb25NYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdHRyYW5zbWlzc2lvbk1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXG5cdFx0XHR0cmFuc21pc3Npb25TYW1wbGVyU2l6ZTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpIH0sXG5cdFx0XHR0cmFuc21pc3Npb25TYW1wbGVyTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHR0aGlja25lc3M6IHsgdmFsdWU6IDAgfSxcblx0XHRcdHRoaWNrbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0dGhpY2tuZXNzTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRcdGF0dGVudWF0aW9uRGlzdGFuY2U6IHsgdmFsdWU6IDAgfSxcblx0XHRcdGF0dGVudWF0aW9uQ29sb3I6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDAwMDAwMCApIH0sXG5cdFx0XHRzcGVjdWxhckNvbG9yOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMSwgMSwgMSApIH0sXG5cdFx0XHRzcGVjdWxhckNvbG9yTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHRzcGVjdWxhckNvbG9yTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0sXG5cdFx0XHRzcGVjdWxhckludGVuc2l0eU1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0c3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxuXHRcdFx0YW5pc290cm9weVZlY3RvcjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpIH0sXG5cdFx0XHRhbmlzb3Ryb3B5TWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHRhbmlzb3Ryb3B5TWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcblx0XHR9XG5cdF0gKSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxuXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcblxufTtcblxuY29uc3QgX3JnYiA9IHsgcjogMCwgYjogMCwgZzogMCB9O1xuY29uc3QgX2UxJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBFdWxlcigpO1xuY29uc3QgX20xJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5cbmZ1bmN0aW9uIFdlYkdMQmFja2dyb3VuZCggcmVuZGVyZXIsIGN1YmVtYXBzLCBjdWJldXZtYXBzLCBzdGF0ZSwgb2JqZWN0cywgYWxwaGEsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuXHRjb25zdCBjbGVhckNvbG9yID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xuXHRsZXQgY2xlYXJBbHBoYSA9IGFscGhhID09PSB0cnVlID8gMCA6IDE7XG5cblx0bGV0IHBsYW5lTWVzaDtcblx0bGV0IGJveE1lc2g7XG5cblx0bGV0IGN1cnJlbnRCYWNrZ3JvdW5kID0gbnVsbDtcblx0bGV0IGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiA9IDA7XG5cdGxldCBjdXJyZW50VG9uZW1hcHBpbmcgPSBudWxsO1xuXG5cdGZ1bmN0aW9uIGdldEJhY2tncm91bmQoIHNjZW5lICkge1xuXG5cdFx0bGV0IGJhY2tncm91bmQgPSBzY2VuZS5pc1NjZW5lID09PSB0cnVlID8gc2NlbmUuYmFja2dyb3VuZCA6IG51bGw7XG5cblx0XHRpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGNvbnN0IHVzZVBNUkVNID0gc2NlbmUuYmFja2dyb3VuZEJsdXJyaW5lc3MgPiAwOyAvLyB1c2UgUE1SRU0gaWYgdGhlIHVzZXIgd2FudHMgdG8gYmx1ciB0aGUgYmFja2dyb3VuZFxuXHRcdFx0YmFja2dyb3VuZCA9ICggdXNlUE1SRU0gPyBjdWJldXZtYXBzIDogY3ViZW1hcHMgKS5nZXQoIGJhY2tncm91bmQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBiYWNrZ3JvdW5kO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXIoIHNjZW5lICkge1xuXG5cdFx0bGV0IGZvcmNlQ2xlYXIgPSBmYWxzZTtcblx0XHRjb25zdCBiYWNrZ3JvdW5kID0gZ2V0QmFja2dyb3VuZCggc2NlbmUgKTtcblxuXHRcdGlmICggYmFja2dyb3VuZCA9PT0gbnVsbCApIHtcblxuXHRcdFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRzZXRDbGVhciggYmFja2dyb3VuZCwgMSApO1xuXHRcdFx0Zm9yY2VDbGVhciA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBlbnZpcm9ubWVudEJsZW5kTW9kZSA9IHJlbmRlcmVyLnhyLmdldEVudmlyb25tZW50QmxlbmRNb2RlKCk7XG5cblx0XHRpZiAoIGVudmlyb25tZW50QmxlbmRNb2RlID09PSAnYWRkaXRpdmUnICkge1xuXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCAwLCAwLCAwLCAxLCBwcmVtdWx0aXBsaWVkQWxwaGEgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGVudmlyb25tZW50QmxlbmRNb2RlID09PSAnYWxwaGEtYmxlbmQnICkge1xuXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCAwLCAwLCAwLCAwLCBwcmVtdWx0aXBsaWVkQWxwaGEgKTtcblxuXHRcdH1cblxuXHRcdGlmICggcmVuZGVyZXIuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIgKSB7XG5cblx0XHRcdC8vIGJ1ZmZlcnMgbWlnaHQgbm90IGJlIHdyaXRhYmxlIHdoaWNoIGlzIHJlcXVpcmVkIHRvIGVuc3VyZSBhIGNvcnJlY3QgY2xlYXJcblxuXHRcdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCB0cnVlICk7XG5cdFx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soIHRydWUgKTtcblx0XHRcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0TWFzayggdHJ1ZSApO1xuXG5cdFx0XHRyZW5kZXJlci5jbGVhciggcmVuZGVyZXIuYXV0b0NsZWFyQ29sb3IsIHJlbmRlcmVyLmF1dG9DbGVhckRlcHRoLCByZW5kZXJlci5hdXRvQ2xlYXJTdGVuY2lsICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFRvUmVuZGVyTGlzdCggcmVuZGVyTGlzdCwgc2NlbmUgKSB7XG5cblx0XHRjb25zdCBiYWNrZ3JvdW5kID0gZ2V0QmFja2dyb3VuZCggc2NlbmUgKTtcblxuXHRcdGlmICggYmFja2dyb3VuZCAmJiAoIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSB8fCBiYWNrZ3JvdW5kLm1hcHBpbmcgPT09IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nICkgKSB7XG5cblx0XHRcdGlmICggYm94TWVzaCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGJveE1lc2ggPSBuZXcgTWVzaChcblx0XHRcdFx0XHRuZXcgQm94R2VvbWV0cnkoIDEsIDEsIDEgKSxcblx0XHRcdFx0XHRuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHRcdFx0XHRcdG5hbWU6ICdCYWNrZ3JvdW5kQ3ViZU1hdGVyaWFsJyxcblx0XHRcdFx0XHRcdHVuaWZvcm1zOiBjbG9uZVVuaWZvcm1zKCBTaGFkZXJMaWIuYmFja2dyb3VuZEN1YmUudW5pZm9ybXMgKSxcblx0XHRcdFx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyTGliLmJhY2tncm91bmRDdWJlLnZlcnRleFNoYWRlcixcblx0XHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZEN1YmUuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRcdFx0XHRzaWRlOiBCYWNrU2lkZSxcblx0XHRcdFx0XHRcdGRlcHRoVGVzdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdFx0XHRcdGZvZzogZmFsc2Vcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRib3hNZXNoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcblx0XHRcdFx0Ym94TWVzaC5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoICd1dicgKTtcblxuXHRcdFx0XHRib3hNZXNoLm9uQmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSApIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weVBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIGFkZCBcImVudk1hcFwiIG1hdGVyaWFsIHByb3BlcnR5IHNvIHRoZSByZW5kZXJlciBjYW4gZXZhbHVhdGUgaXQgbGlrZSBmb3IgYnVpbHQtaW4gbWF0ZXJpYWxzXG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggYm94TWVzaC5tYXRlcmlhbCwgJ2Vudk1hcCcsIHtcblxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy51bmlmb3Jtcy5lbnZNYXAudmFsdWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdG9iamVjdHMudXBkYXRlKCBib3hNZXNoICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2UxJDEuY29weSggc2NlbmUuYmFja2dyb3VuZFJvdGF0aW9uICk7XG5cblx0XHRcdC8vIGFjY29tbW9kYXRlIGxlZnQtaGFuZGVkIGZyYW1lXG5cdFx0XHRfZTEkMS54ICo9IC0gMTsgX2UxJDEueSAqPSAtIDE7IF9lMSQxLnogKj0gLSAxO1xuXG5cdFx0XHRpZiAoIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSAmJiBiYWNrZ3JvdW5kLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gZW52aXJvbm1lbnQgbWFwcyB3aGljaCBhcmUgbm90IGN1YmUgcmVuZGVyIHRhcmdldHMgb3IgUE1SRU1zIGZvbGxvdyBhIGRpZmZlcmVudCBjb252ZW50aW9uXG5cdFx0XHRcdF9lMSQxLnkgKj0gLSAxO1xuXHRcdFx0XHRfZTEkMS56ICo9IC0gMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IGJhY2tncm91bmQ7XG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSAmJiBiYWNrZ3JvdW5kLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgKSA/IC0gMSA6IDE7XG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRCbHVycmluZXNzLnZhbHVlID0gc2NlbmUuYmFja2dyb3VuZEJsdXJyaW5lc3M7XG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRJbnRlbnNpdHkudmFsdWUgPSBzY2VuZS5iYWNrZ3JvdW5kSW50ZW5zaXR5O1xuXHRcdFx0Ym94TWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5iYWNrZ3JvdW5kUm90YXRpb24udmFsdWUuc2V0RnJvbU1hdHJpeDQoIF9tMSQxLm1ha2VSb3RhdGlvbkZyb21FdWxlciggX2UxJDEgKSApO1xuXHRcdFx0Ym94TWVzaC5tYXRlcmlhbC50b25lTWFwcGVkID0gQ29sb3JNYW5hZ2VtZW50LmdldFRyYW5zZmVyKCBiYWNrZ3JvdW5kLmNvbG9yU3BhY2UgKSAhPT0gU1JHQlRyYW5zZmVyO1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kIHx8XG5cdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiAhPT0gYmFja2dyb3VuZC52ZXJzaW9uIHx8XG5cdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyAhPT0gcmVuZGVyZXIudG9uZU1hcHBpbmcgKSB7XG5cblx0XHRcdFx0Ym94TWVzaC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0Y3VycmVudEJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gPSBiYWNrZ3JvdW5kLnZlcnNpb247XG5cdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJveE1lc2gubGF5ZXJzLmVuYWJsZUFsbCgpO1xuXG5cdFx0XHQvLyBwdXNoIHRvIHRoZSBwcmUtc29ydGVkIG9wYXF1ZSByZW5kZXIgbGlzdFxuXHRcdFx0cmVuZGVyTGlzdC51bnNoaWZ0KCBib3hNZXNoLCBib3hNZXNoLmdlb21ldHJ5LCBib3hNZXNoLm1hdGVyaWFsLCAwLCAwLCBudWxsICk7XG5cblx0XHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRpZiAoIHBsYW5lTWVzaCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBsYW5lTWVzaCA9IG5ldyBNZXNoKFxuXHRcdFx0XHRcdG5ldyBQbGFuZUdlb21ldHJ5KCAyLCAyICksXG5cdFx0XHRcdFx0bmV3IFNoYWRlck1hdGVyaWFsKCB7XG5cdFx0XHRcdFx0XHRuYW1lOiAnQmFja2dyb3VuZE1hdGVyaWFsJyxcblx0XHRcdFx0XHRcdHVuaWZvcm1zOiBjbG9uZVVuaWZvcm1zKCBTaGFkZXJMaWIuYmFja2dyb3VuZC51bmlmb3JtcyApLFxuXHRcdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZC52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyTGliLmJhY2tncm91bmQuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRcdFx0XHRzaWRlOiBGcm9udFNpZGUsXG5cdFx0XHRcdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRmb2c6IGZhbHNlXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0cGxhbmVNZXNoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcblxuXHRcdFx0XHQvLyBhZGQgXCJtYXBcIiBtYXRlcmlhbCBwcm9wZXJ0eSBzbyB0aGUgcmVuZGVyZXIgY2FuIGV2YWx1YXRlIGl0IGxpa2UgZm9yIGJ1aWx0LWluIG1hdGVyaWFsc1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHBsYW5lTWVzaC5tYXRlcmlhbCwgJ21hcCcsIHtcblxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy51bmlmb3Jtcy50MkQudmFsdWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdG9iamVjdHMudXBkYXRlKCBwbGFuZU1lc2ggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwbGFuZU1lc2gubWF0ZXJpYWwudW5pZm9ybXMudDJELnZhbHVlID0gYmFja2dyb3VuZDtcblx0XHRcdHBsYW5lTWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5iYWNrZ3JvdW5kSW50ZW5zaXR5LnZhbHVlID0gc2NlbmUuYmFja2dyb3VuZEludGVuc2l0eTtcblx0XHRcdHBsYW5lTWVzaC5tYXRlcmlhbC50b25lTWFwcGVkID0gQ29sb3JNYW5hZ2VtZW50LmdldFRyYW5zZmVyKCBiYWNrZ3JvdW5kLmNvbG9yU3BhY2UgKSAhPT0gU1JHQlRyYW5zZmVyO1xuXG5cdFx0XHRpZiAoIGJhY2tncm91bmQubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRiYWNrZ3JvdW5kLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBsYW5lTWVzaC5tYXRlcmlhbC51bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KCBiYWNrZ3JvdW5kLm1hdHJpeCApO1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kIHx8XG5cdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiAhPT0gYmFja2dyb3VuZC52ZXJzaW9uIHx8XG5cdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyAhPT0gcmVuZGVyZXIudG9uZU1hcHBpbmcgKSB7XG5cblx0XHRcdFx0cGxhbmVNZXNoLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiA9IGJhY2tncm91bmQudmVyc2lvbjtcblx0XHRcdFx0Y3VycmVudFRvbmVtYXBwaW5nID0gcmVuZGVyZXIudG9uZU1hcHBpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0cGxhbmVNZXNoLmxheWVycy5lbmFibGVBbGwoKTtcblxuXHRcdFx0Ly8gcHVzaCB0byB0aGUgcHJlLXNvcnRlZCBvcGFxdWUgcmVuZGVyIGxpc3Rcblx0XHRcdHJlbmRlckxpc3QudW5zaGlmdCggcGxhbmVNZXNoLCBwbGFuZU1lc2guZ2VvbWV0cnksIHBsYW5lTWVzaC5tYXRlcmlhbCwgMCwgMCwgbnVsbCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRDbGVhciggY29sb3IsIGFscGhhICkge1xuXG5cdFx0Y29sb3IuZ2V0UkdCKCBfcmdiLCBnZXRVbmxpdFVuaWZvcm1Db2xvclNwYWNlKCByZW5kZXJlciApICk7XG5cblx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCBfcmdiLnIsIF9yZ2IuZywgX3JnYi5iLCBhbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICk7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cblx0XHRnZXRDbGVhckNvbG9yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBjbGVhckNvbG9yO1xuXG5cdFx0fSxcblx0XHRzZXRDbGVhckNvbG9yOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSA9IDEgKSB7XG5cblx0XHRcdGNsZWFyQ29sb3Iuc2V0KCBjb2xvciApO1xuXHRcdFx0Y2xlYXJBbHBoYSA9IGFscGhhO1xuXHRcdFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcblxuXHRcdH0sXG5cdFx0Z2V0Q2xlYXJBbHBoYTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gY2xlYXJBbHBoYTtcblxuXHRcdH0sXG5cdFx0c2V0Q2xlYXJBbHBoYTogZnVuY3Rpb24gKCBhbHBoYSApIHtcblxuXHRcdFx0Y2xlYXJBbHBoYSA9IGFscGhhO1xuXHRcdFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcblxuXHRcdH0sXG5cdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0YWRkVG9SZW5kZXJMaXN0OiBhZGRUb1JlbmRlckxpc3RcblxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMQmluZGluZ1N0YXRlcyggZ2wsIGF0dHJpYnV0ZXMgKSB7XG5cblx0Y29uc3QgbWF4VmVydGV4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XG5cblx0Y29uc3QgYmluZGluZ1N0YXRlcyA9IHt9O1xuXG5cdGNvbnN0IGRlZmF1bHRTdGF0ZSA9IGNyZWF0ZUJpbmRpbmdTdGF0ZSggbnVsbCApO1xuXHRsZXQgY3VycmVudFN0YXRlID0gZGVmYXVsdFN0YXRlO1xuXHRsZXQgZm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBzZXR1cCggb2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIGluZGV4ICkge1xuXG5cdFx0bGV0IHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZTtcblxuXHRcdGNvbnN0IHN0YXRlID0gZ2V0QmluZGluZ1N0YXRlKCBnZW9tZXRyeSwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcblxuXHRcdGlmICggY3VycmVudFN0YXRlICE9PSBzdGF0ZSApIHtcblxuXHRcdFx0Y3VycmVudFN0YXRlID0gc3RhdGU7XG5cdFx0XHRiaW5kVmVydGV4QXJyYXlPYmplY3QoIGN1cnJlbnRTdGF0ZS5vYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdHVwZGF0ZUJ1ZmZlcnMgPSBuZWVkc1VwZGF0ZSggb2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSwgaW5kZXggKTtcblxuXHRcdGlmICggdXBkYXRlQnVmZmVycyApIHNhdmVDYWNoZSggb2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSwgaW5kZXggKTtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKCBpbmRleCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdXBkYXRlQnVmZmVycyB8fCBmb3JjZVVwZGF0ZSApIHtcblxuXHRcdFx0Zm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBvYmplY3QsIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGVzLmdldCggaW5kZXggKS5idWZmZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVWZXJ0ZXhBcnJheU9iamVjdCgpIHtcblxuXHRcdHJldHVybiBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBiaW5kVmVydGV4QXJyYXlPYmplY3QoIHZhbyApIHtcblxuXHRcdHJldHVybiBnbC5iaW5kVmVydGV4QXJyYXkoIHZhbyApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkZWxldGVWZXJ0ZXhBcnJheU9iamVjdCggdmFvICkge1xuXG5cdFx0cmV0dXJuIGdsLmRlbGV0ZVZlcnRleEFycmF5KCB2YW8gKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0QmluZGluZ1N0YXRlKCBnZW9tZXRyeSwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRjb25zdCB3aXJlZnJhbWUgPSAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApO1xuXG5cdFx0bGV0IHByb2dyYW1NYXAgPSBiaW5kaW5nU3RhdGVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0aWYgKCBwcm9ncmFtTWFwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHByb2dyYW1NYXAgPSB7fTtcblx0XHRcdGJpbmRpbmdTdGF0ZXNbIGdlb21ldHJ5LmlkIF0gPSBwcm9ncmFtTWFwO1xuXG5cdFx0fVxuXG5cdFx0bGV0IHN0YXRlTWFwID0gcHJvZ3JhbU1hcFsgcHJvZ3JhbS5pZCBdO1xuXG5cdFx0aWYgKCBzdGF0ZU1hcCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzdGF0ZU1hcCA9IHt9O1xuXHRcdFx0cHJvZ3JhbU1hcFsgcHJvZ3JhbS5pZCBdID0gc3RhdGVNYXA7XG5cblx0XHR9XG5cblx0XHRsZXQgc3RhdGUgPSBzdGF0ZU1hcFsgd2lyZWZyYW1lIF07XG5cblx0XHRpZiAoIHN0YXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHN0YXRlID0gY3JlYXRlQmluZGluZ1N0YXRlKCBjcmVhdGVWZXJ0ZXhBcnJheU9iamVjdCgpICk7XG5cdFx0XHRzdGF0ZU1hcFsgd2lyZWZyYW1lIF0gPSBzdGF0ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBzdGF0ZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlQmluZGluZ1N0YXRlKCB2YW8gKSB7XG5cblx0XHRjb25zdCBuZXdBdHRyaWJ1dGVzID0gW107XG5cdFx0Y29uc3QgZW5hYmxlZEF0dHJpYnV0ZXMgPSBbXTtcblx0XHRjb25zdCBhdHRyaWJ1dGVEaXZpc29ycyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbWF4VmVydGV4QXR0cmlidXRlczsgaSArKyApIHtcblxuXHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcblx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGkgXSA9IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHQvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBvbiBub24tVkFPIHN1cHBvcnQgYnJvd3NlclxuXHRcdFx0Z2VvbWV0cnk6IG51bGwsXG5cdFx0XHRwcm9ncmFtOiBudWxsLFxuXHRcdFx0d2lyZWZyYW1lOiBmYWxzZSxcblxuXHRcdFx0bmV3QXR0cmlidXRlczogbmV3QXR0cmlidXRlcyxcblx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzOiBlbmFibGVkQXR0cmlidXRlcyxcblx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzOiBhdHRyaWJ1dGVEaXZpc29ycyxcblx0XHRcdG9iamVjdDogdmFvLFxuXHRcdFx0YXR0cmlidXRlczoge30sXG5cdFx0XHRpbmRleDogbnVsbFxuXG5cdFx0fTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gbmVlZHNVcGRhdGUoIG9iamVjdCwgZ2VvbWV0cnksIHByb2dyYW0sIGluZGV4ICkge1xuXG5cdFx0Y29uc3QgY2FjaGVkQXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHRsZXQgYXR0cmlidXRlc051bSA9IDA7XG5cblx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiA+PSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IGNhY2hlZEF0dHJpYnV0ZSA9IGNhY2hlZEF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHRcdFx0bGV0IGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBuYW1lID09PSAnaW5zdGFuY2VNYXRyaXgnICYmIG9iamVjdC5pbnN0YW5jZU1hdHJpeCApIGdlb21ldHJ5QXR0cmlidXRlID0gb2JqZWN0Lmluc3RhbmNlTWF0cml4O1xuXHRcdFx0XHRcdGlmICggbmFtZSA9PT0gJ2luc3RhbmNlQ29sb3InICYmIG9iamVjdC5pbnN0YW5jZUNvbG9yICkgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VDb2xvcjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjYWNoZWRBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdGlmICggY2FjaGVkQXR0cmlidXRlLmF0dHJpYnV0ZSAhPT0gZ2VvbWV0cnlBdHRyaWJ1dGUgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICYmIGNhY2hlZEF0dHJpYnV0ZS5kYXRhICE9PSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhICkgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0YXR0cmlidXRlc051bSArKztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBjdXJyZW50U3RhdGUuYXR0cmlidXRlc051bSAhPT0gYXR0cmlidXRlc051bSApIHJldHVybiB0cnVlO1xuXG5cdFx0aWYgKCBjdXJyZW50U3RhdGUuaW5kZXggIT09IGluZGV4ICkgcmV0dXJuIHRydWU7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNhdmVDYWNoZSggb2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSwgaW5kZXggKSB7XG5cblx0XHRjb25zdCBjYWNoZSA9IHt9O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdGxldCBhdHRyaWJ1dGVzTnVtID0gMDtcblxuXHRcdGNvbnN0IHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIHByb2dyYW1BdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uID49IDAgKSB7XG5cblx0XHRcdFx0bGV0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBuYW1lID09PSAnaW5zdGFuY2VNYXRyaXgnICYmIG9iamVjdC5pbnN0YW5jZU1hdHJpeCApIGF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZU1hdHJpeDtcblx0XHRcdFx0XHRpZiAoIG5hbWUgPT09ICdpbnN0YW5jZUNvbG9yJyAmJiBvYmplY3QuaW5zdGFuY2VDb2xvciApIGF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZUNvbG9yO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBkYXRhID0ge307XG5cdFx0XHRcdGRhdGEuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5kYXRhICkge1xuXG5cdFx0XHRcdFx0ZGF0YS5kYXRhID0gYXR0cmlidXRlLmRhdGE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhY2hlWyBuYW1lIF0gPSBkYXRhO1xuXG5cdFx0XHRcdGF0dHJpYnV0ZXNOdW0gKys7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVzID0gY2FjaGU7XG5cdFx0Y3VycmVudFN0YXRlLmF0dHJpYnV0ZXNOdW0gPSBhdHRyaWJ1dGVzTnVtO1xuXG5cdFx0Y3VycmVudFN0YXRlLmluZGV4ID0gaW5kZXg7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRBdHRyaWJ1dGVzKCkge1xuXG5cdFx0Y29uc3QgbmV3QXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5uZXdBdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdG5ld0F0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0ZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggYXR0cmlidXRlLCAwICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuXHRcdGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUubmV3QXR0cmlidXRlcztcblx0XHRjb25zdCBlbmFibGVkQXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5lbmFibGVkQXR0cmlidXRlcztcblx0XHRjb25zdCBhdHRyaWJ1dGVEaXZpc29ycyA9IGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVEaXZpc29ycztcblxuXHRcdG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xuXG5cdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XG5cdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gIT09IG1lc2hQZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApO1xuXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gbWVzaFBlckF0dHJpYnV0ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKSB7XG5cblx0XHRjb25zdCBuZXdBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLm5ld0F0dHJpYnV0ZXM7XG5cdFx0Y29uc3QgZW5hYmxlZEF0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSAhPT0gbmV3QXR0cmlidXRlc1sgaSBdICkge1xuXG5cdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xuXHRcdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB2ZXJ0ZXhBdHRyaWJQb2ludGVyKCBpbmRleCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQsIGludGVnZXIgKSB7XG5cblx0XHRpZiAoIGludGVnZXIgPT09IHRydWUgKSB7XG5cblx0XHRcdGdsLnZlcnRleEF0dHJpYklQb2ludGVyKCBpbmRleCwgc2l6ZSwgdHlwZSwgc3RyaWRlLCBvZmZzZXQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGluZGV4LCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5ICkge1xuXG5cdFx0aW5pdEF0dHJpYnV0ZXMoKTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzID0gbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gPj0gMCApIHtcblxuXHRcdFx0XHRsZXQgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG5hbWUgPT09ICdpbnN0YW5jZU1hdHJpeCcgJiYgb2JqZWN0Lmluc3RhbmNlTWF0cml4ICkgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VNYXRyaXg7XG5cdFx0XHRcdFx0aWYgKCBuYW1lID09PSAnaW5zdGFuY2VDb2xvcicgJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IgKSBnZW9tZXRyeUF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZUNvbG9yO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBub3JtYWxpemVkID0gZ2VvbWV0cnlBdHRyaWJ1dGUubm9ybWFsaXplZDtcblx0XHRcdFx0XHRjb25zdCBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldCggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdC8vIFRPRE8gQXR0cmlidXRlIG1heSBub3QgYmUgYXZhaWxhYmxlIG9uIGNvbnRleHQgcmVzdG9yZVxuXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gYXR0cmlidXRlLmJ1ZmZlcjtcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG5cdFx0XHRcdFx0Y29uc3QgYnl0ZXNQZXJFbGVtZW50ID0gYXR0cmlidXRlLmJ5dGVzUGVyRWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIGNoZWNrIGZvciBpbnRlZ2VyIGF0dHJpYnV0ZXNcblxuXHRcdFx0XHRcdGNvbnN0IGludGVnZXIgPSAoIHR5cGUgPT09IGdsLklOVCB8fCB0eXBlID09PSBnbC5VTlNJR05FRF9JTlQgfHwgZ2VvbWV0cnlBdHRyaWJ1dGUuZ3B1VHlwZSA9PT0gSW50VHlwZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcblx0XHRcdFx0XHRcdGNvbnN0IHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xuXG5cdFx0XHRcdFx0XHRpZiAoIGRhdGEuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpLCBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICE9PSB0cnVlICYmIGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuXHRcdFx0XHRcdFx0XHRcdHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpLFxuXHRcdFx0XHRcdFx0XHRcdHNpemUgLyBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZSxcblx0XHRcdFx0XHRcdFx0XHR0eXBlLFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbGl6ZWQsXG5cdFx0XHRcdFx0XHRcdFx0c3RyaWRlICogYnl0ZXNQZXJFbGVtZW50LFxuXHRcdFx0XHRcdFx0XHRcdCggb2Zmc2V0ICsgKCBzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUgKSAqIGkgKSAqIGJ5dGVzUGVyRWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRpbnRlZ2VyXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggIT09IHRydWUgJiYgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmNvdW50O1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiArIGkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmVydGV4QXR0cmliUG9pbnRlcihcblx0XHRcdFx0XHRcdFx0XHRwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSxcblx0XHRcdFx0XHRcdFx0XHRzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZSxcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxpemVkLFxuXHRcdFx0XHRcdFx0XHRcdHNpemUgKiBieXRlc1BlckVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0KCBzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUgKSAqIGkgKiBieXRlc1BlckVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0aW50ZWdlclxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCB2YWx1ZS5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRyZXNldCgpO1xuXG5cdFx0Zm9yICggY29uc3QgZ2VvbWV0cnlJZCBpbiBiaW5kaW5nU3RhdGVzICkge1xuXG5cdFx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1sgZ2VvbWV0cnlJZCBdO1xuXG5cdFx0XHRmb3IgKCBjb25zdCBwcm9ncmFtSWQgaW4gcHJvZ3JhbU1hcCApIHtcblxuXHRcdFx0XHRjb25zdCBzdGF0ZU1hcCA9IHByb2dyYW1NYXBbIHByb2dyYW1JZCBdO1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IHdpcmVmcmFtZSBpbiBzdGF0ZU1hcCApIHtcblxuXHRcdFx0XHRcdGRlbGV0ZVZlcnRleEFycmF5T2JqZWN0KCBzdGF0ZU1hcFsgd2lyZWZyYW1lIF0ub2JqZWN0ICk7XG5cblx0XHRcdFx0XHRkZWxldGUgc3RhdGVNYXBbIHdpcmVmcmFtZSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgcHJvZ3JhbU1hcFsgcHJvZ3JhbUlkIF07XG5cblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIGJpbmRpbmdTdGF0ZXNbIGdlb21ldHJ5SWQgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVsZWFzZVN0YXRlc09mR2VvbWV0cnkoIGdlb21ldHJ5ICkge1xuXG5cdFx0aWYgKCBiaW5kaW5nU3RhdGVzWyBnZW9tZXRyeS5pZCBdID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1sgZ2VvbWV0cnkuaWQgXTtcblxuXHRcdGZvciAoIGNvbnN0IHByb2dyYW1JZCBpbiBwcm9ncmFtTWFwICkge1xuXG5cdFx0XHRjb25zdCBzdGF0ZU1hcCA9IHByb2dyYW1NYXBbIHByb2dyYW1JZCBdO1xuXG5cdFx0XHRmb3IgKCBjb25zdCB3aXJlZnJhbWUgaW4gc3RhdGVNYXAgKSB7XG5cblx0XHRcdFx0ZGVsZXRlVmVydGV4QXJyYXlPYmplY3QoIHN0YXRlTWFwWyB3aXJlZnJhbWUgXS5vYmplY3QgKTtcblxuXHRcdFx0XHRkZWxldGUgc3RhdGVNYXBbIHdpcmVmcmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBwcm9ncmFtTWFwWyBwcm9ncmFtSWQgXTtcblxuXHRcdH1cblxuXHRcdGRlbGV0ZSBiaW5kaW5nU3RhdGVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWxlYXNlU3RhdGVzT2ZQcm9ncmFtKCBwcm9ncmFtICkge1xuXG5cdFx0Zm9yICggY29uc3QgZ2VvbWV0cnlJZCBpbiBiaW5kaW5nU3RhdGVzICkge1xuXG5cdFx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1sgZ2VvbWV0cnlJZCBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1NYXBbIHByb2dyYW0uaWQgXSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cblx0XHRcdGNvbnN0IHN0YXRlTWFwID0gcHJvZ3JhbU1hcFsgcHJvZ3JhbS5pZCBdO1xuXG5cdFx0XHRmb3IgKCBjb25zdCB3aXJlZnJhbWUgaW4gc3RhdGVNYXAgKSB7XG5cblx0XHRcdFx0ZGVsZXRlVmVydGV4QXJyYXlPYmplY3QoIHN0YXRlTWFwWyB3aXJlZnJhbWUgXS5vYmplY3QgKTtcblxuXHRcdFx0XHRkZWxldGUgc3RhdGVNYXBbIHdpcmVmcmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBwcm9ncmFtTWFwWyBwcm9ncmFtLmlkIF07XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0KCkge1xuXG5cdFx0cmVzZXREZWZhdWx0U3RhdGUoKTtcblx0XHRmb3JjZVVwZGF0ZSA9IHRydWU7XG5cblx0XHRpZiAoIGN1cnJlbnRTdGF0ZSA9PT0gZGVmYXVsdFN0YXRlICkgcmV0dXJuO1xuXG5cdFx0Y3VycmVudFN0YXRlID0gZGVmYXVsdFN0YXRlO1xuXHRcdGJpbmRWZXJ0ZXhBcnJheU9iamVjdCggY3VycmVudFN0YXRlLm9iamVjdCApO1xuXG5cdH1cblxuXHQvLyBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eVxuXG5cdGZ1bmN0aW9uIHJlc2V0RGVmYXVsdFN0YXRlKCkge1xuXG5cdFx0ZGVmYXVsdFN0YXRlLmdlb21ldHJ5ID0gbnVsbDtcblx0XHRkZWZhdWx0U3RhdGUucHJvZ3JhbSA9IG51bGw7XG5cdFx0ZGVmYXVsdFN0YXRlLndpcmVmcmFtZSA9IGZhbHNlO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0c2V0dXA6IHNldHVwLFxuXHRcdHJlc2V0OiByZXNldCxcblx0XHRyZXNldERlZmF1bHRTdGF0ZTogcmVzZXREZWZhdWx0U3RhdGUsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZSxcblx0XHRyZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeTogcmVsZWFzZVN0YXRlc09mR2VvbWV0cnksXG5cdFx0cmVsZWFzZVN0YXRlc09mUHJvZ3JhbTogcmVsZWFzZVN0YXRlc09mUHJvZ3JhbSxcblxuXHRcdGluaXRBdHRyaWJ1dGVzOiBpbml0QXR0cmlidXRlcyxcblx0XHRlbmFibGVBdHRyaWJ1dGU6IGVuYWJsZUF0dHJpYnV0ZSxcblx0XHRkaXNhYmxlVW51c2VkQXR0cmlidXRlczogZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXNcblxuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMQnVmZmVyUmVuZGVyZXIoIGdsLCBleHRlbnNpb25zLCBpbmZvICkge1xuXG5cdGxldCBtb2RlO1xuXG5cdGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xuXG5cdFx0bW9kZSA9IHZhbHVlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdGdsLmRyYXdBcnJheXMoIG1vZGUsIHN0YXJ0LCBjb3VudCApO1xuXG5cdFx0aW5mby51cGRhdGUoIGNvdW50LCBtb2RlLCAxICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggc3RhcnQsIGNvdW50LCBwcmltY291bnQgKSB7XG5cblx0XHRpZiAoIHByaW1jb3VudCA9PT0gMCApIHJldHVybjtcblxuXHRcdGdsLmRyYXdBcnJheXNJbnN0YW5jZWQoIG1vZGUsIHN0YXJ0LCBjb3VudCwgcHJpbWNvdW50ICk7XG5cblx0XHRpbmZvLnVwZGF0ZSggY291bnQsIG1vZGUsIHByaW1jb3VudCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJNdWx0aURyYXcoIHN0YXJ0cywgY291bnRzLCBkcmF3Q291bnQgKSB7XG5cblx0XHRpZiAoIGRyYXdDb3VudCA9PT0gMCApIHJldHVybjtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlfZHJhdycgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkcmF3Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5yZW5kZXIoIHN0YXJ0c1sgaSBdLCBjb3VudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRleHRlbnNpb24ubXVsdGlEcmF3QXJyYXlzV0VCR0woIG1vZGUsIHN0YXJ0cywgMCwgY291bnRzLCAwLCBkcmF3Q291bnQgKTtcblxuXHRcdFx0bGV0IGVsZW1lbnRDb3VudCA9IDA7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkcmF3Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0ZWxlbWVudENvdW50ICs9IGNvdW50c1sgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGluZm8udXBkYXRlKCBlbGVtZW50Q291bnQsIG1vZGUsIDEgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzKCBzdGFydHMsIGNvdW50cywgZHJhd0NvdW50LCBwcmltY291bnQgKSB7XG5cblx0XHRpZiAoIGRyYXdDb3VudCA9PT0gMCApIHJldHVybjtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlfZHJhdycgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzdGFydHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHJlbmRlckluc3RhbmNlcyggc3RhcnRzWyBpIF0sIGNvdW50c1sgaSBdLCBwcmltY291bnRbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRleHRlbnNpb24ubXVsdGlEcmF3QXJyYXlzSW5zdGFuY2VkV0VCR0woIG1vZGUsIHN0YXJ0cywgMCwgY291bnRzLCAwLCBwcmltY291bnQsIDAsIGRyYXdDb3VudCApO1xuXG5cdFx0XHRsZXQgZWxlbWVudENvdW50ID0gMDtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRyYXdDb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRlbGVtZW50Q291bnQgKz0gY291bnRzWyBpIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcHJpbWNvdW50Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRpbmZvLnVwZGF0ZSggZWxlbWVudENvdW50LCBtb2RlLCBwcmltY291bnRbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vXG5cblx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcblx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XG5cdHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xuXHR0aGlzLnJlbmRlck11bHRpRHJhdyA9IHJlbmRlck11bHRpRHJhdztcblx0dGhpcy5yZW5kZXJNdWx0aURyYXdJbnN0YW5jZXMgPSByZW5kZXJNdWx0aURyYXdJbnN0YW5jZXM7XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xDYXBhYmlsaXRpZXMoIGdsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzLCB1dGlscyApIHtcblxuXHRsZXQgbWF4QW5pc290cm9weTtcblxuXHRmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xuXG5cdFx0aWYgKCBtYXhBbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gbWF4QW5pc290cm9weTtcblxuXHRcdGlmICggZXh0ZW5zaW9ucy5oYXMoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXG5cdFx0XHRtYXhBbmlzb3Ryb3B5ID0gZ2wuZ2V0UGFyYW1ldGVyKCBleHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtYXhBbmlzb3Ryb3B5ID0gMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXhBbmlzb3Ryb3B5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiB0ZXh0dXJlRm9ybWF0UmVhZGFibGUoIHRleHR1cmVGb3JtYXQgKSB7XG5cblx0XHRpZiAoIHRleHR1cmVGb3JtYXQgIT09IFJHQkFGb3JtYXQgJiYgdXRpbHMuY29udmVydCggdGV4dHVyZUZvcm1hdCApICE9PSBnbC5nZXRQYXJhbWV0ZXIoIGdsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfRk9STUFUICkgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB0ZXh0dXJlVHlwZVJlYWRhYmxlKCB0ZXh0dXJlVHlwZSApIHtcblxuXHRcdGNvbnN0IGhhbGZGbG9hdFN1cHBvcnRlZEJ5RXh0ID0gKCB0ZXh0dXJlVHlwZSA9PT0gSGFsZkZsb2F0VHlwZSApICYmICggZXh0ZW5zaW9ucy5oYXMoICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnICkgfHwgZXh0ZW5zaW9ucy5oYXMoICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyApICk7XG5cblx0XHRpZiAoIHRleHR1cmVUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlICYmIHV0aWxzLmNvbnZlcnQoIHRleHR1cmVUeXBlICkgIT09IGdsLmdldFBhcmFtZXRlciggZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFICkgJiYgLy8gRWRnZSBhbmQgQ2hyb21lIE1hYyA8IDUyICgjOTUxMylcblx0XHRcdHRleHR1cmVUeXBlICE9PSBGbG9hdFR5cGUgJiYgISBoYWxmRmxvYXRTdXBwb3J0ZWRCeUV4dCApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldE1heFByZWNpc2lvbiggcHJlY2lzaW9uICkge1xuXG5cdFx0aWYgKCBwcmVjaXNpb24gPT09ICdoaWdocCcgKSB7XG5cblx0XHRcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxuXHRcdFx0XHRnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuICdoaWdocCc7XG5cblx0XHRcdH1cblxuXHRcdFx0cHJlY2lzaW9uID0gJ21lZGl1bXAnO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwcmVjaXNpb24gPT09ICdtZWRpdW1wJyApIHtcblxuXHRcdFx0aWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcblx0XHRcdFx0Z2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuICdtZWRpdW1wJztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuICdsb3dwJztcblxuXHR9XG5cblx0bGV0IHByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCc7XG5cdGNvbnN0IG1heFByZWNpc2lvbiA9IGdldE1heFByZWNpc2lvbiggcHJlY2lzaW9uICk7XG5cblx0aWYgKCBtYXhQcmVjaXNpb24gIT09IHByZWNpc2lvbiApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6JywgcHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBtYXhQcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcblx0XHRwcmVjaXNpb24gPSBtYXhQcmVjaXNpb247XG5cblx0fVxuXG5cdGNvbnN0IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPT09IHRydWU7XG5cblx0Y29uc3QgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cdGNvbnN0IG1heFZlcnRleFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblx0Y29uc3QgbWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX1NJWkUgKTtcblx0Y29uc3QgbWF4Q3ViZW1hcFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcblxuXHRjb25zdCBtYXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX0FUVFJJQlMgKTtcblx0Y29uc3QgbWF4VmVydGV4VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICk7XG5cdGNvbnN0IG1heFZhcnlpbmdzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkFSWUlOR19WRUNUT1JTICk7XG5cdGNvbnN0IG1heEZyYWdtZW50VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMgKTtcblxuXHRjb25zdCB2ZXJ0ZXhUZXh0dXJlcyA9IG1heFZlcnRleFRleHR1cmVzID4gMDtcblxuXHRjb25zdCBtYXhTYW1wbGVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfU0FNUExFUyApO1xuXG5cdHJldHVybiB7XG5cblx0XHRpc1dlYkdMMjogdHJ1ZSwgLy8ga2VlcGluZyB0aGlzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5cdFx0Z2V0TWF4QW5pc290cm9weTogZ2V0TWF4QW5pc290cm9weSxcblx0XHRnZXRNYXhQcmVjaXNpb246IGdldE1heFByZWNpc2lvbixcblxuXHRcdHRleHR1cmVGb3JtYXRSZWFkYWJsZTogdGV4dHVyZUZvcm1hdFJlYWRhYmxlLFxuXHRcdHRleHR1cmVUeXBlUmVhZGFibGU6IHRleHR1cmVUeXBlUmVhZGFibGUsXG5cblx0XHRwcmVjaXNpb246IHByZWNpc2lvbixcblx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBsb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuXG5cdFx0bWF4VGV4dHVyZXM6IG1heFRleHR1cmVzLFxuXHRcdG1heFZlcnRleFRleHR1cmVzOiBtYXhWZXJ0ZXhUZXh0dXJlcyxcblx0XHRtYXhUZXh0dXJlU2l6ZTogbWF4VGV4dHVyZVNpemUsXG5cdFx0bWF4Q3ViZW1hcFNpemU6IG1heEN1YmVtYXBTaXplLFxuXG5cdFx0bWF4QXR0cmlidXRlczogbWF4QXR0cmlidXRlcyxcblx0XHRtYXhWZXJ0ZXhVbmlmb3JtczogbWF4VmVydGV4VW5pZm9ybXMsXG5cdFx0bWF4VmFyeWluZ3M6IG1heFZhcnlpbmdzLFxuXHRcdG1heEZyYWdtZW50VW5pZm9ybXM6IG1heEZyYWdtZW50VW5pZm9ybXMsXG5cblx0XHR2ZXJ0ZXhUZXh0dXJlczogdmVydGV4VGV4dHVyZXMsXG5cblx0XHRtYXhTYW1wbGVzOiBtYXhTYW1wbGVzXG5cblx0fTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTENsaXBwaW5nKCBwcm9wZXJ0aWVzICkge1xuXG5cdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRsZXQgZ2xvYmFsU3RhdGUgPSBudWxsLFxuXHRcdG51bUdsb2JhbFBsYW5lcyA9IDAsXG5cdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcblx0XHRyZW5kZXJpbmdTaGFkb3dzID0gZmFsc2U7XG5cblx0Y29uc3QgcGxhbmUgPSBuZXcgUGxhbmUoKSxcblx0XHR2aWV3Tm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKSxcblxuXHRcdHVuaWZvcm0gPSB7IHZhbHVlOiBudWxsLCBuZWVkc1VwZGF0ZTogZmFsc2UgfTtcblxuXHR0aGlzLnVuaWZvcm0gPSB1bmlmb3JtO1xuXHR0aGlzLm51bVBsYW5lcyA9IDA7XG5cdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gMDtcblxuXHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoIHBsYW5lcywgZW5hYmxlTG9jYWxDbGlwcGluZyApIHtcblxuXHRcdGNvbnN0IGVuYWJsZWQgPVxuXHRcdFx0cGxhbmVzLmxlbmd0aCAhPT0gMCB8fFxuXHRcdFx0ZW5hYmxlTG9jYWxDbGlwcGluZyB8fFxuXHRcdFx0Ly8gZW5hYmxlIHN0YXRlIG9mIHByZXZpb3VzIGZyYW1lIC0gdGhlIGNsaXBwaW5nIGNvZGUgaGFzIHRvXG5cdFx0XHQvLyBydW4gYW5vdGhlciBmcmFtZSBpbiBvcmRlciB0byByZXNldCB0aGUgc3RhdGU6XG5cdFx0XHRudW1HbG9iYWxQbGFuZXMgIT09IDAgfHxcblx0XHRcdGxvY2FsQ2xpcHBpbmdFbmFibGVkO1xuXG5cdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBlbmFibGVMb2NhbENsaXBwaW5nO1xuXG5cdFx0bnVtR2xvYmFsUGxhbmVzID0gcGxhbmVzLmxlbmd0aDtcblxuXHRcdHJldHVybiBlbmFibGVkO1xuXG5cdH07XG5cblx0dGhpcy5iZWdpblNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZW5kZXJpbmdTaGFkb3dzID0gdHJ1ZTtcblx0XHRwcm9qZWN0UGxhbmVzKCBudWxsICk7XG5cblx0fTtcblxuXHR0aGlzLmVuZFNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZW5kZXJpbmdTaGFkb3dzID0gZmFsc2U7XG5cblx0fTtcblxuXHR0aGlzLnNldEdsb2JhbFN0YXRlID0gZnVuY3Rpb24gKCBwbGFuZXMsIGNhbWVyYSApIHtcblxuXHRcdGdsb2JhbFN0YXRlID0gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIDAgKTtcblxuXHR9O1xuXG5cdHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBjYW1lcmEsIHVzZUNhY2hlICkge1xuXG5cdFx0Y29uc3QgcGxhbmVzID0gbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMsXG5cdFx0XHRjbGlwSW50ZXJzZWN0aW9uID0gbWF0ZXJpYWwuY2xpcEludGVyc2VjdGlvbixcblx0XHRcdGNsaXBTaGFkb3dzID0gbWF0ZXJpYWwuY2xpcFNoYWRvd3M7XG5cblx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblxuXHRcdGlmICggISBsb2NhbENsaXBwaW5nRW5hYmxlZCB8fCBwbGFuZXMgPT09IG51bGwgfHwgcGxhbmVzLmxlbmd0aCA9PT0gMCB8fCByZW5kZXJpbmdTaGFkb3dzICYmICEgY2xpcFNoYWRvd3MgKSB7XG5cblx0XHRcdC8vIHRoZXJlJ3Mgbm8gbG9jYWwgY2xpcHBpbmdcblxuXHRcdFx0aWYgKCByZW5kZXJpbmdTaGFkb3dzICkge1xuXG5cdFx0XHRcdC8vIHRoZXJlJ3Mgbm8gZ2xvYmFsIGNsaXBwaW5nXG5cblx0XHRcdFx0cHJvamVjdFBsYW5lcyggbnVsbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlc2V0R2xvYmFsU3RhdGUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3Qgbkdsb2JhbCA9IHJlbmRlcmluZ1NoYWRvd3MgPyAwIDogbnVtR2xvYmFsUGxhbmVzLFxuXHRcdFx0XHRsR2xvYmFsID0gbkdsb2JhbCAqIDQ7XG5cblx0XHRcdGxldCBkc3RBcnJheSA9IG1hdGVyaWFsUHJvcGVydGllcy5jbGlwcGluZ1N0YXRlIHx8IG51bGw7XG5cblx0XHRcdHVuaWZvcm0udmFsdWUgPSBkc3RBcnJheTsgLy8gZW5zdXJlIHVuaXF1ZSBzdGF0ZVxuXG5cdFx0XHRkc3RBcnJheSA9IHByb2plY3RQbGFuZXMoIHBsYW5lcywgY2FtZXJhLCBsR2xvYmFsLCB1c2VDYWNoZSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IGxHbG9iYWw7ICsrIGkgKSB7XG5cblx0XHRcdFx0ZHN0QXJyYXlbIGkgXSA9IGdsb2JhbFN0YXRlWyBpIF07XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmNsaXBwaW5nU3RhdGUgPSBkc3RBcnJheTtcblx0XHRcdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gY2xpcEludGVyc2VjdGlvbiA/IHRoaXMubnVtUGxhbmVzIDogMDtcblx0XHRcdHRoaXMubnVtUGxhbmVzICs9IG5HbG9iYWw7XG5cblx0XHR9XG5cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlc2V0R2xvYmFsU3RhdGUoKSB7XG5cblx0XHRpZiAoIHVuaWZvcm0udmFsdWUgIT09IGdsb2JhbFN0YXRlICkge1xuXG5cdFx0XHR1bmlmb3JtLnZhbHVlID0gZ2xvYmFsU3RhdGU7XG5cdFx0XHR1bmlmb3JtLm5lZWRzVXBkYXRlID0gbnVtR2xvYmFsUGxhbmVzID4gMDtcblxuXHRcdH1cblxuXHRcdHNjb3BlLm51bVBsYW5lcyA9IG51bUdsb2JhbFBsYW5lcztcblx0XHRzY29wZS5udW1JbnRlcnNlY3Rpb24gPSAwO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgZHN0T2Zmc2V0LCBza2lwVHJhbnNmb3JtICkge1xuXG5cdFx0Y29uc3QgblBsYW5lcyA9IHBsYW5lcyAhPT0gbnVsbCA/IHBsYW5lcy5sZW5ndGggOiAwO1xuXHRcdGxldCBkc3RBcnJheSA9IG51bGw7XG5cblx0XHRpZiAoIG5QbGFuZXMgIT09IDAgKSB7XG5cblx0XHRcdGRzdEFycmF5ID0gdW5pZm9ybS52YWx1ZTtcblxuXHRcdFx0aWYgKCBza2lwVHJhbnNmb3JtICE9PSB0cnVlIHx8IGRzdEFycmF5ID09PSBudWxsICkge1xuXG5cdFx0XHRcdGNvbnN0IGZsYXRTaXplID0gZHN0T2Zmc2V0ICsgblBsYW5lcyAqIDQsXG5cdFx0XHRcdFx0dmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XG5cblx0XHRcdFx0dmlld05vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHRpZiAoIGRzdEFycmF5ID09PSBudWxsIHx8IGRzdEFycmF5Lmxlbmd0aCA8IGZsYXRTaXplICkge1xuXG5cdFx0XHRcdFx0ZHN0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBmbGF0U2l6ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGk0ID0gZHN0T2Zmc2V0OyBpICE9PSBuUGxhbmVzOyArKyBpLCBpNCArPSA0ICkge1xuXG5cdFx0XHRcdFx0cGxhbmUuY29weSggcGxhbmVzWyBpIF0gKS5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXgsIHZpZXdOb3JtYWxNYXRyaXggKTtcblxuXHRcdFx0XHRcdHBsYW5lLm5vcm1hbC50b0FycmF5KCBkc3RBcnJheSwgaTQgKTtcblx0XHRcdFx0XHRkc3RBcnJheVsgaTQgKyAzIF0gPSBwbGFuZS5jb25zdGFudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dW5pZm9ybS52YWx1ZSA9IGRzdEFycmF5O1xuXHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRzY29wZS5udW1QbGFuZXMgPSBuUGxhbmVzO1xuXHRcdHNjb3BlLm51bUludGVyc2VjdGlvbiA9IDA7XG5cblx0XHRyZXR1cm4gZHN0QXJyYXk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIFdlYkdMQ3ViZU1hcHMoIHJlbmRlcmVyICkge1xuXG5cdGxldCBjdWJlbWFwcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0ZnVuY3Rpb24gbWFwVGV4dHVyZU1hcHBpbmcoIHRleHR1cmUsIG1hcHBpbmcgKSB7XG5cblx0XHRpZiAoIG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nICkge1xuXG5cdFx0XHR0ZXh0dXJlLm1hcHBpbmcgPSBDdWJlUmVmbGVjdGlvbk1hcHBpbmc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyApIHtcblxuXHRcdFx0dGV4dHVyZS5tYXBwaW5nID0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldCggdGV4dHVyZSApIHtcblxuXHRcdGlmICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0Y29uc3QgbWFwcGluZyA9IHRleHR1cmUubWFwcGluZztcblxuXHRcdFx0aWYgKCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyB8fCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyApIHtcblxuXHRcdFx0XHRpZiAoIGN1YmVtYXBzLmhhcyggdGV4dHVyZSApICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgY3ViZW1hcCA9IGN1YmVtYXBzLmdldCggdGV4dHVyZSApLnRleHR1cmU7XG5cdFx0XHRcdFx0cmV0dXJuIG1hcFRleHR1cmVNYXBwaW5nKCBjdWJlbWFwLCB0ZXh0dXJlLm1hcHBpbmcgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc3QgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG5cdFx0XHRcdFx0aWYgKCBpbWFnZSAmJiBpbWFnZS5oZWlnaHQgPiAwICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KCBpbWFnZS5oZWlnaHQgKTtcblx0XHRcdFx0XHRcdHJlbmRlclRhcmdldC5mcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZSggcmVuZGVyZXIsIHRleHR1cmUgKTtcblx0XHRcdFx0XHRcdGN1YmVtYXBzLnNldCggdGV4dHVyZSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiBtYXBUZXh0dXJlTWFwcGluZyggcmVuZGVyVGFyZ2V0LnRleHR1cmUsIHRleHR1cmUubWFwcGluZyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gaW1hZ2Ugbm90IHlldCByZWFkeS4gdHJ5IHRoZSBjb252ZXJzaW9uIG5leHQgZnJhbWVcblxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25UZXh0dXJlRGlzcG9zZSggZXZlbnQgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuXHRcdGNvbnN0IGN1YmVtYXAgPSBjdWJlbWFwcy5nZXQoIHRleHR1cmUgKTtcblxuXHRcdGlmICggY3ViZW1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjdWJlbWFwcy5kZWxldGUoIHRleHR1cmUgKTtcblx0XHRcdGN1YmVtYXAuZGlzcG9zZSgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBkaXNwb3NlKCkge1xuXG5cdFx0Y3ViZW1hcHMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGdldDogZ2V0LFxuXHRcdGRpc3Bvc2U6IGRpc3Bvc2Vcblx0fTtcblxufVxuXG5jbGFzcyBPcnRob2dyYXBoaWNDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xuXG5cdGNvbnN0cnVjdG9yKCBsZWZ0ID0gLSAxLCByaWdodCA9IDEsIHRvcCA9IDEsIGJvdHRvbSA9IC0gMSwgbmVhciA9IDAuMSwgZmFyID0gMjAwMCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzT3J0aG9ncmFwaGljQ2FtZXJhID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xuXG5cdFx0dGhpcy56b29tID0gMTtcblx0XHR0aGlzLnZpZXcgPSBudWxsO1xuXG5cdFx0dGhpcy5sZWZ0ID0gbGVmdDtcblx0XHR0aGlzLnJpZ2h0ID0gcmlnaHQ7XG5cdFx0dGhpcy50b3AgPSB0b3A7XG5cdFx0dGhpcy5ib3R0b20gPSBib3R0b207XG5cblx0XHR0aGlzLm5lYXIgPSBuZWFyO1xuXHRcdHRoaXMuZmFyID0gZmFyO1xuXG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMubGVmdCA9IHNvdXJjZS5sZWZ0O1xuXHRcdHRoaXMucmlnaHQgPSBzb3VyY2UucmlnaHQ7XG5cdFx0dGhpcy50b3AgPSBzb3VyY2UudG9wO1xuXHRcdHRoaXMuYm90dG9tID0gc291cmNlLmJvdHRvbTtcblx0XHR0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcblx0XHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG5cblx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblx0XHR0aGlzLnZpZXcgPSBzb3VyY2UudmlldyA9PT0gbnVsbCA/IG51bGwgOiBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnZpZXcgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRpZiAoIHRoaXMudmlldyA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy52aWV3ID0ge1xuXHRcdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0XHRmdWxsV2lkdGg6IDEsXG5cdFx0XHRcdGZ1bGxIZWlnaHQ6IDEsXG5cdFx0XHRcdG9mZnNldFg6IDAsXG5cdFx0XHRcdG9mZnNldFk6IDAsXG5cdFx0XHRcdHdpZHRoOiAxLFxuXHRcdFx0XHRoZWlnaHQ6IDFcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy52aWV3LmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblx0XHR0aGlzLnZpZXcuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XG5cdFx0dGhpcy52aWV3Lm9mZnNldFggPSB4O1xuXHRcdHRoaXMudmlldy5vZmZzZXRZID0geTtcblx0XHR0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0fVxuXG5cdGNsZWFyVmlld09mZnNldCgpIHtcblxuXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0fVxuXG5cdHVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKSB7XG5cblx0XHRjb25zdCBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XG5cdFx0Y29uc3QgZHkgPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvICggMiAqIHRoaXMuem9vbSApO1xuXHRcdGNvbnN0IGN4ID0gKCB0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0ICkgLyAyO1xuXHRcdGNvbnN0IGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xuXG5cdFx0bGV0IGxlZnQgPSBjeCAtIGR4O1xuXHRcdGxldCByaWdodCA9IGN4ICsgZHg7XG5cdFx0bGV0IHRvcCA9IGN5ICsgZHk7XG5cdFx0bGV0IGJvdHRvbSA9IGN5IC0gZHk7XG5cblx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCAmJiB0aGlzLnZpZXcuZW5hYmxlZCApIHtcblxuXHRcdFx0Y29uc3Qgc2NhbGVXID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyB0aGlzLnZpZXcuZnVsbFdpZHRoIC8gdGhpcy56b29tO1xuXHRcdFx0Y29uc3Qgc2NhbGVIID0gKCB0aGlzLnRvcCAtIHRoaXMuYm90dG9tICkgLyB0aGlzLnZpZXcuZnVsbEhlaWdodCAvIHRoaXMuem9vbTtcblxuXHRcdFx0bGVmdCArPSBzY2FsZVcgKiB0aGlzLnZpZXcub2Zmc2V0WDtcblx0XHRcdHJpZ2h0ID0gbGVmdCArIHNjYWxlVyAqIHRoaXMudmlldy53aWR0aDtcblx0XHRcdHRvcCAtPSBzY2FsZUggKiB0aGlzLnZpZXcub2Zmc2V0WTtcblx0XHRcdGJvdHRvbSA9IHRvcCAtIHNjYWxlSCAqIHRoaXMudmlldy5oZWlnaHQ7XG5cblx0XHR9XG5cblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCB0aGlzLm5lYXIsIHRoaXMuZmFyLCB0aGlzLmNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSggdGhpcy5wcm9qZWN0aW9uTWF0cml4ICkuaW52ZXJ0KCk7XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcblxuXHRcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG5cdFx0ZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcblx0XHRkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XG5cdFx0ZGF0YS5vYmplY3QudG9wID0gdGhpcy50b3A7XG5cdFx0ZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XG5cdFx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcblx0XHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcblxuXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkgZGF0YS5vYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCB0aGlzLnZpZXcgKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5jb25zdCBMT0RfTUlOID0gNDtcblxuLy8gVGhlIHN0YW5kYXJkIGRldmlhdGlvbnMgKHJhZGlhbnMpIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXh0cmEgbWlwcy4gVGhlc2UgYXJlXG4vLyBjaG9zZW4gdG8gYXBwcm94aW1hdGUgYSBUcm93YnJpZGdlLVJlaXR6IGRpc3RyaWJ1dGlvbiBmdW5jdGlvbiB0aW1lcyB0aGVcbi8vIGdlb21ldHJpYyBzaGFkb3dpbmcgZnVuY3Rpb24uIFRoZXNlIHNpZ21hIHZhbHVlcyBzcXVhcmVkIG11c3QgbWF0Y2ggdGhlXG4vLyB2YXJpYW5jZSAjZGVmaW5lcyBpbiBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQuZ2xzbC5qcy5cbmNvbnN0IEVYVFJBX0xPRF9TSUdNQSA9IFsgMC4xMjUsIDAuMjE1LCAwLjM1LCAwLjQ0NiwgMC41MjYsIDAuNTgyIF07XG5cbi8vIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgYmx1ciBmb3IgbG9vcC4gU21hbGxlciBzaWdtYXMgd2lsbCB1c2UgZmV3ZXJcbi8vIHNhbXBsZXMgYW5kIGV4aXQgZWFybHksIGJ1dCBub3QgcmVjb21waWxlIHRoZSBzaGFkZXIuXG5jb25zdCBNQVhfU0FNUExFUyA9IDIwO1xuXG5jb25zdCBfZmxhdENhbWVyYSA9IC8qQF9fUFVSRV9fKi8gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSgpO1xuY29uc3QgX2NsZWFyQ29sb3IgPSAvKkBfX1BVUkVfXyovIG5ldyBDb2xvcigpO1xubGV0IF9vbGRUYXJnZXQgPSBudWxsO1xubGV0IF9vbGRBY3RpdmVDdWJlRmFjZSA9IDA7XG5sZXQgX29sZEFjdGl2ZU1pcG1hcExldmVsID0gMDtcbmxldCBfb2xkWHJFbmFibGVkID0gZmFsc2U7XG5cbi8vIEdvbGRlbiBSYXRpb1xuY29uc3QgUEhJID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5jb25zdCBJTlZfUEhJID0gMSAvIFBISTtcblxuLy8gVmVydGljZXMgb2YgYSBkb2RlY2FoZWRyb24gKGV4Y2VwdCB0aGUgb3Bwb3NpdGVzLCB3aGljaCByZXByZXNlbnQgdGhlXG4vLyBzYW1lIGF4aXMpLCB1c2VkIGFzIGF4aXMgZGlyZWN0aW9ucyBldmVubHkgc3ByZWFkIG9uIGEgc3BoZXJlLlxuY29uc3QgX2F4aXNEaXJlY3Rpb25zID0gW1xuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAtIFBISSwgSU5WX1BISSwgMCApLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCBQSEksIElOVl9QSEksIDAgKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggLSBJTlZfUEhJLCAwLCBQSEkgKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggSU5WX1BISSwgMCwgUEhJICksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIFBISSwgLSBJTlZfUEhJICksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIFBISSwgSU5WX1BISSApLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAtIDEsIDEsIC0gMSApLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAxLCAxLCAtIDEgKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggLSAxLCAxLCAxICksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKSBdO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIGEgUHJlZmlsdGVyZWQsIE1pcG1hcHBlZCBSYWRpYW5jZSBFbnZpcm9ubWVudCBNYXBcbiAqIChQTVJFTSkgZnJvbSBhIGN1YmVNYXAgZW52aXJvbm1lbnQgdGV4dHVyZS4gVGhpcyBhbGxvd3MgZGlmZmVyZW50IGxldmVscyBvZlxuICogYmx1ciB0byBiZSBxdWlja2x5IGFjY2Vzc2VkIGJhc2VkIG9uIG1hdGVyaWFsIHJvdWdobmVzcy4gSXQgaXMgcGFja2VkIGludG8gYVxuICogc3BlY2lhbCBDdWJlVVYgZm9ybWF0IHRoYXQgYWxsb3dzIHVzIHRvIHBlcmZvcm0gY3VzdG9tIGludGVycG9sYXRpb24gc28gdGhhdFxuICogd2UgY2FuIHN1cHBvcnQgbm9ubGluZWFyIGZvcm1hdHMgc3VjaCBhcyBSR0JFLiBVbmxpa2UgYSB0cmFkaXRpb25hbCBtaXBtYXBcbiAqIGNoYWluLCBpdCBvbmx5IGdvZXMgZG93biB0byB0aGUgTE9EX01JTiBsZXZlbCAoYWJvdmUpLCBhbmQgdGhlbiBjcmVhdGVzIGV4dHJhXG4gKiBldmVuIG1vcmUgZmlsdGVyZWQgJ21pcHMnIGF0IHRoZSBzYW1lIExPRF9NSU4gcmVzb2x1dGlvbiwgYXNzb2NpYXRlZCB3aXRoXG4gKiBoaWdoZXIgcm91Z2huZXNzIGxldmVscy4gSW4gdGhpcyB3YXkgd2UgbWFpbnRhaW4gcmVzb2x1dGlvbiB0byBzbW9vdGhseVxuICogaW50ZXJwb2xhdGUgZGlmZnVzZSBsaWdodGluZyB3aGlsZSBsaW1pdGluZyBzYW1wbGluZyBjb21wdXRhdGlvbi5cbiAqXG4gKiBQYXBlcjogRmFzdCwgQWNjdXJhdGUgSW1hZ2UtQmFzZWQgTGlnaHRpbmdcbiAqIGh0dHBzOi8vZHJpdmUuZ29vZ2xlLmNvbS9maWxlL2QvMTV5OHJfVXBLbFU5U3ZWNElMYjBDM3FDUGVjUzhwdkx6L3ZpZXdcbiovXG5cbmNsYXNzIFBNUkVNR2VuZXJhdG9yIHtcblxuXHRjb25zdHJ1Y3RvciggcmVuZGVyZXIgKSB7XG5cblx0XHR0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2xvZE1heCA9IDA7XG5cdFx0dGhpcy5fY3ViZVNpemUgPSAwO1xuXHRcdHRoaXMuX2xvZFBsYW5lcyA9IFtdO1xuXHRcdHRoaXMuX3NpemVMb2RzID0gW107XG5cdFx0dGhpcy5fc2lnbWFzID0gW107XG5cblx0XHR0aGlzLl9ibHVyTWF0ZXJpYWwgPSBudWxsO1xuXHRcdHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IG51bGw7XG5cdFx0dGhpcy5fZXF1aXJlY3RNYXRlcmlhbCA9IG51bGw7XG5cblx0XHR0aGlzLl9jb21waWxlTWF0ZXJpYWwoIHRoaXMuX2JsdXJNYXRlcmlhbCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgUE1SRU0gZnJvbSBhIHN1cHBsaWVkIFNjZW5lLCB3aGljaCBjYW4gYmUgZmFzdGVyIHRoYW4gdXNpbmcgYW5cblx0ICogaW1hZ2UgaWYgbmV0d29ya2luZyBiYW5kd2lkdGggaXMgbG93LiBPcHRpb25hbCBzaWdtYSBzcGVjaWZpZXMgYSBibHVyIHJhZGl1c1xuXHQgKiBpbiByYWRpYW5zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNjZW5lIGJlZm9yZSBQTVJFTSBnZW5lcmF0aW9uLiBPcHRpb25hbCBuZWFyXG5cdCAqIGFuZCBmYXIgcGxhbmVzIGVuc3VyZSB0aGUgc2NlbmUgaXMgcmVuZGVyZWQgaW4gaXRzIGVudGlyZXR5ICh0aGUgY3ViZUNhbWVyYVxuXHQgKiBpcyBwbGFjZWQgYXQgdGhlIG9yaWdpbikuXG5cdCAqL1xuXHRmcm9tU2NlbmUoIHNjZW5lLCBzaWdtYSA9IDAsIG5lYXIgPSAwLjEsIGZhciA9IDEwMCApIHtcblxuXHRcdF9vbGRUYXJnZXQgPSB0aGlzLl9yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRfb2xkQWN0aXZlQ3ViZUZhY2UgPSB0aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVDdWJlRmFjZSgpO1xuXHRcdF9vbGRBY3RpdmVNaXBtYXBMZXZlbCA9IHRoaXMuX3JlbmRlcmVyLmdldEFjdGl2ZU1pcG1hcExldmVsKCk7XG5cdFx0X29sZFhyRW5hYmxlZCA9IHRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQ7XG5cblx0XHR0aGlzLl9yZW5kZXJlci54ci5lbmFibGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLl9zZXRTaXplKCAyNTYgKTtcblxuXHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO1xuXHRcdGN1YmVVVlJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XG5cblx0XHR0aGlzLl9zY2VuZVRvQ3ViZVVWKCBzY2VuZSwgbmVhciwgZmFyLCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblxuXHRcdGlmICggc2lnbWEgPiAwICkge1xuXG5cdFx0XHR0aGlzLl9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIHNpZ21hICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9hcHBseVBNUkVNKCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblx0XHR0aGlzLl9jbGVhbnVwKCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGVxdWlyZWN0YW5ndWxhciB0ZXh0dXJlLCB3aGljaCBjYW4gYmUgZWl0aGVyIExEUlxuXHQgKiBvciBIRFIuIFRoZSBpZGVhbCBpbnB1dCBpbWFnZSBzaXplIGlzIDFrICgxMDI0IHggNTEyKSxcblx0ICogYXMgdGhpcyBtYXRjaGVzIGJlc3Qgd2l0aCB0aGUgMjU2IHggMjU2IGN1YmVtYXAgb3V0cHV0LlxuXHQgKiBUaGUgc21hbGxlc3Qgc3VwcG9ydGVkIGVxdWlyZWN0YW5ndWxhciBpbWFnZSBzaXplIGlzIDY0IHggMzIuXG5cdCAqL1xuXHRmcm9tRXF1aXJlY3Rhbmd1bGFyKCBlcXVpcmVjdGFuZ3VsYXIsIHJlbmRlclRhcmdldCA9IG51bGwgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoIGVxdWlyZWN0YW5ndWxhciwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGN1YmVtYXAgdGV4dHVyZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBMRFJcblx0ICogb3IgSERSLiBUaGUgaWRlYWwgaW5wdXQgY3ViZSBzaXplIGlzIDI1NiB4IDI1Nixcblx0ICogYXMgdGhpcyBtYXRjaGVzIGJlc3Qgd2l0aCB0aGUgMjU2IHggMjU2IGN1YmVtYXAgb3V0cHV0LlxuXHQgKiBUaGUgc21hbGxlc3Qgc3VwcG9ydGVkIGN1YmUgc2l6ZSBpcyAxNiB4IDE2LlxuXHQgKi9cblx0ZnJvbUN1YmVtYXAoIGN1YmVtYXAsIHJlbmRlclRhcmdldCA9IG51bGwgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoIGN1YmVtYXAsIHJlbmRlclRhcmdldCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJlLWNvbXBpbGVzIHRoZSBjdWJlbWFwIHNoYWRlci4gWW91IGNhbiBnZXQgZmFzdGVyIHN0YXJ0LXVwIGJ5IGludm9raW5nIHRoaXMgbWV0aG9kIGR1cmluZ1xuXHQgKiB5b3VyIHRleHR1cmUncyBuZXR3b3JrIGZldGNoIGZvciBpbmNyZWFzZWQgY29uY3VycmVuY3kuXG5cdCAqL1xuXHRjb21waWxlQ3ViZW1hcFNoYWRlcigpIHtcblxuXHRcdGlmICggdGhpcy5fY3ViZW1hcE1hdGVyaWFsID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgPSBfZ2V0Q3ViZW1hcE1hdGVyaWFsKCk7XG5cdFx0XHR0aGlzLl9jb21waWxlTWF0ZXJpYWwoIHRoaXMuX2N1YmVtYXBNYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUHJlLWNvbXBpbGVzIHRoZSBlcXVpcmVjdGFuZ3VsYXIgc2hhZGVyLiBZb3UgY2FuIGdldCBmYXN0ZXIgc3RhcnQtdXAgYnkgaW52b2tpbmcgdGhpcyBtZXRob2QgZHVyaW5nXG5cdCAqIHlvdXIgdGV4dHVyZSdzIG5ldHdvcmsgZmV0Y2ggZm9yIGluY3JlYXNlZCBjb25jdXJyZW5jeS5cblx0ICovXG5cdGNvbXBpbGVFcXVpcmVjdGFuZ3VsYXJTaGFkZXIoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBfZ2V0RXF1aXJlY3RNYXRlcmlhbCgpO1xuXHRcdFx0dGhpcy5fY29tcGlsZU1hdGVyaWFsKCB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwb3NlcyBvZiB0aGUgUE1SRU1HZW5lcmF0b3IncyBpbnRlcm5hbCBtZW1vcnkuIE5vdGUgdGhhdCBQTVJFTUdlbmVyYXRvciBpcyBhIHN0YXRpYyBjbGFzcyxcblx0ICogc28geW91IHNob3VsZCBub3QgbmVlZCBtb3JlIHRoYW4gb25lIFBNUkVNR2VuZXJhdG9yIG9iamVjdC4gSWYgeW91IGRvLCBjYWxsaW5nIGRpc3Bvc2UoKSBvblxuXHQgKiBvbmUgb2YgdGhlbSB3aWxsIGNhdXNlIGFueSBvdGhlcnMgdG8gYWxzbyBiZWNvbWUgdW51c2FibGUuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xuXG5cdFx0aWYgKCB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdGlmICggdGhpcy5fZXF1aXJlY3RNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHQvLyBwcml2YXRlIGludGVyZmFjZVxuXG5cdF9zZXRTaXplKCBjdWJlU2l6ZSApIHtcblxuXHRcdHRoaXMuX2xvZE1heCA9IE1hdGguZmxvb3IoIE1hdGgubG9nMiggY3ViZVNpemUgKSApO1xuXHRcdHRoaXMuX2N1YmVTaXplID0gTWF0aC5wb3coIDIsIHRoaXMuX2xvZE1heCApO1xuXG5cdH1cblxuXHRfZGlzcG9zZSgpIHtcblxuXHRcdGlmICggdGhpcy5fYmx1ck1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5fYmx1ck1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHRcdGlmICggdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgIT09IG51bGwgKSB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC5kaXNwb3NlKCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLl9sb2RQbGFuZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLl9sb2RQbGFuZXNbIGkgXS5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9jbGVhbnVwKCBvdXRwdXRUYXJnZXQgKSB7XG5cblx0XHR0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIF9vbGRUYXJnZXQsIF9vbGRBY3RpdmVDdWJlRmFjZSwgX29sZEFjdGl2ZU1pcG1hcExldmVsICk7XG5cdFx0dGhpcy5fcmVuZGVyZXIueHIuZW5hYmxlZCA9IF9vbGRYckVuYWJsZWQ7XG5cblx0XHRvdXRwdXRUYXJnZXQuc2Npc3NvclRlc3QgPSBmYWxzZTtcblx0XHRfc2V0Vmlld3BvcnQoIG91dHB1dFRhcmdldCwgMCwgMCwgb3V0cHV0VGFyZ2V0LndpZHRoLCBvdXRwdXRUYXJnZXQuaGVpZ2h0ICk7XG5cblx0fVxuXG5cdF9mcm9tVGV4dHVyZSggdGV4dHVyZSwgcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZsZWN0aW9uTWFwcGluZyB8fCB0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZyYWN0aW9uTWFwcGluZyApIHtcblxuXHRcdFx0dGhpcy5fc2V0U2l6ZSggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDAgPyAxNiA6ICggdGV4dHVyZS5pbWFnZVsgMCBdLndpZHRoIHx8IHRleHR1cmUuaW1hZ2VbIDAgXS5pbWFnZS53aWR0aCApICk7XG5cblx0XHR9IGVsc2UgeyAvLyBFcXVpcmVjdGFuZ3VsYXJcblxuXHRcdFx0dGhpcy5fc2V0U2l6ZSggdGV4dHVyZS5pbWFnZS53aWR0aCAvIDQgKTtcblxuXHRcdH1cblxuXHRcdF9vbGRUYXJnZXQgPSB0aGlzLl9yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRfb2xkQWN0aXZlQ3ViZUZhY2UgPSB0aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVDdWJlRmFjZSgpO1xuXHRcdF9vbGRBY3RpdmVNaXBtYXBMZXZlbCA9IHRoaXMuX3JlbmRlcmVyLmdldEFjdGl2ZU1pcG1hcExldmVsKCk7XG5cdFx0X29sZFhyRW5hYmxlZCA9IHRoaXMuX3JlbmRlcmVyLnhyLmVuYWJsZWQ7XG5cblx0XHR0aGlzLl9yZW5kZXJlci54ci5lbmFibGVkID0gZmFsc2U7XG5cblx0XHRjb25zdCBjdWJlVVZSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQgfHwgdGhpcy5fYWxsb2NhdGVUYXJnZXRzKCk7XG5cdFx0dGhpcy5fdGV4dHVyZVRvQ3ViZVVWKCB0ZXh0dXJlLCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblx0XHR0aGlzLl9hcHBseVBNUkVNKCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblx0XHR0aGlzLl9jbGVhbnVwKCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cblx0fVxuXG5cdF9hbGxvY2F0ZVRhcmdldHMoKSB7XG5cblx0XHRjb25zdCB3aWR0aCA9IDMgKiBNYXRoLm1heCggdGhpcy5fY3ViZVNpemUsIDE2ICogNyApO1xuXHRcdGNvbnN0IGhlaWdodCA9IDQgKiB0aGlzLl9jdWJlU2l6ZTtcblxuXHRcdGNvbnN0IHBhcmFtcyA9IHtcblx0XHRcdG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLFxuXHRcdFx0bWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG5cdFx0XHRnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuXHRcdFx0dHlwZTogSGFsZkZsb2F0VHlwZSxcblx0XHRcdGZvcm1hdDogUkdCQUZvcm1hdCxcblx0XHRcdGNvbG9yU3BhY2U6IExpbmVhclNSR0JDb2xvclNwYWNlLFxuXHRcdFx0ZGVwdGhCdWZmZXI6IGZhbHNlXG5cdFx0fTtcblxuXHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IF9jcmVhdGVSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHBhcmFtcyApO1xuXG5cdFx0aWYgKCB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCA9PT0gbnVsbCB8fCB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQuaGVpZ2h0ICE9PSBoZWlnaHQgKSB7XG5cblx0XHRcdGlmICggdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5fZGlzcG9zZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gX2NyZWF0ZVJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgcGFyYW1zICk7XG5cblx0XHRcdGNvbnN0IHsgX2xvZE1heCB9ID0gdGhpcztcblx0XHRcdCggeyBzaXplTG9kczogdGhpcy5fc2l6ZUxvZHMsIGxvZFBsYW5lczogdGhpcy5fbG9kUGxhbmVzLCBzaWdtYXM6IHRoaXMuX3NpZ21hcyB9ID0gX2NyZWF0ZVBsYW5lcyggX2xvZE1heCApICk7XG5cblx0XHRcdHRoaXMuX2JsdXJNYXRlcmlhbCA9IF9nZXRCbHVyU2hhZGVyKCBfbG9kTWF4LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xuXG5cdH1cblxuXHRfY29tcGlsZU1hdGVyaWFsKCBtYXRlcmlhbCApIHtcblxuXHRcdGNvbnN0IHRtcE1lc2ggPSBuZXcgTWVzaCggdGhpcy5fbG9kUGxhbmVzWyAwIF0sIG1hdGVyaWFsICk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuY29tcGlsZSggdG1wTWVzaCwgX2ZsYXRDYW1lcmEgKTtcblxuXHR9XG5cblx0X3NjZW5lVG9DdWJlVVYoIHNjZW5lLCBuZWFyLCBmYXIsIGN1YmVVVlJlbmRlclRhcmdldCApIHtcblxuXHRcdGNvbnN0IGZvdiA9IDkwO1xuXHRcdGNvbnN0IGFzcGVjdCA9IDE7XG5cdFx0Y29uc3QgY3ViZUNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNvbnN0IHVwU2lnbiA9IFsgMSwgLSAxLCAxLCAxLCAxLCAxIF07XG5cdFx0Y29uc3QgZm9yd2FyZFNpZ24gPSBbIDEsIDEsIDEsIC0gMSwgLSAxLCAtIDEgXTtcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0Y29uc3Qgb3JpZ2luYWxBdXRvQ2xlYXIgPSByZW5kZXJlci5hdXRvQ2xlYXI7XG5cdFx0Y29uc3QgdG9uZU1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcblx0XHRyZW5kZXJlci5nZXRDbGVhckNvbG9yKCBfY2xlYXJDb2xvciApO1xuXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xuXG5cdFx0Y29uc3QgYmFja2dyb3VuZE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7XG5cdFx0XHRuYW1lOiAnUE1SRU0uQmFja2dyb3VuZCcsXG5cdFx0XHRzaWRlOiBCYWNrU2lkZSxcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHR9ICk7XG5cblx0XHRjb25zdCBiYWNrZ3JvdW5kQm94ID0gbmV3IE1lc2goIG5ldyBCb3hHZW9tZXRyeSgpLCBiYWNrZ3JvdW5kTWF0ZXJpYWwgKTtcblxuXHRcdGxldCB1c2VTb2xpZENvbG9yID0gZmFsc2U7XG5cdFx0Y29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG5cblx0XHRpZiAoIGJhY2tncm91bmQgKSB7XG5cblx0XHRcdGlmICggYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRcdGJhY2tncm91bmRNYXRlcmlhbC5jb2xvci5jb3B5KCBiYWNrZ3JvdW5kICk7XG5cdFx0XHRcdHNjZW5lLmJhY2tncm91bmQgPSBudWxsO1xuXHRcdFx0XHR1c2VTb2xpZENvbG9yID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YmFja2dyb3VuZE1hdGVyaWFsLmNvbG9yLmNvcHkoIF9jbGVhckNvbG9yICk7XG5cdFx0XHR1c2VTb2xpZENvbG9yID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNvbCA9IGkgJSAzO1xuXG5cdFx0XHRpZiAoIGNvbCA9PT0gMCApIHtcblxuXHRcdFx0XHRjdWJlQ2FtZXJhLnVwLnNldCggMCwgdXBTaWduWyBpIF0sIDAgKTtcblx0XHRcdFx0Y3ViZUNhbWVyYS5sb29rQXQoIGZvcndhcmRTaWduWyBpIF0sIDAsIDAgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggY29sID09PSAxICkge1xuXG5cdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KCAwLCAwLCB1cFNpZ25bIGkgXSApO1xuXHRcdFx0XHRjdWJlQ2FtZXJhLmxvb2tBdCggMCwgZm9yd2FyZFNpZ25bIGkgXSwgMCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KCAwLCB1cFNpZ25bIGkgXSwgMCApO1xuXHRcdFx0XHRjdWJlQ2FtZXJhLmxvb2tBdCggMCwgMCwgZm9yd2FyZFNpZ25bIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNpemUgPSB0aGlzLl9jdWJlU2l6ZTtcblxuXHRcdFx0X3NldFZpZXdwb3J0KCBjdWJlVVZSZW5kZXJUYXJnZXQsIGNvbCAqIHNpemUsIGkgPiAyID8gc2l6ZSA6IDAsIHNpemUsIHNpemUgKTtcblxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0aWYgKCB1c2VTb2xpZENvbG9yICkge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlciggYmFja2dyb3VuZEJveCwgY3ViZUNhbWVyYSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGN1YmVDYW1lcmEgKTtcblxuXHRcdH1cblxuXHRcdGJhY2tncm91bmRCb3guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdGJhY2tncm91bmRCb3gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSB0b25lTWFwcGluZztcblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBvcmlnaW5hbEF1dG9DbGVhcjtcblx0XHRzY2VuZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblxuXHR9XG5cblx0X3RleHR1cmVUb0N1YmVVViggdGV4dHVyZSwgY3ViZVVWUmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGNvbnN0IGlzQ3ViZVRleHR1cmUgPSAoIHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIHx8IHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nICk7XG5cblx0XHRpZiAoIGlzQ3ViZVRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5fY3ViZW1hcE1hdGVyaWFsID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IF9nZXRDdWJlbWFwTWF0ZXJpYWwoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jdWJlbWFwTWF0ZXJpYWwudW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IGZhbHNlICkgPyAtIDEgOiAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBfZ2V0RXF1aXJlY3RNYXRlcmlhbCgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IGlzQ3ViZVRleHR1cmUgPyB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgOiB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsO1xuXHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaCggdGhpcy5fbG9kUGxhbmVzWyAwIF0sIG1hdGVyaWFsICk7XG5cblx0XHRjb25zdCB1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuXG5cdFx0dW5pZm9ybXNbICdlbnZNYXAnIF0udmFsdWUgPSB0ZXh0dXJlO1xuXG5cdFx0Y29uc3Qgc2l6ZSA9IHRoaXMuX2N1YmVTaXplO1xuXG5cdFx0X3NldFZpZXdwb3J0KCBjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIDMgKiBzaXplLCAyICogc2l6ZSApO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIG1lc2gsIF9mbGF0Q2FtZXJhICk7XG5cblx0fVxuXG5cdF9hcHBseVBNUkVNKCBjdWJlVVZSZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXHRcdGNvbnN0IGF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBmYWxzZTtcblx0XHRjb25zdCBuID0gdGhpcy5fbG9kUGxhbmVzLmxlbmd0aDtcblxuXHRcdGZvciAoIGxldCBpID0gMTsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHNpZ21hID0gTWF0aC5zcXJ0KCB0aGlzLl9zaWdtYXNbIGkgXSAqIHRoaXMuX3NpZ21hc1sgaSBdIC0gdGhpcy5fc2lnbWFzWyBpIC0gMSBdICogdGhpcy5fc2lnbWFzWyBpIC0gMSBdICk7XG5cblx0XHRcdGNvbnN0IHBvbGVBeGlzID0gX2F4aXNEaXJlY3Rpb25zWyAoIG4gLSBpIC0gMSApICUgX2F4aXNEaXJlY3Rpb25zLmxlbmd0aCBdO1xuXG5cdFx0XHR0aGlzLl9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIGkgLSAxLCBpLCBzaWdtYSwgcG9sZUF4aXMgKTtcblxuXHRcdH1cblxuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGF1dG9DbGVhcjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgaXMgYSB0d28tcGFzcyBHYXVzc2lhbiBibHVyIGZvciBhIGN1YmVtYXAuIE5vcm1hbGx5IHRoaXMgaXMgZG9uZVxuXHQgKiB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHksIGJ1dCB0aGlzIGJyZWFrcyBkb3duIG9uIGEgY3ViZS4gSGVyZSB3ZSBhcHBseVxuXHQgKiB0aGUgYmx1ciBsYXRpdHVkaW5hbGx5IChhcm91bmQgdGhlIHBvbGVzKSwgYW5kIHRoZW4gbG9uZ2l0dWRpbmFsbHkgKHRvd2FyZHNcblx0ICogdGhlIHBvbGVzKSB0byBhcHByb3hpbWF0ZSB0aGUgb3J0aG9nb25hbGx5LXNlcGFyYWJsZSBibHVyLiBJdCBpcyBsZWFzdFxuXHQgKiBhY2N1cmF0ZSBhdCB0aGUgcG9sZXMsIGJ1dCBzdGlsbCBkb2VzIGEgZGVjZW50IGpvYi5cblx0ICovXG5cdF9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hLCBwb2xlQXhpcyApIHtcblxuXHRcdGNvbnN0IHBpbmdQb25nUmVuZGVyVGFyZ2V0ID0gdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQ7XG5cblx0XHR0aGlzLl9oYWxmQmx1cihcblx0XHRcdGN1YmVVVlJlbmRlclRhcmdldCxcblx0XHRcdHBpbmdQb25nUmVuZGVyVGFyZ2V0LFxuXHRcdFx0bG9kSW4sXG5cdFx0XHRsb2RPdXQsXG5cdFx0XHRzaWdtYSxcblx0XHRcdCdsYXRpdHVkaW5hbCcsXG5cdFx0XHRwb2xlQXhpcyApO1xuXG5cdFx0dGhpcy5faGFsZkJsdXIoXG5cdFx0XHRwaW5nUG9uZ1JlbmRlclRhcmdldCxcblx0XHRcdGN1YmVVVlJlbmRlclRhcmdldCxcblx0XHRcdGxvZE91dCxcblx0XHRcdGxvZE91dCxcblx0XHRcdHNpZ21hLFxuXHRcdFx0J2xvbmdpdHVkaW5hbCcsXG5cdFx0XHRwb2xlQXhpcyApO1xuXG5cdH1cblxuXHRfaGFsZkJsdXIoIHRhcmdldEluLCB0YXJnZXRPdXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hUmFkaWFucywgZGlyZWN0aW9uLCBwb2xlQXhpcyApIHtcblxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG5cdFx0Y29uc3QgYmx1ck1hdGVyaWFsID0gdGhpcy5fYmx1ck1hdGVyaWFsO1xuXG5cdFx0aWYgKCBkaXJlY3Rpb24gIT09ICdsYXRpdHVkaW5hbCcgJiYgZGlyZWN0aW9uICE9PSAnbG9uZ2l0dWRpbmFsJyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0J2JsdXIgZGlyZWN0aW9uIG11c3QgYmUgZWl0aGVyIGxhdGl0dWRpbmFsIG9yIGxvbmdpdHVkaW5hbCEnICk7XG5cblx0XHR9XG5cblx0XHQvLyBOdW1iZXIgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucyBhdCB3aGljaCB0byBjdXQgb2ZmIHRoZSBkaXNjcmV0ZSBhcHByb3hpbWF0aW9uLlxuXHRcdGNvbnN0IFNUQU5EQVJEX0RFVklBVElPTlMgPSAzO1xuXG5cdFx0Y29uc3QgYmx1ck1lc2ggPSBuZXcgTWVzaCggdGhpcy5fbG9kUGxhbmVzWyBsb2RPdXQgXSwgYmx1ck1hdGVyaWFsICk7XG5cdFx0Y29uc3QgYmx1clVuaWZvcm1zID0gYmx1ck1hdGVyaWFsLnVuaWZvcm1zO1xuXG5cdFx0Y29uc3QgcGl4ZWxzID0gdGhpcy5fc2l6ZUxvZHNbIGxvZEluIF0gLSAxO1xuXHRcdGNvbnN0IHJhZGlhbnNQZXJQaXhlbCA9IGlzRmluaXRlKCBzaWdtYVJhZGlhbnMgKSA/IE1hdGguUEkgLyAoIDIgKiBwaXhlbHMgKSA6IDIgKiBNYXRoLlBJIC8gKCAyICogTUFYX1NBTVBMRVMgLSAxICk7XG5cdFx0Y29uc3Qgc2lnbWFQaXhlbHMgPSBzaWdtYVJhZGlhbnMgLyByYWRpYW5zUGVyUGl4ZWw7XG5cdFx0Y29uc3Qgc2FtcGxlcyA9IGlzRmluaXRlKCBzaWdtYVJhZGlhbnMgKSA/IDEgKyBNYXRoLmZsb29yKCBTVEFOREFSRF9ERVZJQVRJT05TICogc2lnbWFQaXhlbHMgKSA6IE1BWF9TQU1QTEVTO1xuXG5cdFx0aWYgKCBzYW1wbGVzID4gTUFYX1NBTVBMRVMgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggYHNpZ21hUmFkaWFucywgJHtcblx0XHRcdFx0c2lnbWFSYWRpYW5zfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke1xuXHRcdFx0XHRzYW1wbGVzfSBzYW1wbGVzIHdoZW4gdGhlIG1heGltdW0gaXMgc2V0IHRvICR7TUFYX1NBTVBMRVN9YCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgd2VpZ2h0cyA9IFtdO1xuXHRcdGxldCBzdW0gPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgTUFYX1NBTVBMRVM7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IHggPSBpIC8gc2lnbWFQaXhlbHM7XG5cdFx0XHRjb25zdCB3ZWlnaHQgPSBNYXRoLmV4cCggLSB4ICogeCAvIDIgKTtcblx0XHRcdHdlaWdodHMucHVzaCggd2VpZ2h0ICk7XG5cblx0XHRcdGlmICggaSA9PT0gMCApIHtcblxuXHRcdFx0XHRzdW0gKz0gd2VpZ2h0O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBpIDwgc2FtcGxlcyApIHtcblxuXHRcdFx0XHRzdW0gKz0gMiAqIHdlaWdodDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHdlaWdodHNbIGkgXSA9IHdlaWdodHNbIGkgXSAvIHN1bTtcblxuXHRcdH1cblxuXHRcdGJsdXJVbmlmb3Jtc1sgJ2Vudk1hcCcgXS52YWx1ZSA9IHRhcmdldEluLnRleHR1cmU7XG5cdFx0Ymx1clVuaWZvcm1zWyAnc2FtcGxlcycgXS52YWx1ZSA9IHNhbXBsZXM7XG5cdFx0Ymx1clVuaWZvcm1zWyAnd2VpZ2h0cycgXS52YWx1ZSA9IHdlaWdodHM7XG5cdFx0Ymx1clVuaWZvcm1zWyAnbGF0aXR1ZGluYWwnIF0udmFsdWUgPSBkaXJlY3Rpb24gPT09ICdsYXRpdHVkaW5hbCc7XG5cblx0XHRpZiAoIHBvbGVBeGlzICkge1xuXG5cdFx0XHRibHVyVW5pZm9ybXNbICdwb2xlQXhpcycgXS52YWx1ZSA9IHBvbGVBeGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgeyBfbG9kTWF4IH0gPSB0aGlzO1xuXHRcdGJsdXJVbmlmb3Jtc1sgJ2RUaGV0YScgXS52YWx1ZSA9IHJhZGlhbnNQZXJQaXhlbDtcblx0XHRibHVyVW5pZm9ybXNbICdtaXBJbnQnIF0udmFsdWUgPSBfbG9kTWF4IC0gbG9kSW47XG5cblx0XHRjb25zdCBvdXRwdXRTaXplID0gdGhpcy5fc2l6ZUxvZHNbIGxvZE91dCBdO1xuXHRcdGNvbnN0IHggPSAzICogb3V0cHV0U2l6ZSAqICggbG9kT3V0ID4gX2xvZE1heCAtIExPRF9NSU4gPyBsb2RPdXQgLSBfbG9kTWF4ICsgTE9EX01JTiA6IDAgKTtcblx0XHRjb25zdCB5ID0gNCAqICggdGhpcy5fY3ViZVNpemUgLSBvdXRwdXRTaXplICk7XG5cblx0XHRfc2V0Vmlld3BvcnQoIHRhcmdldE91dCwgeCwgeSwgMyAqIG91dHB1dFNpemUsIDIgKiBvdXRwdXRTaXplICk7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB0YXJnZXRPdXQgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIGJsdXJNZXNoLCBfZmxhdENhbWVyYSApO1xuXG5cdH1cblxufVxuXG5cblxuZnVuY3Rpb24gX2NyZWF0ZVBsYW5lcyggbG9kTWF4ICkge1xuXG5cdGNvbnN0IGxvZFBsYW5lcyA9IFtdO1xuXHRjb25zdCBzaXplTG9kcyA9IFtdO1xuXHRjb25zdCBzaWdtYXMgPSBbXTtcblxuXHRsZXQgbG9kID0gbG9kTWF4O1xuXG5cdGNvbnN0IHRvdGFsTG9kcyA9IGxvZE1heCAtIExPRF9NSU4gKyAxICsgRVhUUkFfTE9EX1NJR01BLmxlbmd0aDtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0b3RhbExvZHM7IGkgKysgKSB7XG5cblx0XHRjb25zdCBzaXplTG9kID0gTWF0aC5wb3coIDIsIGxvZCApO1xuXHRcdHNpemVMb2RzLnB1c2goIHNpemVMb2QgKTtcblx0XHRsZXQgc2lnbWEgPSAxLjAgLyBzaXplTG9kO1xuXG5cdFx0aWYgKCBpID4gbG9kTWF4IC0gTE9EX01JTiApIHtcblxuXHRcdFx0c2lnbWEgPSBFWFRSQV9MT0RfU0lHTUFbIGkgLSBsb2RNYXggKyBMT0RfTUlOIC0gMSBdO1xuXG5cdFx0fSBlbHNlIGlmICggaSA9PT0gMCApIHtcblxuXHRcdFx0c2lnbWEgPSAwO1xuXG5cdFx0fVxuXG5cdFx0c2lnbWFzLnB1c2goIHNpZ21hICk7XG5cblx0XHRjb25zdCB0ZXhlbFNpemUgPSAxLjAgLyAoIHNpemVMb2QgLSAyICk7XG5cdFx0Y29uc3QgbWluID0gLSB0ZXhlbFNpemU7XG5cdFx0Y29uc3QgbWF4ID0gMSArIHRleGVsU2l6ZTtcblx0XHRjb25zdCB1djEgPSBbIG1pbiwgbWluLCBtYXgsIG1pbiwgbWF4LCBtYXgsIG1pbiwgbWluLCBtYXgsIG1heCwgbWluLCBtYXggXTtcblxuXHRcdGNvbnN0IGN1YmVGYWNlcyA9IDY7XG5cdFx0Y29uc3QgdmVydGljZXMgPSA2O1xuXHRcdGNvbnN0IHBvc2l0aW9uU2l6ZSA9IDM7XG5cdFx0Y29uc3QgdXZTaXplID0gMjtcblx0XHRjb25zdCBmYWNlSW5kZXhTaXplID0gMTtcblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25TaXplICogdmVydGljZXMgKiBjdWJlRmFjZXMgKTtcblx0XHRjb25zdCB1diA9IG5ldyBGbG9hdDMyQXJyYXkoIHV2U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzICk7XG5cdFx0Y29uc3QgZmFjZUluZGV4ID0gbmV3IEZsb2F0MzJBcnJheSggZmFjZUluZGV4U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzICk7XG5cblx0XHRmb3IgKCBsZXQgZmFjZSA9IDA7IGZhY2UgPCBjdWJlRmFjZXM7IGZhY2UgKysgKSB7XG5cblx0XHRcdGNvbnN0IHggPSAoIGZhY2UgJSAzICkgKiAyIC8gMyAtIDE7XG5cdFx0XHRjb25zdCB5ID0gZmFjZSA+IDIgPyAwIDogLSAxO1xuXHRcdFx0Y29uc3QgY29vcmRpbmF0ZXMgPSBbXG5cdFx0XHRcdHgsIHksIDAsXG5cdFx0XHRcdHggKyAyIC8gMywgeSwgMCxcblx0XHRcdFx0eCArIDIgLyAzLCB5ICsgMSwgMCxcblx0XHRcdFx0eCwgeSwgMCxcblx0XHRcdFx0eCArIDIgLyAzLCB5ICsgMSwgMCxcblx0XHRcdFx0eCwgeSArIDEsIDBcblx0XHRcdF07XG5cdFx0XHRwb3NpdGlvbi5zZXQoIGNvb3JkaW5hdGVzLCBwb3NpdGlvblNpemUgKiB2ZXJ0aWNlcyAqIGZhY2UgKTtcblx0XHRcdHV2LnNldCggdXYxLCB1dlNpemUgKiB2ZXJ0aWNlcyAqIGZhY2UgKTtcblx0XHRcdGNvbnN0IGZpbGwgPSBbIGZhY2UsIGZhY2UsIGZhY2UsIGZhY2UsIGZhY2UsIGZhY2UgXTtcblx0XHRcdGZhY2VJbmRleC5zZXQoIGZpbGwsIGZhY2VJbmRleFNpemUgKiB2ZXJ0aWNlcyAqIGZhY2UgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBsYW5lcyA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBwb3NpdGlvblNpemUgKSApO1xuXHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2LCB1dlNpemUgKSApO1xuXHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoICdmYWNlSW5kZXgnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBmYWNlSW5kZXgsIGZhY2VJbmRleFNpemUgKSApO1xuXHRcdGxvZFBsYW5lcy5wdXNoKCBwbGFuZXMgKTtcblxuXHRcdGlmICggbG9kID4gTE9EX01JTiApIHtcblxuXHRcdFx0bG9kIC0tO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4geyBsb2RQbGFuZXMsIHNpemVMb2RzLCBzaWdtYXMgfTtcblxufVxuXG5mdW5jdGlvbiBfY3JlYXRlUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBwYXJhbXMgKSB7XG5cblx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBwYXJhbXMgKTtcblx0Y3ViZVVWUmVuZGVyVGFyZ2V0LnRleHR1cmUubWFwcGluZyA9IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nO1xuXHRjdWJlVVZSZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gJ1BNUkVNLmN1YmVVdic7XG5cdGN1YmVVVlJlbmRlclRhcmdldC5zY2lzc29yVGVzdCA9IHRydWU7XG5cdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cbn1cblxuZnVuY3Rpb24gX3NldFZpZXdwb3J0KCB0YXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0dGFyZ2V0LnZpZXdwb3J0LnNldCggeCwgeSwgd2lkdGgsIGhlaWdodCApO1xuXHR0YXJnZXQuc2Npc3Nvci5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcblxufVxuXG5mdW5jdGlvbiBfZ2V0Qmx1clNoYWRlciggbG9kTWF4LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdGNvbnN0IHdlaWdodHMgPSBuZXcgRmxvYXQzMkFycmF5KCBNQVhfU0FNUExFUyApO1xuXHRjb25zdCBwb2xlQXhpcyA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XG5cdGNvbnN0IHNoYWRlck1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKCB7XG5cblx0XHRuYW1lOiAnU3BoZXJpY2FsR2F1c3NpYW5CbHVyJyxcblxuXHRcdGRlZmluZXM6IHtcblx0XHRcdCduJzogTUFYX1NBTVBMRVMsXG5cdFx0XHQnQ1VCRVVWX1RFWEVMX1dJRFRIJzogMS4wIC8gd2lkdGgsXG5cdFx0XHQnQ1VCRVVWX1RFWEVMX0hFSUdIVCc6IDEuMCAvIGhlaWdodCxcblx0XHRcdCdDVUJFVVZfTUFYX01JUCc6IGAke2xvZE1heH0uMGAsXG5cdFx0fSxcblxuXHRcdHVuaWZvcm1zOiB7XG5cdFx0XHQnZW52TWFwJzogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0J3NhbXBsZXMnOiB7IHZhbHVlOiAxIH0sXG5cdFx0XHQnd2VpZ2h0cyc6IHsgdmFsdWU6IHdlaWdodHMgfSxcblx0XHRcdCdsYXRpdHVkaW5hbCc6IHsgdmFsdWU6IGZhbHNlIH0sXG5cdFx0XHQnZFRoZXRhJzogeyB2YWx1ZTogMCB9LFxuXHRcdFx0J21pcEludCc6IHsgdmFsdWU6IDAgfSxcblx0XHRcdCdwb2xlQXhpcyc6IHsgdmFsdWU6IHBvbGVBeGlzIH1cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqL2BcblxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XG5cdFx0XHR1bmlmb3JtIGludCBzYW1wbGVzO1xuXHRcdFx0dW5pZm9ybSBmbG9hdCB3ZWlnaHRzWyBuIF07XG5cdFx0XHR1bmlmb3JtIGJvb2wgbGF0aXR1ZGluYWw7XG5cdFx0XHR1bmlmb3JtIGZsb2F0IGRUaGV0YTtcblx0XHRcdHVuaWZvcm0gZmxvYXQgbWlwSW50O1xuXHRcdFx0dW5pZm9ybSB2ZWMzIHBvbGVBeGlzO1xuXG5cdFx0XHQjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVZcblx0XHRcdCNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XG5cblx0XHRcdHZlYzMgZ2V0U2FtcGxlKCBmbG9hdCB0aGV0YSwgdmVjMyBheGlzICkge1xuXG5cdFx0XHRcdGZsb2F0IGNvc1RoZXRhID0gY29zKCB0aGV0YSApO1xuXHRcdFx0XHQvLyBSb2RyaWd1ZXMnIGF4aXMtYW5nbGUgcm90YXRpb25cblx0XHRcdFx0dmVjMyBzYW1wbGVEaXJlY3Rpb24gPSB2T3V0cHV0RGlyZWN0aW9uICogY29zVGhldGFcblx0XHRcdFx0XHQrIGNyb3NzKCBheGlzLCB2T3V0cHV0RGlyZWN0aW9uICkgKiBzaW4oIHRoZXRhIClcblx0XHRcdFx0XHQrIGF4aXMgKiBkb3QoIGF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKSAqICggMS4wIC0gY29zVGhldGEgKTtcblxuXHRcdFx0XHRyZXR1cm4gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyZWN0aW9uLCBtaXBJbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0dmVjMyBheGlzID0gbGF0aXR1ZGluYWwgPyBwb2xlQXhpcyA6IGNyb3NzKCBwb2xlQXhpcywgdk91dHB1dERpcmVjdGlvbiApO1xuXG5cdFx0XHRcdGlmICggYWxsKCBlcXVhbCggYXhpcywgdmVjMyggMC4wICkgKSApICkge1xuXG5cdFx0XHRcdFx0YXhpcyA9IHZlYzMoIHZPdXRwdXREaXJlY3Rpb24ueiwgMC4wLCAtIHZPdXRwdXREaXJlY3Rpb24ueCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRheGlzID0gbm9ybWFsaXplKCBheGlzICk7XG5cblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XG5cdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgMCBdICogZ2V0U2FtcGxlKCAwLjAsIGF4aXMgKTtcblxuXHRcdFx0XHRmb3IgKCBpbnQgaSA9IDE7IGkgPCBuOyBpKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGkgPj0gc2FtcGxlcyApIHtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmbG9hdCB0aGV0YSA9IGRUaGV0YSAqIGZsb2F0KCBpICk7XG5cdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyBpIF0gKiBnZXRTYW1wbGUoIC0xLjAgKiB0aGV0YSwgYXhpcyApO1xuXHRcdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgaSBdICogZ2V0U2FtcGxlKCB0aGV0YSwgYXhpcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdGAsXG5cblx0XHRibGVuZGluZzogTm9CbGVuZGluZyxcblx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdGRlcHRoV3JpdGU6IGZhbHNlXG5cblx0fSApO1xuXG5cdHJldHVybiBzaGFkZXJNYXRlcmlhbDtcblxufVxuXG5mdW5jdGlvbiBfZ2V0RXF1aXJlY3RNYXRlcmlhbCgpIHtcblxuXHRyZXR1cm4gbmV3IFNoYWRlck1hdGVyaWFsKCB7XG5cblx0XHRuYW1lOiAnRXF1aXJlY3Rhbmd1bGFyVG9DdWJlVVYnLFxuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdCdlbnZNYXAnOiB7IHZhbHVlOiBudWxsIH1cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqL2BcblxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XG5cblx0XHRcdCNpbmNsdWRlIDxjb21tb24+XG5cblx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHR2ZWMzIG91dHB1dERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdk91dHB1dERpcmVjdGlvbiApO1xuXHRcdFx0XHR2ZWMyIHV2ID0gZXF1aXJlY3RVdiggb3V0cHV0RGlyZWN0aW9uICk7XG5cblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEICggZW52TWFwLCB1diApLnJnYiwgMS4wICk7XG5cblx0XHRcdH1cblx0XHRgLFxuXG5cdFx0YmxlbmRpbmc6IE5vQmxlbmRpbmcsXG5cdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHRkZXB0aFdyaXRlOiBmYWxzZVxuXG5cdH0gKTtcblxufVxuXG5mdW5jdGlvbiBfZ2V0Q3ViZW1hcE1hdGVyaWFsKCkge1xuXG5cdHJldHVybiBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcblxuXHRcdG5hbWU6ICdDdWJlbWFwVG9DdWJlVVYnLFxuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdCdlbnZNYXAnOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHQnZmxpcEVudk1hcCc6IHsgdmFsdWU6IC0gMSB9XG5cdFx0fSxcblxuXHRcdHZlcnRleFNoYWRlcjogX2dldENvbW1vblZlcnRleFNoYWRlcigpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IC8qIGdsc2wgKi9gXG5cblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG5cdFx0XHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcblxuXHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIGZsaXBFbnZNYXAgKiB2T3V0cHV0RGlyZWN0aW9uLngsIHZPdXRwdXREaXJlY3Rpb24ueXogKSApO1xuXG5cdFx0XHR9XG5cdFx0YCxcblxuXHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuXHRcdGRlcHRoVGVzdDogZmFsc2UsXG5cdFx0ZGVwdGhXcml0ZTogZmFsc2VcblxuXHR9ICk7XG5cbn1cblxuZnVuY3Rpb24gX2dldENvbW1vblZlcnRleFNoYWRlcigpIHtcblxuXHRyZXR1cm4gLyogZ2xzbCAqL2BcblxuXHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdHByZWNpc2lvbiBtZWRpdW1wIGludDtcblxuXHRcdGF0dHJpYnV0ZSBmbG9hdCBmYWNlSW5kZXg7XG5cblx0XHR2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjtcblxuXHRcdC8vIFJIIGNvb3JkaW5hdGUgc3lzdGVtOyBQTVJFTSBmYWNlLWluZGV4aW5nIGNvbnZlbnRpb25cblx0XHR2ZWMzIGdldERpcmVjdGlvbiggdmVjMiB1diwgZmxvYXQgZmFjZSApIHtcblxuXHRcdFx0dXYgPSAyLjAgKiB1diAtIDEuMDtcblxuXHRcdFx0dmVjMyBkaXJlY3Rpb24gPSB2ZWMzKCB1diwgMS4wICk7XG5cblx0XHRcdGlmICggZmFjZSA9PSAwLjAgKSB7XG5cblx0XHRcdFx0ZGlyZWN0aW9uID0gZGlyZWN0aW9uLnp5eDsgLy8gKCAxLCB2LCB1ICkgcG9zIHhcblxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7XG5cblx0XHRcdFx0ZGlyZWN0aW9uID0gZGlyZWN0aW9uLnh6eTtcblx0XHRcdFx0ZGlyZWN0aW9uLnh6ICo9IC0xLjA7IC8vICggLXUsIDEsIC12ICkgcG9zIHlcblxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSA9PSAyLjAgKSB7XG5cblx0XHRcdFx0ZGlyZWN0aW9uLnggKj0gLTEuMDsgLy8gKCAtdSwgdiwgMSApIHBvcyB6XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi56eXg7XG5cdFx0XHRcdGRpcmVjdGlvbi54eiAqPSAtMS4wOyAvLyAoIC0xLCB2LCAtdSApIG5lZyB4XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gNC4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7XG5cdFx0XHRcdGRpcmVjdGlvbi54eSAqPSAtMS4wOyAvLyAoIC11LCAtMSwgdiApIG5lZyB5XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gNS4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbi56ICo9IC0xLjA7IC8vICggdSwgdiwgLTEgKSBuZWcgelxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkaXJlY3Rpb247XG5cblx0XHR9XG5cblx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdHZPdXRwdXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oIHV2LCBmYWNlSW5kZXggKTtcblx0XHRcdGdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24sIDEuMCApO1xuXG5cdFx0fVxuXHRgO1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMQ3ViZVVWTWFwcyggcmVuZGVyZXIgKSB7XG5cblx0bGV0IGN1YmVVVm1hcHMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGxldCBwbXJlbUdlbmVyYXRvciA9IG51bGw7XG5cblx0ZnVuY3Rpb24gZ2V0KCB0ZXh0dXJlICkge1xuXG5cdFx0aWYgKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRjb25zdCBtYXBwaW5nID0gdGV4dHVyZS5tYXBwaW5nO1xuXG5cdFx0XHRjb25zdCBpc0VxdWlyZWN0TWFwID0gKCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyB8fCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyApO1xuXHRcdFx0Y29uc3QgaXNDdWJlTWFwID0gKCBtYXBwaW5nID09PSBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nICk7XG5cblx0XHRcdC8vIGVxdWlyZWN0L2N1YmUgbWFwIHRvIGN1YmVVViBjb252ZXJzaW9uXG5cblx0XHRcdGlmICggaXNFcXVpcmVjdE1hcCB8fCBpc0N1YmVNYXAgKSB7XG5cblx0XHRcdFx0bGV0IHJlbmRlclRhcmdldCA9IGN1YmVVVm1hcHMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0Y29uc3QgY3VycmVudFBNUkVNVmVyc2lvbiA9IHJlbmRlclRhcmdldCAhPT0gdW5kZWZpbmVkID8gcmVuZGVyVGFyZ2V0LnRleHR1cmUucG1yZW1WZXJzaW9uIDogMDtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICYmIHRleHR1cmUucG1yZW1WZXJzaW9uICE9PSBjdXJyZW50UE1SRU1WZXJzaW9uICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwbXJlbUdlbmVyYXRvciA9PT0gbnVsbCApIHBtcmVtR2VuZXJhdG9yID0gbmV3IFBNUkVNR2VuZXJhdG9yKCByZW5kZXJlciApO1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0ID0gaXNFcXVpcmVjdE1hcCA/IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIoIHRleHR1cmUsIHJlbmRlclRhcmdldCApIDogcG1yZW1HZW5lcmF0b3IuZnJvbUN1YmVtYXAoIHRleHR1cmUsIHJlbmRlclRhcmdldCApO1xuXHRcdFx0XHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLnBtcmVtVmVyc2lvbiA9IHRleHR1cmUucG1yZW1WZXJzaW9uO1xuXG5cdFx0XHRcdFx0Y3ViZVVWbWFwcy5zZXQoIHRleHR1cmUsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cblx0XHRcdFx0XHRcdGlmICggKCBpc0VxdWlyZWN0TWFwICYmIGltYWdlICYmIGltYWdlLmhlaWdodCA+IDAgKSB8fCAoIGlzQ3ViZU1hcCAmJiBpbWFnZSAmJiBpc0N1YmVUZXh0dXJlQ29tcGxldGUoIGltYWdlICkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHBtcmVtR2VuZXJhdG9yID09PSBudWxsICkgcG1yZW1HZW5lcmF0b3IgPSBuZXcgUE1SRU1HZW5lcmF0b3IoIHJlbmRlcmVyICk7XG5cblx0XHRcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0ID0gaXNFcXVpcmVjdE1hcCA/IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIoIHRleHR1cmUgKSA6IHBtcmVtR2VuZXJhdG9yLmZyb21DdWJlbWFwKCB0ZXh0dXJlICk7XG5cdFx0XHRcdFx0XHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLnBtcmVtVmVyc2lvbiA9IHRleHR1cmUucG1yZW1WZXJzaW9uO1xuXG5cdFx0XHRcdFx0XHRcdGN1YmVVVm1hcHMuc2V0KCB0ZXh0dXJlLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpbWFnZSBub3QgeWV0IHJlYWR5LiB0cnkgdGhlIGNvbnZlcnNpb24gbmV4dCBmcmFtZVxuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaXNDdWJlVGV4dHVyZUNvbXBsZXRlKCBpbWFnZSApIHtcblxuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0Y29uc3QgbGVuZ3RoID0gNjtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBpbWFnZVsgaSBdICE9PSB1bmRlZmluZWQgKSBjb3VudCArKztcblxuXHRcdH1cblxuXHRcdHJldHVybiBjb3VudCA9PT0gbGVuZ3RoO1xuXG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcblxuXHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHRjb25zdCBjdWJlbWFwVVYgPSBjdWJlVVZtYXBzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0aWYgKCBjdWJlbWFwVVYgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y3ViZVVWbWFwcy5kZWxldGUoIHRleHR1cmUgKTtcblx0XHRcdGN1YmVtYXBVVi5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRjdWJlVVZtYXBzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdGlmICggcG1yZW1HZW5lcmF0b3IgIT09IG51bGwgKSB7XG5cblx0XHRcdHBtcmVtR2VuZXJhdG9yLmRpc3Bvc2UoKTtcblx0XHRcdHBtcmVtR2VuZXJhdG9yID0gbnVsbDtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGdldCxcblx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xFeHRlbnNpb25zKCBnbCApIHtcblxuXHRjb25zdCBleHRlbnNpb25zID0ge307XG5cblx0ZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKCBuYW1lICkge1xuXG5cdFx0aWYgKCBleHRlbnNpb25zWyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbnNbIG5hbWUgXTtcblxuXHRcdH1cblxuXHRcdGxldCBleHRlbnNpb247XG5cblx0XHRzd2l0Y2ggKCBuYW1lICkge1xuXG5cdFx0XHRjYXNlICdXRUJHTF9kZXB0aF90ZXh0dXJlJzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfZGVwdGhfdGV4dHVyZScgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyc6XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggbmFtZSApO1xuXG5cdFx0fVxuXG5cdFx0ZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbjtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdGhhczogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0RXh0ZW5zaW9uKCBuYW1lICkgIT09IG51bGw7XG5cblx0XHR9LFxuXG5cdFx0aW5pdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRnZXRFeHRlbnNpb24oICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyApO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnV0VCR0xfY2xpcF9jdWxsX2Rpc3RhbmNlJyApO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JyApO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyApO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnV0VCR0xfcmVuZGVyX3NoYXJlZF9leHBvbmVudCcgKTtcblxuXHRcdH0sXG5cblx0XHRnZXQ6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG5cdFx0XHRcdHdhcm5PbmNlKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uO1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xHZW9tZXRyaWVzKCBnbCwgYXR0cmlidXRlcywgaW5mbywgYmluZGluZ1N0YXRlcyApIHtcblxuXHRjb25zdCBnZW9tZXRyaWVzID0ge307XG5cdGNvbnN0IHdpcmVmcmFtZUF0dHJpYnV0ZXMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGZ1bmN0aW9uIG9uR2VvbWV0cnlEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoIGdlb21ldHJ5LmluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF0gKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKCBhcnJheVsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuXHRcdGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoIGdlb21ldHJ5ICk7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZSApIHtcblxuXHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoIGF0dHJpYnV0ZSApO1xuXHRcdFx0d2lyZWZyYW1lQXR0cmlidXRlcy5kZWxldGUoIGdlb21ldHJ5ICk7XG5cblx0XHR9XG5cblx0XHRiaW5kaW5nU3RhdGVzLnJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID09PSB0cnVlICkge1xuXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQ7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0KCBvYmplY3QsIGdlb21ldHJ5ICkge1xuXG5cdFx0aWYgKCBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID09PSB0cnVlICkgcmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0Z2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xuXG5cdFx0Z2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSA9IHRydWU7XG5cblx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGUoIGdlb21ldHJ5ICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuXHRcdC8vIFVwZGF0aW5nIGluZGV4IGJ1ZmZlciBpbiBWQU8gbm93LiBTZWUgV2ViR0xCaW5kaW5nU3RhdGVzLlxuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBnZW9tZXRyeUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKCBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0XHR9XG5cblx0XHQvLyBtb3JwaCB0YXJnZXRzXG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZSggYXJyYXlbIGkgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApIHtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5SW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBnZW9tZXRyeVBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRsZXQgdmVyc2lvbiA9IDA7XG5cblx0XHRpZiAoIGdlb21ldHJ5SW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gZ2VvbWV0cnlJbmRleC5hcnJheTtcblx0XHRcdHZlcnNpb24gPSBnZW9tZXRyeUluZGV4LnZlcnNpb247XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRjb25zdCBhID0gYXJyYXlbIGkgKyAwIF07XG5cdFx0XHRcdGNvbnN0IGIgPSBhcnJheVsgaSArIDEgXTtcblx0XHRcdFx0Y29uc3QgYyA9IGFycmF5WyBpICsgMiBdO1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeVBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gZ2VvbWV0cnlQb3NpdGlvbi5hcnJheTtcblx0XHRcdHZlcnNpb24gPSBnZW9tZXRyeVBvc2l0aW9uLnZlcnNpb247XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9ICggYXJyYXkubGVuZ3RoIC8gMyApIC0gMTsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRjb25zdCBhID0gaSArIDA7XG5cdFx0XHRcdGNvbnN0IGIgPSBpICsgMTtcblx0XHRcdFx0Y29uc3QgYyA9IGkgKyAyO1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRjb25zdCBhdHRyaWJ1dGUgPSBuZXcgKCBhcnJheU5lZWRzVWludDMyKCBpbmRpY2VzICkgPyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgOiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgKSggaW5kaWNlcywgMSApO1xuXHRcdGF0dHJpYnV0ZS52ZXJzaW9uID0gdmVyc2lvbjtcblxuXHRcdC8vIFVwZGF0aW5nIGluZGV4IGJ1ZmZlciBpbiBWQU8gbm93LiBTZWUgV2ViR0xCaW5kaW5nU3RhdGVzXG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgcHJldmlvdXNBdHRyaWJ1dGUgPSB3aXJlZnJhbWVBdHRyaWJ1dGVzLmdldCggZ2VvbWV0cnkgKTtcblxuXHRcdGlmICggcHJldmlvdXNBdHRyaWJ1dGUgKSBhdHRyaWJ1dGVzLnJlbW92ZSggcHJldmlvdXNBdHRyaWJ1dGUgKTtcblxuXHRcdC8vXG5cblx0XHR3aXJlZnJhbWVBdHRyaWJ1dGVzLnNldCggZ2VvbWV0cnksIGF0dHJpYnV0ZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICkge1xuXG5cdFx0Y29uc3QgY3VycmVudEF0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXMuZ2V0KCBnZW9tZXRyeSApO1xuXG5cdFx0aWYgKCBjdXJyZW50QXR0cmlidXRlICkge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeUluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cblx0XHRcdGlmICggZ2VvbWV0cnlJbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHQvLyBpZiB0aGUgYXR0cmlidXRlIGlzIG9ic29sZXRlLCBjcmVhdGUgYSBuZXcgb25lXG5cblx0XHRcdFx0aWYgKCBjdXJyZW50QXR0cmlidXRlLnZlcnNpb24gPCBnZW9tZXRyeUluZGV4LnZlcnNpb24gKSB7XG5cblx0XHRcdFx0XHR1cGRhdGVXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1cGRhdGVXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoIGdlb21ldHJ5ICk7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cblx0XHRnZXQ6IGdldCxcblx0XHR1cGRhdGU6IHVwZGF0ZSxcblxuXHRcdGdldFdpcmVmcmFtZUF0dHJpYnV0ZTogZ2V0V2lyZWZyYW1lQXR0cmlidXRlXG5cblx0fTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggZ2wsIGV4dGVuc2lvbnMsIGluZm8gKSB7XG5cblx0bGV0IG1vZGU7XG5cblx0ZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XG5cblx0XHRtb2RlID0gdmFsdWU7XG5cblx0fVxuXG5cdGxldCB0eXBlLCBieXRlc1BlckVsZW1lbnQ7XG5cblx0ZnVuY3Rpb24gc2V0SW5kZXgoIHZhbHVlICkge1xuXG5cdFx0dHlwZSA9IHZhbHVlLnR5cGU7XG5cdFx0Ynl0ZXNQZXJFbGVtZW50ID0gdmFsdWUuYnl0ZXNQZXJFbGVtZW50O1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdGdsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50ICk7XG5cblx0XHRpbmZvLnVwZGF0ZSggY291bnQsIG1vZGUsIDEgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBzdGFydCwgY291bnQsIHByaW1jb3VudCApIHtcblxuXHRcdGlmICggcHJpbWNvdW50ID09PSAwICkgcmV0dXJuO1xuXG5cdFx0Z2wuZHJhd0VsZW1lbnRzSW5zdGFuY2VkKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBieXRlc1BlckVsZW1lbnQsIHByaW1jb3VudCApO1xuXG5cdFx0aW5mby51cGRhdGUoIGNvdW50LCBtb2RlLCBwcmltY291bnQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyTXVsdGlEcmF3KCBzdGFydHMsIGNvdW50cywgZHJhd0NvdW50ICkge1xuXG5cdFx0aWYgKCBkcmF3Q291bnQgPT09IDAgKSByZXR1cm47XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX211bHRpX2RyYXcnICk7XG5cblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZHJhd0NvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMucmVuZGVyKCBzdGFydHNbIGkgXSAvIGJ5dGVzUGVyRWxlbWVudCwgY291bnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZXh0ZW5zaW9uLm11bHRpRHJhd0VsZW1lbnRzV0VCR0woIG1vZGUsIGNvdW50cywgMCwgdHlwZSwgc3RhcnRzLCAwLCBkcmF3Q291bnQgKTtcblxuXHRcdFx0bGV0IGVsZW1lbnRDb3VudCA9IDA7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkcmF3Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0ZWxlbWVudENvdW50ICs9IGNvdW50c1sgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGluZm8udXBkYXRlKCBlbGVtZW50Q291bnQsIG1vZGUsIDEgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzKCBzdGFydHMsIGNvdW50cywgZHJhd0NvdW50LCBwcmltY291bnQgKSB7XG5cblx0XHRpZiAoIGRyYXdDb3VudCA9PT0gMCApIHJldHVybjtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlfZHJhdycgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzdGFydHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHJlbmRlckluc3RhbmNlcyggc3RhcnRzWyBpIF0gLyBieXRlc1BlckVsZW1lbnQsIGNvdW50c1sgaSBdLCBwcmltY291bnRbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRleHRlbnNpb24ubXVsdGlEcmF3RWxlbWVudHNJbnN0YW5jZWRXRUJHTCggbW9kZSwgY291bnRzLCAwLCB0eXBlLCBzdGFydHMsIDAsIHByaW1jb3VudCwgMCwgZHJhd0NvdW50ICk7XG5cblx0XHRcdGxldCBlbGVtZW50Q291bnQgPSAwO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZHJhd0NvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdGVsZW1lbnRDb3VudCArPSBjb3VudHNbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcmltY291bnQubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGluZm8udXBkYXRlKCBlbGVtZW50Q291bnQsIG1vZGUsIHByaW1jb3VudFsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly9cblxuXHR0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xuXHR0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XG5cdHRoaXMucmVuZGVyID0gcmVuZGVyO1xuXHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcblx0dGhpcy5yZW5kZXJNdWx0aURyYXcgPSByZW5kZXJNdWx0aURyYXc7XG5cdHRoaXMucmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzID0gcmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzO1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMSW5mbyggZ2wgKSB7XG5cblx0Y29uc3QgbWVtb3J5ID0ge1xuXHRcdGdlb21ldHJpZXM6IDAsXG5cdFx0dGV4dHVyZXM6IDBcblx0fTtcblxuXHRjb25zdCByZW5kZXIgPSB7XG5cdFx0ZnJhbWU6IDAsXG5cdFx0Y2FsbHM6IDAsXG5cdFx0dHJpYW5nbGVzOiAwLFxuXHRcdHBvaW50czogMCxcblx0XHRsaW5lczogMFxuXHR9O1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZSggY291bnQsIG1vZGUsIGluc3RhbmNlQ291bnQgKSB7XG5cblx0XHRyZW5kZXIuY2FsbHMgKys7XG5cblx0XHRzd2l0Y2ggKCBtb2RlICkge1xuXG5cdFx0XHRjYXNlIGdsLlRSSUFOR0xFUzpcblx0XHRcdFx0cmVuZGVyLnRyaWFuZ2xlcyArPSBpbnN0YW5jZUNvdW50ICogKCBjb3VudCAvIDMgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgZ2wuTElORVM6XG5cdFx0XHRcdHJlbmRlci5saW5lcyArPSBpbnN0YW5jZUNvdW50ICogKCBjb3VudCAvIDIgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgZ2wuTElORV9TVFJJUDpcblx0XHRcdFx0cmVuZGVyLmxpbmVzICs9IGluc3RhbmNlQ291bnQgKiAoIGNvdW50IC0gMSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBnbC5MSU5FX0xPT1A6XG5cdFx0XHRcdHJlbmRlci5saW5lcyArPSBpbnN0YW5jZUNvdW50ICogY291bnQ7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIGdsLlBPSU5UUzpcblx0XHRcdFx0cmVuZGVyLnBvaW50cyArPSBpbnN0YW5jZUNvdW50ICogY291bnQ7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xJbmZvOiBVbmtub3duIGRyYXcgbW9kZTonLCBtb2RlICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZXNldCgpIHtcblxuXHRcdHJlbmRlci5jYWxscyA9IDA7XG5cdFx0cmVuZGVyLnRyaWFuZ2xlcyA9IDA7XG5cdFx0cmVuZGVyLnBvaW50cyA9IDA7XG5cdFx0cmVuZGVyLmxpbmVzID0gMDtcblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRtZW1vcnk6IG1lbW9yeSxcblx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRwcm9ncmFtczogbnVsbCxcblx0XHRhdXRvUmVzZXQ6IHRydWUsXG5cdFx0cmVzZXQ6IHJlc2V0LFxuXHRcdHVwZGF0ZTogdXBkYXRlXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xNb3JwaHRhcmdldHMoIGdsLCBjYXBhYmlsaXRpZXMsIHRleHR1cmVzICkge1xuXG5cdGNvbnN0IG1vcnBoVGV4dHVyZXMgPSBuZXcgV2Vha01hcCgpO1xuXHRjb25zdCBtb3JwaCA9IG5ldyBWZWN0b3I0KCk7XG5cblx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QsIGdlb21ldHJ5LCBwcm9ncmFtICkge1xuXG5cdFx0Y29uc3Qgb2JqZWN0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHQvLyB0aGUgZm9sbG93aW5nIGVuY29kZXMgbW9ycGggdGFyZ2V0cyBpbnRvIGFuIGFycmF5IG9mIGRhdGEgdGV4dHVyZXMuIEVhY2ggbGF5ZXIgcmVwcmVzZW50cyBhIHNpbmdsZSBtb3JwaCB0YXJnZXQuXG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvcjtcblx0XHRjb25zdCBtb3JwaFRhcmdldHNDb3VudCA9ICggbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApID8gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoIDogMDtcblxuXHRcdGxldCBlbnRyeSA9IG1vcnBoVGV4dHVyZXMuZ2V0KCBnZW9tZXRyeSApO1xuXG5cdFx0aWYgKCBlbnRyeSA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5LmNvdW50ICE9PSBtb3JwaFRhcmdldHNDb3VudCApIHtcblxuXHRcdFx0aWYgKCBlbnRyeSAhPT0gdW5kZWZpbmVkICkgZW50cnkudGV4dHVyZS5kaXNwb3NlKCk7XG5cblx0XHRcdGNvbnN0IGhhc01vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZDtcblx0XHRcdGNvbnN0IGhhc01vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZDtcblx0XHRcdGNvbnN0IGhhc01vcnBoQ29sb3JzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQ7XG5cblx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBbXTtcblx0XHRcdGNvbnN0IG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgW107XG5cdFx0XHRjb25zdCBtb3JwaENvbG9ycyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciB8fCBbXTtcblxuXHRcdFx0bGV0IHZlcnRleERhdGFDb3VudCA9IDA7XG5cblx0XHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiA9PT0gdHJ1ZSApIHZlcnRleERhdGFDb3VudCA9IDE7XG5cdFx0XHRpZiAoIGhhc01vcnBoTm9ybWFscyA9PT0gdHJ1ZSApIHZlcnRleERhdGFDb3VudCA9IDI7XG5cdFx0XHRpZiAoIGhhc01vcnBoQ29sb3JzID09PSB0cnVlICkgdmVydGV4RGF0YUNvdW50ID0gMztcblxuXHRcdFx0bGV0IHdpZHRoID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCAqIHZlcnRleERhdGFDb3VudDtcblx0XHRcdGxldCBoZWlnaHQgPSAxO1xuXG5cdFx0XHRpZiAoIHdpZHRoID4gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICkge1xuXG5cdFx0XHRcdGhlaWdodCA9IE1hdGguY2VpbCggd2lkdGggLyBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUgKTtcblx0XHRcdFx0d2lkdGggPSBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemU7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggd2lkdGggKiBoZWlnaHQgKiA0ICogbW9ycGhUYXJnZXRzQ291bnQgKTtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBEYXRhQXJyYXlUZXh0dXJlKCBidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG1vcnBoVGFyZ2V0c0NvdW50ICk7XG5cdFx0XHR0ZXh0dXJlLnR5cGUgPSBGbG9hdFR5cGU7XG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0Ly8gZmlsbCBidWZmZXJcblxuXHRcdFx0Y29uc3QgdmVydGV4RGF0YVN0cmlkZSA9IHZlcnRleERhdGFDb3VudCAqIDQ7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1vcnBoVGFyZ2V0c0NvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IG1vcnBoTm9ybWFsID0gbW9ycGhOb3JtYWxzWyBpIF07XG5cdFx0XHRcdGNvbnN0IG1vcnBoQ29sb3IgPSBtb3JwaENvbG9yc1sgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IG9mZnNldCA9IHdpZHRoICogaGVpZ2h0ICogNCAqIGk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgbW9ycGhUYXJnZXQuY291bnQ7IGogKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBzdHJpZGUgPSBqICogdmVydGV4RGF0YVN0cmlkZTtcblxuXHRcdFx0XHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0bW9ycGguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhUYXJnZXQsIGogKTtcblxuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyAwIF0gPSBtb3JwaC54O1xuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyAxIF0gPSBtb3JwaC55O1xuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyAyIF0gPSBtb3JwaC56O1xuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyAzIF0gPSAwO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBoYXNNb3JwaE5vcm1hbHMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdG1vcnBoLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoTm9ybWFsLCBqICk7XG5cblx0XHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgNCBdID0gbW9ycGgueDtcblx0XHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgNSBdID0gbW9ycGgueTtcblx0XHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgNiBdID0gbW9ycGguejtcblx0XHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgNyBdID0gMDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaGFzTW9ycGhDb2xvcnMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdG1vcnBoLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQ29sb3IsIGogKTtcblxuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyA4IF0gPSBtb3JwaC54O1xuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyA5IF0gPSBtb3JwaC55O1xuXHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyAxMCBdID0gbW9ycGguejtcblx0XHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgMTEgXSA9ICggbW9ycGhDb2xvci5pdGVtU2l6ZSA9PT0gNCApID8gbW9ycGgudyA6IDE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGVudHJ5ID0ge1xuXHRcdFx0XHRjb3VudDogbW9ycGhUYXJnZXRzQ291bnQsXG5cdFx0XHRcdHRleHR1cmU6IHRleHR1cmUsXG5cdFx0XHRcdHNpemU6IG5ldyBWZWN0b3IyKCB3aWR0aCwgaGVpZ2h0IClcblx0XHRcdH07XG5cblx0XHRcdG1vcnBoVGV4dHVyZXMuc2V0KCBnZW9tZXRyeSwgZW50cnkgKTtcblxuXHRcdFx0ZnVuY3Rpb24gZGlzcG9zZVRleHR1cmUoKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5kaXNwb3NlKCk7XG5cblx0XHRcdFx0bW9ycGhUZXh0dXJlcy5kZWxldGUoIGdlb21ldHJ5ICk7XG5cblx0XHRcdFx0Z2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBkaXNwb3NlVGV4dHVyZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgZGlzcG9zZVRleHR1cmUgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cdFx0aWYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoID09PSB0cnVlICYmIG9iamVjdC5tb3JwaFRleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZSggZ2wsICdtb3JwaFRleHR1cmUnLCBvYmplY3QubW9ycGhUZXh0dXJlLCB0ZXh0dXJlcyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bGV0IG1vcnBoSW5mbHVlbmNlc1N1bSA9IDA7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG9iamVjdEluZmx1ZW5jZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1N1bSArPSBvYmplY3RJbmZsdWVuY2VzWyBpIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbW9ycGhCYXNlSW5mbHVlbmNlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPyAxIDogMSAtIG1vcnBoSW5mbHVlbmNlc1N1bTtcblxuXG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoIGdsLCAnbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlJywgbW9ycGhCYXNlSW5mbHVlbmNlICk7XG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoIGdsLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJywgb2JqZWN0SW5mbHVlbmNlcyApO1xuXG5cdFx0fVxuXG5cdFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKCBnbCwgJ21vcnBoVGFyZ2V0c1RleHR1cmUnLCBlbnRyeS50ZXh0dXJlLCB0ZXh0dXJlcyApO1xuXHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZSggZ2wsICdtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZScsIGVudHJ5LnNpemUgKTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdHVwZGF0ZTogdXBkYXRlXG5cblx0fTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTE9iamVjdHMoIGdsLCBnZW9tZXRyaWVzLCBhdHRyaWJ1dGVzLCBpbmZvICkge1xuXG5cdGxldCB1cGRhdGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xuXG5cdFx0Y29uc3QgZnJhbWUgPSBpbmZvLnJlbmRlci5mcmFtZTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXHRcdGNvbnN0IGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllcy5nZXQoIG9iamVjdCwgZ2VvbWV0cnkgKTtcblxuXHRcdC8vIFVwZGF0ZSBvbmNlIHBlciBmcmFtZVxuXG5cdFx0aWYgKCB1cGRhdGVNYXAuZ2V0KCBidWZmZXJnZW9tZXRyeSApICE9PSBmcmFtZSApIHtcblxuXHRcdFx0Z2VvbWV0cmllcy51cGRhdGUoIGJ1ZmZlcmdlb21ldHJ5ICk7XG5cblx0XHRcdHVwZGF0ZU1hcC5zZXQoIGJ1ZmZlcmdlb21ldHJ5LCBmcmFtZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5oYXNFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uSW5zdGFuY2VkTWVzaERpc3Bvc2UgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0b2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25JbnN0YW5jZWRNZXNoRGlzcG9zZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXBkYXRlTWFwLmdldCggb2JqZWN0ICkgIT09IGZyYW1lICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKCBvYmplY3QuaW5zdGFuY2VNYXRyaXgsIGdsLkFSUkFZX0JVRkZFUiApO1xuXG5cdFx0XHRcdGlmICggb2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZSggb2JqZWN0Lmluc3RhbmNlQ29sb3IsIGdsLkFSUkFZX0JVRkZFUiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1cGRhdGVNYXAuc2V0KCBvYmplY3QsIGZyYW1lICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0LmlzU2tpbm5lZE1lc2ggKSB7XG5cblx0XHRcdGNvbnN0IHNrZWxldG9uID0gb2JqZWN0LnNrZWxldG9uO1xuXG5cdFx0XHRpZiAoIHVwZGF0ZU1hcC5nZXQoIHNrZWxldG9uICkgIT09IGZyYW1lICkge1xuXG5cdFx0XHRcdHNrZWxldG9uLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdHVwZGF0ZU1hcC5zZXQoIHNrZWxldG9uLCBmcmFtZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYnVmZmVyZ2VvbWV0cnk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHR1cGRhdGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbkluc3RhbmNlZE1lc2hEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdGNvbnN0IGluc3RhbmNlZE1lc2ggPSBldmVudC50YXJnZXQ7XG5cblx0XHRpbnN0YW5jZWRNZXNoLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25JbnN0YW5jZWRNZXNoRGlzcG9zZSApO1xuXG5cdFx0YXR0cmlidXRlcy5yZW1vdmUoIGluc3RhbmNlZE1lc2guaW5zdGFuY2VNYXRyaXggKTtcblxuXHRcdGlmICggaW5zdGFuY2VkTWVzaC5pbnN0YW5jZUNvbG9yICE9PSBudWxsICkgYXR0cmlidXRlcy5yZW1vdmUoIGluc3RhbmNlZE1lc2guaW5zdGFuY2VDb2xvciApO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXG5cdH07XG5cbn1cblxuY2xhc3MgRGVwdGhUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cblx0Y29uc3RydWN0b3IoIHdpZHRoLCBoZWlnaHQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGZvcm1hdCA9IERlcHRoRm9ybWF0ICkge1xuXG5cdFx0aWYgKCBmb3JtYXQgIT09IERlcHRoRm9ybWF0ICYmIGZvcm1hdCAhPT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdEZXB0aFRleHR1cmUgZm9ybWF0IG11c3QgYmUgZWl0aGVyIFRIUkVFLkRlcHRoRm9ybWF0IG9yIFRIUkVFLkRlcHRoU3RlbmNpbEZvcm1hdCcgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgKSB0eXBlID0gVW5zaWduZWRJbnRUeXBlO1xuXHRcdGlmICggdHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkgdHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcblxuXHRcdHN1cGVyKCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuXHRcdHRoaXMuaXNEZXB0aFRleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuXG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdHRoaXMuY29tcGFyZUZ1bmN0aW9uID0gbnVsbDtcblxuXHR9XG5cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29tcGFyZUZ1bmN0aW9uID0gc291cmNlLmNvbXBhcmVGdW5jdGlvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCBtZXRhICk7XG5cblx0XHRpZiAoIHRoaXMuY29tcGFyZUZ1bmN0aW9uICE9PSBudWxsICkgZGF0YS5jb21wYXJlRnVuY3Rpb24gPSB0aGlzLmNvbXBhcmVGdW5jdGlvbjtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIFVuaWZvcm1zIG9mIGEgcHJvZ3JhbS5cbiAqIFRob3NlIGZvcm0gYSB0cmVlIHN0cnVjdHVyZSB3aXRoIGEgc3BlY2lhbCB0b3AtbGV2ZWwgY29udGFpbmVyIGZvciB0aGUgcm9vdCxcbiAqIHdoaWNoIHlvdSBnZXQgYnkgY2FsbGluZyAnbmV3IFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtICknLlxuICpcbiAqXG4gKiBQcm9wZXJ0aWVzIG9mIGlubmVyIG5vZGVzIGluY2x1ZGluZyB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcbiAqXG4gKiAuc2VxIC0gYXJyYXkgb2YgbmVzdGVkIHVuaWZvcm1zXG4gKiAubWFwIC0gbmVzdGVkIHVuaWZvcm1zIGJ5IG5hbWVcbiAqXG4gKlxuICogTWV0aG9kcyBvZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxuICpcbiAqIC5zZXRWYWx1ZSggZ2wsIHZhbHVlLCBbdGV4dHVyZXNdIClcbiAqXG4gKiBcdFx0dXBsb2FkcyBhIHVuaWZvcm0gdmFsdWUocylcbiAqICBcdHRoZSAndGV4dHVyZXMnIHBhcmFtZXRlciBpcyBuZWVkZWQgZm9yIHNhbXBsZXIgdW5pZm9ybXNcbiAqXG4gKlxuICogU3RhdGljIG1ldGhvZHMgb2YgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgKHRleHR1cmVzIGZhY3Rvcml6YXRpb25zKTpcbiAqXG4gKiAudXBsb2FkKCBnbCwgc2VxLCB2YWx1ZXMsIHRleHR1cmVzIClcbiAqXG4gKiBcdFx0c2V0cyB1bmlmb3JtcyBpbiAnc2VxJyB0byAndmFsdWVzW2lkXS52YWx1ZSdcbiAqXG4gKiAuc2VxV2l0aFZhbHVlKCBzZXEsIHZhbHVlcyApIDogZmlsdGVyZWRTZXFcbiAqXG4gKiBcdFx0ZmlsdGVycyAnc2VxJyBlbnRyaWVzIHdpdGggY29ycmVzcG9uZGluZyBlbnRyeSBpbiB2YWx1ZXNcbiAqXG4gKlxuICogTWV0aG9kcyBvZiB0aGUgdG9wLWxldmVsIGNvbnRhaW5lciAodGV4dHVyZXMgZmFjdG9yaXphdGlvbnMpOlxuICpcbiAqIC5zZXRWYWx1ZSggZ2wsIG5hbWUsIHZhbHVlLCB0ZXh0dXJlcyApXG4gKlxuICogXHRcdHNldHMgdW5pZm9ybSB3aXRoICBuYW1lICduYW1lJyB0byAndmFsdWUnXG4gKlxuICogLnNldE9wdGlvbmFsKCBnbCwgb2JqLCBwcm9wIClcbiAqXG4gKiBcdFx0bGlrZSAuc2V0IGZvciBhbiBvcHRpb25hbCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0XG4gKlxuICovXG5cblxuY29uc3QgZW1wdHlUZXh0dXJlID0gLypAX19QVVJFX18qLyBuZXcgVGV4dHVyZSgpO1xuXG5jb25zdCBlbXB0eVNoYWRvd1RleHR1cmUgPSAvKkBfX1BVUkVfXyovIG5ldyBEZXB0aFRleHR1cmUoIDEsIDEgKTtcbmVtcHR5U2hhZG93VGV4dHVyZS5jb21wYXJlRnVuY3Rpb24gPSBMZXNzRXF1YWxDb21wYXJlO1xuXG5jb25zdCBlbXB0eUFycmF5VGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbmV3IERhdGFBcnJheVRleHR1cmUoKTtcbmNvbnN0IGVtcHR5M2RUZXh0dXJlID0gLypAX19QVVJFX18qLyBuZXcgRGF0YTNEVGV4dHVyZSgpO1xuY29uc3QgZW1wdHlDdWJlVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbmV3IEN1YmVUZXh0dXJlKCk7XG5cbi8vIC0tLSBVdGlsaXRpZXMgLS0tXG5cbi8vIEFycmF5IENhY2hlcyAocHJvdmlkZSB0eXBlZCBhcnJheXMgZm9yIHRlbXBvcmFyeSBieSBzaXplKVxuXG5jb25zdCBhcnJheUNhY2hlRjMyID0gW107XG5jb25zdCBhcnJheUNhY2hlSTMyID0gW107XG5cbi8vIEZsb2F0MzJBcnJheSBjYWNoZXMgdXNlZCBmb3IgdXBsb2FkaW5nIE1hdHJpeCB1bmlmb3Jtc1xuXG5jb25zdCBtYXQ0YXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiApO1xuY29uc3QgbWF0M2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOSApO1xuY29uc3QgbWF0MmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggNCApO1xuXG4vLyBGbGF0dGVuaW5nIGZvciBhcnJheXMgb2YgdmVjdG9ycyBhbmQgbWF0cmljZXNcblxuZnVuY3Rpb24gZmxhdHRlbiggYXJyYXksIG5CbG9ja3MsIGJsb2NrU2l6ZSApIHtcblxuXHRjb25zdCBmaXJzdEVsZW0gPSBhcnJheVsgMCBdO1xuXG5cdGlmICggZmlyc3RFbGVtIDw9IDAgfHwgZmlyc3RFbGVtID4gMCApIHJldHVybiBhcnJheTtcblx0Ly8gdW5vcHRpbWl6ZWQ6ICEgaXNOYU4oIGZpcnN0RWxlbSApXG5cdC8vIHNlZSBodHRwOi8vamFja3NvbmR1bnN0YW4uY29tL2FydGljbGVzLzk4M1xuXG5cdGNvbnN0IG4gPSBuQmxvY2tzICogYmxvY2tTaXplO1xuXHRsZXQgciA9IGFycmF5Q2FjaGVGMzJbIG4gXTtcblxuXHRpZiAoIHIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHIgPSBuZXcgRmxvYXQzMkFycmF5KCBuICk7XG5cdFx0YXJyYXlDYWNoZUYzMlsgbiBdID0gcjtcblxuXHR9XG5cblx0aWYgKCBuQmxvY2tzICE9PSAwICkge1xuXG5cdFx0Zmlyc3RFbGVtLnRvQXJyYXkoIHIsIDAgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMSwgb2Zmc2V0ID0gMDsgaSAhPT0gbkJsb2NrczsgKysgaSApIHtcblxuXHRcdFx0b2Zmc2V0ICs9IGJsb2NrU2l6ZTtcblx0XHRcdGFycmF5WyBpIF0udG9BcnJheSggciwgb2Zmc2V0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiByO1xuXG59XG5cbmZ1bmN0aW9uIGFycmF5c0VxdWFsKCBhLCBiICkge1xuXG5cdGlmICggYS5sZW5ndGggIT09IGIubGVuZ3RoICkgcmV0dXJuIGZhbHNlO1xuXG5cdGZvciAoIGxldCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGlmICggYVsgaSBdICE9PSBiWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdHJldHVybiB0cnVlO1xuXG59XG5cbmZ1bmN0aW9uIGNvcHlBcnJheSggYSwgYiApIHtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBiLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRhWyBpIF0gPSBiWyBpIF07XG5cblx0fVxuXG59XG5cbi8vIFRleHR1cmUgdW5pdCBhbGxvY2F0aW9uXG5cbmZ1bmN0aW9uIGFsbG9jVGV4VW5pdHMoIHRleHR1cmVzLCBuICkge1xuXG5cdGxldCByID0gYXJyYXlDYWNoZUkzMlsgbiBdO1xuXG5cdGlmICggciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0ciA9IG5ldyBJbnQzMkFycmF5KCBuICk7XG5cdFx0YXJyYXlDYWNoZUkzMlsgbiBdID0gcjtcblxuXHR9XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0clsgaSBdID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXG5cdH1cblxuXHRyZXR1cm4gcjtcblxufVxuXG4vLyAtLS0gU2V0dGVycyAtLS1cblxuLy8gTm90ZTogRGVmaW5pbmcgdGhlc2UgbWV0aG9kcyBleHRlcm5hbGx5LCBiZWNhdXNlIHRoZXkgY29tZSBpbiBhIGJ1bmNoXG4vLyBhbmQgdGhpcyB3YXkgdGhlaXIgbmFtZXMgbWluaWZ5LlxuXG4vLyBTaW5nbGUgc2NhbGFyXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjFmKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0aWYgKCBjYWNoZVsgMCBdID09PSB2ICkgcmV0dXJuO1xuXG5cdGdsLnVuaWZvcm0xZiggdGhpcy5hZGRyLCB2ICk7XG5cblx0Y2FjaGVbIDAgXSA9IHY7XG5cbn1cblxuLy8gU2luZ2xlIGZsb2F0IHZlY3RvciAoZnJvbSBmbGF0IGFycmF5IG9yIFRIUkVFLlZlY3Rvck4pXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjJmKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0aWYgKCB2LnggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSApIHtcblxuXHRcdFx0Z2wudW5pZm9ybTJmKCB0aGlzLmFkZHIsIHYueCwgdi55ICk7XG5cblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xuXG5cdFx0Z2wudW5pZm9ybTJmdiggdGhpcy5hZGRyLCB2ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVjNmKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0aWYgKCB2LnggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSB8fCBjYWNoZVsgMiBdICE9PSB2LnogKSB7XG5cblx0XHRcdGdsLnVuaWZvcm0zZiggdGhpcy5hZGRyLCB2LngsIHYueSwgdi56ICk7XG5cblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xuXHRcdFx0Y2FjaGVbIDIgXSA9IHYuejtcblxuXHRcdH1cblxuXHR9IGVsc2UgaWYgKCB2LnIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi5yIHx8IGNhY2hlWyAxIF0gIT09IHYuZyB8fCBjYWNoZVsgMiBdICE9PSB2LmIgKSB7XG5cblx0XHRcdGdsLnVuaWZvcm0zZiggdGhpcy5hZGRyLCB2LnIsIHYuZywgdi5iICk7XG5cblx0XHRcdGNhY2hlWyAwIF0gPSB2LnI7XG5cdFx0XHRjYWNoZVsgMSBdID0gdi5nO1xuXHRcdFx0Y2FjaGVbIDIgXSA9IHYuYjtcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcblxuXHRcdGdsLnVuaWZvcm0zZnYoIHRoaXMuYWRkciwgdiApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdiApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0ZiggZ2wsIHYgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGlmICggdi54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRpZiAoIGNhY2hlWyAwIF0gIT09IHYueCB8fCBjYWNoZVsgMSBdICE9PSB2LnkgfHwgY2FjaGVbIDIgXSAhPT0gdi56IHx8IGNhY2hlWyAzIF0gIT09IHYudyApIHtcblxuXHRcdFx0Z2wudW5pZm9ybTRmKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnosIHYudyApO1xuXG5cdFx0XHRjYWNoZVsgMCBdID0gdi54O1xuXHRcdFx0Y2FjaGVbIDEgXSA9IHYueTtcblx0XHRcdGNhY2hlWyAyIF0gPSB2Lno7XG5cdFx0XHRjYWNoZVsgMyBdID0gdi53O1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xuXG5cdFx0Z2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCB2ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XG5cblx0fVxuXG59XG5cbi8vIFNpbmdsZSBtYXRyaXggKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5NYXRyaXhOKVxuXG5mdW5jdGlvbiBzZXRWYWx1ZU0yKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdGNvbnN0IGVsZW1lbnRzID0gdi5lbGVtZW50cztcblxuXHRpZiAoIGVsZW1lbnRzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xuXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDJmdiggdGhpcy5hZGRyLCBmYWxzZSwgdiApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdiApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgZWxlbWVudHMgKSApIHJldHVybjtcblxuXHRcdG1hdDJhcnJheS5zZXQoIGVsZW1lbnRzICk7XG5cblx0XHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBtYXQyYXJyYXkgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIGVsZW1lbnRzICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlTTMoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgZWxlbWVudHMgPSB2LmVsZW1lbnRzO1xuXG5cdGlmICggZWxlbWVudHMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XG5cblx0XHRnbC51bmlmb3JtTWF0cml4M2Z2KCB0aGlzLmFkZHIsIGZhbHNlLCB2ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCBlbGVtZW50cyApICkgcmV0dXJuO1xuXG5cdFx0bWF0M2FycmF5LnNldCggZWxlbWVudHMgKTtcblxuXHRcdGdsLnVuaWZvcm1NYXRyaXgzZnYoIHRoaXMuYWRkciwgZmFsc2UsIG1hdDNhcnJheSApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgZWxlbWVudHMgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVNNCggZ2wsIHYgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRjb25zdCBlbGVtZW50cyA9IHYuZWxlbWVudHM7XG5cblx0aWYgKCBlbGVtZW50cyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcblxuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIGVsZW1lbnRzICkgKSByZXR1cm47XG5cblx0XHRtYXQ0YXJyYXkuc2V0KCBlbGVtZW50cyApO1xuXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgbWF0NGFycmF5ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCBlbGVtZW50cyApO1xuXG5cdH1cblxufVxuXG4vLyBTaW5nbGUgaW50ZWdlciAvIGJvb2xlYW5cblxuZnVuY3Rpb24gc2V0VmFsdWVWMWkoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRpZiAoIGNhY2hlWyAwIF0gPT09IHYgKSByZXR1cm47XG5cblx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHYgKTtcblxuXHRjYWNoZVsgMCBdID0gdjtcblxufVxuXG4vLyBTaW5nbGUgaW50ZWdlciAvIGJvb2xlYW4gdmVjdG9yIChmcm9tIGZsYXQgYXJyYXkgb3IgVEhSRUUuVmVjdG9yTilcblxuZnVuY3Rpb24gc2V0VmFsdWVWMmkoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYgKCBjYWNoZVsgMCBdICE9PSB2LnggfHwgY2FjaGVbIDEgXSAhPT0gdi55ICkge1xuXG5cdFx0XHRnbC51bmlmb3JtMmkoIHRoaXMuYWRkciwgdi54LCB2LnkgKTtcblxuXHRcdFx0Y2FjaGVbIDAgXSA9IHYueDtcblx0XHRcdGNhY2hlWyAxIF0gPSB2Lnk7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XG5cblx0XHRnbC51bmlmb3JtMml2KCB0aGlzLmFkZHIsIHYgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWM2koIGdsLCB2ICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYgKCBjYWNoZVsgMCBdICE9PSB2LnggfHwgY2FjaGVbIDEgXSAhPT0gdi55IHx8IGNhY2hlWyAyIF0gIT09IHYueiApIHtcblxuXHRcdFx0Z2wudW5pZm9ybTNpKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnogKTtcblxuXHRcdFx0Y2FjaGVbIDAgXSA9IHYueDtcblx0XHRcdGNhY2hlWyAxIF0gPSB2Lnk7XG5cdFx0XHRjYWNoZVsgMiBdID0gdi56O1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xuXG5cdFx0Z2wudW5pZm9ybTNpdiggdGhpcy5hZGRyLCB2ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVjRpKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0aWYgKCB2LnggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSB8fCBjYWNoZVsgMiBdICE9PSB2LnogfHwgY2FjaGVbIDMgXSAhPT0gdi53ICkge1xuXG5cdFx0XHRnbC51bmlmb3JtNGkoIHRoaXMuYWRkciwgdi54LCB2LnksIHYueiwgdi53ICk7XG5cblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xuXHRcdFx0Y2FjaGVbIDIgXSA9IHYuejtcblx0XHRcdGNhY2hlWyAzIF0gPSB2Lnc7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XG5cblx0XHRnbC51bmlmb3JtNGl2KCB0aGlzLmFkZHIsIHYgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcblxuXHR9XG5cbn1cblxuLy8gU2luZ2xlIHVuc2lnbmVkIGludGVnZXJcblxuZnVuY3Rpb24gc2V0VmFsdWVWMXVpKCBnbCwgdiApIHtcblxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0aWYgKCBjYWNoZVsgMCBdID09PSB2ICkgcmV0dXJuO1xuXG5cdGdsLnVuaWZvcm0xdWkoIHRoaXMuYWRkciwgdiApO1xuXG5cdGNhY2hlWyAwIF0gPSB2O1xuXG59XG5cbi8vIFNpbmdsZSB1bnNpZ25lZCBpbnRlZ2VyIHZlY3RvciAoZnJvbSBmbGF0IGFycmF5IG9yIFRIUkVFLlZlY3Rvck4pXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjJ1aSggZ2wsIHYgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGlmICggdi54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRpZiAoIGNhY2hlWyAwIF0gIT09IHYueCB8fCBjYWNoZVsgMSBdICE9PSB2LnkgKSB7XG5cblx0XHRcdGdsLnVuaWZvcm0ydWkoIHRoaXMuYWRkciwgdi54LCB2LnkgKTtcblxuXHRcdFx0Y2FjaGVbIDAgXSA9IHYueDtcblx0XHRcdGNhY2hlWyAxIF0gPSB2Lnk7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XG5cblx0XHRnbC51bmlmb3JtMnVpdiggdGhpcy5hZGRyLCB2ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVjN1aSggZ2wsIHYgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGlmICggdi54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRpZiAoIGNhY2hlWyAwIF0gIT09IHYueCB8fCBjYWNoZVsgMSBdICE9PSB2LnkgfHwgY2FjaGVbIDIgXSAhPT0gdi56ICkge1xuXG5cdFx0XHRnbC51bmlmb3JtM3VpKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnogKTtcblxuXHRcdFx0Y2FjaGVbIDAgXSA9IHYueDtcblx0XHRcdGNhY2hlWyAxIF0gPSB2Lnk7XG5cdFx0XHRjYWNoZVsgMiBdID0gdi56O1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xuXG5cdFx0Z2wudW5pZm9ybTN1aXYoIHRoaXMuYWRkciwgdiApO1xuXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdiApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0dWkoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYgKCBjYWNoZVsgMCBdICE9PSB2LnggfHwgY2FjaGVbIDEgXSAhPT0gdi55IHx8IGNhY2hlWyAyIF0gIT09IHYueiB8fCBjYWNoZVsgMyBdICE9PSB2LncgKSB7XG5cblx0XHRcdGdsLnVuaWZvcm00dWkoIHRoaXMuYWRkciwgdi54LCB2LnksIHYueiwgdi53ICk7XG5cblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xuXHRcdFx0Y2FjaGVbIDIgXSA9IHYuejtcblx0XHRcdGNhY2hlWyAzIF0gPSB2Lnc7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XG5cblx0XHRnbC51bmlmb3JtNHVpdiggdGhpcy5hZGRyLCB2ICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XG5cblx0fVxuXG59XG5cblxuLy8gU2luZ2xlIHRleHR1cmUgKDJEIC8gQ3ViZSlcblxuZnVuY3Rpb24gc2V0VmFsdWVUMSggZ2wsIHYsIHRleHR1cmVzICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblxuXHRpZiAoIGNhY2hlWyAwIF0gIT09IHVuaXQgKSB7XG5cblx0XHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xuXHRcdGNhY2hlWyAwIF0gPSB1bml0O1xuXG5cdH1cblxuXHRjb25zdCBlbXB0eVRleHR1cmUyRCA9ICggdGhpcy50eXBlID09PSBnbC5TQU1QTEVSXzJEX1NIQURPVyApID8gZW1wdHlTaGFkb3dUZXh0dXJlIDogZW1wdHlUZXh0dXJlO1xuXG5cdHRleHR1cmVzLnNldFRleHR1cmUyRCggdiB8fCBlbXB0eVRleHR1cmUyRCwgdW5pdCApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVDNEMSggZ2wsIHYsIHRleHR1cmVzICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblxuXHRpZiAoIGNhY2hlWyAwIF0gIT09IHVuaXQgKSB7XG5cblx0XHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xuXHRcdGNhY2hlWyAwIF0gPSB1bml0O1xuXG5cdH1cblxuXHR0ZXh0dXJlcy5zZXRUZXh0dXJlM0QoIHYgfHwgZW1wdHkzZFRleHR1cmUsIHVuaXQgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVQ2KCBnbCwgdiwgdGV4dHVyZXMgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRjb25zdCB1bml0ID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXG5cdGlmICggY2FjaGVbIDAgXSAhPT0gdW5pdCApIHtcblxuXHRcdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB1bml0ICk7XG5cdFx0Y2FjaGVbIDAgXSA9IHVuaXQ7XG5cblx0fVxuXG5cdHRleHR1cmVzLnNldFRleHR1cmVDdWJlKCB2IHx8IGVtcHR5Q3ViZVRleHR1cmUsIHVuaXQgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVQyREFycmF5MSggZ2wsIHYsIHRleHR1cmVzICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblxuXHRpZiAoIGNhY2hlWyAwIF0gIT09IHVuaXQgKSB7XG5cblx0XHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xuXHRcdGNhY2hlWyAwIF0gPSB1bml0O1xuXG5cdH1cblxuXHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheSggdiB8fCBlbXB0eUFycmF5VGV4dHVyZSwgdW5pdCApO1xuXG59XG5cbi8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIHRoZSBzaW5ndWxhciBjYXNlXG5cbmZ1bmN0aW9uIGdldFNpbmd1bGFyU2V0dGVyKCB0eXBlICkge1xuXG5cdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRjYXNlIDB4MTQwNjogcmV0dXJuIHNldFZhbHVlVjFmOyAvLyBGTE9BVFxuXHRcdGNhc2UgMHg4YjUwOiByZXR1cm4gc2V0VmFsdWVWMmY7IC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhiNTE6IHJldHVybiBzZXRWYWx1ZVYzZjsgLy8gX1ZFQzNcblx0XHRjYXNlIDB4OGI1MjogcmV0dXJuIHNldFZhbHVlVjRmOyAvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZU0yOyAvLyBfTUFUMlxuXHRcdGNhc2UgMHg4YjViOiByZXR1cm4gc2V0VmFsdWVNMzsgLy8gX01BVDNcblx0XHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlTTQ7IC8vIF9NQVQ0XG5cblx0XHRjYXNlIDB4MTQwNDogY2FzZSAweDhiNTY6IHJldHVybiBzZXRWYWx1ZVYxaTsgLy8gSU5ULCBCT09MXG5cdFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWVWMmk7IC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhiNTQ6IGNhc2UgMHg4YjU4OiByZXR1cm4gc2V0VmFsdWVWM2k7IC8vIF9WRUMzXG5cdFx0Y2FzZSAweDhiNTU6IGNhc2UgMHg4YjU5OiByZXR1cm4gc2V0VmFsdWVWNGk7IC8vIF9WRUM0XG5cblx0XHRjYXNlIDB4MTQwNTogcmV0dXJuIHNldFZhbHVlVjF1aTsgLy8gVUlOVFxuXHRcdGNhc2UgMHg4ZGM2OiByZXR1cm4gc2V0VmFsdWVWMnVpOyAvLyBfVkVDMlxuXHRcdGNhc2UgMHg4ZGM3OiByZXR1cm4gc2V0VmFsdWVWM3VpOyAvLyBfVkVDM1xuXHRcdGNhc2UgMHg4ZGM4OiByZXR1cm4gc2V0VmFsdWVWNHVpOyAvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDhiNWU6IC8vIFNBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGQ2NjogLy8gU0FNUExFUl9FWFRFUk5BTF9PRVNcblx0XHRjYXNlIDB4OGRjYTogLy8gSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGRkMjogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGI2MjogLy8gU0FNUExFUl8yRF9TSEFET1dcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQxO1xuXG5cdFx0Y2FzZSAweDhiNWY6IC8vIFNBTVBMRVJfM0Rcblx0XHRjYXNlIDB4OGRjYjogLy8gSU5UX1NBTVBMRVJfM0Rcblx0XHRjYXNlIDB4OGRkMzogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfM0Rcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQzRDE7XG5cblx0XHRjYXNlIDB4OGI2MDogLy8gU0FNUExFUl9DVUJFXG5cdFx0Y2FzZSAweDhkY2M6IC8vIElOVF9TQU1QTEVSX0NVQkVcblx0XHRjYXNlIDB4OGRkNDogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRVxuXHRcdGNhc2UgMHg4ZGM1OiAvLyBTQU1QTEVSX0NVQkVfU0hBRE9XXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUNjtcblxuXHRcdGNhc2UgMHg4ZGMxOiAvLyBTQU1QTEVSXzJEX0FSUkFZXG5cdFx0Y2FzZSAweDhkY2Y6IC8vIElOVF9TQU1QTEVSXzJEX0FSUkFZXG5cdFx0Y2FzZSAweDhkZDc6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEX0FSUkFZXG5cdFx0Y2FzZSAweDhkYzQ6IC8vIFNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUMkRBcnJheTE7XG5cblx0fVxuXG59XG5cblxuLy8gQXJyYXkgb2Ygc2NhbGFyc1xuXG5mdW5jdGlvbiBzZXRWYWx1ZVYxZkFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtMWZ2KCB0aGlzLmFkZHIsIHYgKTtcblxufVxuXG4vLyBBcnJheSBvZiB2ZWN0b3JzIChmcm9tIGZsYXQgYXJyYXkgb3IgYXJyYXkgb2YgVEhSRUUuVmVjdG9yTilcblxuZnVuY3Rpb24gc2V0VmFsdWVWMmZBcnJheSggZ2wsIHYgKSB7XG5cblx0Y29uc3QgZGF0YSA9IGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMiApO1xuXG5cdGdsLnVuaWZvcm0yZnYoIHRoaXMuYWRkciwgZGF0YSApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVjNmQXJyYXkoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGRhdGEgPSBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDMgKTtcblxuXHRnbC51bmlmb3JtM2Z2KCB0aGlzLmFkZHIsIGRhdGEgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0ZkFycmF5KCBnbCwgdiApIHtcblxuXHRjb25zdCBkYXRhID0gZmxhdHRlbiggdiwgdGhpcy5zaXplLCA0ICk7XG5cblx0Z2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCBkYXRhICk7XG5cbn1cblxuLy8gQXJyYXkgb2YgbWF0cmljZXMgKGZyb20gZmxhdCBhcnJheSBvciBhcnJheSBvZiBUSFJFRS5NYXRyaXhOKVxuXG5mdW5jdGlvbiBzZXRWYWx1ZU0yQXJyYXkoIGdsLCB2ICkge1xuXG5cdGNvbnN0IGRhdGEgPSBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDQgKTtcblxuXHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBkYXRhICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVNM0FycmF5KCBnbCwgdiApIHtcblxuXHRjb25zdCBkYXRhID0gZmxhdHRlbiggdiwgdGhpcy5zaXplLCA5ICk7XG5cblx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgZGF0YSApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlTTRBcnJheSggZ2wsIHYgKSB7XG5cblx0Y29uc3QgZGF0YSA9IGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMTYgKTtcblxuXHRnbC51bmlmb3JtTWF0cml4NGZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBkYXRhICk7XG5cbn1cblxuLy8gQXJyYXkgb2YgaW50ZWdlciAvIGJvb2xlYW5cblxuZnVuY3Rpb24gc2V0VmFsdWVWMWlBcnJheSggZ2wsIHYgKSB7XG5cblx0Z2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB2ICk7XG5cbn1cblxuLy8gQXJyYXkgb2YgaW50ZWdlciAvIGJvb2xlYW4gdmVjdG9ycyAoZnJvbSBmbGF0IGFycmF5KVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYyaUFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtMml2KCB0aGlzLmFkZHIsIHYgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYzaUFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtM2l2KCB0aGlzLmFkZHIsIHYgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0aUFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtNGl2KCB0aGlzLmFkZHIsIHYgKTtcblxufVxuXG4vLyBBcnJheSBvZiB1bnNpZ25lZCBpbnRlZ2VyXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjF1aUFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtMXVpdiggdGhpcy5hZGRyLCB2ICk7XG5cbn1cblxuLy8gQXJyYXkgb2YgdW5zaWduZWQgaW50ZWdlciB2ZWN0b3JzIChmcm9tIGZsYXQgYXJyYXkpXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjJ1aUFycmF5KCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtMnVpdiggdGhpcy5hZGRyLCB2ICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWM3VpQXJyYXkoIGdsLCB2ICkge1xuXG5cdGdsLnVuaWZvcm0zdWl2KCB0aGlzLmFkZHIsIHYgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0dWlBcnJheSggZ2wsIHYgKSB7XG5cblx0Z2wudW5pZm9ybTR1aXYoIHRoaXMuYWRkciwgdiApO1xuXG59XG5cblxuLy8gQXJyYXkgb2YgdGV4dHVyZXMgKDJEIC8gM0QgLyBDdWJlIC8gMkRBcnJheSlcblxuZnVuY3Rpb24gc2V0VmFsdWVUMUFycmF5KCBnbCwgdiwgdGV4dHVyZXMgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblxuXHRjb25zdCB1bml0cyA9IGFsbG9jVGV4VW5pdHMoIHRleHR1cmVzLCBuICk7XG5cblx0aWYgKCAhIGFycmF5c0VxdWFsKCBjYWNoZSwgdW5pdHMgKSApIHtcblxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHVuaXRzICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdlsgaSBdIHx8IGVtcHR5VGV4dHVyZSwgdW5pdHNbIGkgXSApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVQzREFycmF5KCBnbCwgdiwgdGV4dHVyZXMgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblxuXHRjb25zdCB1bml0cyA9IGFsbG9jVGV4VW5pdHMoIHRleHR1cmVzLCBuICk7XG5cblx0aWYgKCAhIGFycmF5c0VxdWFsKCBjYWNoZSwgdW5pdHMgKSApIHtcblxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHVuaXRzICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdHRleHR1cmVzLnNldFRleHR1cmUzRCggdlsgaSBdIHx8IGVtcHR5M2RUZXh0dXJlLCB1bml0c1sgaSBdICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVDZBcnJheSggZ2wsIHYsIHRleHR1cmVzICkge1xuXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRjb25zdCBuID0gdi5sZW5ndGg7XG5cblx0Y29uc3QgdW5pdHMgPSBhbGxvY1RleFVuaXRzKCB0ZXh0dXJlcywgbiApO1xuXG5cdGlmICggISBhcnJheXNFcXVhbCggY2FjaGUsIHVuaXRzICkgKSB7XG5cblx0XHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHVuaXRzICk7XG5cblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB1bml0cyApO1xuXG5cdH1cblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlQ3ViZSggdlsgaSBdIHx8IGVtcHR5Q3ViZVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVUMkRBcnJheUFycmF5KCBnbCwgdiwgdGV4dHVyZXMgKSB7XG5cblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblxuXHRjb25zdCB1bml0cyA9IGFsbG9jVGV4VW5pdHMoIHRleHR1cmVzLCBuICk7XG5cblx0aWYgKCAhIGFycmF5c0VxdWFsKCBjYWNoZSwgdW5pdHMgKSApIHtcblxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcblxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHVuaXRzICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdHRleHR1cmVzLnNldFRleHR1cmUyREFycmF5KCB2WyBpIF0gfHwgZW1wdHlBcnJheVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcblxuXHR9XG5cbn1cblxuXG4vLyBIZWxwZXIgdG8gcGljayB0aGUgcmlnaHQgc2V0dGVyIGZvciBhIHB1cmUgKGJvdHRvbS1sZXZlbCkgYXJyYXlcblxuZnVuY3Rpb24gZ2V0UHVyZUFycmF5U2V0dGVyKCB0eXBlICkge1xuXG5cdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRjYXNlIDB4MTQwNjogcmV0dXJuIHNldFZhbHVlVjFmQXJyYXk7IC8vIEZMT0FUXG5cdFx0Y2FzZSAweDhiNTA6IHJldHVybiBzZXRWYWx1ZVYyZkFycmF5OyAvLyBfVkVDMlxuXHRcdGNhc2UgMHg4YjUxOiByZXR1cm4gc2V0VmFsdWVWM2ZBcnJheTsgLy8gX1ZFQzNcblx0XHRjYXNlIDB4OGI1MjogcmV0dXJuIHNldFZhbHVlVjRmQXJyYXk7IC8vIF9WRUM0XG5cblx0XHRjYXNlIDB4OGI1YTogcmV0dXJuIHNldFZhbHVlTTJBcnJheTsgLy8gX01BVDJcblx0XHRjYXNlIDB4OGI1YjogcmV0dXJuIHNldFZhbHVlTTNBcnJheTsgLy8gX01BVDNcblx0XHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlTTRBcnJheTsgLy8gX01BVDRcblxuXHRcdGNhc2UgMHgxNDA0OiBjYXNlIDB4OGI1NjogcmV0dXJuIHNldFZhbHVlVjFpQXJyYXk7IC8vIElOVCwgQk9PTFxuXHRcdGNhc2UgMHg4YjUzOiBjYXNlIDB4OGI1NzogcmV0dXJuIHNldFZhbHVlVjJpQXJyYXk7IC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhiNTQ6IGNhc2UgMHg4YjU4OiByZXR1cm4gc2V0VmFsdWVWM2lBcnJheTsgLy8gX1ZFQzNcblx0XHRjYXNlIDB4OGI1NTogY2FzZSAweDhiNTk6IHJldHVybiBzZXRWYWx1ZVY0aUFycmF5OyAvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDE0MDU6IHJldHVybiBzZXRWYWx1ZVYxdWlBcnJheTsgLy8gVUlOVFxuXHRcdGNhc2UgMHg4ZGM2OiByZXR1cm4gc2V0VmFsdWVWMnVpQXJyYXk7IC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhkYzc6IHJldHVybiBzZXRWYWx1ZVYzdWlBcnJheTsgLy8gX1ZFQzNcblx0XHRjYXNlIDB4OGRjODogcmV0dXJuIHNldFZhbHVlVjR1aUFycmF5OyAvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDhiNWU6IC8vIFNBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGQ2NjogLy8gU0FNUExFUl9FWFRFUk5BTF9PRVNcblx0XHRjYXNlIDB4OGRjYTogLy8gSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGRkMjogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGI2MjogLy8gU0FNUExFUl8yRF9TSEFET1dcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQxQXJyYXk7XG5cblx0XHRjYXNlIDB4OGI1ZjogLy8gU0FNUExFUl8zRFxuXHRcdGNhc2UgMHg4ZGNiOiAvLyBJTlRfU0FNUExFUl8zRFxuXHRcdGNhc2UgMHg4ZGQzOiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl8zRFxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVDNEQXJyYXk7XG5cblx0XHRjYXNlIDB4OGI2MDogLy8gU0FNUExFUl9DVUJFXG5cdFx0Y2FzZSAweDhkY2M6IC8vIElOVF9TQU1QTEVSX0NVQkVcblx0XHRjYXNlIDB4OGRkNDogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRVxuXHRcdGNhc2UgMHg4ZGM1OiAvLyBTQU1QTEVSX0NVQkVfU0hBRE9XXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUNkFycmF5O1xuXG5cdFx0Y2FzZSAweDhkYzE6IC8vIFNBTVBMRVJfMkRfQVJSQVlcblx0XHRjYXNlIDB4OGRjZjogLy8gSU5UX1NBTVBMRVJfMkRfQVJSQVlcblx0XHRjYXNlIDB4OGRkNzogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRfQVJSQVlcblx0XHRjYXNlIDB4OGRjNDogLy8gU0FNUExFUl8yRF9BUlJBWV9TSEFET1dcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQyREFycmF5QXJyYXk7XG5cblx0fVxuXG59XG5cbi8vIC0tLSBVbmlmb3JtIENsYXNzZXMgLS0tXG5cbmNsYXNzIFNpbmdsZVVuaWZvcm0ge1xuXG5cdGNvbnN0cnVjdG9yKCBpZCwgYWN0aXZlSW5mbywgYWRkciApIHtcblxuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLmFkZHIgPSBhZGRyO1xuXHRcdHRoaXMuY2FjaGUgPSBbXTtcblx0XHR0aGlzLnR5cGUgPSBhY3RpdmVJbmZvLnR5cGU7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IGdldFNpbmd1bGFyU2V0dGVyKCBhY3RpdmVJbmZvLnR5cGUgKTtcblxuXHRcdC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcblxuXHR9XG5cbn1cblxuY2xhc3MgUHVyZUFycmF5VW5pZm9ybSB7XG5cblx0Y29uc3RydWN0b3IoIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkge1xuXG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMuYWRkciA9IGFkZHI7XG5cdFx0dGhpcy5jYWNoZSA9IFtdO1xuXHRcdHRoaXMudHlwZSA9IGFjdGl2ZUluZm8udHlwZTtcblx0XHR0aGlzLnNpemUgPSBhY3RpdmVJbmZvLnNpemU7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IGdldFB1cmVBcnJheVNldHRlciggYWN0aXZlSW5mby50eXBlICk7XG5cblx0XHQvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXG5cblx0fVxuXG59XG5cbmNsYXNzIFN0cnVjdHVyZWRVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3RvciggaWQgKSB7XG5cblx0XHR0aGlzLmlkID0gaWQ7XG5cblx0XHR0aGlzLnNlcSA9IFtdO1xuXHRcdHRoaXMubWFwID0ge307XG5cblx0fVxuXG5cdHNldFZhbHVlKCBnbCwgdmFsdWUsIHRleHR1cmVzICkge1xuXG5cdFx0Y29uc3Qgc2VxID0gdGhpcy5zZXE7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCB1ID0gc2VxWyBpIF07XG5cdFx0XHR1LnNldFZhbHVlKCBnbCwgdmFsdWVbIHUuaWQgXSwgdGV4dHVyZXMgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gLS0tIFRvcC1sZXZlbCAtLS1cblxuLy8gUGFyc2VyIC0gYnVpbGRzIHVwIHRoZSBwcm9wZXJ0eSB0cmVlIGZyb20gdGhlIHBhdGggc3RyaW5nc1xuXG5jb25zdCBSZVBhdGhQYXJ0ID0gLyhcXHcrKShcXF0pPyhcXFt8XFwuKT8vZztcblxuLy8gZXh0cmFjdHNcbi8vIFx0LSB0aGUgaWRlbnRpZmllciAobWVtYmVyIG5hbWUgb3IgYXJyYXkgaW5kZXgpXG4vLyAgLSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCByaWdodCBicmFja2V0IChmb3VuZCB3aGVuIGFycmF5IGluZGV4KVxuLy8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgbGVmdCBicmFja2V0IG9yIGRvdCAodHlwZSBvZiBzdWJzY3JpcHQpXG4vL1xuLy8gTm90ZTogVGhlc2UgcG9ydGlvbnMgY2FuIGJlIHJlYWQgaW4gYSBub24tb3ZlcmxhcHBpbmcgZmFzaGlvbiBhbmRcbi8vIGFsbG93IHN0cmFpZ2h0Zm9yd2FyZCBwYXJzaW5nIG9mIHRoZSBoaWVyYXJjaHkgdGhhdCBXZWJHTCBlbmNvZGVzXG4vLyBpbiB0aGUgdW5pZm9ybSBuYW1lcy5cblxuZnVuY3Rpb24gYWRkVW5pZm9ybSggY29udGFpbmVyLCB1bmlmb3JtT2JqZWN0ICkge1xuXG5cdGNvbnRhaW5lci5zZXEucHVzaCggdW5pZm9ybU9iamVjdCApO1xuXHRjb250YWluZXIubWFwWyB1bmlmb3JtT2JqZWN0LmlkIF0gPSB1bmlmb3JtT2JqZWN0O1xuXG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5pZm9ybSggYWN0aXZlSW5mbywgYWRkciwgY29udGFpbmVyICkge1xuXG5cdGNvbnN0IHBhdGggPSBhY3RpdmVJbmZvLm5hbWUsXG5cdFx0cGF0aExlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG5cdC8vIHJlc2V0IFJlZ0V4cCBvYmplY3QsIGJlY2F1c2Ugb2YgdGhlIGVhcmx5IGV4aXQgb2YgYSBwcmV2aW91cyBydW5cblx0UmVQYXRoUGFydC5sYXN0SW5kZXggPSAwO1xuXG5cdHdoaWxlICggdHJ1ZSApIHtcblxuXHRcdGNvbnN0IG1hdGNoID0gUmVQYXRoUGFydC5leGVjKCBwYXRoICksXG5cdFx0XHRtYXRjaEVuZCA9IFJlUGF0aFBhcnQubGFzdEluZGV4O1xuXG5cdFx0bGV0IGlkID0gbWF0Y2hbIDEgXTtcblx0XHRjb25zdCBpZElzSW5kZXggPSBtYXRjaFsgMiBdID09PSAnXScsXG5cdFx0XHRzdWJzY3JpcHQgPSBtYXRjaFsgMyBdO1xuXG5cdFx0aWYgKCBpZElzSW5kZXggKSBpZCA9IGlkIHwgMDsgLy8gY29udmVydCB0byBpbnRlZ2VyXG5cblx0XHRpZiAoIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkIHx8IHN1YnNjcmlwdCA9PT0gJ1snICYmIG1hdGNoRW5kICsgMiA9PT0gcGF0aExlbmd0aCApIHtcblxuXHRcdFx0Ly8gYmFyZSBuYW1lIG9yIFwicHVyZVwiIGJvdHRvbS1sZXZlbCBhcnJheSBcIlswXVwiIHN1ZmZpeFxuXG5cdFx0XHRhZGRVbmlmb3JtKCBjb250YWluZXIsIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0bmV3IFNpbmdsZVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgOlxuXHRcdFx0XHRuZXcgUHVyZUFycmF5VW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSApO1xuXG5cdFx0XHRicmVhaztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIHN0ZXAgaW50byBpbm5lciBub2RlIC8gY3JlYXRlIGl0IGluIGNhc2UgaXQgZG9lc24ndCBleGlzdFxuXG5cdFx0XHRjb25zdCBtYXAgPSBjb250YWluZXIubWFwO1xuXHRcdFx0bGV0IG5leHQgPSBtYXBbIGlkIF07XG5cblx0XHRcdGlmICggbmV4dCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG5leHQgPSBuZXcgU3RydWN0dXJlZFVuaWZvcm0oIGlkICk7XG5cdFx0XHRcdGFkZFVuaWZvcm0oIGNvbnRhaW5lciwgbmV4dCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnRhaW5lciA9IG5leHQ7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8vIFJvb3QgQ29udGFpbmVyXG5cbmNsYXNzIFdlYkdMVW5pZm9ybXMge1xuXG5cdGNvbnN0cnVjdG9yKCBnbCwgcHJvZ3JhbSApIHtcblxuXHRcdHRoaXMuc2VxID0gW107XG5cdFx0dGhpcy5tYXAgPSB7fTtcblxuXHRcdGNvbnN0IG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKCBwcm9ncmFtLCBpICksXG5cdFx0XHRcdGFkZHIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIGluZm8ubmFtZSApO1xuXG5cdFx0XHRwYXJzZVVuaWZvcm0oIGluZm8sIGFkZHIsIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0VmFsdWUoIGdsLCBuYW1lLCB2YWx1ZSwgdGV4dHVyZXMgKSB7XG5cblx0XHRjb25zdCB1ID0gdGhpcy5tYXBbIG5hbWUgXTtcblxuXHRcdGlmICggdSAhPT0gdW5kZWZpbmVkICkgdS5zZXRWYWx1ZSggZ2wsIHZhbHVlLCB0ZXh0dXJlcyApO1xuXG5cdH1cblxuXHRzZXRPcHRpb25hbCggZ2wsIG9iamVjdCwgbmFtZSApIHtcblxuXHRcdGNvbnN0IHYgPSBvYmplY3RbIG5hbWUgXTtcblxuXHRcdGlmICggdiAhPT0gdW5kZWZpbmVkICkgdGhpcy5zZXRWYWx1ZSggZ2wsIG5hbWUsIHYgKTtcblxuXHR9XG5cblx0c3RhdGljIHVwbG9hZCggZ2wsIHNlcSwgdmFsdWVzLCB0ZXh0dXJlcyApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IHUgPSBzZXFbIGkgXSxcblx0XHRcdFx0diA9IHZhbHVlc1sgdS5pZCBdO1xuXG5cdFx0XHRpZiAoIHYubmVlZHNVcGRhdGUgIT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIG5vdGU6IGFsd2F5cyB1cGRhdGluZyB3aGVuIC5uZWVkc1VwZGF0ZSBpcyB1bmRlZmluZWRcblx0XHRcdFx0dS5zZXRWYWx1ZSggZ2wsIHYudmFsdWUsIHRleHR1cmVzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0c3RhdGljIHNlcVdpdGhWYWx1ZSggc2VxLCB2YWx1ZXMgKSB7XG5cblx0XHRjb25zdCByID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCB1ID0gc2VxWyBpIF07XG5cdFx0XHRpZiAoIHUuaWQgaW4gdmFsdWVzICkgci5wdXNoKCB1ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcjtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XG5cblx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XG5cblx0Z2wuc2hhZGVyU291cmNlKCBzaGFkZXIsIHN0cmluZyApO1xuXHRnbC5jb21waWxlU2hhZGVyKCBzaGFkZXIgKTtcblxuXHRyZXR1cm4gc2hhZGVyO1xuXG59XG5cbi8vIEZyb20gaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9LSFJfcGFyYWxsZWxfc2hhZGVyX2NvbXBpbGUvXG5jb25zdCBDT01QTEVUSU9OX1NUQVRVU19LSFIgPSAweDkxQjE7XG5cbmxldCBwcm9ncmFtSWRDb3VudCA9IDA7XG5cbmZ1bmN0aW9uIGhhbmRsZVNvdXJjZSggc3RyaW5nLCBlcnJvckxpbmUgKSB7XG5cblx0Y29uc3QgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XG5cdGNvbnN0IGxpbmVzMiA9IFtdO1xuXG5cdGNvbnN0IGZyb20gPSBNYXRoLm1heCggZXJyb3JMaW5lIC0gNiwgMCApO1xuXHRjb25zdCB0byA9IE1hdGgubWluKCBlcnJvckxpbmUgKyA2LCBsaW5lcy5sZW5ndGggKTtcblxuXHRmb3IgKCBsZXQgaSA9IGZyb207IGkgPCB0bzsgaSArKyApIHtcblxuXHRcdGNvbnN0IGxpbmUgPSBpICsgMTtcblx0XHRsaW5lczIucHVzaCggYCR7bGluZSA9PT0gZXJyb3JMaW5lID8gJz4nIDogJyAnfSAke2xpbmV9OiAke2xpbmVzWyBpIF19YCApO1xuXG5cdH1cblxuXHRyZXR1cm4gbGluZXMyLmpvaW4oICdcXG4nICk7XG5cbn1cblxuZnVuY3Rpb24gZ2V0RW5jb2RpbmdDb21wb25lbnRzKCBjb2xvclNwYWNlICkge1xuXG5cdGNvbnN0IHdvcmtpbmdQcmltYXJpZXMgPSBDb2xvck1hbmFnZW1lbnQuZ2V0UHJpbWFyaWVzKCBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2UgKTtcblx0Y29uc3QgZW5jb2RpbmdQcmltYXJpZXMgPSBDb2xvck1hbmFnZW1lbnQuZ2V0UHJpbWFyaWVzKCBjb2xvclNwYWNlICk7XG5cblx0bGV0IGdhbXV0TWFwcGluZztcblxuXHRpZiAoIHdvcmtpbmdQcmltYXJpZXMgPT09IGVuY29kaW5nUHJpbWFyaWVzICkge1xuXG5cdFx0Z2FtdXRNYXBwaW5nID0gJyc7XG5cblx0fSBlbHNlIGlmICggd29ya2luZ1ByaW1hcmllcyA9PT0gUDNQcmltYXJpZXMgJiYgZW5jb2RpbmdQcmltYXJpZXMgPT09IFJlYzcwOVByaW1hcmllcyApIHtcblxuXHRcdGdhbXV0TWFwcGluZyA9ICdMaW5lYXJEaXNwbGF5UDNUb0xpbmVhclNSR0InO1xuXG5cdH0gZWxzZSBpZiAoIHdvcmtpbmdQcmltYXJpZXMgPT09IFJlYzcwOVByaW1hcmllcyAmJiBlbmNvZGluZ1ByaW1hcmllcyA9PT0gUDNQcmltYXJpZXMgKSB7XG5cblx0XHRnYW11dE1hcHBpbmcgPSAnTGluZWFyU1JHQlRvTGluZWFyRGlzcGxheVAzJztcblxuXHR9XG5cblx0c3dpdGNoICggY29sb3JTcGFjZSApIHtcblxuXHRcdGNhc2UgTGluZWFyU1JHQkNvbG9yU3BhY2U6XG5cdFx0Y2FzZSBMaW5lYXJEaXNwbGF5UDNDb2xvclNwYWNlOlxuXHRcdFx0cmV0dXJuIFsgZ2FtdXRNYXBwaW5nLCAnTGluZWFyVHJhbnNmZXJPRVRGJyBdO1xuXG5cdFx0Y2FzZSBTUkdCQ29sb3JTcGFjZTpcblx0XHRjYXNlIERpc3BsYXlQM0NvbG9yU3BhY2U6XG5cdFx0XHRyZXR1cm4gWyBnYW11dE1hcHBpbmcsICdzUkdCVHJhbnNmZXJPRVRGJyBdO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogVW5zdXBwb3J0ZWQgY29sb3Igc3BhY2U6JywgY29sb3JTcGFjZSApO1xuXHRcdFx0cmV0dXJuIFsgZ2FtdXRNYXBwaW5nLCAnTGluZWFyVHJhbnNmZXJPRVRGJyBdO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBnZXRTaGFkZXJFcnJvcnMoIGdsLCBzaGFkZXIsIHR5cGUgKSB7XG5cblx0Y29uc3Qgc3RhdHVzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICk7XG5cdGNvbnN0IGVycm9ycyA9IGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApLnRyaW0oKTtcblxuXHRpZiAoIHN0YXR1cyAmJiBlcnJvcnMgPT09ICcnICkgcmV0dXJuICcnO1xuXG5cdGNvbnN0IGVycm9yTWF0Y2hlcyA9IC9FUlJPUjogMDooXFxkKykvLmV4ZWMoIGVycm9ycyApO1xuXHRpZiAoIGVycm9yTWF0Y2hlcyApIHtcblxuXHRcdC8vIC0tZW5hYmxlLXByaXZpbGVnZWQtd2ViZ2wtZXh0ZW5zaW9uXG5cdFx0Ly8gY29uc29sZS5sb2coICcqKicgKyB0eXBlICsgJyoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBzaGFkZXIgKSApO1xuXG5cdFx0Y29uc3QgZXJyb3JMaW5lID0gcGFyc2VJbnQoIGVycm9yTWF0Y2hlc1sgMSBdICk7XG5cdFx0cmV0dXJuIHR5cGUudG9VcHBlckNhc2UoKSArICdcXG5cXG4nICsgZXJyb3JzICsgJ1xcblxcbicgKyBoYW5kbGVTb3VyY2UoIGdsLmdldFNoYWRlclNvdXJjZSggc2hhZGVyICksIGVycm9yTGluZSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gZXJyb3JzO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBnZXRUZXhlbEVuY29kaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgY29sb3JTcGFjZSApIHtcblxuXHRjb25zdCBjb21wb25lbnRzID0gZ2V0RW5jb2RpbmdDb21wb25lbnRzKCBjb2xvclNwYWNlICk7XG5cdHJldHVybiBgdmVjNCAke2Z1bmN0aW9uTmFtZX0oIHZlYzQgdmFsdWUgKSB7IHJldHVybiAke2NvbXBvbmVudHNbIDAgXX0oICR7Y29tcG9uZW50c1sgMSBdfSggdmFsdWUgKSApOyB9YDtcblxufVxuXG5mdW5jdGlvbiBnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCBmdW5jdGlvbk5hbWUsIHRvbmVNYXBwaW5nICkge1xuXG5cdGxldCB0b25lTWFwcGluZ05hbWU7XG5cblx0c3dpdGNoICggdG9uZU1hcHBpbmcgKSB7XG5cblx0XHRjYXNlIExpbmVhclRvbmVNYXBwaW5nOlxuXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ0xpbmVhcic7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgUmVpbmhhcmRUb25lTWFwcGluZzpcblx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdSZWluaGFyZCc7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQ2luZW9uVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnT3B0aW1pemVkQ2luZW9uJztcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBBQ0VTRmlsbWljVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnQUNFU0ZpbG1pYyc7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQWdYVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnQWdYJztcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBOZXV0cmFsVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnTmV1dHJhbCc7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQ3VzdG9tVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnQ3VzdG9tJztcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogVW5zdXBwb3J0ZWQgdG9uZU1hcHBpbmc6JywgdG9uZU1hcHBpbmcgKTtcblx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdMaW5lYXInO1xuXG5cdH1cblxuXHRyZXR1cm4gJ3ZlYzMgJyArIGZ1bmN0aW9uTmFtZSArICcoIHZlYzMgY29sb3IgKSB7IHJldHVybiAnICsgdG9uZU1hcHBpbmdOYW1lICsgJ1RvbmVNYXBwaW5nKCBjb2xvciApOyB9JztcblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVZlcnRleEV4dGVuc2lvbnMoIHBhcmFtZXRlcnMgKSB7XG5cblx0Y29uc3QgY2h1bmtzID0gW1xuXHRcdHBhcmFtZXRlcnMuZXh0ZW5zaW9uQ2xpcEN1bGxEaXN0YW5jZSA/ICcjZXh0ZW5zaW9uIEdMX0FOR0xFX2NsaXBfY3VsbF9kaXN0YW5jZSA6IHJlcXVpcmUnIDogJycsXG5cdFx0cGFyYW1ldGVycy5leHRlbnNpb25NdWx0aURyYXcgPyAnI2V4dGVuc2lvbiBHTF9BTkdMRV9tdWx0aV9kcmF3IDogcmVxdWlyZScgOiAnJyxcblx0XTtcblxuXHRyZXR1cm4gY2h1bmtzLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XG5cblx0Y29uc3QgY2h1bmtzID0gW107XG5cblx0Zm9yICggY29uc3QgbmFtZSBpbiBkZWZpbmVzICkge1xuXG5cdFx0Y29uc3QgdmFsdWUgPSBkZWZpbmVzWyBuYW1lIF07XG5cblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG5cdFx0Y2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcblxuXHR9XG5cblx0cmV0dXJuIGNodW5rcy5qb2luKCAnXFxuJyApO1xuXG59XG5cbmZ1bmN0aW9uIGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApIHtcblxuXHRjb25zdCBhdHRyaWJ1dGVzID0ge307XG5cblx0Y29uc3QgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTICk7XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbjsgaSArKyApIHtcblxuXHRcdGNvbnN0IGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIoIHByb2dyYW0sIGkgKTtcblx0XHRjb25zdCBuYW1lID0gaW5mby5uYW1lO1xuXG5cdFx0bGV0IGxvY2F0aW9uU2l6ZSA9IDE7XG5cdFx0aWYgKCBpbmZvLnR5cGUgPT09IGdsLkZMT0FUX01BVDIgKSBsb2NhdGlvblNpemUgPSAyO1xuXHRcdGlmICggaW5mby50eXBlID09PSBnbC5GTE9BVF9NQVQzICkgbG9jYXRpb25TaXplID0gMztcblx0XHRpZiAoIGluZm8udHlwZSA9PT0gZ2wuRkxPQVRfTUFUNCApIGxvY2F0aW9uU2l6ZSA9IDQ7XG5cblx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFZFUlRFWCBBVFRSSUJVVEU6JywgbmFtZSwgaSApO1xuXG5cdFx0YXR0cmlidXRlc1sgbmFtZSBdID0ge1xuXHRcdFx0dHlwZTogaW5mby50eXBlLFxuXHRcdFx0bG9jYXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICksXG5cdFx0XHRsb2NhdGlvblNpemU6IGxvY2F0aW9uU2l6ZVxuXHRcdH07XG5cblx0fVxuXG5cdHJldHVybiBhdHRyaWJ1dGVzO1xuXG59XG5cbmZ1bmN0aW9uIGZpbHRlckVtcHR5TGluZSggc3RyaW5nICkge1xuXG5cdHJldHVybiBzdHJpbmcgIT09ICcnO1xuXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VMaWdodE51bXMoIHN0cmluZywgcGFyYW1ldGVycyApIHtcblxuXHRjb25zdCBudW1TcG90TGlnaHRDb29yZHMgPSBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3MgKyBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodE1hcHMgLSBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcztcblxuXHRyZXR1cm4gc3RyaW5nXG5cdFx0LnJlcGxhY2UoIC9OVU1fRElSX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0cyApXG5cdFx0LnJlcGxhY2UoIC9OVU1fU1BPVF9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1TcG90TGlnaHRzIClcblx0XHQucmVwbGFjZSggL05VTV9TUE9UX0xJR0hUX01BUFMvZywgcGFyYW1ldGVycy5udW1TcG90TGlnaHRNYXBzIClcblx0XHQucmVwbGFjZSggL05VTV9TUE9UX0xJR0hUX0NPT1JEUy9nLCBudW1TcG90TGlnaHRDb29yZHMgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX1JFQ1RfQVJFQV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1SZWN0QXJlYUxpZ2h0cyApXG5cdFx0LnJlcGxhY2UoIC9OVU1fUE9JTlRfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodHMgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX0hFTUlfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtSGVtaUxpZ2h0cyApXG5cdFx0LnJlcGxhY2UoIC9OVU1fRElSX0xJR0hUX1NIQURPV1MvZywgcGFyYW1ldGVycy5udW1EaXJMaWdodFNoYWRvd3MgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRfU0hBRE9XU19XSVRIX01BUFMvZywgcGFyYW1ldGVycy5udW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHMgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRfU0hBRE9XUy9nLCBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3MgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MvZywgcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0U2hhZG93cyApO1xuXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VDbGlwcGluZ1BsYW5lTnVtcyggc3RyaW5nLCBwYXJhbWV0ZXJzICkge1xuXG5cdHJldHVybiBzdHJpbmdcblx0XHQucmVwbGFjZSggL05VTV9DTElQUElOR19QTEFORVMvZywgcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcyApXG5cdFx0LnJlcGxhY2UoIC9VTklPTl9DTElQUElOR19QTEFORVMvZywgKCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzIC0gcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uICkgKTtcblxufVxuXG4vLyBSZXNvbHZlIEluY2x1ZGVzXG5cbmNvbnN0IGluY2x1ZGVQYXR0ZXJuID0gL15bIFxcdF0qI2luY2x1ZGUgKzwoW1xcd1xcZC4vXSspPi9nbTtcblxuZnVuY3Rpb24gcmVzb2x2ZUluY2x1ZGVzKCBzdHJpbmcgKSB7XG5cblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBpbmNsdWRlUGF0dGVybiwgaW5jbHVkZVJlcGxhY2VyICk7XG5cbn1cblxuY29uc3Qgc2hhZGVyQ2h1bmtNYXAgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGluY2x1ZGVSZXBsYWNlciggbWF0Y2gsIGluY2x1ZGUgKSB7XG5cblx0bGV0IHN0cmluZyA9IFNoYWRlckNodW5rWyBpbmNsdWRlIF07XG5cblx0aWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGNvbnN0IG5ld0luY2x1ZGUgPSBzaGFkZXJDaHVua01hcC5nZXQoIGluY2x1ZGUgKTtcblxuXHRcdGlmICggbmV3SW5jbHVkZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzdHJpbmcgPSBTaGFkZXJDaHVua1sgbmV3SW5jbHVkZSBdO1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogU2hhZGVyIGNodW5rIFwiJXNcIiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgXCIlc1wiIGluc3RlYWQuJywgaW5jbHVkZSwgbmV3SW5jbHVkZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2FuIG5vdCByZXNvbHZlICNpbmNsdWRlIDwnICsgaW5jbHVkZSArICc+JyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gcmVzb2x2ZUluY2x1ZGVzKCBzdHJpbmcgKTtcblxufVxuXG4vLyBVbnJvbGwgTG9vcHNcblxuY29uc3QgdW5yb2xsTG9vcFBhdHRlcm4gPSAvI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxccytmb3JcXHMqXFwoXFxzKmludFxccytpXFxzKj1cXHMqKFxcZCspXFxzKjtcXHMqaVxccyo8XFxzKihcXGQrKVxccyo7XFxzKmlcXHMqXFwrXFwrXFxzKlxcKVxccyp7KFtcXHNcXFNdKz8pfVxccysjcHJhZ21hIHVucm9sbF9sb29wX2VuZC9nO1xuXG5mdW5jdGlvbiB1bnJvbGxMb29wcyggc3RyaW5nICkge1xuXG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggdW5yb2xsTG9vcFBhdHRlcm4sIGxvb3BSZXBsYWNlciApO1xuXG59XG5cbmZ1bmN0aW9uIGxvb3BSZXBsYWNlciggbWF0Y2gsIHN0YXJ0LCBlbmQsIHNuaXBwZXQgKSB7XG5cblx0bGV0IHN0cmluZyA9ICcnO1xuXG5cdGZvciAoIGxldCBpID0gcGFyc2VJbnQoIHN0YXJ0ICk7IGkgPCBwYXJzZUludCggZW5kICk7IGkgKysgKSB7XG5cblx0XHRzdHJpbmcgKz0gc25pcHBldFxuXHRcdFx0LnJlcGxhY2UoIC9cXFtcXHMqaVxccypcXF0vZywgJ1sgJyArIGkgKyAnIF0nIClcblx0XHRcdC5yZXBsYWNlKCAvVU5ST0xMRURfTE9PUF9JTkRFWC9nLCBpICk7XG5cblx0fVxuXG5cdHJldHVybiBzdHJpbmc7XG5cbn1cblxuLy9cblxuZnVuY3Rpb24gZ2VuZXJhdGVQcmVjaXNpb24oIHBhcmFtZXRlcnMgKSB7XG5cblx0bGV0IHByZWNpc2lvbnN0cmluZyA9IGBwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gZmxvYXQ7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSBpbnQ7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSBzYW1wbGVyMkQ7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSBzYW1wbGVyQ3ViZTtcblx0cHJlY2lzaW9uICR7cGFyYW1ldGVycy5wcmVjaXNpb259IHNhbXBsZXIzRDtcblx0cHJlY2lzaW9uICR7cGFyYW1ldGVycy5wcmVjaXNpb259IHNhbXBsZXIyREFycmF5O1xuXHRwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gc2FtcGxlcjJEU2hhZG93O1xuXHRwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gc2FtcGxlckN1YmVTaGFkb3c7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSBzYW1wbGVyMkRBcnJheVNoYWRvdztcblx0cHJlY2lzaW9uICR7cGFyYW1ldGVycy5wcmVjaXNpb259IGlzYW1wbGVyMkQ7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSBpc2FtcGxlcjNEO1xuXHRwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gaXNhbXBsZXJDdWJlO1xuXHRwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gaXNhbXBsZXIyREFycmF5O1xuXHRwcmVjaXNpb24gJHtwYXJhbWV0ZXJzLnByZWNpc2lvbn0gdXNhbXBsZXIyRDtcblx0cHJlY2lzaW9uICR7cGFyYW1ldGVycy5wcmVjaXNpb259IHVzYW1wbGVyM0Q7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSB1c2FtcGxlckN1YmU7XG5cdHByZWNpc2lvbiAke3BhcmFtZXRlcnMucHJlY2lzaW9ufSB1c2FtcGxlcjJEQXJyYXk7XG5cdGA7XG5cblx0aWYgKCBwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ2hpZ2hwJyApIHtcblxuXHRcdHByZWNpc2lvbnN0cmluZyArPSAnXFxuI2RlZmluZSBISUdIX1BSRUNJU0lPTic7XG5cblx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5wcmVjaXNpb24gPT09ICdtZWRpdW1wJyApIHtcblxuXHRcdHByZWNpc2lvbnN0cmluZyArPSAnXFxuI2RlZmluZSBNRURJVU1fUFJFQ0lTSU9OJztcblxuXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ2xvd3AnICkge1xuXG5cdFx0cHJlY2lzaW9uc3RyaW5nICs9ICdcXG4jZGVmaW5lIExPV19QUkVDSVNJT04nO1xuXG5cdH1cblxuXHRyZXR1cm4gcHJlY2lzaW9uc3RyaW5nO1xuXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2hhZG93TWFwVHlwZURlZmluZSggcGFyYW1ldGVycyApIHtcblxuXHRsZXQgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XG5cblx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNoYWRvd01hcCApIHtcblxuXHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGJztcblxuXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cblx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRl9TT0ZUJztcblxuXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFZTTVNoYWRvd01hcCApIHtcblxuXHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfVlNNJztcblxuXHR9XG5cblx0cmV0dXJuIHNoYWRvd01hcFR5cGVEZWZpbmU7XG5cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFbnZNYXBUeXBlRGVmaW5lKCBwYXJhbWV0ZXJzICkge1xuXG5cdGxldCBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuXG5cdGlmICggcGFyYW1ldGVycy5lbnZNYXAgKSB7XG5cblx0XHRzd2l0Y2ggKCBwYXJhbWV0ZXJzLmVudk1hcE1vZGUgKSB7XG5cblx0XHRcdGNhc2UgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOlxuXHRcdFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkVfVVYnO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGVudk1hcFR5cGVEZWZpbmU7XG5cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFbnZNYXBNb2RlRGVmaW5lKCBwYXJhbWV0ZXJzICkge1xuXG5cdGxldCBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xuXG5cdGlmICggcGFyYW1ldGVycy5lbnZNYXAgKSB7XG5cblx0XHRzd2l0Y2ggKCBwYXJhbWV0ZXJzLmVudk1hcE1vZGUgKSB7XG5cblx0XHRcdGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuXG5cdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZW52TWFwTW9kZURlZmluZTtcblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVudk1hcEJsZW5kaW5nRGVmaW5lKCBwYXJhbWV0ZXJzICkge1xuXG5cdGxldCBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTk9ORSc7XG5cblx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcblxuXHRcdHN3aXRjaCAoIHBhcmFtZXRlcnMuY29tYmluZSApIHtcblxuXHRcdFx0Y2FzZSBNdWx0aXBseU9wZXJhdGlvbjpcblx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgTWl4T3BlcmF0aW9uOlxuXHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgQWRkT3BlcmF0aW9uOlxuXHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBlbnZNYXBCbGVuZGluZ0RlZmluZTtcblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUN1YmVVVlNpemUoIHBhcmFtZXRlcnMgKSB7XG5cblx0Y29uc3QgaW1hZ2VIZWlnaHQgPSBwYXJhbWV0ZXJzLmVudk1hcEN1YmVVVkhlaWdodDtcblxuXHRpZiAoIGltYWdlSGVpZ2h0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0Y29uc3QgbWF4TWlwID0gTWF0aC5sb2cyKCBpbWFnZUhlaWdodCApIC0gMjtcblxuXHRjb25zdCB0ZXhlbEhlaWdodCA9IDEuMCAvIGltYWdlSGVpZ2h0O1xuXG5cdGNvbnN0IHRleGVsV2lkdGggPSAxLjAgLyAoIDMgKiBNYXRoLm1heCggTWF0aC5wb3coIDIsIG1heE1pcCApLCA3ICogMTYgKSApO1xuXG5cdHJldHVybiB7IHRleGVsV2lkdGgsIHRleGVsSGVpZ2h0LCBtYXhNaXAgfTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjYWNoZUtleSwgcGFyYW1ldGVycywgYmluZGluZ1N0YXRlcyApIHtcblxuXHQvLyBUT0RPIFNlbmQgdGhpcyBldmVudCB0byBUaHJlZS5qcyBEZXZUb29sc1xuXHQvLyBjb25zb2xlLmxvZyggJ1dlYkdMUHJvZ3JhbScsIGNhY2hlS2V5ICk7XG5cblx0Y29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG5cblx0Y29uc3QgZGVmaW5lcyA9IHBhcmFtZXRlcnMuZGVmaW5lcztcblxuXHRsZXQgdmVydGV4U2hhZGVyID0gcGFyYW1ldGVycy52ZXJ0ZXhTaGFkZXI7XG5cdGxldCBmcmFnbWVudFNoYWRlciA9IHBhcmFtZXRlcnMuZnJhZ21lbnRTaGFkZXI7XG5cblx0Y29uc3Qgc2hhZG93TWFwVHlwZURlZmluZSA9IGdlbmVyYXRlU2hhZG93TWFwVHlwZURlZmluZSggcGFyYW1ldGVycyApO1xuXHRjb25zdCBlbnZNYXBUeXBlRGVmaW5lID0gZ2VuZXJhdGVFbnZNYXBUeXBlRGVmaW5lKCBwYXJhbWV0ZXJzICk7XG5cdGNvbnN0IGVudk1hcE1vZGVEZWZpbmUgPSBnZW5lcmF0ZUVudk1hcE1vZGVEZWZpbmUoIHBhcmFtZXRlcnMgKTtcblx0Y29uc3QgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSBnZW5lcmF0ZUVudk1hcEJsZW5kaW5nRGVmaW5lKCBwYXJhbWV0ZXJzICk7XG5cdGNvbnN0IGVudk1hcEN1YmVVVlNpemUgPSBnZW5lcmF0ZUN1YmVVVlNpemUoIHBhcmFtZXRlcnMgKTtcblxuXHRjb25zdCBjdXN0b21WZXJ0ZXhFeHRlbnNpb25zID0gZ2VuZXJhdGVWZXJ0ZXhFeHRlbnNpb25zKCBwYXJhbWV0ZXJzICk7XG5cblx0Y29uc3QgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xuXG5cdGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cblx0bGV0IHByZWZpeFZlcnRleCwgcHJlZml4RnJhZ21lbnQ7XG5cdGxldCB2ZXJzaW9uU3RyaW5nID0gcGFyYW1ldGVycy5nbHNsVmVyc2lvbiA/ICcjdmVyc2lvbiAnICsgcGFyYW1ldGVycy5nbHNsVmVyc2lvbiArICdcXG4nIDogJyc7XG5cblx0aWYgKCBwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRwcmVmaXhWZXJ0ZXggPSBbXG5cblx0XHRcdCcjZGVmaW5lIFNIQURFUl9UWVBFICcgKyBwYXJhbWV0ZXJzLnNoYWRlclR5cGUsXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgcGFyYW1ldGVycy5zaGFkZXJOYW1lLFxuXG5cdFx0XHRjdXN0b21EZWZpbmVzXG5cblx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuXHRcdGlmICggcHJlZml4VmVydGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHByZWZpeFZlcnRleCArPSAnXFxuJztcblxuXHRcdH1cblxuXHRcdHByZWZpeEZyYWdtZW50ID0gW1xuXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfVFlQRSAnICsgcGFyYW1ldGVycy5zaGFkZXJUeXBlLFxuXHRcdFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArIHBhcmFtZXRlcnMuc2hhZGVyTmFtZSxcblxuXHRcdFx0Y3VzdG9tRGVmaW5lc1xuXG5cdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cblx0XHRpZiAoIHByZWZpeEZyYWdtZW50Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHByZWZpeEZyYWdtZW50ICs9ICdcXG4nO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRwcmVmaXhWZXJ0ZXggPSBbXG5cblx0XHRcdGdlbmVyYXRlUHJlY2lzaW9uKCBwYXJhbWV0ZXJzICksXG5cblx0XHRcdCcjZGVmaW5lIFNIQURFUl9UWVBFICcgKyBwYXJhbWV0ZXJzLnNoYWRlclR5cGUsXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgcGFyYW1ldGVycy5zaGFkZXJOYW1lLFxuXG5cdFx0XHRjdXN0b21EZWZpbmVzLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmV4dGVuc2lvbkNsaXBDdWxsRGlzdGFuY2UgPyAnI2RlZmluZSBVU0VfQ0xJUF9ESVNUQU5DRScgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYmF0Y2hpbmcgPyAnI2RlZmluZSBVU0VfQkFUQ0hJTkcnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmJhdGNoaW5nQ29sb3IgPyAnI2RlZmluZSBVU0VfQkFUQ0hJTkdfQ09MT1InIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmluc3RhbmNpbmcgPyAnI2RlZmluZSBVU0VfSU5TVEFOQ0lORycgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yID8gJyNkZWZpbmUgVVNFX0lOU1RBTkNJTkdfQ09MT1InIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmluc3RhbmNpbmdNb3JwaCA/ICcjZGVmaW5lIFVTRV9JTlNUQU5DSU5HX01PUlBIJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cDIgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwT2JqZWN0U3BhY2UgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQX09CSkVDVFNQQUNFJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXBUYW5nZW50U3BhY2UgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRScgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwID8gJyNkZWZpbmUgVVNFX0RJU1BMQUNFTUVOVE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuYW5pc290cm9weSA/ICcjZGVmaW5lIFVTRV9BTklTT1RST1BZJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hbmlzb3Ryb3B5TWFwID8gJyNkZWZpbmUgVVNFX0FOSVNPVFJPUFlNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0TWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmNsZWFyY29hdE5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlTWFwID8gJyNkZWZpbmUgVVNFX0lSSURFU0NFTkNFTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJfQ09MT1JNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFySW50ZW5zaXR5TWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFIYXNoID8gJyNkZWZpbmUgVVNFX0FMUEhBSEFTSCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy50cmFuc21pc3Npb24gPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy50cmFuc21pc3Npb25NYXAgPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy50aGlja25lc3NNYXAgPyAnI2RlZmluZSBVU0VfVEhJQ0tORVNTTUFQJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNoZWVuQ29sb3JNYXAgPyAnI2RlZmluZSBVU0VfU0hFRU5fQ09MT1JNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNoZWVuUm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1NIRUVOX1JPVUdITkVTU01BUCcgOiAnJyxcblxuXHRcdFx0Ly9cblxuXHRcdFx0cGFyYW1ldGVycy5tYXBVdiA/ICcjZGVmaW5lIE1BUF9VViAnICsgcGFyYW1ldGVycy5tYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcFV2ID8gJyNkZWZpbmUgQUxQSEFNQVBfVVYgJyArIHBhcmFtZXRlcnMuYWxwaGFNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5saWdodE1hcFV2ID8gJyNkZWZpbmUgTElHSFRNQVBfVVYgJyArIHBhcmFtZXRlcnMubGlnaHRNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hb01hcFV2ID8gJyNkZWZpbmUgQU9NQVBfVVYgJyArIHBhcmFtZXRlcnMuYW9NYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcFV2ID8gJyNkZWZpbmUgRU1JU1NJVkVNQVBfVVYgJyArIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5idW1wTWFwVXYgPyAnI2RlZmluZSBCVU1QTUFQX1VWICcgKyBwYXJhbWV0ZXJzLmJ1bXBNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXBVdiA/ICcjZGVmaW5lIE5PUk1BTE1BUF9VViAnICsgcGFyYW1ldGVycy5ub3JtYWxNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXBVdiA/ICcjZGVmaW5lIERJU1BMQUNFTUVOVE1BUF9VViAnICsgcGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXBVdiA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcFV2ID8gJyNkZWZpbmUgTUVUQUxORVNTTUFQX1VWICcgKyBwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcFV2IDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcFV2ID8gJyNkZWZpbmUgUk9VR0hORVNTTUFQX1VWICcgKyBwYXJhbWV0ZXJzLnJvdWdobmVzc01hcFV2IDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuYW5pc290cm9weU1hcFV2ID8gJyNkZWZpbmUgQU5JU09UUk9QWU1BUF9VViAnICsgcGFyYW1ldGVycy5hbmlzb3Ryb3B5TWFwVXYgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXRNYXBVdiA/ICcjZGVmaW5lIENMRUFSQ09BVE1BUF9VViAnICsgcGFyYW1ldGVycy5jbGVhcmNvYXRNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXROb3JtYWxNYXBVdiA/ICcjZGVmaW5lIENMRUFSQ09BVF9OT1JNQUxNQVBfVVYgJyArIHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwVXYgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwVXYgPyAnI2RlZmluZSBDTEVBUkNPQVRfUk9VR0hORVNTTUFQX1VWICcgKyBwYXJhbWV0ZXJzLmNsZWFyY29hdFJvdWdobmVzc01hcFV2IDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VNYXBVdiA/ICcjZGVmaW5lIElSSURFU0NFTkNFTUFQX1VWICcgKyBwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlTWFwVXYgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdiA/ICcjZGVmaW5lIElSSURFU0NFTkNFX1RISUNLTkVTU01BUF9VViAnICsgcGFyYW1ldGVycy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2IDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuc2hlZW5Db2xvck1hcFV2ID8gJyNkZWZpbmUgU0hFRU5fQ09MT1JNQVBfVVYgJyArIHBhcmFtZXRlcnMuc2hlZW5Db2xvck1hcFV2IDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNoZWVuUm91Z2huZXNzTWFwVXYgPyAnI2RlZmluZSBTSEVFTl9ST1VHSE5FU1NNQVBfVVYgJyArIHBhcmFtZXRlcnMuc2hlZW5Sb3VnaG5lc3NNYXBVdiA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwVXYgPyAnI2RlZmluZSBTUEVDVUxBUk1BUF9VViAnICsgcGFyYW1ldGVycy5zcGVjdWxhck1hcFV2IDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXBVdiA/ICcjZGVmaW5lIFNQRUNVTEFSX0NPTE9STUFQX1VWICcgKyBwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhckludGVuc2l0eU1hcFV2ID8gJyNkZWZpbmUgU1BFQ1VMQVJfSU5URU5TSVRZTUFQX1VWICcgKyBwYXJhbWV0ZXJzLnNwZWN1bGFySW50ZW5zaXR5TWFwVXYgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy50cmFuc21pc3Npb25NYXBVdiA/ICcjZGVmaW5lIFRSQU5TTUlTU0lPTk1BUF9VViAnICsgcGFyYW1ldGVycy50cmFuc21pc3Npb25NYXBVdiA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy50aGlja25lc3NNYXBVdiA/ICcjZGVmaW5lIFRISUNLTkVTU01BUF9VViAnICsgcGFyYW1ldGVycy50aGlja25lc3NNYXBVdiA6ICcnLFxuXG5cdFx0XHQvL1xuXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleFRhbmdlbnRzICYmIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPT09IGZhbHNlID8gJyNkZWZpbmUgVVNFX1RBTkdFTlQnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4QWxwaGFzID8gJyNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhVdjFzID8gJyNkZWZpbmUgVVNFX1VWMScgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4VXYycyA/ICcjZGVmaW5lIFVTRV9VVjInIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleFV2M3MgPyAnI2RlZmluZSBVU0VfVVYzJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnBvaW50c1V2cyA/ICcjZGVmaW5lIFVTRV9QT0lOVFNfVVYnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5za2lubmluZyA/ICcjZGVmaW5lIFVTRV9TS0lOTklORycgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPyAnI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTJyA6ICcnLFxuXHRcdFx0KCBwYXJhbWV0ZXJzLm1vcnBoQ29sb3JzICkgPyAnI2RlZmluZSBVU0VfTU9SUEhDT0xPUlMnIDogJycsXG5cdFx0XHQoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgPiAwICkgPyAnI2RlZmluZSBNT1JQSFRBUkdFVFNfVEVYVFVSRV9TVFJJREUgJyArIHBhcmFtZXRlcnMubW9ycGhUZXh0dXJlU3RyaWRlIDogJycsXG5cdFx0XHQoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgPiAwICkgPyAnI2RlZmluZSBNT1JQSFRBUkdFVFNfQ09VTlQgJyArIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMubnVtTGlnaHRQcm9iZXMgPiAwID8gJyNkZWZpbmUgVVNFX0xJR0hUX1BST0JFUycgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxuXG5cdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7Jyxcblx0XHRcdCd1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXG5cdFx0XHQndW5pZm9ybSBib29sIGlzT3J0aG9ncmFwaGljOycsXG5cblx0XHRcdCcjaWZkZWYgVVNFX0lOU1RBTkNJTkcnLFxuXG5cdFx0XHQnXHRhdHRyaWJ1dGUgbWF0NCBpbnN0YW5jZU1hdHJpeDsnLFxuXG5cdFx0XHQnI2VuZGlmJyxcblxuXHRcdFx0JyNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUicsXG5cblx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlQ29sb3I7JyxcblxuXHRcdFx0JyNlbmRpZicsXG5cblx0XHRcdCcjaWZkZWYgVVNFX0lOU1RBTkNJTkdfTU9SUEgnLFxuXG5cdFx0XHQnXHR1bmlmb3JtIHNhbXBsZXIyRCBtb3JwaFRleHR1cmU7JyxcblxuXHRcdFx0JyNlbmRpZicsXG5cblx0XHRcdCdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxuXHRcdFx0J2F0dHJpYnV0ZSB2ZWMzIG5vcm1hbDsnLFxuXHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cblx0XHRcdCcjaWZkZWYgVVNFX1VWMScsXG5cblx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMyIHV2MTsnLFxuXG5cdFx0XHQnI2VuZGlmJyxcblxuXHRcdFx0JyNpZmRlZiBVU0VfVVYyJyxcblxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzIgdXYyOycsXG5cblx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHQnI2lmZGVmIFVTRV9VVjMnLFxuXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMiB1djM7JyxcblxuXHRcdFx0JyNlbmRpZicsXG5cblx0XHRcdCcjaWZkZWYgVVNFX1RBTkdFTlQnLFxuXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjNCB0YW5nZW50OycsXG5cblx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHQnI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApJyxcblxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgY29sb3I7JyxcblxuXHRcdFx0JyNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApJyxcblxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgY29sb3I7JyxcblxuXHRcdFx0JyNlbmRpZicsXG5cblx0XHRcdCcjaWZkZWYgVVNFX1NLSU5OSU5HJyxcblxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OycsXG5cblx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHQnXFxuJ1xuXG5cdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cblx0XHRwcmVmaXhGcmFnbWVudCA9IFtcblxuXHRcdFx0Z2VuZXJhdGVQcmVjaXNpb24oIHBhcmFtZXRlcnMgKSxcblxuXHRcdFx0JyNkZWZpbmUgU0hBREVSX1RZUEUgJyArIHBhcmFtZXRlcnMuc2hhZGVyVHlwZSxcblx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBwYXJhbWV0ZXJzLnNoYWRlck5hbWUsXG5cblx0XHRcdGN1c3RvbURlZmluZXMsXG5cblx0XHRcdHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwMiA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmFscGhhVG9Db3ZlcmFnZSA/ICcjZGVmaW5lIEFMUEhBX1RPX0NPVkVSQUdFJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5tYXRjYXAgPyAnI2RlZmluZSBVU0VfTUFUQ0FQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwVHlwZURlZmluZSA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwQmxlbmRpbmdEZWZpbmUgOiAnJyxcblx0XHRcdGVudk1hcEN1YmVVVlNpemUgPyAnI2RlZmluZSBDVUJFVVZfVEVYRUxfV0lEVEggJyArIGVudk1hcEN1YmVVVlNpemUudGV4ZWxXaWR0aCA6ICcnLFxuXHRcdFx0ZW52TWFwQ3ViZVVWU2l6ZSA/ICcjZGVmaW5lIENVQkVVVl9URVhFTF9IRUlHSFQgJyArIGVudk1hcEN1YmVVVlNpemUudGV4ZWxIZWlnaHQgOiAnJyxcblx0XHRcdGVudk1hcEN1YmVVVlNpemUgPyAnI2RlZmluZSBDVUJFVVZfTUFYX01JUCAnICsgZW52TWFwQ3ViZVVWU2l6ZS5tYXhNaXAgKyAnLjAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXBPYmplY3RTcGFjZSA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVBfT0JKRUNUU1BBQ0UnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcFRhbmdlbnRTcGFjZSA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5hbmlzb3Ryb3B5ID8gJyNkZWZpbmUgVVNFX0FOSVNPVFJPUFknIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmFuaXNvdHJvcHlNYXAgPyAnI2RlZmluZSBVU0VfQU5JU09UUk9QWU1BUCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXQgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXRNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuZGlzcGVyc2lvbiA/ICcjZGVmaW5lIFVTRV9ESVNQRVJTSU9OJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlID8gJyNkZWZpbmUgVVNFX0lSSURFU0NFTkNFJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5pcmlkZXNjZW5jZU1hcCA/ICcjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPyAnI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhckNvbG9yTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSX0NPTE9STUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhckludGVuc2l0eU1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMucm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1JPVUdITkVTU01BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgVVNFX0FMUEhBVEVTVCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFIYXNoID8gJyNkZWZpbmUgVVNFX0FMUEhBSEFTSCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5zaGVlbiA/ICcjZGVmaW5lIFVTRV9TSEVFTicgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuc2hlZW5Db2xvck1hcCA/ICcjZGVmaW5lIFVTRV9TSEVFTl9DT0xPUk1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuc2hlZW5Sb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfU0hFRU5fUk9VR0hORVNTTUFQJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbiA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT04nIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbk1hcCA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnRoaWNrbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9USElDS05FU1NNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMudmVydGV4VGFuZ2VudHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfVEFOR0VOVCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzIHx8IHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yIHx8IHBhcmFtZXRlcnMuYmF0Y2hpbmdDb2xvciA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4QWxwaGFzID8gJyNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhVdjFzID8gJyNkZWZpbmUgVVNFX1VWMScgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4VXYycyA/ICcjZGVmaW5lIFVTRV9VVjInIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleFV2M3MgPyAnI2RlZmluZSBVU0VfVVYzJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnBvaW50c1V2cyA/ICcjZGVmaW5lIFVTRV9QT0lOVFNfVVYnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuZ3JhZGllbnRNYXAgPyAnI2RlZmluZSBVU0VfR1JBRElFTlRNQVAnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhID8gJyNkZWZpbmUgUFJFTVVMVElQTElFRF9BTFBIQScgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5udW1MaWdodFByb2JlcyA+IDAgPyAnI2RlZmluZSBVU0VfTElHSFRfUFJPQkVTJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmRlY29kZVZpZGVvVGV4dHVyZSA/ICcjZGVmaW5lIERFQ09ERV9WSURFT19URVhUVVJFJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG5cblx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXHRcdFx0J3VuaWZvcm0gYm9vbCBpc09ydGhvZ3JhcGhpYzsnLFxuXG5cdFx0XHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/ICcjZGVmaW5lIFRPTkVfTUFQUElORycgOiAnJyxcblx0XHRcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gU2hhZGVyQ2h1bmtbICd0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50JyBdIDogJycsIC8vIHRoaXMgY29kZSBpcyByZXF1aXJlZCBoZXJlIGJlY2F1c2UgaXQgaXMgdXNlZCBieSB0aGUgdG9uZU1hcHBpbmcoKSBmdW5jdGlvbiBkZWZpbmVkIGJlbG93XG5cdFx0XHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/IGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oICd0b25lTWFwcGluZycsIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgKSA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmRpdGhlcmluZyA/ICcjZGVmaW5lIERJVEhFUklORycgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMub3BhcXVlID8gJyNkZWZpbmUgT1BBUVVFJyA6ICcnLFxuXG5cdFx0XHRTaGFkZXJDaHVua1sgJ2NvbG9yc3BhY2VfcGFyc19mcmFnbWVudCcgXSwgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB2YXJpb3VzIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcblx0XHRcdGdldFRleGVsRW5jb2RpbmdGdW5jdGlvbiggJ2xpbmVhclRvT3V0cHV0VGV4ZWwnLCBwYXJhbWV0ZXJzLm91dHB1dENvbG9yU3BhY2UgKSxcblxuXHRcdFx0cGFyYW1ldGVycy51c2VEZXB0aFBhY2tpbmcgPyAnI2RlZmluZSBERVBUSF9QQUNLSU5HICcgKyBwYXJhbWV0ZXJzLmRlcHRoUGFja2luZyA6ICcnLFxuXG5cdFx0XHQnXFxuJ1xuXG5cdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cblx0fVxuXG5cdHZlcnRleFNoYWRlciA9IHJlc29sdmVJbmNsdWRlcyggdmVydGV4U2hhZGVyICk7XG5cdHZlcnRleFNoYWRlciA9IHJlcGxhY2VMaWdodE51bXMoIHZlcnRleFNoYWRlciwgcGFyYW1ldGVycyApO1xuXHR2ZXJ0ZXhTaGFkZXIgPSByZXBsYWNlQ2xpcHBpbmdQbGFuZU51bXMoIHZlcnRleFNoYWRlciwgcGFyYW1ldGVycyApO1xuXG5cdGZyYWdtZW50U2hhZGVyID0gcmVzb2x2ZUluY2x1ZGVzKCBmcmFnbWVudFNoYWRlciApO1xuXHRmcmFnbWVudFNoYWRlciA9IHJlcGxhY2VMaWdodE51bXMoIGZyYWdtZW50U2hhZGVyLCBwYXJhbWV0ZXJzICk7XG5cdGZyYWdtZW50U2hhZGVyID0gcmVwbGFjZUNsaXBwaW5nUGxhbmVOdW1zKCBmcmFnbWVudFNoYWRlciwgcGFyYW1ldGVycyApO1xuXG5cdHZlcnRleFNoYWRlciA9IHVucm9sbExvb3BzKCB2ZXJ0ZXhTaGFkZXIgKTtcblx0ZnJhZ21lbnRTaGFkZXIgPSB1bnJvbGxMb29wcyggZnJhZ21lbnRTaGFkZXIgKTtcblxuXHRpZiAoIHBhcmFtZXRlcnMuaXNSYXdTaGFkZXJNYXRlcmlhbCAhPT0gdHJ1ZSApIHtcblxuXHRcdC8vIEdMU0wgMy4wIGNvbnZlcnNpb24gZm9yIGJ1aWx0LWluIG1hdGVyaWFscyBhbmQgU2hhZGVyTWF0ZXJpYWxcblxuXHRcdHZlcnNpb25TdHJpbmcgPSAnI3ZlcnNpb24gMzAwIGVzXFxuJztcblxuXHRcdHByZWZpeFZlcnRleCA9IFtcblx0XHRcdGN1c3RvbVZlcnRleEV4dGVuc2lvbnMsXG5cdFx0XHQnI2RlZmluZSBhdHRyaWJ1dGUgaW4nLFxuXHRcdFx0JyNkZWZpbmUgdmFyeWluZyBvdXQnLFxuXHRcdFx0JyNkZWZpbmUgdGV4dHVyZTJEIHRleHR1cmUnXG5cdFx0XS5qb2luKCAnXFxuJyApICsgJ1xcbicgKyBwcmVmaXhWZXJ0ZXg7XG5cblx0XHRwcmVmaXhGcmFnbWVudCA9IFtcblx0XHRcdCcjZGVmaW5lIHZhcnlpbmcgaW4nLFxuXHRcdFx0KCBwYXJhbWV0ZXJzLmdsc2xWZXJzaW9uID09PSBHTFNMMyApID8gJycgOiAnbGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IGhpZ2hwIHZlYzQgcGNfZnJhZ0NvbG9yOycsXG5cdFx0XHQoIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPT09IEdMU0wzICkgPyAnJyA6ICcjZGVmaW5lIGdsX0ZyYWdDb2xvciBwY19mcmFnQ29sb3InLFxuXHRcdFx0JyNkZWZpbmUgZ2xfRnJhZ0RlcHRoRVhUIGdsX0ZyYWdEZXB0aCcsXG5cdFx0XHQnI2RlZmluZSB0ZXh0dXJlMkQgdGV4dHVyZScsXG5cdFx0XHQnI2RlZmluZSB0ZXh0dXJlQ3ViZSB0ZXh0dXJlJyxcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyRFByb2ogdGV4dHVyZVByb2onLFxuXHRcdFx0JyNkZWZpbmUgdGV4dHVyZTJETG9kRVhUIHRleHR1cmVMb2QnLFxuXHRcdFx0JyNkZWZpbmUgdGV4dHVyZTJEUHJvakxvZEVYVCB0ZXh0dXJlUHJvakxvZCcsXG5cdFx0XHQnI2RlZmluZSB0ZXh0dXJlQ3ViZUxvZEVYVCB0ZXh0dXJlTG9kJyxcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyREdyYWRFWFQgdGV4dHVyZUdyYWQnLFxuXHRcdFx0JyNkZWZpbmUgdGV4dHVyZTJEUHJvakdyYWRFWFQgdGV4dHVyZVByb2pHcmFkJyxcblx0XHRcdCcjZGVmaW5lIHRleHR1cmVDdWJlR3JhZEVYVCB0ZXh0dXJlR3JhZCdcblx0XHRdLmpvaW4oICdcXG4nICkgKyAnXFxuJyArIHByZWZpeEZyYWdtZW50O1xuXG5cdH1cblxuXHRjb25zdCB2ZXJ0ZXhHbHNsID0gdmVyc2lvblN0cmluZyArIHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcblx0Y29uc3QgZnJhZ21lbnRHbHNsID0gdmVyc2lvblN0cmluZyArIHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XG5cblx0Ly8gY29uc29sZS5sb2coICcqVkVSVEVYKicsIHZlcnRleEdsc2wgKTtcblx0Ly8gY29uc29sZS5sb2coICcqRlJBR01FTlQqJywgZnJhZ21lbnRHbHNsICk7XG5cblx0Y29uc3QgZ2xWZXJ0ZXhTaGFkZXIgPSBXZWJHTFNoYWRlciggZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wgKTtcblx0Y29uc3QgZ2xGcmFnbWVudFNoYWRlciA9IFdlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcblxuXHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XG5cdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xuXG5cdC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cblxuXHRpZiAoIHBhcmFtZXRlcnMuaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBwYXJhbWV0ZXJzLmluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcblxuXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdC8vIHByb2dyYW1zIHdpdGggbW9ycGhUYXJnZXRzIGRpc3BsYWNlIHBvc2l0aW9uIG91dCBvZiBhdHRyaWJ1dGUgMFxuXHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyApO1xuXG5cdH1cblxuXHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG5cdGZ1bmN0aW9uIG9uRmlyc3RVc2UoIHNlbGYgKSB7XG5cblx0XHQvLyBjaGVjayBmb3IgbGluayBlcnJvcnNcblx0XHRpZiAoIHJlbmRlcmVyLmRlYnVnLmNoZWNrU2hhZGVyRXJyb3JzICkge1xuXG5cdFx0XHRjb25zdCBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKS50cmltKCk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXhMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbFZlcnRleFNoYWRlciApLnRyaW0oKTtcblx0XHRcdGNvbnN0IGZyYWdtZW50TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xGcmFnbWVudFNoYWRlciApLnRyaW0oKTtcblxuXHRcdFx0bGV0IHJ1bm5hYmxlID0gdHJ1ZTtcblx0XHRcdGxldCBoYXZlRGlhZ25vc3RpY3MgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdHJ1bm5hYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKCB0eXBlb2YgcmVuZGVyZXIuZGVidWcub25TaGFkZXJFcnJvciA9PT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdFx0XHRcdHJlbmRlcmVyLmRlYnVnLm9uU2hhZGVyRXJyb3IoIGdsLCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciwgZ2xGcmFnbWVudFNoYWRlciApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBkZWZhdWx0IGVycm9yIHJlcG9ydGluZ1xuXG5cdFx0XHRcdFx0Y29uc3QgdmVydGV4RXJyb3JzID0gZ2V0U2hhZGVyRXJyb3JzKCBnbCwgZ2xWZXJ0ZXhTaGFkZXIsICd2ZXJ0ZXgnICk7XG5cdFx0XHRcdFx0Y29uc3QgZnJhZ21lbnRFcnJvcnMgPSBnZXRTaGFkZXJFcnJvcnMoIGdsLCBnbEZyYWdtZW50U2hhZGVyLCAnZnJhZ21lbnQnICk7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRcdFx0J1RIUkVFLldlYkdMUHJvZ3JhbTogU2hhZGVyIEVycm9yICcgKyBnbC5nZXRFcnJvcigpICsgJyAtICcgK1xuXHRcdFx0XHRcdFx0J1ZBTElEQVRFX1NUQVRVUyAnICsgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTICkgKyAnXFxuXFxuJyArXG5cdFx0XHRcdFx0XHQnTWF0ZXJpYWwgTmFtZTogJyArIHNlbGYubmFtZSArICdcXG4nICtcblx0XHRcdFx0XHRcdCdNYXRlcmlhbCBUeXBlOiAnICsgc2VsZi50eXBlICsgJ1xcblxcbicgK1xuXHRcdFx0XHRcdFx0J1Byb2dyYW0gSW5mbyBMb2c6ICcgKyBwcm9ncmFtTG9nICsgJ1xcbicgK1xuXHRcdFx0XHRcdFx0dmVydGV4RXJyb3JzICsgJ1xcbicgK1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRFcnJvcnNcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBQcm9ncmFtIEluZm8gTG9nOicsIHByb2dyYW1Mb2cgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XG5cblx0XHRcdFx0aGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XG5cblx0XHRcdFx0c2VsZi5kaWFnbm9zdGljcyA9IHtcblxuXHRcdFx0XHRcdHJ1bm5hYmxlOiBydW5uYWJsZSxcblxuXHRcdFx0XHRcdHByb2dyYW1Mb2c6IHByb2dyYW1Mb2csXG5cblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHtcblxuXHRcdFx0XHRcdFx0bG9nOiB2ZXJ0ZXhMb2csXG5cdFx0XHRcdFx0XHRwcmVmaXg6IHByZWZpeFZlcnRleFxuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiB7XG5cblx0XHRcdFx0XHRcdGxvZzogZnJhZ21lbnRMb2csXG5cdFx0XHRcdFx0XHRwcmVmaXg6IHByZWZpeEZyYWdtZW50XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYW4gdXBcblxuXHRcdC8vIENyYXNoZXMgaW4gaU9TOSBhbmQgaU9TMTAuICMxODQwMlxuXHRcdC8vIGdsLmRldGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcblx0XHQvLyBnbC5kZXRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdGdsLmRlbGV0ZVNoYWRlciggZ2xWZXJ0ZXhTaGFkZXIgKTtcblx0XHRnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdGNhY2hlZFVuaWZvcm1zID0gbmV3IFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtICk7XG5cdFx0Y2FjaGVkQXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xuXG5cdH1cblxuXHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgdW5pZm9ybSBsb2NhdGlvbnNcblxuXHRsZXQgY2FjaGVkVW5pZm9ybXM7XG5cblx0dGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggY2FjaGVkVW5pZm9ybXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gUG9wdWxhdGVzIGNhY2hlZFVuaWZvcm1zIGFuZCBjYWNoZWRBdHRyaWJ1dGVzXG5cdFx0XHRvbkZpcnN0VXNlKCB0aGlzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2FjaGVkVW5pZm9ybXM7XG5cblx0fTtcblxuXHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgYXR0cmlidXRlIGxvY2F0aW9uc1xuXG5cdGxldCBjYWNoZWRBdHRyaWJ1dGVzO1xuXG5cdHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggY2FjaGVkQXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBQb3B1bGF0ZXMgY2FjaGVkQXR0cmlidXRlcyBhbmQgY2FjaGVkVW5pZm9ybXNcblx0XHRcdG9uRmlyc3RVc2UoIHRoaXMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBjYWNoZWRBdHRyaWJ1dGVzO1xuXG5cdH07XG5cblx0Ly8gaW5kaWNhdGUgd2hlbiB0aGUgcHJvZ3JhbSBpcyByZWFkeSB0byBiZSB1c2VkLiBpZiB0aGUgS0hSX3BhcmFsbGVsX3NoYWRlcl9jb21waWxlIGV4dGVuc2lvbiBpc24ndCBzdXBwb3J0ZWQsXG5cdC8vIGZsYWcgdGhlIHByb2dyYW0gYXMgcmVhZHkgaW1tZWRpYXRlbHkuIEl0IG1heSBjYXVzZSBhIHN0YWxsIHdoZW4gaXQncyBmaXJzdCB1c2VkLlxuXG5cdGxldCBwcm9ncmFtUmVhZHkgPSAoIHBhcmFtZXRlcnMucmVuZGVyZXJFeHRlbnNpb25QYXJhbGxlbFNoYWRlckNvbXBpbGUgPT09IGZhbHNlICk7XG5cblx0dGhpcy5pc1JlYWR5ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCBwcm9ncmFtUmVhZHkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRwcm9ncmFtUmVhZHkgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBDT01QTEVUSU9OX1NUQVRVU19LSFIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwcm9ncmFtUmVhZHk7XG5cblx0fTtcblxuXHQvLyBmcmVlIHJlc291cmNlXG5cblx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0YmluZGluZ1N0YXRlcy5yZWxlYXNlU3RhdGVzT2ZQcm9ncmFtKCB0aGlzICk7XG5cblx0XHRnbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XG5cdFx0dGhpcy5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXG5cdH07XG5cblx0Ly9cblxuXHR0aGlzLnR5cGUgPSBwYXJhbWV0ZXJzLnNoYWRlclR5cGU7XG5cdHRoaXMubmFtZSA9IHBhcmFtZXRlcnMuc2hhZGVyTmFtZTtcblx0dGhpcy5pZCA9IHByb2dyYW1JZENvdW50ICsrO1xuXHR0aGlzLmNhY2hlS2V5ID0gY2FjaGVLZXk7XG5cdHRoaXMudXNlZFRpbWVzID0gMTtcblx0dGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcblx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBnbFZlcnRleFNoYWRlcjtcblx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGdsRnJhZ21lbnRTaGFkZXI7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn1cblxubGV0IF9pZCQxID0gMDtcblxuY2xhc3MgV2ViR0xTaGFkZXJDYWNoZSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLnNoYWRlckNhY2hlID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMubWF0ZXJpYWxDYWNoZSA9IG5ldyBNYXAoKTtcblxuXHR9XG5cblx0dXBkYXRlKCBtYXRlcmlhbCApIHtcblxuXHRcdGNvbnN0IHZlcnRleFNoYWRlciA9IG1hdGVyaWFsLnZlcnRleFNoYWRlcjtcblx0XHRjb25zdCBmcmFnbWVudFNoYWRlciA9IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyO1xuXG5cdFx0Y29uc3QgdmVydGV4U2hhZGVyU3RhZ2UgPSB0aGlzLl9nZXRTaGFkZXJTdGFnZSggdmVydGV4U2hhZGVyICk7XG5cdFx0Y29uc3QgZnJhZ21lbnRTaGFkZXJTdGFnZSA9IHRoaXMuX2dldFNoYWRlclN0YWdlKCBmcmFnbWVudFNoYWRlciApO1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWxTaGFkZXJzID0gdGhpcy5fZ2V0U2hhZGVyQ2FjaGVGb3JNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHRcdGlmICggbWF0ZXJpYWxTaGFkZXJzLmhhcyggdmVydGV4U2hhZGVyU3RhZ2UgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdG1hdGVyaWFsU2hhZGVycy5hZGQoIHZlcnRleFNoYWRlclN0YWdlICk7XG5cdFx0XHR2ZXJ0ZXhTaGFkZXJTdGFnZS51c2VkVGltZXMgKys7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsU2hhZGVycy5oYXMoIGZyYWdtZW50U2hhZGVyU3RhZ2UgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdG1hdGVyaWFsU2hhZGVycy5hZGQoIGZyYWdtZW50U2hhZGVyU3RhZ2UgKTtcblx0XHRcdGZyYWdtZW50U2hhZGVyU3RhZ2UudXNlZFRpbWVzICsrO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJlbW92ZSggbWF0ZXJpYWwgKSB7XG5cblx0XHRjb25zdCBtYXRlcmlhbFNoYWRlcnMgPSB0aGlzLm1hdGVyaWFsQ2FjaGUuZ2V0KCBtYXRlcmlhbCApO1xuXG5cdFx0Zm9yICggY29uc3Qgc2hhZGVyU3RhZ2Ugb2YgbWF0ZXJpYWxTaGFkZXJzICkge1xuXG5cdFx0XHRzaGFkZXJTdGFnZS51c2VkVGltZXMgLS07XG5cblx0XHRcdGlmICggc2hhZGVyU3RhZ2UudXNlZFRpbWVzID09PSAwICkgdGhpcy5zaGFkZXJDYWNoZS5kZWxldGUoIHNoYWRlclN0YWdlLmNvZGUgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMubWF0ZXJpYWxDYWNoZS5kZWxldGUoIG1hdGVyaWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0VmVydGV4U2hhZGVySUQoIG1hdGVyaWFsICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2dldFNoYWRlclN0YWdlKCBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgKS5pZDtcblxuXHR9XG5cblx0Z2V0RnJhZ21lbnRTaGFkZXJJRCggbWF0ZXJpYWwgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZ2V0U2hhZGVyU3RhZ2UoIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyICkuaWQ7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLnNoYWRlckNhY2hlLmNsZWFyKCk7XG5cdFx0dGhpcy5tYXRlcmlhbENhY2hlLmNsZWFyKCk7XG5cblx0fVxuXG5cdF9nZXRTaGFkZXJDYWNoZUZvck1hdGVyaWFsKCBtYXRlcmlhbCApIHtcblxuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5tYXRlcmlhbENhY2hlO1xuXHRcdGxldCBzZXQgPSBjYWNoZS5nZXQoIG1hdGVyaWFsICk7XG5cblx0XHRpZiAoIHNldCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzZXQgPSBuZXcgU2V0KCk7XG5cdFx0XHRjYWNoZS5zZXQoIG1hdGVyaWFsLCBzZXQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBzZXQ7XG5cblx0fVxuXG5cdF9nZXRTaGFkZXJTdGFnZSggY29kZSApIHtcblxuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5zaGFkZXJDYWNoZTtcblx0XHRsZXQgc3RhZ2UgPSBjYWNoZS5nZXQoIGNvZGUgKTtcblxuXHRcdGlmICggc3RhZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c3RhZ2UgPSBuZXcgV2ViR0xTaGFkZXJTdGFnZSggY29kZSApO1xuXHRcdFx0Y2FjaGUuc2V0KCBjb2RlLCBzdGFnZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0YWdlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBXZWJHTFNoYWRlclN0YWdlIHtcblxuXHRjb25zdHJ1Y3RvciggY29kZSApIHtcblxuXHRcdHRoaXMuaWQgPSBfaWQkMSArKztcblxuXHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0dGhpcy51c2VkVGltZXMgPSAwO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBXZWJHTFByb2dyYW1zKCByZW5kZXJlciwgY3ViZW1hcHMsIGN1YmV1dm1hcHMsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgYmluZGluZ1N0YXRlcywgY2xpcHBpbmcgKSB7XG5cblx0Y29uc3QgX3Byb2dyYW1MYXllcnMgPSBuZXcgTGF5ZXJzKCk7XG5cdGNvbnN0IF9jdXN0b21TaGFkZXJzID0gbmV3IFdlYkdMU2hhZGVyQ2FjaGUoKTtcblx0Y29uc3QgX2FjdGl2ZUNoYW5uZWxzID0gbmV3IFNldCgpO1xuXHRjb25zdCBwcm9ncmFtcyA9IFtdO1xuXG5cdGNvbnN0IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjtcblx0Y29uc3QgU1VQUE9SVFNfVkVSVEVYX1RFWFRVUkVTID0gY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xuXG5cdGxldCBwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMucHJlY2lzaW9uO1xuXG5cdGNvbnN0IHNoYWRlcklEcyA9IHtcblx0XHRNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcblx0XHRNZXNoRGlzdGFuY2VNYXRlcmlhbDogJ2Rpc3RhbmNlUkdCQScsXG5cdFx0TWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcblx0XHRNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcblx0XHRNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXG5cdFx0TWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG5cdFx0TWVzaFRvb25NYXRlcmlhbDogJ3Rvb24nLFxuXHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuXHRcdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuXHRcdE1lc2hNYXRjYXBNYXRlcmlhbDogJ21hdGNhcCcsXG5cdFx0TGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG5cdFx0TGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcblx0XHRQb2ludHNNYXRlcmlhbDogJ3BvaW50cycsXG5cdFx0U2hhZG93TWF0ZXJpYWw6ICdzaGFkb3cnLFxuXHRcdFNwcml0ZU1hdGVyaWFsOiAnc3ByaXRlJ1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldENoYW5uZWwoIHZhbHVlICkge1xuXG5cdFx0X2FjdGl2ZUNoYW5uZWxzLmFkZCggdmFsdWUgKTtcblxuXHRcdGlmICggdmFsdWUgPT09IDAgKSByZXR1cm4gJ3V2JztcblxuXHRcdHJldHVybiBgdXYkeyB2YWx1ZSB9YDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UGFyYW1ldGVycyggbWF0ZXJpYWwsIGxpZ2h0cywgc2hhZG93cywgc2NlbmUsIG9iamVjdCApIHtcblxuXHRcdGNvbnN0IGZvZyA9IHNjZW5lLmZvZztcblx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0XHRjb25zdCBlbnZpcm9ubWVudCA9IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBzY2VuZS5lbnZpcm9ubWVudCA6IG51bGw7XG5cblx0XHRjb25zdCBlbnZNYXAgPSAoIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBjdWJldXZtYXBzIDogY3ViZW1hcHMgKS5nZXQoIG1hdGVyaWFsLmVudk1hcCB8fCBlbnZpcm9ubWVudCApO1xuXHRcdGNvbnN0IGVudk1hcEN1YmVVVkhlaWdodCA9ICggISEgZW52TWFwICkgJiYgKCBlbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgKSA/IGVudk1hcC5pbWFnZS5oZWlnaHQgOiBudWxsO1xuXG5cdFx0Y29uc3Qgc2hhZGVySUQgPSBzaGFkZXJJRHNbIG1hdGVyaWFsLnR5cGUgXTtcblxuXHRcdC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXG5cdFx0Ly8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcblxuXHRcdGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMuZ2V0TWF4UHJlY2lzaW9uKCBtYXRlcmlhbC5wcmVjaXNpb24gKTtcblxuXHRcdFx0aWYgKCBwcmVjaXNpb24gIT09IG1hdGVyaWFsLnByZWNpc2lvbiApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7XG5cdFx0Y29uc3QgbW9ycGhUYXJnZXRzQ291bnQgPSAoIG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSA/IG1vcnBoQXR0cmlidXRlLmxlbmd0aCA6IDA7XG5cblx0XHRsZXQgbW9ycGhUZXh0dXJlU3RyaWRlID0gMDtcblxuXHRcdGlmICggZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBtb3JwaFRleHR1cmVTdHJpZGUgPSAxO1xuXHRcdGlmICggZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkICkgbW9ycGhUZXh0dXJlU3RyaWRlID0gMjtcblx0XHRpZiAoIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICkgbW9ycGhUZXh0dXJlU3RyaWRlID0gMztcblxuXHRcdC8vXG5cblx0XHRsZXQgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcjtcblx0XHRsZXQgY3VzdG9tVmVydGV4U2hhZGVySUQsIGN1c3RvbUZyYWdtZW50U2hhZGVySUQ7XG5cblx0XHRpZiAoIHNoYWRlcklEICkge1xuXG5cdFx0XHRjb25zdCBzaGFkZXIgPSBTaGFkZXJMaWJbIHNoYWRlcklEIF07XG5cblx0XHRcdHZlcnRleFNoYWRlciA9IHNoYWRlci52ZXJ0ZXhTaGFkZXI7XG5cdFx0XHRmcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZlcnRleFNoYWRlciA9IG1hdGVyaWFsLnZlcnRleFNoYWRlcjtcblx0XHRcdGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXI7XG5cblx0XHRcdF9jdXN0b21TaGFkZXJzLnVwZGF0ZSggbWF0ZXJpYWwgKTtcblxuXHRcdFx0Y3VzdG9tVmVydGV4U2hhZGVySUQgPSBfY3VzdG9tU2hhZGVycy5nZXRWZXJ0ZXhTaGFkZXJJRCggbWF0ZXJpYWwgKTtcblx0XHRcdGN1c3RvbUZyYWdtZW50U2hhZGVySUQgPSBfY3VzdG9tU2hhZGVycy5nZXRGcmFnbWVudFNoYWRlcklEKCBtYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG5cdFx0Y29uc3QgSVNfSU5TVEFOQ0VETUVTSCA9IG9iamVjdC5pc0luc3RhbmNlZE1lc2ggPT09IHRydWU7XG5cdFx0Y29uc3QgSVNfQkFUQ0hFRE1FU0ggPSBvYmplY3QuaXNCYXRjaGVkTWVzaCA9PT0gdHJ1ZTtcblxuXHRcdGNvbnN0IEhBU19NQVAgPSAhISBtYXRlcmlhbC5tYXA7XG5cdFx0Y29uc3QgSEFTX01BVENBUCA9ICEhIG1hdGVyaWFsLm1hdGNhcDtcblx0XHRjb25zdCBIQVNfRU5WTUFQID0gISEgZW52TWFwO1xuXHRcdGNvbnN0IEhBU19BT01BUCA9ICEhIG1hdGVyaWFsLmFvTWFwO1xuXHRcdGNvbnN0IEhBU19MSUdIVE1BUCA9ICEhIG1hdGVyaWFsLmxpZ2h0TWFwO1xuXHRcdGNvbnN0IEhBU19CVU1QTUFQID0gISEgbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRjb25zdCBIQVNfTk9STUFMTUFQID0gISEgbWF0ZXJpYWwubm9ybWFsTWFwO1xuXHRcdGNvbnN0IEhBU19ESVNQTEFDRU1FTlRNQVAgPSAhISBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0Y29uc3QgSEFTX0VNSVNTSVZFTUFQID0gISEgbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cblx0XHRjb25zdCBIQVNfTUVUQUxORVNTTUFQID0gISEgbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xuXHRcdGNvbnN0IEhBU19ST1VHSE5FU1NNQVAgPSAhISBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XG5cblx0XHRjb25zdCBIQVNfQU5JU09UUk9QWSA9IG1hdGVyaWFsLmFuaXNvdHJvcHkgPiAwO1xuXHRcdGNvbnN0IEhBU19DTEVBUkNPQVQgPSBtYXRlcmlhbC5jbGVhcmNvYXQgPiAwO1xuXHRcdGNvbnN0IEhBU19ESVNQRVJTSU9OID0gbWF0ZXJpYWwuZGlzcGVyc2lvbiA+IDA7XG5cdFx0Y29uc3QgSEFTX0lSSURFU0NFTkNFID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2UgPiAwO1xuXHRcdGNvbnN0IEhBU19TSEVFTiA9IG1hdGVyaWFsLnNoZWVuID4gMDtcblx0XHRjb25zdCBIQVNfVFJBTlNNSVNTSU9OID0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMDtcblxuXHRcdGNvbnN0IEhBU19BTklTT1RST1BZTUFQID0gSEFTX0FOSVNPVFJPUFkgJiYgISEgbWF0ZXJpYWwuYW5pc290cm9weU1hcDtcblxuXHRcdGNvbnN0IEhBU19DTEVBUkNPQVRNQVAgPSBIQVNfQ0xFQVJDT0FUICYmICEhIG1hdGVyaWFsLmNsZWFyY29hdE1hcDtcblx0XHRjb25zdCBIQVNfQ0xFQVJDT0FUX05PUk1BTE1BUCA9IEhBU19DTEVBUkNPQVQgJiYgISEgbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwO1xuXHRcdGNvbnN0IEhBU19DTEVBUkNPQVRfUk9VR0hORVNTTUFQID0gSEFTX0NMRUFSQ09BVCAmJiAhISBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXA7XG5cblx0XHRjb25zdCBIQVNfSVJJREVTQ0VOQ0VNQVAgPSBIQVNfSVJJREVTQ0VOQ0UgJiYgISEgbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXA7XG5cdFx0Y29uc3QgSEFTX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUCA9IEhBU19JUklERVNDRU5DRSAmJiAhISBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcDtcblxuXHRcdGNvbnN0IEhBU19TSEVFTl9DT0xPUk1BUCA9IEhBU19TSEVFTiAmJiAhISBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwO1xuXHRcdGNvbnN0IEhBU19TSEVFTl9ST1VHSE5FU1NNQVAgPSBIQVNfU0hFRU4gJiYgISEgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXA7XG5cblx0XHRjb25zdCBIQVNfU1BFQ1VMQVJNQVAgPSAhISBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblx0XHRjb25zdCBIQVNfU1BFQ1VMQVJfQ09MT1JNQVAgPSAhISBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwO1xuXHRcdGNvbnN0IEhBU19TUEVDVUxBUl9JTlRFTlNJVFlNQVAgPSAhISBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcDtcblxuXHRcdGNvbnN0IEhBU19UUkFOU01JU1NJT05NQVAgPSBIQVNfVFJBTlNNSVNTSU9OICYmICEhIG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcDtcblx0XHRjb25zdCBIQVNfVEhJQ0tORVNTTUFQID0gSEFTX1RSQU5TTUlTU0lPTiAmJiAhISBtYXRlcmlhbC50aGlja25lc3NNYXA7XG5cblx0XHRjb25zdCBIQVNfR1JBRElFTlRNQVAgPSAhISBtYXRlcmlhbC5ncmFkaWVudE1hcDtcblxuXHRcdGNvbnN0IEhBU19BTFBIQU1BUCA9ICEhIG1hdGVyaWFsLmFscGhhTWFwO1xuXG5cdFx0Y29uc3QgSEFTX0FMUEhBVEVTVCA9IG1hdGVyaWFsLmFscGhhVGVzdCA+IDA7XG5cblx0XHRjb25zdCBIQVNfQUxQSEFIQVNIID0gISEgbWF0ZXJpYWwuYWxwaGFIYXNoO1xuXG5cdFx0Y29uc3QgSEFTX0VYVEVOU0lPTlMgPSAhISBtYXRlcmlhbC5leHRlbnNpb25zO1xuXG5cdFx0bGV0IHRvbmVNYXBwaW5nID0gTm9Ub25lTWFwcGluZztcblxuXHRcdGlmICggbWF0ZXJpYWwudG9uZU1hcHBlZCApIHtcblxuXHRcdFx0aWYgKCBjdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsIHx8IGN1cnJlbnRSZW5kZXJUYXJnZXQuaXNYUlJlbmRlclRhcmdldCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHR0b25lTWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYXJhbWV0ZXJzID0ge1xuXG5cdFx0XHRzaGFkZXJJRDogc2hhZGVySUQsXG5cdFx0XHRzaGFkZXJUeXBlOiBtYXRlcmlhbC50eXBlLFxuXHRcdFx0c2hhZGVyTmFtZTogbWF0ZXJpYWwubmFtZSxcblxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRkZWZpbmVzOiBtYXRlcmlhbC5kZWZpbmVzLFxuXG5cdFx0XHRjdXN0b21WZXJ0ZXhTaGFkZXJJRDogY3VzdG9tVmVydGV4U2hhZGVySUQsXG5cdFx0XHRjdXN0b21GcmFnbWVudFNoYWRlcklEOiBjdXN0b21GcmFnbWVudFNoYWRlcklELFxuXG5cdFx0XHRpc1Jhd1NoYWRlck1hdGVyaWFsOiBtYXRlcmlhbC5pc1Jhd1NoYWRlck1hdGVyaWFsID09PSB0cnVlLFxuXHRcdFx0Z2xzbFZlcnNpb246IG1hdGVyaWFsLmdsc2xWZXJzaW9uLFxuXG5cdFx0XHRwcmVjaXNpb246IHByZWNpc2lvbixcblxuXHRcdFx0YmF0Y2hpbmc6IElTX0JBVENIRURNRVNILFxuXHRcdFx0YmF0Y2hpbmdDb2xvcjogSVNfQkFUQ0hFRE1FU0ggJiYgb2JqZWN0Ll9jb2xvcnNUZXh0dXJlICE9PSBudWxsLFxuXHRcdFx0aW5zdGFuY2luZzogSVNfSU5TVEFOQ0VETUVTSCxcblx0XHRcdGluc3RhbmNpbmdDb2xvcjogSVNfSU5TVEFOQ0VETUVTSCAmJiBvYmplY3QuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCxcblx0XHRcdGluc3RhbmNpbmdNb3JwaDogSVNfSU5TVEFOQ0VETUVTSCAmJiBvYmplY3QubW9ycGhUZXh0dXJlICE9PSBudWxsLFxuXG5cdFx0XHRzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiBTVVBQT1JUU19WRVJURVhfVEVYVFVSRVMsXG5cdFx0XHRvdXRwdXRDb2xvclNwYWNlOiAoIGN1cnJlbnRSZW5kZXJUYXJnZXQgPT09IG51bGwgKSA/IHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgOiAoIGN1cnJlbnRSZW5kZXJUYXJnZXQuaXNYUlJlbmRlclRhcmdldCA9PT0gdHJ1ZSA/IGN1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2UgKSxcblx0XHRcdGFscGhhVG9Db3ZlcmFnZTogISEgbWF0ZXJpYWwuYWxwaGFUb0NvdmVyYWdlLFxuXG5cdFx0XHRtYXA6IEhBU19NQVAsXG5cdFx0XHRtYXRjYXA6IEhBU19NQVRDQVAsXG5cdFx0XHRlbnZNYXA6IEhBU19FTlZNQVAsXG5cdFx0XHRlbnZNYXBNb2RlOiBIQVNfRU5WTUFQICYmIGVudk1hcC5tYXBwaW5nLFxuXHRcdFx0ZW52TWFwQ3ViZVVWSGVpZ2h0OiBlbnZNYXBDdWJlVVZIZWlnaHQsXG5cdFx0XHRhb01hcDogSEFTX0FPTUFQLFxuXHRcdFx0bGlnaHRNYXA6IEhBU19MSUdIVE1BUCxcblx0XHRcdGJ1bXBNYXA6IEhBU19CVU1QTUFQLFxuXHRcdFx0bm9ybWFsTWFwOiBIQVNfTk9STUFMTUFQLFxuXHRcdFx0ZGlzcGxhY2VtZW50TWFwOiBTVVBQT1JUU19WRVJURVhfVEVYVFVSRVMgJiYgSEFTX0RJU1BMQUNFTUVOVE1BUCxcblx0XHRcdGVtaXNzaXZlTWFwOiBIQVNfRU1JU1NJVkVNQVAsXG5cblx0XHRcdG5vcm1hbE1hcE9iamVjdFNwYWNlOiBIQVNfTk9STUFMTUFQICYmIG1hdGVyaWFsLm5vcm1hbE1hcFR5cGUgPT09IE9iamVjdFNwYWNlTm9ybWFsTWFwLFxuXHRcdFx0bm9ybWFsTWFwVGFuZ2VudFNwYWNlOiBIQVNfTk9STUFMTUFQICYmIG1hdGVyaWFsLm5vcm1hbE1hcFR5cGUgPT09IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCxcblxuXHRcdFx0bWV0YWxuZXNzTWFwOiBIQVNfTUVUQUxORVNTTUFQLFxuXHRcdFx0cm91Z2huZXNzTWFwOiBIQVNfUk9VR0hORVNTTUFQLFxuXG5cdFx0XHRhbmlzb3Ryb3B5OiBIQVNfQU5JU09UUk9QWSxcblx0XHRcdGFuaXNvdHJvcHlNYXA6IEhBU19BTklTT1RST1BZTUFQLFxuXG5cdFx0XHRjbGVhcmNvYXQ6IEhBU19DTEVBUkNPQVQsXG5cdFx0XHRjbGVhcmNvYXRNYXA6IEhBU19DTEVBUkNPQVRNQVAsXG5cdFx0XHRjbGVhcmNvYXROb3JtYWxNYXA6IEhBU19DTEVBUkNPQVRfTk9STUFMTUFQLFxuXHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzTWFwOiBIQVNfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCxcblxuXHRcdFx0ZGlzcGVyc2lvbjogSEFTX0RJU1BFUlNJT04sXG5cblx0XHRcdGlyaWRlc2NlbmNlOiBIQVNfSVJJREVTQ0VOQ0UsXG5cdFx0XHRpcmlkZXNjZW5jZU1hcDogSEFTX0lSSURFU0NFTkNFTUFQLFxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNYXA6IEhBU19JUklERVNDRU5DRV9USElDS05FU1NNQVAsXG5cblx0XHRcdHNoZWVuOiBIQVNfU0hFRU4sXG5cdFx0XHRzaGVlbkNvbG9yTWFwOiBIQVNfU0hFRU5fQ09MT1JNQVAsXG5cdFx0XHRzaGVlblJvdWdobmVzc01hcDogSEFTX1NIRUVOX1JPVUdITkVTU01BUCxcblxuXHRcdFx0c3BlY3VsYXJNYXA6IEhBU19TUEVDVUxBUk1BUCxcblx0XHRcdHNwZWN1bGFyQ29sb3JNYXA6IEhBU19TUEVDVUxBUl9DT0xPUk1BUCxcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5TWFwOiBIQVNfU1BFQ1VMQVJfSU5URU5TSVRZTUFQLFxuXG5cdFx0XHR0cmFuc21pc3Npb246IEhBU19UUkFOU01JU1NJT04sXG5cdFx0XHR0cmFuc21pc3Npb25NYXA6IEhBU19UUkFOU01JU1NJT05NQVAsXG5cdFx0XHR0aGlja25lc3NNYXA6IEhBU19USElDS05FU1NNQVAsXG5cblx0XHRcdGdyYWRpZW50TWFwOiBIQVNfR1JBRElFTlRNQVAsXG5cblx0XHRcdG9wYXF1ZTogbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IGZhbHNlICYmIG1hdGVyaWFsLmJsZW5kaW5nID09PSBOb3JtYWxCbGVuZGluZyAmJiBtYXRlcmlhbC5hbHBoYVRvQ292ZXJhZ2UgPT09IGZhbHNlLFxuXG5cdFx0XHRhbHBoYU1hcDogSEFTX0FMUEhBTUFQLFxuXHRcdFx0YWxwaGFUZXN0OiBIQVNfQUxQSEFURVNULFxuXHRcdFx0YWxwaGFIYXNoOiBIQVNfQUxQSEFIQVNILFxuXG5cdFx0XHRjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxuXG5cdFx0XHQvL1xuXG5cdFx0XHRtYXBVdjogSEFTX01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5tYXAuY2hhbm5lbCApLFxuXHRcdFx0YW9NYXBVdjogSEFTX0FPTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmFvTWFwLmNoYW5uZWwgKSxcblx0XHRcdGxpZ2h0TWFwVXY6IEhBU19MSUdIVE1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5saWdodE1hcC5jaGFubmVsICksXG5cdFx0XHRidW1wTWFwVXY6IEhBU19CVU1QTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmJ1bXBNYXAuY2hhbm5lbCApLFxuXHRcdFx0bm9ybWFsTWFwVXY6IEhBU19OT1JNQUxNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwubm9ybWFsTWFwLmNoYW5uZWwgKSxcblx0XHRcdGRpc3BsYWNlbWVudE1hcFV2OiBIQVNfRElTUExBQ0VNRU5UTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcC5jaGFubmVsICksXG5cdFx0XHRlbWlzc2l2ZU1hcFV2OiBIQVNfRU1JU1NJVkVNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuZW1pc3NpdmVNYXAuY2hhbm5lbCApLFxuXG5cdFx0XHRtZXRhbG5lc3NNYXBVdjogSEFTX01FVEFMTkVTU01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5tZXRhbG5lc3NNYXAuY2hhbm5lbCApLFxuXHRcdFx0cm91Z2huZXNzTWFwVXY6IEhBU19ST1VHSE5FU1NNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwucm91Z2huZXNzTWFwLmNoYW5uZWwgKSxcblxuXHRcdFx0YW5pc290cm9weU1hcFV2OiBIQVNfQU5JU09UUk9QWU1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwLmNoYW5uZWwgKSxcblxuXHRcdFx0Y2xlYXJjb2F0TWFwVXY6IEhBU19DTEVBUkNPQVRNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuY2xlYXJjb2F0TWFwLmNoYW5uZWwgKSxcblx0XHRcdGNsZWFyY29hdE5vcm1hbE1hcFV2OiBIQVNfQ0xFQVJDT0FUX05PUk1BTE1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAuY2hhbm5lbCApLFxuXHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzTWFwVXY6IEhBU19DTEVBUkNPQVRfUk9VR0hORVNTTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcC5jaGFubmVsICksXG5cblx0XHRcdGlyaWRlc2NlbmNlTWFwVXY6IEhBU19JUklERVNDRU5DRU1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5pcmlkZXNjZW5jZU1hcC5jaGFubmVsICksXG5cdFx0XHRpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2OiBIQVNfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLmNoYW5uZWwgKSxcblxuXHRcdFx0c2hlZW5Db2xvck1hcFV2OiBIQVNfU0hFRU5fQ09MT1JNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuc2hlZW5Db2xvck1hcC5jaGFubmVsICksXG5cdFx0XHRzaGVlblJvdWdobmVzc01hcFV2OiBIQVNfU0hFRU5fUk9VR0hORVNTTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwLmNoYW5uZWwgKSxcblxuXHRcdFx0c3BlY3VsYXJNYXBVdjogSEFTX1NQRUNVTEFSTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLnNwZWN1bGFyTWFwLmNoYW5uZWwgKSxcblx0XHRcdHNwZWN1bGFyQ29sb3JNYXBVdjogSEFTX1NQRUNVTEFSX0NPTE9STUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXAuY2hhbm5lbCApLFxuXHRcdFx0c3BlY3VsYXJJbnRlbnNpdHlNYXBVdjogSEFTX1NQRUNVTEFSX0lOVEVOU0lUWU1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcC5jaGFubmVsICksXG5cblx0XHRcdHRyYW5zbWlzc2lvbk1hcFV2OiBIQVNfVFJBTlNNSVNTSU9OTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcC5jaGFubmVsICksXG5cdFx0XHR0aGlja25lc3NNYXBVdjogSEFTX1RISUNLTkVTU01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC50aGlja25lc3NNYXAuY2hhbm5lbCApLFxuXG5cdFx0XHRhbHBoYU1hcFV2OiBIQVNfQUxQSEFNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuYWxwaGFNYXAuY2hhbm5lbCApLFxuXG5cdFx0XHQvL1xuXG5cdFx0XHR2ZXJ0ZXhUYW5nZW50czogISEgZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50ICYmICggSEFTX05PUk1BTE1BUCB8fCBIQVNfQU5JU09UUk9QWSApLFxuXHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXG5cdFx0XHR2ZXJ0ZXhBbHBoYXM6IG1hdGVyaWFsLnZlcnRleENvbG9ycyA9PT0gdHJ1ZSAmJiAhISBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuaXRlbVNpemUgPT09IDQsXG5cblx0XHRcdHBvaW50c1V2czogb2JqZWN0LmlzUG9pbnRzID09PSB0cnVlICYmICEhIGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYgJiYgKCBIQVNfTUFQIHx8IEhBU19BTFBIQU1BUCApLFxuXG5cdFx0XHRmb2c6ICEhIGZvZyxcblx0XHRcdHVzZUZvZzogbWF0ZXJpYWwuZm9nID09PSB0cnVlLFxuXHRcdFx0Zm9nRXhwMjogKCAhISBmb2cgJiYgZm9nLmlzRm9nRXhwMiApLFxuXG5cdFx0XHRmbGF0U2hhZGluZzogbWF0ZXJpYWwuZmxhdFNoYWRpbmcgPT09IHRydWUsXG5cblx0XHRcdHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID09PSB0cnVlLFxuXHRcdFx0bG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcblxuXHRcdFx0c2tpbm5pbmc6IG9iamVjdC5pc1NraW5uZWRNZXNoID09PSB0cnVlLFxuXG5cdFx0XHRtb3JwaFRhcmdldHM6IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0bW9ycGhOb3JtYWxzOiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQsXG5cdFx0XHRtb3JwaENvbG9yczogZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQsXG5cdFx0XHRtb3JwaFRhcmdldHNDb3VudDogbW9ycGhUYXJnZXRzQ291bnQsXG5cdFx0XHRtb3JwaFRleHR1cmVTdHJpZGU6IG1vcnBoVGV4dHVyZVN0cmlkZSxcblxuXHRcdFx0bnVtRGlyTGlnaHRzOiBsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoLFxuXHRcdFx0bnVtUG9pbnRMaWdodHM6IGxpZ2h0cy5wb2ludC5sZW5ndGgsXG5cdFx0XHRudW1TcG90TGlnaHRzOiBsaWdodHMuc3BvdC5sZW5ndGgsXG5cdFx0XHRudW1TcG90TGlnaHRNYXBzOiBsaWdodHMuc3BvdExpZ2h0TWFwLmxlbmd0aCxcblx0XHRcdG51bVJlY3RBcmVhTGlnaHRzOiBsaWdodHMucmVjdEFyZWEubGVuZ3RoLFxuXHRcdFx0bnVtSGVtaUxpZ2h0czogbGlnaHRzLmhlbWkubGVuZ3RoLFxuXG5cdFx0XHRudW1EaXJMaWdodFNoYWRvd3M6IGxpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hcC5sZW5ndGgsXG5cdFx0XHRudW1Qb2ludExpZ2h0U2hhZG93czogbGlnaHRzLnBvaW50U2hhZG93TWFwLmxlbmd0aCxcblx0XHRcdG51bVNwb3RMaWdodFNoYWRvd3M6IGxpZ2h0cy5zcG90U2hhZG93TWFwLmxlbmd0aCxcblx0XHRcdG51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwczogbGlnaHRzLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcyxcblxuXHRcdFx0bnVtTGlnaHRQcm9iZXM6IGxpZ2h0cy5udW1MaWdodFByb2JlcyxcblxuXHRcdFx0bnVtQ2xpcHBpbmdQbGFuZXM6IGNsaXBwaW5nLm51bVBsYW5lcyxcblx0XHRcdG51bUNsaXBJbnRlcnNlY3Rpb246IGNsaXBwaW5nLm51bUludGVyc2VjdGlvbixcblxuXHRcdFx0ZGl0aGVyaW5nOiBtYXRlcmlhbC5kaXRoZXJpbmcsXG5cblx0XHRcdHNoYWRvd01hcEVuYWJsZWQ6IHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkICYmIHNoYWRvd3MubGVuZ3RoID4gMCxcblx0XHRcdHNoYWRvd01hcFR5cGU6IHJlbmRlcmVyLnNoYWRvd01hcC50eXBlLFxuXG5cdFx0XHR0b25lTWFwcGluZzogdG9uZU1hcHBpbmcsXG5cblx0XHRcdGRlY29kZVZpZGVvVGV4dHVyZTogSEFTX01BUCAmJiAoIG1hdGVyaWFsLm1hcC5pc1ZpZGVvVGV4dHVyZSA9PT0gdHJ1ZSApICYmICggQ29sb3JNYW5hZ2VtZW50LmdldFRyYW5zZmVyKCBtYXRlcmlhbC5tYXAuY29sb3JTcGFjZSApID09PSBTUkdCVHJhbnNmZXIgKSxcblxuXHRcdFx0cHJlbXVsdGlwbGllZEFscGhhOiBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEsXG5cblx0XHRcdGRvdWJsZVNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlLFxuXHRcdFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSxcblxuXHRcdFx0dXNlRGVwdGhQYWNraW5nOiBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgPj0gMCxcblx0XHRcdGRlcHRoUGFja2luZzogbWF0ZXJpYWwuZGVwdGhQYWNraW5nIHx8IDAsXG5cblx0XHRcdGluZGV4MEF0dHJpYnV0ZU5hbWU6IG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUsXG5cblx0XHRcdGV4dGVuc2lvbkNsaXBDdWxsRGlzdGFuY2U6IEhBU19FWFRFTlNJT05TICYmIG1hdGVyaWFsLmV4dGVuc2lvbnMuY2xpcEN1bGxEaXN0YW5jZSA9PT0gdHJ1ZSAmJiBleHRlbnNpb25zLmhhcyggJ1dFQkdMX2NsaXBfY3VsbF9kaXN0YW5jZScgKSxcblx0XHRcdGV4dGVuc2lvbk11bHRpRHJhdzogSEFTX0VYVEVOU0lPTlMgJiYgbWF0ZXJpYWwuZXh0ZW5zaW9ucy5tdWx0aURyYXcgPT09IHRydWUgJiYgZXh0ZW5zaW9ucy5oYXMoICdXRUJHTF9tdWx0aV9kcmF3JyApLFxuXG5cdFx0XHRyZW5kZXJlckV4dGVuc2lvblBhcmFsbGVsU2hhZGVyQ29tcGlsZTogZXh0ZW5zaW9ucy5oYXMoICdLSFJfcGFyYWxsZWxfc2hhZGVyX2NvbXBpbGUnICksXG5cblx0XHRcdGN1c3RvbVByb2dyYW1DYWNoZUtleTogbWF0ZXJpYWwuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KClcblxuXHRcdH07XG5cblx0XHQvLyB0aGUgdXNhZ2Ugb2YgZ2V0Q2hhbm5lbCgpIGRldGVybWluZXMgdGhlIGFjdGl2ZSB0ZXh0dXJlIGNoYW5uZWxzIGZvciB0aGlzIHNoYWRlclxuXG5cdFx0cGFyYW1ldGVycy52ZXJ0ZXhVdjFzID0gX2FjdGl2ZUNoYW5uZWxzLmhhcyggMSApO1xuXHRcdHBhcmFtZXRlcnMudmVydGV4VXYycyA9IF9hY3RpdmVDaGFubmVscy5oYXMoIDIgKTtcblx0XHRwYXJhbWV0ZXJzLnZlcnRleFV2M3MgPSBfYWN0aXZlQ2hhbm5lbHMuaGFzKCAzICk7XG5cblx0XHRfYWN0aXZlQ2hhbm5lbHMuY2xlYXIoKTtcblxuXHRcdHJldHVybiBwYXJhbWV0ZXJzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQcm9ncmFtQ2FjaGVLZXkoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xuXG5cdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNoYWRlcklEICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmN1c3RvbVZlcnRleFNoYWRlcklEICk7XG5cdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmN1c3RvbUZyYWdtZW50U2hhZGVySUQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggcGFyYW1ldGVycy5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gcGFyYW1ldGVycy5kZWZpbmVzICkge1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIG5hbWUgKTtcblx0XHRcdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5kZWZpbmVzWyBuYW1lIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPT09IGZhbHNlICkge1xuXG5cdFx0XHRnZXRQcm9ncmFtQ2FjaGVLZXlQYXJhbWV0ZXJzKCBhcnJheSwgcGFyYW1ldGVycyApO1xuXHRcdFx0Z2V0UHJvZ3JhbUNhY2hlS2V5Qm9vbGVhbnMoIGFycmF5LCBwYXJhbWV0ZXJzICk7XG5cdFx0XHRhcnJheS5wdXNoKCByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlICk7XG5cblx0XHR9XG5cblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmN1c3RvbVByb2dyYW1DYWNoZUtleSApO1xuXG5cdFx0cmV0dXJuIGFycmF5LmpvaW4oKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UHJvZ3JhbUNhY2hlS2V5UGFyYW1ldGVycyggYXJyYXksIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnByZWNpc2lvbiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMub3V0cHV0Q29sb3JTcGFjZSApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuZW52TWFwTW9kZSApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuZW52TWFwQ3ViZVVWSGVpZ2h0ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5tYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYWxwaGFNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubGlnaHRNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYW9NYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYnVtcE1hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5ub3JtYWxNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5yb3VnaG5lc3NNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYW5pc290cm9weU1hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5jbGVhcmNvYXRNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmNsZWFyY29hdFJvdWdobmVzc01hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5pcmlkZXNjZW5jZU1hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNoZWVuUm91Z2huZXNzTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuc3BlY3VsYXJJbnRlbnNpdHlNYXBVdiApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMudHJhbnNtaXNzaW9uTWFwVXYgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnRoaWNrbmVzc01hcFV2ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5jb21iaW5lICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5mb2dFeHAyICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0c0NvdW50ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5tb3JwaEF0dHJpYnV0ZUNvdW50ICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1EaXJMaWdodHMgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1TcG90TGlnaHRzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1TcG90TGlnaHRNYXBzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1SZWN0QXJlYUxpZ2h0cyApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtRGlyTGlnaHRTaGFkb3dzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0U2hhZG93cyApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93cyApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1MaWdodFByb2JlcyApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSApO1xuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgKTtcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uICk7XG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5kZXB0aFBhY2tpbmcgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UHJvZ3JhbUNhY2hlS2V5Qm9vbGVhbnMoIGFycmF5LCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0X3Byb2dyYW1MYXllcnMuZGlzYWJsZUFsbCgpO1xuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAwICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmluc3RhbmNpbmcgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmluc3RhbmNpbmdDb2xvciApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDIgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuaW5zdGFuY2luZ01vcnBoIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMyApO1xuXHRcdGlmICggcGFyYW1ldGVycy5tYXRjYXAgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA0ICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDUgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMubm9ybWFsTWFwT2JqZWN0U3BhY2UgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA2ICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLm5vcm1hbE1hcFRhbmdlbnRTcGFjZSApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDcgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuY2xlYXJjb2F0IClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggOCApO1xuXHRcdGlmICggcGFyYW1ldGVycy5pcmlkZXNjZW5jZSApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDkgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuYWxwaGFUZXN0IClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTAgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMudmVydGV4Q29sb3JzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTEgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMudmVydGV4QWxwaGFzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTIgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMudmVydGV4VXYxcyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEzICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnZlcnRleFV2MnMgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxNCApO1xuXHRcdGlmICggcGFyYW1ldGVycy52ZXJ0ZXhVdjNzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTUgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMudmVydGV4VGFuZ2VudHMgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxNiApO1xuXHRcdGlmICggcGFyYW1ldGVycy5hbmlzb3Ryb3B5IClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTcgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuYWxwaGFIYXNoIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTggKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuYmF0Y2hpbmcgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxOSApO1xuXHRcdGlmICggcGFyYW1ldGVycy5kaXNwZXJzaW9uIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMjAgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuYmF0Y2hpbmdDb2xvciApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDIxICk7XG5cblx0XHRhcnJheS5wdXNoKCBfcHJvZ3JhbUxheWVycy5tYXNrICk7XG5cdFx0X3Byb2dyYW1MYXllcnMuZGlzYWJsZUFsbCgpO1xuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmZvZyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDAgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMudXNlRm9nIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMSApO1xuXHRcdGlmICggcGFyYW1ldGVycy5mbGF0U2hhZGluZyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDIgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDMgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuc2tpbm5pbmcgKVxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA0ICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDUgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggNiApO1xuXHRcdGlmICggcGFyYW1ldGVycy5tb3JwaENvbG9ycyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDcgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggOCApO1xuXHRcdGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggOSApO1xuXHRcdGlmICggcGFyYW1ldGVycy5kb3VibGVTaWRlZCApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEwICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmZsaXBTaWRlZCApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDExICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnVzZURlcHRoUGFja2luZyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEyICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmRpdGhlcmluZyApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEzICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbiApXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDE0ICk7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnNoZWVuIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTUgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMub3BhcXVlIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTYgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMucG9pbnRzVXZzIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTcgKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuZGVjb2RlVmlkZW9UZXh0dXJlIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTggKTtcblx0XHRpZiAoIHBhcmFtZXRlcnMuYWxwaGFUb0NvdmVyYWdlIClcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTkgKTtcblxuXHRcdGFycmF5LnB1c2goIF9wcm9ncmFtTGF5ZXJzLm1hc2sgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VW5pZm9ybXMoIG1hdGVyaWFsICkge1xuXG5cdFx0Y29uc3Qgc2hhZGVySUQgPSBzaGFkZXJJRHNbIG1hdGVyaWFsLnR5cGUgXTtcblx0XHRsZXQgdW5pZm9ybXM7XG5cblx0XHRpZiAoIHNoYWRlcklEICkge1xuXG5cdFx0XHRjb25zdCBzaGFkZXIgPSBTaGFkZXJMaWJbIHNoYWRlcklEIF07XG5cdFx0XHR1bmlmb3JtcyA9IFVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmlmb3JtcztcblxuXHR9XG5cblx0ZnVuY3Rpb24gYWNxdWlyZVByb2dyYW0oIHBhcmFtZXRlcnMsIGNhY2hlS2V5ICkge1xuXG5cdFx0bGV0IHByb2dyYW07XG5cblx0XHQvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcblx0XHRmb3IgKCBsZXQgcCA9IDAsIHBsID0gcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cblx0XHRcdGNvbnN0IHByZWV4aXN0aW5nUHJvZ3JhbSA9IHByb2dyYW1zWyBwIF07XG5cblx0XHRcdGlmICggcHJlZXhpc3RpbmdQcm9ncmFtLmNhY2hlS2V5ID09PSBjYWNoZUtleSApIHtcblxuXHRcdFx0XHRwcm9ncmFtID0gcHJlZXhpc3RpbmdQcm9ncmFtO1xuXHRcdFx0XHQrKyBwcm9ncmFtLnVzZWRUaW1lcztcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHByb2dyYW0gPSBuZXcgV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgY2FjaGVLZXksIHBhcmFtZXRlcnMsIGJpbmRpbmdTdGF0ZXMgKTtcblx0XHRcdHByb2dyYW1zLnB1c2goIHByb2dyYW0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbSApIHtcblxuXHRcdGlmICggLS0gcHJvZ3JhbS51c2VkVGltZXMgPT09IDAgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBmcm9tIHVub3JkZXJlZCBzZXRcblx0XHRcdGNvbnN0IGkgPSBwcm9ncmFtcy5pbmRleE9mKCBwcm9ncmFtICk7XG5cdFx0XHRwcm9ncmFtc1sgaSBdID0gcHJvZ3JhbXNbIHByb2dyYW1zLmxlbmd0aCAtIDEgXTtcblx0XHRcdHByb2dyYW1zLnBvcCgpO1xuXG5cdFx0XHQvLyBGcmVlIFdlYkdMIHJlc291cmNlc1xuXHRcdFx0cHJvZ3JhbS5kZXN0cm95KCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbGVhc2VTaGFkZXJDYWNoZSggbWF0ZXJpYWwgKSB7XG5cblx0XHRfY3VzdG9tU2hhZGVycy5yZW1vdmUoIG1hdGVyaWFsICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRfY3VzdG9tU2hhZGVycy5kaXNwb3NlKCk7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Z2V0UGFyYW1ldGVyczogZ2V0UGFyYW1ldGVycyxcblx0XHRnZXRQcm9ncmFtQ2FjaGVLZXk6IGdldFByb2dyYW1DYWNoZUtleSxcblx0XHRnZXRVbmlmb3JtczogZ2V0VW5pZm9ybXMsXG5cdFx0YWNxdWlyZVByb2dyYW06IGFjcXVpcmVQcm9ncmFtLFxuXHRcdHJlbGVhc2VQcm9ncmFtOiByZWxlYXNlUHJvZ3JhbSxcblx0XHRyZWxlYXNlU2hhZGVyQ2FjaGU6IHJlbGVhc2VTaGFkZXJDYWNoZSxcblx0XHQvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XG5cdFx0cHJvZ3JhbXM6IHByb2dyYW1zLFxuXHRcdGRpc3Bvc2U6IGRpc3Bvc2Vcblx0fTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTFByb3BlcnRpZXMoKSB7XG5cblx0bGV0IHByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGZ1bmN0aW9uIGdldCggb2JqZWN0ICkge1xuXG5cdFx0bGV0IG1hcCA9IHByb3BlcnRpZXMuZ2V0KCBvYmplY3QgKTtcblxuXHRcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hcCA9IHt9O1xuXHRcdFx0cHJvcGVydGllcy5zZXQoIG9iamVjdCwgbWFwICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbWFwO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmUoIG9iamVjdCApIHtcblxuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCBvYmplY3QgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QsIGtleSwgdmFsdWUgKSB7XG5cblx0XHRwcm9wZXJ0aWVzLmdldCggb2JqZWN0IClbIGtleSBdID0gdmFsdWU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRwcm9wZXJ0aWVzID0gbmV3IFdlYWtNYXAoKTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGdldCxcblx0XHRyZW1vdmU6IHJlbW92ZSxcblx0XHR1cGRhdGU6IHVwZGF0ZSxcblx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XG5cblx0aWYgKCBhLmdyb3VwT3JkZXIgIT09IGIuZ3JvdXBPcmRlciApIHtcblxuXHRcdHJldHVybiBhLmdyb3VwT3JkZXIgLSBiLmdyb3VwT3JkZXI7XG5cblx0fSBlbHNlIGlmICggYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlciApIHtcblxuXHRcdHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcblxuXHR9IGVsc2UgaWYgKCBhLm1hdGVyaWFsLmlkICE9PSBiLm1hdGVyaWFsLmlkICkge1xuXG5cdFx0cmV0dXJuIGEubWF0ZXJpYWwuaWQgLSBiLm1hdGVyaWFsLmlkO1xuXG5cdH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG5cdFx0cmV0dXJuIGEueiAtIGIuejtcblxuXHR9IGVsc2Uge1xuXG5cdFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XG5cblx0aWYgKCBhLmdyb3VwT3JkZXIgIT09IGIuZ3JvdXBPcmRlciApIHtcblxuXHRcdHJldHVybiBhLmdyb3VwT3JkZXIgLSBiLmdyb3VwT3JkZXI7XG5cblx0fSBlbHNlIGlmICggYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlciApIHtcblxuXHRcdHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcblxuXHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcblxuXHRcdHJldHVybiBiLnogLSBhLno7XG5cblx0fSBlbHNlIHtcblxuXHRcdHJldHVybiBhLmlkIC0gYi5pZDtcblxuXHR9XG5cbn1cblxuXG5mdW5jdGlvbiBXZWJHTFJlbmRlckxpc3QoKSB7XG5cblx0Y29uc3QgcmVuZGVySXRlbXMgPSBbXTtcblx0bGV0IHJlbmRlckl0ZW1zSW5kZXggPSAwO1xuXG5cdGNvbnN0IG9wYXF1ZSA9IFtdO1xuXHRjb25zdCB0cmFuc21pc3NpdmUgPSBbXTtcblx0Y29uc3QgdHJhbnNwYXJlbnQgPSBbXTtcblxuXHRmdW5jdGlvbiBpbml0KCkge1xuXG5cdFx0cmVuZGVySXRlbXNJbmRleCA9IDA7XG5cblx0XHRvcGFxdWUubGVuZ3RoID0gMDtcblx0XHR0cmFuc21pc3NpdmUubGVuZ3RoID0gMDtcblx0XHR0cmFuc3BhcmVudC5sZW5ndGggPSAwO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXROZXh0UmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIHosIGdyb3VwICkge1xuXG5cdFx0bGV0IHJlbmRlckl0ZW0gPSByZW5kZXJJdGVtc1sgcmVuZGVySXRlbXNJbmRleCBdO1xuXG5cdFx0aWYgKCByZW5kZXJJdGVtID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlbmRlckl0ZW0gPSB7XG5cdFx0XHRcdGlkOiBvYmplY3QuaWQsXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0LFxuXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnksXG5cdFx0XHRcdG1hdGVyaWFsOiBtYXRlcmlhbCxcblx0XHRcdFx0Z3JvdXBPcmRlcjogZ3JvdXBPcmRlcixcblx0XHRcdFx0cmVuZGVyT3JkZXI6IG9iamVjdC5yZW5kZXJPcmRlcixcblx0XHRcdFx0ejogeixcblx0XHRcdFx0Z3JvdXA6IGdyb3VwXG5cdFx0XHR9O1xuXG5cdFx0XHRyZW5kZXJJdGVtc1sgcmVuZGVySXRlbXNJbmRleCBdID0gcmVuZGVySXRlbTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlbmRlckl0ZW0uaWQgPSBvYmplY3QuaWQ7XG5cdFx0XHRyZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcblx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHRcdHJlbmRlckl0ZW0ubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXBPcmRlciA9IGdyb3VwT3JkZXI7XG5cdFx0XHRyZW5kZXJJdGVtLnJlbmRlck9yZGVyID0gb2JqZWN0LnJlbmRlck9yZGVyO1xuXHRcdFx0cmVuZGVySXRlbS56ID0gejtcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBncm91cDtcblxuXHRcdH1cblxuXHRcdHJlbmRlckl0ZW1zSW5kZXggKys7XG5cblx0XHRyZXR1cm4gcmVuZGVySXRlbTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIHosIGdyb3VwICkge1xuXG5cdFx0Y29uc3QgcmVuZGVySXRlbSA9IGdldE5leHRSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXAgKTtcblxuXHRcdGlmICggbWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMC4wICkge1xuXG5cdFx0XHR0cmFuc21pc3NpdmUucHVzaCggcmVuZGVySXRlbSApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWUgKSB7XG5cblx0XHRcdHRyYW5zcGFyZW50LnB1c2goIHJlbmRlckl0ZW0gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG9wYXF1ZS5wdXNoKCByZW5kZXJJdGVtICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVuc2hpZnQoIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCApIHtcblxuXHRcdGNvbnN0IHJlbmRlckl0ZW0gPSBnZXROZXh0UmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIHosIGdyb3VwICk7XG5cblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAuMCApIHtcblxuXHRcdFx0dHJhbnNtaXNzaXZlLnVuc2hpZnQoIHJlbmRlckl0ZW0gKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICkge1xuXG5cdFx0XHR0cmFuc3BhcmVudC51bnNoaWZ0KCByZW5kZXJJdGVtICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRvcGFxdWUudW5zaGlmdCggcmVuZGVySXRlbSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzb3J0KCBjdXN0b21PcGFxdWVTb3J0LCBjdXN0b21UcmFuc3BhcmVudFNvcnQgKSB7XG5cblx0XHRpZiAoIG9wYXF1ZS5sZW5ndGggPiAxICkgb3BhcXVlLnNvcnQoIGN1c3RvbU9wYXF1ZVNvcnQgfHwgcGFpbnRlclNvcnRTdGFibGUgKTtcblx0XHRpZiAoIHRyYW5zbWlzc2l2ZS5sZW5ndGggPiAxICkgdHJhbnNtaXNzaXZlLnNvcnQoIGN1c3RvbVRyYW5zcGFyZW50U29ydCB8fCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcblx0XHRpZiAoIHRyYW5zcGFyZW50Lmxlbmd0aCA+IDEgKSB0cmFuc3BhcmVudC5zb3J0KCBjdXN0b21UcmFuc3BhcmVudFNvcnQgfHwgcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGZpbmlzaCgpIHtcblxuXHRcdC8vIENsZWFyIHJlZmVyZW5jZXMgZnJvbSBpbmFjdGl2ZSByZW5kZXJJdGVtcyBpbiB0aGUgbGlzdFxuXG5cdFx0Zm9yICggbGV0IGkgPSByZW5kZXJJdGVtc0luZGV4LCBpbCA9IHJlbmRlckl0ZW1zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCByZW5kZXJJdGVtID0gcmVuZGVySXRlbXNbIGkgXTtcblxuXHRcdFx0aWYgKCByZW5kZXJJdGVtLmlkID09PSBudWxsICkgYnJlYWs7XG5cblx0XHRcdHJlbmRlckl0ZW0uaWQgPSBudWxsO1xuXHRcdFx0cmVuZGVySXRlbS5vYmplY3QgPSBudWxsO1xuXHRcdFx0cmVuZGVySXRlbS5nZW9tZXRyeSA9IG51bGw7XG5cdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbnVsbDtcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0b3BhcXVlOiBvcGFxdWUsXG5cdFx0dHJhbnNtaXNzaXZlOiB0cmFuc21pc3NpdmUsXG5cdFx0dHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50LFxuXG5cdFx0aW5pdDogaW5pdCxcblx0XHRwdXNoOiBwdXNoLFxuXHRcdHVuc2hpZnQ6IHVuc2hpZnQsXG5cdFx0ZmluaXNoOiBmaW5pc2gsXG5cblx0XHRzb3J0OiBzb3J0XG5cdH07XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xSZW5kZXJMaXN0cygpIHtcblxuXHRsZXQgbGlzdHMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGZ1bmN0aW9uIGdldCggc2NlbmUsIHJlbmRlckNhbGxEZXB0aCApIHtcblxuXHRcdGNvbnN0IGxpc3RBcnJheSA9IGxpc3RzLmdldCggc2NlbmUgKTtcblx0XHRsZXQgbGlzdDtcblxuXHRcdGlmICggbGlzdEFycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3QgPSBuZXcgV2ViR0xSZW5kZXJMaXN0KCk7XG5cdFx0XHRsaXN0cy5zZXQoIHNjZW5lLCBbIGxpc3QgXSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCByZW5kZXJDYWxsRGVwdGggPj0gbGlzdEFycmF5Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRsaXN0ID0gbmV3IFdlYkdMUmVuZGVyTGlzdCgpO1xuXHRcdFx0XHRsaXN0QXJyYXkucHVzaCggbGlzdCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGxpc3QgPSBsaXN0QXJyYXlbIHJlbmRlckNhbGxEZXB0aCBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbGlzdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuXHRcdGxpc3RzID0gbmV3IFdlYWtNYXAoKTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGdldCxcblx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gVW5pZm9ybXNDYWNoZSgpIHtcblxuXHRjb25zdCBsaWdodHMgPSB7fTtcblxuXHRyZXR1cm4ge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoIGxpZ2h0ICkge1xuXG5cdFx0XHRpZiAoIGxpZ2h0c1sgbGlnaHQuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBsaWdodHNbIGxpZ2h0LmlkIF07XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IHVuaWZvcm1zO1xuXG5cdFx0XHRzd2l0Y2ggKCBsaWdodC50eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogMCxcblx0XHRcdFx0XHRcdGNvbmVDb3M6IDAsXG5cdFx0XHRcdFx0XHRwZW51bWJyYUNvczogMCxcblx0XHRcdFx0XHRcdGRlY2F5OiAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0Jzpcblx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxuXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IDAsXG5cdFx0XHRcdFx0XHRkZWNheTogMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0Jzpcblx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdHNreUNvbG9yOiBuZXcgQ29sb3IoKSxcblx0XHRcdFx0XHRcdGdyb3VuZENvbG9yOiBuZXcgQ29sb3IoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnUmVjdEFyZWFMaWdodCc6XG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdGhhbGZXaWR0aDogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdGhhbGZIZWlnaHQ6IG5ldyBWZWN0b3IzKClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxpZ2h0c1sgbGlnaHQuaWQgXSA9IHVuaWZvcm1zO1xuXG5cdFx0XHRyZXR1cm4gdW5pZm9ybXM7XG5cblx0XHR9XG5cblx0fTtcblxufVxuXG5mdW5jdGlvbiBTaGFkb3dVbmlmb3Jtc0NhY2hlKCkge1xuXG5cdGNvbnN0IGxpZ2h0cyA9IHt9O1xuXG5cdHJldHVybiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICggbGlnaHQgKSB7XG5cblx0XHRcdGlmICggbGlnaHRzWyBsaWdodC5pZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGxpZ2h0c1sgbGlnaHQuaWQgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgdW5pZm9ybXM7XG5cblx0XHRcdHN3aXRjaCAoIGxpZ2h0LnR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxuXHRcdFx0XHRcdFx0c2hhZG93Tm9ybWFsQmlhczogMCxcblx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcblx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxuXHRcdFx0XHRcdFx0c2hhZG93Tm9ybWFsQmlhczogMCxcblx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcblx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcblx0XHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IDAsXG5cdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXG5cdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpLFxuXHRcdFx0XHRcdFx0c2hhZG93Q2FtZXJhTmVhcjogMSxcblx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYUZhcjogMTAwMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IHNldCBSZWN0QXJlYUxpZ2h0IHNoYWRvdyB1bmlmb3Jtc1xuXG5cdFx0XHR9XG5cblx0XHRcdGxpZ2h0c1sgbGlnaHQuaWQgXSA9IHVuaWZvcm1zO1xuXG5cdFx0XHRyZXR1cm4gdW5pZm9ybXM7XG5cblx0XHR9XG5cblx0fTtcblxufVxuXG5cblxubGV0IG5leHRWZXJzaW9uID0gMDtcblxuZnVuY3Rpb24gc2hhZG93Q2FzdGluZ0FuZFRleHR1cmluZ0xpZ2h0c0ZpcnN0KCBsaWdodEEsIGxpZ2h0QiApIHtcblxuXHRyZXR1cm4gKCBsaWdodEIuY2FzdFNoYWRvdyA/IDIgOiAwICkgLSAoIGxpZ2h0QS5jYXN0U2hhZG93ID8gMiA6IDAgKSArICggbGlnaHRCLm1hcCA/IDEgOiAwICkgLSAoIGxpZ2h0QS5tYXAgPyAxIDogMCApO1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMTGlnaHRzKCBleHRlbnNpb25zICkge1xuXG5cdGNvbnN0IGNhY2hlID0gbmV3IFVuaWZvcm1zQ2FjaGUoKTtcblxuXHRjb25zdCBzaGFkb3dDYWNoZSA9IFNoYWRvd1VuaWZvcm1zQ2FjaGUoKTtcblxuXHRjb25zdCBzdGF0ZSA9IHtcblxuXHRcdHZlcnNpb246IDAsXG5cblx0XHRoYXNoOiB7XG5cdFx0XHRkaXJlY3Rpb25hbExlbmd0aDogLSAxLFxuXHRcdFx0cG9pbnRMZW5ndGg6IC0gMSxcblx0XHRcdHNwb3RMZW5ndGg6IC0gMSxcblx0XHRcdHJlY3RBcmVhTGVuZ3RoOiAtIDEsXG5cdFx0XHRoZW1pTGVuZ3RoOiAtIDEsXG5cblx0XHRcdG51bURpcmVjdGlvbmFsU2hhZG93czogLSAxLFxuXHRcdFx0bnVtUG9pbnRTaGFkb3dzOiAtIDEsXG5cdFx0XHRudW1TcG90U2hhZG93czogLSAxLFxuXHRcdFx0bnVtU3BvdE1hcHM6IC0gMSxcblxuXHRcdFx0bnVtTGlnaHRQcm9iZXM6IC0gMVxuXHRcdH0sXG5cblx0XHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcblx0XHRwcm9iZTogW10sXG5cdFx0ZGlyZWN0aW9uYWw6IFtdLFxuXHRcdGRpcmVjdGlvbmFsU2hhZG93OiBbXSxcblx0XHRkaXJlY3Rpb25hbFNoYWRvd01hcDogW10sXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IFtdLFxuXHRcdHNwb3Q6IFtdLFxuXHRcdHNwb3RMaWdodE1hcDogW10sXG5cdFx0c3BvdFNoYWRvdzogW10sXG5cdFx0c3BvdFNoYWRvd01hcDogW10sXG5cdFx0c3BvdExpZ2h0TWF0cml4OiBbXSxcblx0XHRyZWN0QXJlYTogW10sXG5cdFx0cmVjdEFyZWFMVEMxOiBudWxsLFxuXHRcdHJlY3RBcmVhTFRDMjogbnVsbCxcblx0XHRwb2ludDogW10sXG5cdFx0cG9pbnRTaGFkb3c6IFtdLFxuXHRcdHBvaW50U2hhZG93TWFwOiBbXSxcblx0XHRwb2ludFNoYWRvd01hdHJpeDogW10sXG5cdFx0aGVtaTogW10sXG5cdFx0bnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzOiAwLFxuXHRcdG51bUxpZ2h0UHJvYmVzOiAwXG5cblx0fTtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkgc3RhdGUucHJvYmUucHVzaCggbmV3IFZlY3RvcjMoKSApO1xuXG5cdGNvbnN0IHZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBtYXRyaXg0ID0gbmV3IE1hdHJpeDQoKTtcblx0Y29uc3QgbWF0cml4NDIgPSBuZXcgTWF0cml4NCgpO1xuXG5cdGZ1bmN0aW9uIHNldHVwKCBsaWdodHMgKSB7XG5cblx0XHRsZXQgciA9IDAsIGcgPSAwLCBiID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSBzdGF0ZS5wcm9iZVsgaSBdLnNldCggMCwgMCwgMCApO1xuXG5cdFx0bGV0IGRpcmVjdGlvbmFsTGVuZ3RoID0gMDtcblx0XHRsZXQgcG9pbnRMZW5ndGggPSAwO1xuXHRcdGxldCBzcG90TGVuZ3RoID0gMDtcblx0XHRsZXQgcmVjdEFyZWFMZW5ndGggPSAwO1xuXHRcdGxldCBoZW1pTGVuZ3RoID0gMDtcblxuXHRcdGxldCBudW1EaXJlY3Rpb25hbFNoYWRvd3MgPSAwO1xuXHRcdGxldCBudW1Qb2ludFNoYWRvd3MgPSAwO1xuXHRcdGxldCBudW1TcG90U2hhZG93cyA9IDA7XG5cdFx0bGV0IG51bVNwb3RNYXBzID0gMDtcblx0XHRsZXQgbnVtU3BvdFNoYWRvd3NXaXRoTWFwcyA9IDA7XG5cblx0XHRsZXQgbnVtTGlnaHRQcm9iZXMgPSAwO1xuXG5cdFx0Ly8gb3JkZXJpbmcgOiBbc2hhZG93IGNhc3RpbmcgKyBtYXAgdGV4dHVyaW5nLCBtYXAgdGV4dHVyaW5nLCBzaGFkb3cgY2FzdGluZywgbm9uZSBdXG5cdFx0bGlnaHRzLnNvcnQoIHNoYWRvd0Nhc3RpbmdBbmRUZXh0dXJpbmdMaWdodHNGaXJzdCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XG5cblx0XHRcdGNvbnN0IGNvbG9yID0gbGlnaHQuY29sb3I7XG5cdFx0XHRjb25zdCBpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xuXG5cdFx0XHRjb25zdCBzaGFkb3dNYXAgPSAoIGxpZ2h0LnNoYWRvdyAmJiBsaWdodC5zaGFkb3cubWFwICkgPyBsaWdodC5zaGFkb3cubWFwLnRleHR1cmUgOiBudWxsO1xuXG5cdFx0XHRpZiAoIGxpZ2h0LmlzQW1iaWVudExpZ2h0ICkge1xuXG5cdFx0XHRcdHIgKz0gY29sb3IuciAqIGludGVuc2l0eTtcblx0XHRcdFx0ZyArPSBjb2xvci5nICogaW50ZW5zaXR5O1xuXHRcdFx0XHRiICs9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzTGlnaHRQcm9iZSApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCA5OyBqICsrICkge1xuXG5cdFx0XHRcdFx0c3RhdGUucHJvYmVbIGogXS5hZGRTY2FsZWRWZWN0b3IoIGxpZ2h0LnNoLmNvZWZmaWNpZW50c1sgaiBdLCBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bnVtTGlnaHRQcm9iZXMgKys7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzRGlyZWN0aW9uYWxMaWdodCApIHtcblxuXHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cblx0XHRcdFx0XHRjb25zdCBzaGFkb3dVbmlmb3JtcyA9IHNoYWRvd0NhY2hlLmdldCggbGlnaHQgKTtcblxuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dOb3JtYWxCaWFzID0gc2hhZG93Lm5vcm1hbEJpYXM7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93UmFkaXVzID0gc2hhZG93LnJhZGl1cztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XG5cblx0XHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd1sgZGlyZWN0aW9uYWxMZW5ndGggXSA9IHNoYWRvd1VuaWZvcm1zO1xuXHRcdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwWyBkaXJlY3Rpb25hbExlbmd0aCBdID0gc2hhZG93TWFwO1xuXHRcdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBkaXJlY3Rpb25hbExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcblxuXHRcdFx0XHRcdG51bURpcmVjdGlvbmFsU2hhZG93cyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0XHRkaXJlY3Rpb25hbExlbmd0aCArKztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNTcG90TGlnaHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNvbmVDb3MgPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKTtcblx0XHRcdFx0dW5pZm9ybXMucGVudW1icmFDb3MgPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKiAoIDEgLSBsaWdodC5wZW51bWJyYSApICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRlY2F5ID0gbGlnaHQuZGVjYXk7XG5cblx0XHRcdFx0c3RhdGUuc3BvdFsgc3BvdExlbmd0aCBdID0gdW5pZm9ybXM7XG5cblx0XHRcdFx0Y29uc3Qgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXG5cdFx0XHRcdGlmICggbGlnaHQubWFwICkge1xuXG5cdFx0XHRcdFx0c3RhdGUuc3BvdExpZ2h0TWFwWyBudW1TcG90TWFwcyBdID0gbGlnaHQubWFwO1xuXHRcdFx0XHRcdG51bVNwb3RNYXBzICsrO1xuXG5cdFx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSBsaWdodE1hdHJpeCBpcyB1cCB0byBkYXRlXG5cdFx0XHRcdFx0Ly8gVE9ETyA6IGRvIGl0IGlmIHJlcXVpcmVkIG9ubHlcblx0XHRcdFx0XHRzaGFkb3cudXBkYXRlTWF0cmljZXMoIGxpZ2h0ICk7XG5cblx0XHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSBudW1TcG90U2hhZG93c1dpdGhNYXBzICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0ZS5zcG90TGlnaHRNYXRyaXhbIHNwb3RMZW5ndGggXSA9IHNoYWRvdy5tYXRyaXg7XG5cblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2hhZG93VW5pZm9ybXMgPSBzaGFkb3dDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93Tm9ybWFsQmlhcyA9IHNoYWRvdy5ub3JtYWxCaWFzO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xuXG5cdFx0XHRcdFx0c3RhdGUuc3BvdFNoYWRvd1sgc3BvdExlbmd0aCBdID0gc2hhZG93VW5pZm9ybXM7XG5cdFx0XHRcdFx0c3RhdGUuc3BvdFNoYWRvd01hcFsgc3BvdExlbmd0aCBdID0gc2hhZG93TWFwO1xuXG5cdFx0XHRcdFx0bnVtU3BvdFNoYWRvd3MgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNwb3RMZW5ndGggKys7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUmVjdEFyZWFMaWdodCApIHtcblxuXHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBjb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguc2V0KCBsaWdodC53aWR0aCAqIDAuNSwgMC4wLCAwLjAgKTtcblx0XHRcdFx0dW5pZm9ybXMuaGFsZkhlaWdodC5zZXQoIDAuMCwgbGlnaHQuaGVpZ2h0ICogMC41LCAwLjAgKTtcblxuXHRcdFx0XHRzdGF0ZS5yZWN0QXJlYVsgcmVjdEFyZWFMZW5ndGggXSA9IHVuaWZvcm1zO1xuXG5cdFx0XHRcdHJlY3RBcmVhTGVuZ3RoICsrO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc1BvaW50TGlnaHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG5cdFx0XHRcdHVuaWZvcm1zLmRlY2F5ID0gbGlnaHQuZGVjYXk7XG5cblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2hhZG93VW5pZm9ybXMgPSBzaGFkb3dDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93Tm9ybWFsQmlhcyA9IHNoYWRvdy5ub3JtYWxCaWFzO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0NhbWVyYU5lYXIgPSBzaGFkb3cuY2FtZXJhLm5lYXI7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93Q2FtZXJhRmFyID0gc2hhZG93LmNhbWVyYS5mYXI7XG5cblx0XHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd1sgcG9pbnRMZW5ndGggXSA9IHNoYWRvd1VuaWZvcm1zO1xuXHRcdFx0XHRcdHN0YXRlLnBvaW50U2hhZG93TWFwWyBwb2ludExlbmd0aCBdID0gc2hhZG93TWFwO1xuXHRcdFx0XHRcdHN0YXRlLnBvaW50U2hhZG93TWF0cml4WyBwb2ludExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcblxuXHRcdFx0XHRcdG51bVBvaW50U2hhZG93cyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUucG9pbnRbIHBvaW50TGVuZ3RoIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0XHRwb2ludExlbmd0aCArKztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNIZW1pc3BoZXJlTGlnaHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuc2t5Q29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XG5cdFx0XHRcdHVuaWZvcm1zLmdyb3VuZENvbG9yLmNvcHkoIGxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdHN0YXRlLmhlbWlbIGhlbWlMZW5ndGggXSA9IHVuaWZvcm1zO1xuXG5cdFx0XHRcdGhlbWlMZW5ndGggKys7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggcmVjdEFyZWFMZW5ndGggPiAwICkge1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbnMuaGFzKCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHN0YXRlLnJlY3RBcmVhTFRDMSA9IFVuaWZvcm1zTGliLkxUQ19GTE9BVF8xO1xuXHRcdFx0XHRzdGF0ZS5yZWN0QXJlYUxUQzIgPSBVbmlmb3Jtc0xpYi5MVENfRkxPQVRfMjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdGF0ZS5yZWN0QXJlYUxUQzEgPSBVbmlmb3Jtc0xpYi5MVENfSEFMRl8xO1xuXHRcdFx0XHRzdGF0ZS5yZWN0QXJlYUxUQzIgPSBVbmlmb3Jtc0xpYi5MVENfSEFMRl8yO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5hbWJpZW50WyAwIF0gPSByO1xuXHRcdHN0YXRlLmFtYmllbnRbIDEgXSA9IGc7XG5cdFx0c3RhdGUuYW1iaWVudFsgMiBdID0gYjtcblxuXHRcdGNvbnN0IGhhc2ggPSBzdGF0ZS5oYXNoO1xuXG5cdFx0aWYgKCBoYXNoLmRpcmVjdGlvbmFsTGVuZ3RoICE9PSBkaXJlY3Rpb25hbExlbmd0aCB8fFxuXHRcdFx0aGFzaC5wb2ludExlbmd0aCAhPT0gcG9pbnRMZW5ndGggfHxcblx0XHRcdGhhc2guc3BvdExlbmd0aCAhPT0gc3BvdExlbmd0aCB8fFxuXHRcdFx0aGFzaC5yZWN0QXJlYUxlbmd0aCAhPT0gcmVjdEFyZWFMZW5ndGggfHxcblx0XHRcdGhhc2guaGVtaUxlbmd0aCAhPT0gaGVtaUxlbmd0aCB8fFxuXHRcdFx0aGFzaC5udW1EaXJlY3Rpb25hbFNoYWRvd3MgIT09IG51bURpcmVjdGlvbmFsU2hhZG93cyB8fFxuXHRcdFx0aGFzaC5udW1Qb2ludFNoYWRvd3MgIT09IG51bVBvaW50U2hhZG93cyB8fFxuXHRcdFx0aGFzaC5udW1TcG90U2hhZG93cyAhPT0gbnVtU3BvdFNoYWRvd3MgfHxcblx0XHRcdGhhc2gubnVtU3BvdE1hcHMgIT09IG51bVNwb3RNYXBzIHx8XG5cdFx0XHRoYXNoLm51bUxpZ2h0UHJvYmVzICE9PSBudW1MaWdodFByb2JlcyApIHtcblxuXHRcdFx0c3RhdGUuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyZWN0aW9uYWxMZW5ndGg7XG5cdFx0XHRzdGF0ZS5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XG5cdFx0XHRzdGF0ZS5yZWN0QXJlYS5sZW5ndGggPSByZWN0QXJlYUxlbmd0aDtcblx0XHRcdHN0YXRlLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xuXHRcdFx0c3RhdGUuaGVtaS5sZW5ndGggPSBoZW1pTGVuZ3RoO1xuXG5cdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvdy5sZW5ndGggPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcC5sZW5ndGggPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5wb2ludFNoYWRvdy5sZW5ndGggPSBudW1Qb2ludFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hcC5sZW5ndGggPSBudW1Qb2ludFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5zcG90U2hhZG93Lmxlbmd0aCA9IG51bVNwb3RTaGFkb3dzO1xuXHRcdFx0c3RhdGUuc3BvdFNoYWRvd01hcC5sZW5ndGggPSBudW1TcG90U2hhZG93cztcblx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4Lmxlbmd0aCA9IG51bURpcmVjdGlvbmFsU2hhZG93cztcblx0XHRcdHN0YXRlLnBvaW50U2hhZG93TWF0cml4Lmxlbmd0aCA9IG51bVBvaW50U2hhZG93cztcblx0XHRcdHN0YXRlLnNwb3RMaWdodE1hdHJpeC5sZW5ndGggPSBudW1TcG90U2hhZG93cyArIG51bVNwb3RNYXBzIC0gbnVtU3BvdFNoYWRvd3NXaXRoTWFwcztcblx0XHRcdHN0YXRlLnNwb3RMaWdodE1hcC5sZW5ndGggPSBudW1TcG90TWFwcztcblx0XHRcdHN0YXRlLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcyA9IG51bVNwb3RTaGFkb3dzV2l0aE1hcHM7XG5cdFx0XHRzdGF0ZS5udW1MaWdodFByb2JlcyA9IG51bUxpZ2h0UHJvYmVzO1xuXG5cdFx0XHRoYXNoLmRpcmVjdGlvbmFsTGVuZ3RoID0gZGlyZWN0aW9uYWxMZW5ndGg7XG5cdFx0XHRoYXNoLnBvaW50TGVuZ3RoID0gcG9pbnRMZW5ndGg7XG5cdFx0XHRoYXNoLnNwb3RMZW5ndGggPSBzcG90TGVuZ3RoO1xuXHRcdFx0aGFzaC5yZWN0QXJlYUxlbmd0aCA9IHJlY3RBcmVhTGVuZ3RoO1xuXHRcdFx0aGFzaC5oZW1pTGVuZ3RoID0gaGVtaUxlbmd0aDtcblxuXHRcdFx0aGFzaC5udW1EaXJlY3Rpb25hbFNoYWRvd3MgPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG5cdFx0XHRoYXNoLm51bVBvaW50U2hhZG93cyA9IG51bVBvaW50U2hhZG93cztcblx0XHRcdGhhc2gubnVtU3BvdFNoYWRvd3MgPSBudW1TcG90U2hhZG93cztcblx0XHRcdGhhc2gubnVtU3BvdE1hcHMgPSBudW1TcG90TWFwcztcblxuXHRcdFx0aGFzaC5udW1MaWdodFByb2JlcyA9IG51bUxpZ2h0UHJvYmVzO1xuXG5cdFx0XHRzdGF0ZS52ZXJzaW9uID0gbmV4dFZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldHVwVmlldyggbGlnaHRzLCBjYW1lcmEgKSB7XG5cblx0XHRsZXQgZGlyZWN0aW9uYWxMZW5ndGggPSAwO1xuXHRcdGxldCBwb2ludExlbmd0aCA9IDA7XG5cdFx0bGV0IHNwb3RMZW5ndGggPSAwO1xuXHRcdGxldCByZWN0QXJlYUxlbmd0aCA9IDA7XG5cdFx0bGV0IGhlbWlMZW5ndGggPSAwO1xuXG5cdFx0Y29uc3Qgdmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBsaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgbGlnaHQgPSBsaWdodHNbIGkgXTtcblxuXHRcdFx0aWYgKCBsaWdodC5pc0RpcmVjdGlvbmFsTGlnaHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5kaXJlY3Rpb25hbFsgZGlyZWN0aW9uYWxMZW5ndGggXTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR2ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIoIHZlY3RvcjMgKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdGRpcmVjdGlvbmFsTGVuZ3RoICsrO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc1Nwb3RMaWdodCApIHtcblxuXHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IHN0YXRlLnNwb3RbIHNwb3RMZW5ndGggXTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1YiggdmVjdG9yMyApO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XG5cblx0XHRcdFx0c3BvdExlbmd0aCArKztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNSZWN0QXJlYUxpZ2h0ICkge1xuXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gc3RhdGUucmVjdEFyZWFbIHJlY3RBcmVhTGVuZ3RoIF07XG5cblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHQvLyBleHRyYWN0IGxvY2FsIHJvdGF0aW9uIG9mIGxpZ2h0IHRvIGRlcml2ZSB3aWR0aC9oZWlnaHQgaGFsZiB2ZWN0b3JzXG5cdFx0XHRcdG1hdHJpeDQyLmlkZW50aXR5KCk7XG5cdFx0XHRcdG1hdHJpeDQuY29weSggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0bWF0cml4NC5wcmVtdWx0aXBseSggdmlld01hdHJpeCApO1xuXHRcdFx0XHRtYXRyaXg0Mi5leHRyYWN0Um90YXRpb24oIG1hdHJpeDQgKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguc2V0KCBsaWdodC53aWR0aCAqIDAuNSwgMC4wLCAwLjAgKTtcblx0XHRcdFx0dW5pZm9ybXMuaGFsZkhlaWdodC5zZXQoIDAuMCwgbGlnaHQuaGVpZ2h0ICogMC41LCAwLjAgKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KCBtYXRyaXg0MiApO1xuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LmFwcGx5TWF0cml4NCggbWF0cml4NDIgKTtcblxuXHRcdFx0XHRyZWN0QXJlYUxlbmd0aCArKztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNQb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gc3RhdGUucG9pbnRbIHBvaW50TGVuZ3RoIF07XG5cblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHRwb2ludExlbmd0aCArKztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNIZW1pc3BoZXJlTGlnaHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5oZW1pWyBoZW1pTGVuZ3RoIF07XG5cblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdGhlbWlMZW5ndGggKys7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzZXR1cDogc2V0dXAsXG5cdFx0c2V0dXBWaWV3OiBzZXR1cFZpZXcsXG5cdFx0c3RhdGU6IHN0YXRlXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xSZW5kZXJTdGF0ZSggZXh0ZW5zaW9ucyApIHtcblxuXHRjb25zdCBsaWdodHMgPSBuZXcgV2ViR0xMaWdodHMoIGV4dGVuc2lvbnMgKTtcblxuXHRjb25zdCBsaWdodHNBcnJheSA9IFtdO1xuXHRjb25zdCBzaGFkb3dzQXJyYXkgPSBbXTtcblxuXHRmdW5jdGlvbiBpbml0KCBjYW1lcmEgKSB7XG5cblx0XHRzdGF0ZS5jYW1lcmEgPSBjYW1lcmE7XG5cblx0XHRsaWdodHNBcnJheS5sZW5ndGggPSAwO1xuXHRcdHNoYWRvd3NBcnJheS5sZW5ndGggPSAwO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBwdXNoTGlnaHQoIGxpZ2h0ICkge1xuXG5cdFx0bGlnaHRzQXJyYXkucHVzaCggbGlnaHQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcHVzaFNoYWRvdyggc2hhZG93TGlnaHQgKSB7XG5cblx0XHRzaGFkb3dzQXJyYXkucHVzaCggc2hhZG93TGlnaHQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0dXBMaWdodHMoKSB7XG5cblx0XHRsaWdodHMuc2V0dXAoIGxpZ2h0c0FycmF5ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldHVwTGlnaHRzVmlldyggY2FtZXJhICkge1xuXG5cdFx0bGlnaHRzLnNldHVwVmlldyggbGlnaHRzQXJyYXksIGNhbWVyYSApO1xuXG5cdH1cblxuXHRjb25zdCBzdGF0ZSA9IHtcblx0XHRsaWdodHNBcnJheTogbGlnaHRzQXJyYXksXG5cdFx0c2hhZG93c0FycmF5OiBzaGFkb3dzQXJyYXksXG5cblx0XHRjYW1lcmE6IG51bGwsXG5cblx0XHRsaWdodHM6IGxpZ2h0cyxcblxuXHRcdHRyYW5zbWlzc2lvblJlbmRlclRhcmdldDoge31cblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdGluaXQ6IGluaXQsXG5cdFx0c3RhdGU6IHN0YXRlLFxuXHRcdHNldHVwTGlnaHRzOiBzZXR1cExpZ2h0cyxcblx0XHRzZXR1cExpZ2h0c1ZpZXc6IHNldHVwTGlnaHRzVmlldyxcblxuXHRcdHB1c2hMaWdodDogcHVzaExpZ2h0LFxuXHRcdHB1c2hTaGFkb3c6IHB1c2hTaGFkb3dcblx0fTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTFJlbmRlclN0YXRlcyggZXh0ZW5zaW9ucyApIHtcblxuXHRsZXQgcmVuZGVyU3RhdGVzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRmdW5jdGlvbiBnZXQoIHNjZW5lLCByZW5kZXJDYWxsRGVwdGggPSAwICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyU3RhdGVBcnJheSA9IHJlbmRlclN0YXRlcy5nZXQoIHNjZW5lICk7XG5cdFx0bGV0IHJlbmRlclN0YXRlO1xuXG5cdFx0aWYgKCByZW5kZXJTdGF0ZUFycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlbmRlclN0YXRlID0gbmV3IFdlYkdMUmVuZGVyU3RhdGUoIGV4dGVuc2lvbnMgKTtcblx0XHRcdHJlbmRlclN0YXRlcy5zZXQoIHNjZW5lLCBbIHJlbmRlclN0YXRlIF0gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggcmVuZGVyQ2FsbERlcHRoID49IHJlbmRlclN0YXRlQXJyYXkubGVuZ3RoICkge1xuXG5cdFx0XHRcdHJlbmRlclN0YXRlID0gbmV3IFdlYkdMUmVuZGVyU3RhdGUoIGV4dGVuc2lvbnMgKTtcblx0XHRcdFx0cmVuZGVyU3RhdGVBcnJheS5wdXNoKCByZW5kZXJTdGF0ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVBcnJheVsgcmVuZGVyQ2FsbERlcHRoIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZW5kZXJTdGF0ZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuXHRcdHJlbmRlclN0YXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBnZXQsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHR9O1xuXG59XG5cbmNsYXNzIE1lc2hEZXB0aE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNNZXNoRGVwdGhNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5kZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZztcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5kZXB0aFBhY2tpbmcgPSBzb3VyY2UuZGVwdGhQYWNraW5nO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBNZXNoRGlzdGFuY2VNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hEaXN0YW5jZU1hdGVyaWFsJztcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jb25zdCB2ZXJ0ZXggPSBcInZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59XCI7XG5cbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dfcGFzcztcXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXG4jaW5jbHVkZSA8cGFja2luZz5cXG52b2lkIG1haW4oKSB7XFxuXFx0Y29uc3QgZmxvYXQgc2FtcGxlcyA9IGZsb2F0KCBWU01fU0FNUExFUyApO1xcblxcdGZsb2F0IG1lYW4gPSAwLjA7XFxuXFx0ZmxvYXQgc3F1YXJlZF9tZWFuID0gMC4wO1xcblxcdGZsb2F0IHV2U3RyaWRlID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAyLjAgLyAoIHNhbXBsZXMgLSAxLjAgKTtcXG5cXHRmbG9hdCB1dlN0YXJ0ID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAtIDEuMDtcXG5cXHRmb3IgKCBmbG9hdCBpID0gMC4wOyBpIDwgc2FtcGxlczsgaSArKyApIHtcXG5cXHRcXHRmbG9hdCB1dk9mZnNldCA9IHV2U3RhcnQgKyBpICogdXZTdHJpZGU7XFxuXFx0XFx0I2lmZGVmIEhPUklaT05UQUxfUEFTU1xcblxcdFxcdFxcdHZlYzIgZGlzdHJpYnV0aW9uID0gdW5wYWNrUkdCQVRvMkhhbGYoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggdXZPZmZzZXQsIDAuMCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTtcXG5cXHRcXHRcXHRtZWFuICs9IGRpc3RyaWJ1dGlvbi54O1xcblxcdFxcdFxcdHNxdWFyZWRfbWVhbiArPSBkaXN0cmlidXRpb24ueSAqIGRpc3RyaWJ1dGlvbi55ICsgZGlzdHJpYnV0aW9uLnggKiBkaXN0cmlidXRpb24ueDtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdGZsb2F0IGRlcHRoID0gdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggMC4wLCB1dk9mZnNldCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTtcXG5cXHRcXHRcXHRtZWFuICs9IGRlcHRoO1xcblxcdFxcdFxcdHNxdWFyZWRfbWVhbiArPSBkZXB0aCAqIGRlcHRoO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHRtZWFuID0gbWVhbiAvIHNhbXBsZXM7XFxuXFx0c3F1YXJlZF9tZWFuID0gc3F1YXJlZF9tZWFuIC8gc2FtcGxlcztcXG5cXHRmbG9hdCBzdGRfZGV2ID0gc3FydCggc3F1YXJlZF9tZWFuIC0gbWVhbiAqIG1lYW4gKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSBwYWNrMkhhbGZUb1JHQkEoIHZlYzIoIG1lYW4sIHN0ZF9kZXYgKSApO1xcbn1cIjtcblxuZnVuY3Rpb24gV2ViR0xTaGFkb3dNYXAoIHJlbmRlcmVyLCBvYmplY3RzLCBjYXBhYmlsaXRpZXMgKSB7XG5cblx0bGV0IF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcblxuXHRjb25zdCBfc2hhZG93TWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCksXG5cdFx0X3ZpZXdwb3J0U2l6ZSA9IG5ldyBWZWN0b3IyKCksXG5cblx0XHRfdmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpLFxuXG5cdFx0X2RlcHRoTWF0ZXJpYWwgPSBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoIHsgZGVwdGhQYWNraW5nOiBSR0JBRGVwdGhQYWNraW5nIH0gKSxcblx0XHRfZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBNZXNoRGlzdGFuY2VNYXRlcmlhbCgpLFxuXG5cdFx0X21hdGVyaWFsQ2FjaGUgPSB7fSxcblxuXHRcdF9tYXhUZXh0dXJlU2l6ZSA9IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcblxuXHRjb25zdCBzaGFkb3dTaWRlID0geyBbIEZyb250U2lkZSBdOiBCYWNrU2lkZSwgWyBCYWNrU2lkZSBdOiBGcm9udFNpZGUsIFsgRG91YmxlU2lkZSBdOiBEb3VibGVTaWRlIH07XG5cblx0Y29uc3Qgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbCA9IG5ldyBTaGFkZXJNYXRlcmlhbCgge1xuXHRcdGRlZmluZXM6IHtcblx0XHRcdFZTTV9TQU1QTEVTOiA4XG5cdFx0fSxcblx0XHR1bmlmb3Jtczoge1xuXHRcdFx0c2hhZG93X3Bhc3M6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdHJlc29sdXRpb246IHsgdmFsdWU6IG5ldyBWZWN0b3IyKCkgfSxcblx0XHRcdHJhZGl1czogeyB2YWx1ZTogNC4wIH1cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50XG5cblx0fSApO1xuXG5cdGNvbnN0IHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbCA9IHNoYWRvd01hdGVyaWFsVmVydGljYWwuY2xvbmUoKTtcblx0c2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLmRlZmluZXMuSE9SSVpPTlRBTF9QQVNTID0gMTtcblxuXHRjb25zdCBmdWxsU2NyZWVuVHJpID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdGZ1bGxTY3JlZW5Ucmkuc2V0QXR0cmlidXRlKFxuXHRcdCdwb3NpdGlvbicsXG5cdFx0bmV3IEJ1ZmZlckF0dHJpYnV0ZShcblx0XHRcdG5ldyBGbG9hdDMyQXJyYXkoIFsgLSAxLCAtIDEsIDAuNSwgMywgLSAxLCAwLjUsIC0gMSwgMywgMC41IF0gKSxcblx0XHRcdDNcblx0XHQpXG5cdCk7XG5cblx0Y29uc3QgZnVsbFNjcmVlbk1lc2ggPSBuZXcgTWVzaCggZnVsbFNjcmVlblRyaSwgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbCApO1xuXG5cdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy50eXBlID0gUENGU2hhZG93TWFwO1xuXHRsZXQgX3ByZXZpb3VzVHlwZSA9IHRoaXMudHlwZTtcblxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggbGlnaHRzLCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblx0XHRpZiAoIHNjb3BlLmF1dG9VcGRhdGUgPT09IGZhbHNlICYmIHNjb3BlLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGlmICggbGlnaHRzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRjb25zdCBhY3RpdmVDdWJlRmFjZSA9IHJlbmRlcmVyLmdldEFjdGl2ZUN1YmVGYWNlKCk7XG5cdFx0Y29uc3QgYWN0aXZlTWlwbWFwTGV2ZWwgPSByZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xuXG5cdFx0Y29uc3QgX3N0YXRlID0gcmVuZGVyZXIuc3RhdGU7XG5cblx0XHQvLyBTZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcC5cblx0XHRfc3RhdGUuc2V0QmxlbmRpbmcoIE5vQmxlbmRpbmcgKTtcblx0XHRfc3RhdGUuYnVmZmVycy5jb2xvci5zZXRDbGVhciggMSwgMSwgMSwgMSApO1xuXHRcdF9zdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoIHRydWUgKTtcblx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XG5cblx0XHQvLyBjaGVjayBmb3Igc2hhZG93IG1hcCB0eXBlIGNoYW5nZXNcblxuXHRcdGNvbnN0IHRvVlNNID0gKCBfcHJldmlvdXNUeXBlICE9PSBWU01TaGFkb3dNYXAgJiYgdGhpcy50eXBlID09PSBWU01TaGFkb3dNYXAgKTtcblx0XHRjb25zdCBmcm9tVlNNID0gKCBfcHJldmlvdXNUeXBlID09PSBWU01TaGFkb3dNYXAgJiYgdGhpcy50eXBlICE9PSBWU01TaGFkb3dNYXAgKTtcblxuXHRcdC8vIHJlbmRlciBkZXB0aCBtYXBcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XG5cdFx0XHRjb25zdCBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cblx0XHRcdGlmICggc2hhZG93ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xTaGFkb3dNYXA6JywgbGlnaHQsICdoYXMgbm8gc2hhZG93LicgKTtcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzaGFkb3cuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2hhZG93Lm5lZWRzVXBkYXRlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRfc2hhZG93TWFwU2l6ZS5jb3B5KCBzaGFkb3cubWFwU2l6ZSApO1xuXG5cdFx0XHRjb25zdCBzaGFkb3dGcmFtZUV4dGVudHMgPSBzaGFkb3cuZ2V0RnJhbWVFeHRlbnRzKCk7XG5cblx0XHRcdF9zaGFkb3dNYXBTaXplLm11bHRpcGx5KCBzaGFkb3dGcmFtZUV4dGVudHMgKTtcblxuXHRcdFx0X3ZpZXdwb3J0U2l6ZS5jb3B5KCBzaGFkb3cubWFwU2l6ZSApO1xuXG5cdFx0XHRpZiAoIF9zaGFkb3dNYXBTaXplLnggPiBfbWF4VGV4dHVyZVNpemUgfHwgX3NoYWRvd01hcFNpemUueSA+IF9tYXhUZXh0dXJlU2l6ZSApIHtcblxuXHRcdFx0XHRpZiAoIF9zaGFkb3dNYXBTaXplLnggPiBfbWF4VGV4dHVyZVNpemUgKSB7XG5cblx0XHRcdFx0XHRfdmlld3BvcnRTaXplLnggPSBNYXRoLmZsb29yKCBfbWF4VGV4dHVyZVNpemUgLyBzaGFkb3dGcmFtZUV4dGVudHMueCApO1xuXHRcdFx0XHRcdF9zaGFkb3dNYXBTaXplLnggPSBfdmlld3BvcnRTaXplLnggKiBzaGFkb3dGcmFtZUV4dGVudHMueDtcblx0XHRcdFx0XHRzaGFkb3cubWFwU2l6ZS54ID0gX3ZpZXdwb3J0U2l6ZS54O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIF9zaGFkb3dNYXBTaXplLnkgPiBfbWF4VGV4dHVyZVNpemUgKSB7XG5cblx0XHRcdFx0XHRfdmlld3BvcnRTaXplLnkgPSBNYXRoLmZsb29yKCBfbWF4VGV4dHVyZVNpemUgLyBzaGFkb3dGcmFtZUV4dGVudHMueSApO1xuXHRcdFx0XHRcdF9zaGFkb3dNYXBTaXplLnkgPSBfdmlld3BvcnRTaXplLnkgKiBzaGFkb3dGcmFtZUV4dGVudHMueTtcblx0XHRcdFx0XHRzaGFkb3cubWFwU2l6ZS55ID0gX3ZpZXdwb3J0U2l6ZS55O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNoYWRvdy5tYXAgPT09IG51bGwgfHwgdG9WU00gPT09IHRydWUgfHwgZnJvbVZTTSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjb25zdCBwYXJzID0gKCB0aGlzLnR5cGUgIT09IFZTTVNoYWRvd01hcCApID8geyBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlciB9IDoge307XG5cblx0XHRcdFx0aWYgKCBzaGFkb3cubWFwICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0c2hhZG93Lm1hcC5kaXNwb3NlKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoYWRvdy5tYXAgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoIF9zaGFkb3dNYXBTaXplLngsIF9zaGFkb3dNYXBTaXplLnksIHBhcnMgKTtcblx0XHRcdFx0c2hhZG93Lm1hcC50ZXh0dXJlLm5hbWUgPSBsaWdodC5uYW1lICsgJy5zaGFkb3dNYXAnO1xuXG5cdFx0XHRcdHNoYWRvdy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93Lm1hcCApO1xuXHRcdFx0cmVuZGVyZXIuY2xlYXIoKTtcblxuXHRcdFx0Y29uc3Qgdmlld3BvcnRDb3VudCA9IHNoYWRvdy5nZXRWaWV3cG9ydENvdW50KCk7XG5cblx0XHRcdGZvciAoIGxldCB2cCA9IDA7IHZwIDwgdmlld3BvcnRDb3VudDsgdnAgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgdmlld3BvcnQgPSBzaGFkb3cuZ2V0Vmlld3BvcnQoIHZwICk7XG5cblx0XHRcdFx0X3ZpZXdwb3J0LnNldChcblx0XHRcdFx0XHRfdmlld3BvcnRTaXplLnggKiB2aWV3cG9ydC54LFxuXHRcdFx0XHRcdF92aWV3cG9ydFNpemUueSAqIHZpZXdwb3J0LnksXG5cdFx0XHRcdFx0X3ZpZXdwb3J0U2l6ZS54ICogdmlld3BvcnQueixcblx0XHRcdFx0XHRfdmlld3BvcnRTaXplLnkgKiB2aWV3cG9ydC53XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0X3N0YXRlLnZpZXdwb3J0KCBfdmlld3BvcnQgKTtcblxuXHRcdFx0XHRzaGFkb3cudXBkYXRlTWF0cmljZXMoIGxpZ2h0LCB2cCApO1xuXG5cdFx0XHRcdF9mcnVzdHVtID0gc2hhZG93LmdldEZydXN0dW0oKTtcblxuXHRcdFx0XHRyZW5kZXJPYmplY3QoIHNjZW5lLCBjYW1lcmEsIHNoYWRvdy5jYW1lcmEsIGxpZ2h0LCB0aGlzLnR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBkbyBibHVyIHBhc3MgZm9yIFZTTVxuXG5cdFx0XHRpZiAoIHNoYWRvdy5pc1BvaW50TGlnaHRTaGFkb3cgIT09IHRydWUgJiYgdGhpcy50eXBlID09PSBWU01TaGFkb3dNYXAgKSB7XG5cblx0XHRcdFx0VlNNUGFzcyggc2hhZG93LCBjYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzaGFkb3cubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdF9wcmV2aW91c1R5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdXJyZW50UmVuZGVyVGFyZ2V0LCBhY3RpdmVDdWJlRmFjZSwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFZTTVBhc3MoIHNoYWRvdywgY2FtZXJhICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZSggZnVsbFNjcmVlbk1lc2ggKTtcblxuXHRcdGlmICggc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC5kZWZpbmVzLlZTTV9TQU1QTEVTICE9PSBzaGFkb3cuYmx1clNhbXBsZXMgKSB7XG5cblx0XHRcdHNoYWRvd01hdGVyaWFsVmVydGljYWwuZGVmaW5lcy5WU01fU0FNUExFUyA9IHNoYWRvdy5ibHVyU2FtcGxlcztcblx0XHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC5kZWZpbmVzLlZTTV9TQU1QTEVTID0gc2hhZG93LmJsdXJTYW1wbGVzO1xuXG5cdFx0XHRzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIHNoYWRvdy5tYXBQYXNzID09PSBudWxsICkge1xuXG5cdFx0XHRzaGFkb3cubWFwUGFzcyA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCggX3NoYWRvd01hcFNpemUueCwgX3NoYWRvd01hcFNpemUueSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdmVydGljYWwgcGFzc1xuXG5cdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZSA9IHNoYWRvdy5tYXAudGV4dHVyZTtcblx0XHRzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUgPSBzaGFkb3cubWFwU2l6ZTtcblx0XHRzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHNoYWRvdy5yYWRpdXM7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3cubWFwUGFzcyApO1xuXHRcdHJlbmRlcmVyLmNsZWFyKCk7XG5cdFx0cmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLCBmdWxsU2NyZWVuTWVzaCwgbnVsbCApO1xuXG5cdFx0Ly8gaG9yaXpvbnRhbCBwYXNzXG5cblx0XHRzaGFkb3dNYXRlcmlhbEhvcml6b250YWwudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWUgPSBzaGFkb3cubWFwUGFzcy50ZXh0dXJlO1xuXHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlID0gc2hhZG93Lm1hcFNpemU7XG5cdFx0c2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHNoYWRvdy5yYWRpdXM7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3cubWFwICk7XG5cdFx0cmVuZGVyZXIuY2xlYXIoKTtcblx0XHRyZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbCwgZnVsbFNjcmVlbk1lc2gsIG51bGwgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgbGlnaHQsIHR5cGUgKSB7XG5cblx0XHRsZXQgcmVzdWx0ID0gbnVsbDtcblxuXHRcdGNvbnN0IGN1c3RvbU1hdGVyaWFsID0gKCBsaWdodC5pc1BvaW50TGlnaHQgPT09IHRydWUgKSA/IG9iamVjdC5jdXN0b21EaXN0YW5jZU1hdGVyaWFsIDogb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWw7XG5cblx0XHRpZiAoIGN1c3RvbU1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlc3VsdCA9IGN1c3RvbU1hdGVyaWFsO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVzdWx0ID0gKCBsaWdodC5pc1BvaW50TGlnaHQgPT09IHRydWUgKSA/IF9kaXN0YW5jZU1hdGVyaWFsIDogX2RlcHRoTWF0ZXJpYWw7XG5cblx0XHRcdGlmICggKCByZW5kZXJlci5sb2NhbENsaXBwaW5nRW5hYmxlZCAmJiBtYXRlcmlhbC5jbGlwU2hhZG93cyA9PT0gdHJ1ZSAmJiBBcnJheS5pc0FycmF5KCBtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcyApICYmIG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLmxlbmd0aCAhPT0gMCApIHx8XG5cdFx0XHRcdCggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICYmIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlICE9PSAwICkgfHxcblx0XHRcdFx0KCBtYXRlcmlhbC5hbHBoYU1hcCAmJiBtYXRlcmlhbC5hbHBoYVRlc3QgPiAwICkgfHxcblx0XHRcdFx0KCBtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCApICkge1xuXG5cdFx0XHRcdC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIGEgdW5pcXVlIG1hdGVyaWFsIGluc3RhbmNlIHJlZmxlY3RpbmcgdGhlXG5cdFx0XHRcdC8vIGFwcHJvcHJpYXRlIHN0YXRlXG5cblx0XHRcdFx0Y29uc3Qga2V5QSA9IHJlc3VsdC51dWlkLCBrZXlCID0gbWF0ZXJpYWwudXVpZDtcblxuXHRcdFx0XHRsZXQgbWF0ZXJpYWxzRm9yVmFyaWFudCA9IF9tYXRlcmlhbENhY2hlWyBrZXlBIF07XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbHNGb3JWYXJpYW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbHNGb3JWYXJpYW50ID0ge307XG5cdFx0XHRcdFx0X21hdGVyaWFsQ2FjaGVbIGtleUEgXSA9IG1hdGVyaWFsc0ZvclZhcmlhbnQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXTtcblxuXHRcdFx0XHRpZiAoIGNhY2hlZE1hdGVyaWFsID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjYWNoZWRNYXRlcmlhbCA9IHJlc3VsdC5jbG9uZSgpO1xuXHRcdFx0XHRcdG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXSA9IGNhY2hlZE1hdGVyaWFsO1xuXHRcdFx0XHRcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ID0gY2FjaGVkTWF0ZXJpYWw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJlc3VsdC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcblx0XHRyZXN1bHQud2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lO1xuXG5cdFx0aWYgKCB0eXBlID09PSBWU01TaGFkb3dNYXAgKSB7XG5cblx0XHRcdHJlc3VsdC5zaWRlID0gKCBtYXRlcmlhbC5zaGFkb3dTaWRlICE9PSBudWxsICkgPyBtYXRlcmlhbC5zaGFkb3dTaWRlIDogbWF0ZXJpYWwuc2lkZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlc3VsdC5zaWRlID0gKCBtYXRlcmlhbC5zaGFkb3dTaWRlICE9PSBudWxsICkgPyBtYXRlcmlhbC5zaGFkb3dTaWRlIDogc2hhZG93U2lkZVsgbWF0ZXJpYWwuc2lkZSBdO1xuXG5cdFx0fVxuXG5cdFx0cmVzdWx0LmFscGhhTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cdFx0cmVzdWx0LmFscGhhVGVzdCA9IG1hdGVyaWFsLmFscGhhVGVzdDtcblx0XHRyZXN1bHQubWFwID0gbWF0ZXJpYWwubWFwO1xuXG5cdFx0cmVzdWx0LmNsaXBTaGFkb3dzID0gbWF0ZXJpYWwuY2xpcFNoYWRvd3M7XG5cdFx0cmVzdWx0LmNsaXBwaW5nUGxhbmVzID0gbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXM7XG5cdFx0cmVzdWx0LmNsaXBJbnRlcnNlY3Rpb24gPSBtYXRlcmlhbC5jbGlwSW50ZXJzZWN0aW9uO1xuXG5cdFx0cmVzdWx0LmRpc3BsYWNlbWVudE1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRyZXN1bHQuZGlzcGxhY2VtZW50U2NhbGUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRyZXN1bHQuZGlzcGxhY2VtZW50QmlhcyA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRyZXN1bHQud2lyZWZyYW1lTGluZXdpZHRoID0gbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHJlc3VsdC5saW5ld2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XG5cblx0XHRpZiAoIGxpZ2h0LmlzUG9pbnRMaWdodCA9PT0gdHJ1ZSAmJiByZXN1bHQuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcmVuZGVyZXIucHJvcGVydGllcy5nZXQoIHJlc3VsdCApO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0ID0gbGlnaHQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJPYmplY3QoIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGxpZ2h0LCB0eXBlICkge1xuXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRjb25zdCB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICk7XG5cblx0XHRpZiAoIHZpc2libGUgJiYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkgKSB7XG5cblx0XHRcdGlmICggKCBvYmplY3QuY2FzdFNoYWRvdyB8fCAoIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmIHR5cGUgPT09IFZTTVNoYWRvd01hcCApICkgJiYgKCAhIG9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApICkgKSB7XG5cblx0XHRcdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGsgPSAwLCBrbCA9IGdyb3Vwcy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGsgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIGdyb3VwTWF0ZXJpYWwsIGxpZ2h0LCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0Lm9uQmVmb3JlU2hhZG93KCByZW5kZXJlciwgb2JqZWN0LCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIGdyb3VwICk7XG5cblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0Lm9uQWZ0ZXJTaGFkb3coIHJlbmRlcmVyLCBvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgZ3JvdXAgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgbGlnaHQsIHR5cGUgKTtcblxuXHRcdFx0XHRcdG9iamVjdC5vbkJlZm9yZVNoYWRvdyggcmVuZGVyZXIsIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBudWxsICk7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgbnVsbCApO1xuXG5cdFx0XHRcdFx0b2JqZWN0Lm9uQWZ0ZXJTaGFkb3coIHJlbmRlcmVyLCBvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgbnVsbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRyZW5kZXJPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBsaWdodCwgdHlwZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHRcdC8vIG1ha2Ugc3VyZSB0byByZW1vdmUgdGhlIHVuaXF1ZSBkaXN0YW5jZS9kZXB0aCBtYXRlcmlhbHMgdXNlZCBmb3Igc2hhZG93IG1hcCByZW5kZXJpbmdcblxuXHRcdGZvciAoIGNvbnN0IGlkIGluIF9tYXRlcmlhbENhY2hlICkge1xuXG5cdFx0XHRjb25zdCBjYWNoZSA9IF9tYXRlcmlhbENhY2hlWyBpZCBdO1xuXG5cdFx0XHRjb25zdCB1dWlkID0gZXZlbnQudGFyZ2V0LnV1aWQ7XG5cblx0XHRcdGlmICggdXVpZCBpbiBjYWNoZSApIHtcblxuXHRcdFx0XHRjb25zdCBzaGFkb3dNYXRlcmlhbCA9IGNhY2hlWyB1dWlkIF07XG5cdFx0XHRcdHNoYWRvd01hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyB1dWlkIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xTdGF0ZSggZ2wgKSB7XG5cblx0ZnVuY3Rpb24gQ29sb3JCdWZmZXIoKSB7XG5cblx0XHRsZXQgbG9ja2VkID0gZmFsc2U7XG5cblx0XHRjb25zdCBjb2xvciA9IG5ldyBWZWN0b3I0KCk7XG5cdFx0bGV0IGN1cnJlbnRDb2xvck1hc2sgPSBudWxsO1xuXHRcdGNvbnN0IGN1cnJlbnRDb2xvckNsZWFyID0gbmV3IFZlY3RvcjQoIDAsIDAsIDAsIDAgKTtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggY29sb3JNYXNrICkge1xuXG5cdFx0XHRcdGlmICggY3VycmVudENvbG9yTWFzayAhPT0gY29sb3JNYXNrICYmICEgbG9ja2VkICkge1xuXG5cdFx0XHRcdFx0Z2wuY29sb3JNYXNrKCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2sgKTtcblx0XHRcdFx0XHRjdXJyZW50Q29sb3JNYXNrID0gY29sb3JNYXNrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XG5cblx0XHRcdFx0bG9ja2VkID0gbG9jaztcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggciwgZywgYiwgYSwgcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG5cdFx0XHRcdGlmICggcHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0ciAqPSBhOyBnICo9IGE7IGIgKj0gYTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29sb3Iuc2V0KCByLCBnLCBiLCBhICk7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50Q29sb3JDbGVhci5lcXVhbHMoIGNvbG9yICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0Z2wuY2xlYXJDb2xvciggciwgZywgYiwgYSApO1xuXHRcdFx0XHRcdGN1cnJlbnRDb2xvckNsZWFyLmNvcHkoIGNvbG9yICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGN1cnJlbnRDb2xvck1hc2sgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50Q29sb3JDbGVhci5zZXQoIC0gMSwgMCwgMCwgMCApOyAvLyBzZXQgdG8gaW52YWxpZCBzdGF0ZVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBEZXB0aEJ1ZmZlcigpIHtcblxuXHRcdGxldCBsb2NrZWQgPSBmYWxzZTtcblxuXHRcdGxldCBjdXJyZW50RGVwdGhNYXNrID0gbnVsbDtcblx0XHRsZXQgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHNldFRlc3Q6IGZ1bmN0aW9uICggZGVwdGhUZXN0ICkge1xuXG5cdFx0XHRcdGlmICggZGVwdGhUZXN0ICkge1xuXG5cdFx0XHRcdFx0ZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggZGVwdGhNYXNrICkge1xuXG5cdFx0XHRcdGlmICggY3VycmVudERlcHRoTWFzayAhPT0gZGVwdGhNYXNrICYmICEgbG9ja2VkICkge1xuXG5cdFx0XHRcdFx0Z2wuZGVwdGhNYXNrKCBkZXB0aE1hc2sgKTtcblx0XHRcdFx0XHRjdXJyZW50RGVwdGhNYXNrID0gZGVwdGhNYXNrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0RnVuYzogZnVuY3Rpb24gKCBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgTmV2ZXJEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLk5FVkVSICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEFsd2F5c0RlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuQUxXQVlTICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIExlc3NEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgTGVzc0VxdWFsRGVwdGg6XG5cblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgRXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkVRVUFMICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEdyZWF0ZXJFcXVhbERlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEdyZWF0ZXJEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkdSRUFURVIgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgTm90RXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLk5PVEVRVUFMICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XG5cblx0XHRcdFx0bG9ja2VkID0gbG9jaztcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggZGVwdGggKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50RGVwdGhDbGVhciAhPT0gZGVwdGggKSB7XG5cblx0XHRcdFx0XHRnbC5jbGVhckRlcHRoKCBkZXB0aCApO1xuXHRcdFx0XHRcdGN1cnJlbnREZXB0aENsZWFyID0gZGVwdGg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudERlcHRoQ2xlYXIgPSBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBTdGVuY2lsQnVmZmVyKCkge1xuXG5cdFx0bGV0IGxvY2tlZCA9IGZhbHNlO1xuXG5cdFx0bGV0IGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRTdGVuY2lsUmVmID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRTdGVuY2lsRmFpbCA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRzZXRUZXN0OiBmdW5jdGlvbiAoIHN0ZW5jaWxUZXN0ICkge1xuXG5cdFx0XHRcdGlmICggISBsb2NrZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHN0ZW5jaWxUZXN0ICkge1xuXG5cdFx0XHRcdFx0XHRlbmFibGUoIGdsLlNURU5DSUxfVEVTVCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZGlzYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoIHN0ZW5jaWxNYXNrICkge1xuXG5cdFx0XHRcdGlmICggY3VycmVudFN0ZW5jaWxNYXNrICE9PSBzdGVuY2lsTWFzayAmJiAhIGxvY2tlZCApIHtcblxuXHRcdFx0XHRcdGdsLnN0ZW5jaWxNYXNrKCBzdGVuY2lsTWFzayApO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsTWFzayA9IHN0ZW5jaWxNYXNrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0RnVuYzogZnVuY3Rpb24gKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZ1bmMgIT09IHN0ZW5jaWxGdW5jIHx8XG5cdFx0XHRcdCAgICAgY3VycmVudFN0ZW5jaWxSZWYgIT09IHN0ZW5jaWxSZWYgfHxcblx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrICE9PSBzdGVuY2lsTWFzayApIHtcblxuXHRcdFx0XHRcdGdsLnN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcblxuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsUmVmID0gc3RlbmNpbFJlZjtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gc3RlbmNpbE1hc2s7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRPcDogZnVuY3Rpb24gKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZhaWwgIT09IHN0ZW5jaWxGYWlsIHx8XG5cdFx0XHRcdCAgICAgY3VycmVudFN0ZW5jaWxaRmFpbCAhPT0gc3RlbmNpbFpGYWlsIHx8XG5cdFx0XHRcdCAgICAgY3VycmVudFN0ZW5jaWxaUGFzcyAhPT0gc3RlbmNpbFpQYXNzICkge1xuXG5cdFx0XHRcdFx0Z2wuc3RlbmNpbE9wKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKTtcblxuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IHN0ZW5jaWxGYWlsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBzdGVuY2lsWkZhaWw7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaUGFzcyA9IHN0ZW5jaWxaUGFzcztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xuXG5cdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoIHN0ZW5jaWwgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbENsZWFyICE9PSBzdGVuY2lsICkge1xuXG5cdFx0XHRcdFx0Z2wuY2xlYXJTdGVuY2lsKCBzdGVuY2lsICk7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxDbGVhciA9IHN0ZW5jaWw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsUmVmID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdC8vXG5cblx0Y29uc3QgY29sb3JCdWZmZXIgPSBuZXcgQ29sb3JCdWZmZXIoKTtcblx0Y29uc3QgZGVwdGhCdWZmZXIgPSBuZXcgRGVwdGhCdWZmZXIoKTtcblx0Y29uc3Qgc3RlbmNpbEJ1ZmZlciA9IG5ldyBTdGVuY2lsQnVmZmVyKCk7XG5cblx0Y29uc3QgdWJvQmluZGluZ3MgPSBuZXcgV2Vha01hcCgpO1xuXHRjb25zdCB1Ym9Qcm9ncmFtTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuXHRsZXQgZW5hYmxlZENhcGFiaWxpdGllcyA9IHt9O1xuXG5cdGxldCBjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnMgPSB7fTtcblx0bGV0IGN1cnJlbnREcmF3YnVmZmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cdGxldCBkZWZhdWx0RHJhd2J1ZmZlcnMgPSBbXTtcblxuXHRsZXQgY3VycmVudFByb2dyYW0gPSBudWxsO1xuXG5cdGxldCBjdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XG5cdGxldCBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXHRsZXQgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xuXHRsZXQgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcblx0bGV0IGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG5cdGxldCBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcblx0bGV0IGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcblx0bGV0IGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblx0bGV0IGN1cnJlbnRCbGVuZENvbG9yID0gbmV3IENvbG9yKCAwLCAwLCAwICk7XG5cdGxldCBjdXJyZW50QmxlbmRBbHBoYSA9IDA7XG5cdGxldCBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBmYWxzZTtcblxuXHRsZXQgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG5cdGxldCBjdXJyZW50Q3VsbEZhY2UgPSBudWxsO1xuXG5cdGxldCBjdXJyZW50TGluZVdpZHRoID0gbnVsbDtcblxuXHRsZXQgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xuXHRsZXQgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cblx0Y29uc3QgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cblx0bGV0IGxpbmVXaWR0aEF2YWlsYWJsZSA9IGZhbHNlO1xuXHRsZXQgdmVyc2lvbiA9IDA7XG5cdGNvbnN0IGdsVmVyc2lvbiA9IGdsLmdldFBhcmFtZXRlciggZ2wuVkVSU0lPTiApO1xuXG5cdGlmICggZ2xWZXJzaW9uLmluZGV4T2YoICdXZWJHTCcgKSAhPT0gLSAxICkge1xuXG5cdFx0dmVyc2lvbiA9IHBhcnNlRmxvYXQoIC9eV2ViR0wgKFxcZCkvLmV4ZWMoIGdsVmVyc2lvbiApWyAxIF0gKTtcblx0XHRsaW5lV2lkdGhBdmFpbGFibGUgPSAoIHZlcnNpb24gPj0gMS4wICk7XG5cblx0fSBlbHNlIGlmICggZ2xWZXJzaW9uLmluZGV4T2YoICdPcGVuR0wgRVMnICkgIT09IC0gMSApIHtcblxuXHRcdHZlcnNpb24gPSBwYXJzZUZsb2F0KCAvXk9wZW5HTCBFUyAoXFxkKS8uZXhlYyggZ2xWZXJzaW9uIClbIDEgXSApO1xuXHRcdGxpbmVXaWR0aEF2YWlsYWJsZSA9ICggdmVyc2lvbiA+PSAyLjAgKTtcblxuXHR9XG5cblx0bGV0IGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XG5cdGxldCBjdXJyZW50Qm91bmRUZXh0dXJlcyA9IHt9O1xuXG5cdGNvbnN0IHNjaXNzb3JQYXJhbSA9IGdsLmdldFBhcmFtZXRlciggZ2wuU0NJU1NPUl9CT1ggKTtcblx0Y29uc3Qgdmlld3BvcnRQYXJhbSA9IGdsLmdldFBhcmFtZXRlciggZ2wuVklFV1BPUlQgKTtcblxuXHRjb25zdCBjdXJyZW50U2Npc3NvciA9IG5ldyBWZWN0b3I0KCkuZnJvbUFycmF5KCBzY2lzc29yUGFyYW0gKTtcblx0Y29uc3QgY3VycmVudFZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKS5mcm9tQXJyYXkoIHZpZXdwb3J0UGFyYW0gKTtcblxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0dXJlKCB0eXBlLCB0YXJnZXQsIGNvdW50LCBkaW1lbnNpb25zICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KCA0ICk7IC8vIDQgaXMgcmVxdWlyZWQgdG8gbWF0Y2ggZGVmYXVsdCB1bnBhY2sgYWxpZ25tZW50IG9mIDQuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKCB0eXBlLCB0ZXh0dXJlICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggdHlwZSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggdHlwZSwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCB0eXBlID09PSBnbC5URVhUVVJFXzNEIHx8IHR5cGUgPT09IGdsLlRFWFRVUkVfMkRfQVJSQVkgKSB7XG5cblx0XHRcdFx0Z2wudGV4SW1hZ2UzRCggdGFyZ2V0LCAwLCBnbC5SR0JBLCAxLCAxLCBkaW1lbnNpb25zLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Z2wudGV4SW1hZ2UyRCggdGFyZ2V0ICsgaSwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cblx0Y29uc3QgZW1wdHlUZXh0dXJlcyA9IHt9O1xuXHRlbXB0eVRleHR1cmVzWyBnbC5URVhUVVJFXzJEIF0gPSBjcmVhdGVUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFXzJELCAxICk7XG5cdGVtcHR5VGV4dHVyZXNbIGdsLlRFWFRVUkVfQ1VCRV9NQVAgXSA9IGNyZWF0ZVRleHR1cmUoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgNiApO1xuXHRlbXB0eVRleHR1cmVzWyBnbC5URVhUVVJFXzJEX0FSUkFZIF0gPSBjcmVhdGVUZXh0dXJlKCBnbC5URVhUVVJFXzJEX0FSUkFZLCBnbC5URVhUVVJFXzJEX0FSUkFZLCAxLCAxICk7XG5cdGVtcHR5VGV4dHVyZXNbIGdsLlRFWFRVUkVfM0QgXSA9IGNyZWF0ZVRleHR1cmUoIGdsLlRFWFRVUkVfM0QsIGdsLlRFWFRVUkVfM0QsIDEsIDEgKTtcblxuXHQvLyBpbml0XG5cblx0Y29sb3JCdWZmZXIuc2V0Q2xlYXIoIDAsIDAsIDAsIDEgKTtcblx0ZGVwdGhCdWZmZXIuc2V0Q2xlYXIoIDEgKTtcblx0c3RlbmNpbEJ1ZmZlci5zZXRDbGVhciggMCApO1xuXG5cdGVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXHRkZXB0aEJ1ZmZlci5zZXRGdW5jKCBMZXNzRXF1YWxEZXB0aCApO1xuXG5cdHNldEZsaXBTaWRlZCggZmFsc2UgKTtcblx0c2V0Q3VsbEZhY2UoIEN1bGxGYWNlQmFjayApO1xuXHRlbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5cdHNldEJsZW5kaW5nKCBOb0JsZW5kaW5nICk7XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBlbmFibGUoIGlkICkge1xuXG5cdFx0aWYgKCBlbmFibGVkQ2FwYWJpbGl0aWVzWyBpZCBdICE9PSB0cnVlICkge1xuXG5cdFx0XHRnbC5lbmFibGUoIGlkICk7XG5cdFx0XHRlbmFibGVkQ2FwYWJpbGl0aWVzWyBpZCBdID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzYWJsZSggaWQgKSB7XG5cblx0XHRpZiAoIGVuYWJsZWRDYXBhYmlsaXRpZXNbIGlkIF0gIT09IGZhbHNlICkge1xuXG5cdFx0XHRnbC5kaXNhYmxlKCBpZCApO1xuXHRcdFx0ZW5hYmxlZENhcGFiaWxpdGllc1sgaWQgXSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBiaW5kRnJhbWVidWZmZXIoIHRhcmdldCwgZnJhbWVidWZmZXIgKSB7XG5cblx0XHRpZiAoIGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVyc1sgdGFyZ2V0IF0gIT09IGZyYW1lYnVmZmVyICkge1xuXG5cdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoIHRhcmdldCwgZnJhbWVidWZmZXIgKTtcblxuXHRcdFx0Y3VycmVudEJvdW5kRnJhbWVidWZmZXJzWyB0YXJnZXQgXSA9IGZyYW1lYnVmZmVyO1xuXG5cdFx0XHQvLyBnbC5EUkFXX0ZSQU1FQlVGRkVSIGlzIGVxdWl2YWxlbnQgdG8gZ2wuRlJBTUVCVUZGRVJcblxuXHRcdFx0aWYgKCB0YXJnZXQgPT09IGdsLkRSQVdfRlJBTUVCVUZGRVIgKSB7XG5cblx0XHRcdFx0Y3VycmVudEJvdW5kRnJhbWVidWZmZXJzWyBnbC5GUkFNRUJVRkZFUiBdID0gZnJhbWVidWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0YXJnZXQgPT09IGdsLkZSQU1FQlVGRkVSICkge1xuXG5cdFx0XHRcdGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVyc1sgZ2wuRFJBV19GUkFNRUJVRkZFUiBdID0gZnJhbWVidWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdCdWZmZXJzKCByZW5kZXJUYXJnZXQsIGZyYW1lYnVmZmVyICkge1xuXG5cdFx0bGV0IGRyYXdCdWZmZXJzID0gZGVmYXVsdERyYXdidWZmZXJzO1xuXG5cdFx0bGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0ZHJhd0J1ZmZlcnMgPSBjdXJyZW50RHJhd2J1ZmZlcnMuZ2V0KCBmcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRpZiAoIGRyYXdCdWZmZXJzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZHJhd0J1ZmZlcnMgPSBbXTtcblx0XHRcdFx0Y3VycmVudERyYXdidWZmZXJzLnNldCggZnJhbWVidWZmZXIsIGRyYXdCdWZmZXJzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZXM7XG5cblx0XHRcdGlmICggZHJhd0J1ZmZlcnMubGVuZ3RoICE9PSB0ZXh0dXJlcy5sZW5ndGggfHwgZHJhd0J1ZmZlcnNbIDAgXSAhPT0gZ2wuQ09MT1JfQVRUQUNITUVOVDAgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZHJhd0J1ZmZlcnNbIGkgXSA9IGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZHJhd0J1ZmZlcnMubGVuZ3RoID0gdGV4dHVyZXMubGVuZ3RoO1xuXG5cdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBkcmF3QnVmZmVyc1sgMCBdICE9PSBnbC5CQUNLICkge1xuXG5cdFx0XHRcdGRyYXdCdWZmZXJzWyAwIF0gPSBnbC5CQUNLO1xuXG5cdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBuZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0Z2wuZHJhd0J1ZmZlcnMoIGRyYXdCdWZmZXJzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVzZVByb2dyYW0oIHByb2dyYW0gKSB7XG5cblx0XHRpZiAoIGN1cnJlbnRQcm9ncmFtICE9PSBwcm9ncmFtICkge1xuXG5cdFx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRcdGN1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbTtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdGNvbnN0IGVxdWF0aW9uVG9HTCA9IHtcblx0XHRbIEFkZEVxdWF0aW9uIF06IGdsLkZVTkNfQURELFxuXHRcdFsgU3VidHJhY3RFcXVhdGlvbiBdOiBnbC5GVU5DX1NVQlRSQUNULFxuXHRcdFsgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gXTogZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUXG5cdH07XG5cblx0ZXF1YXRpb25Ub0dMWyBNaW5FcXVhdGlvbiBdID0gZ2wuTUlOO1xuXHRlcXVhdGlvblRvR0xbIE1heEVxdWF0aW9uIF0gPSBnbC5NQVg7XG5cblx0Y29uc3QgZmFjdG9yVG9HTCA9IHtcblx0XHRbIFplcm9GYWN0b3IgXTogZ2wuWkVSTyxcblx0XHRbIE9uZUZhY3RvciBdOiBnbC5PTkUsXG5cdFx0WyBTcmNDb2xvckZhY3RvciBdOiBnbC5TUkNfQ09MT1IsXG5cdFx0WyBTcmNBbHBoYUZhY3RvciBdOiBnbC5TUkNfQUxQSEEsXG5cdFx0WyBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yIF06IGdsLlNSQ19BTFBIQV9TQVRVUkFURSxcblx0XHRbIERzdENvbG9yRmFjdG9yIF06IGdsLkRTVF9DT0xPUixcblx0XHRbIERzdEFscGhhRmFjdG9yIF06IGdsLkRTVF9BTFBIQSxcblx0XHRbIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgXTogZ2wuT05FX01JTlVTX1NSQ19DT0xPUixcblx0XHRbIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgXTogZ2wuT05FX01JTlVTX1NSQ19BTFBIQSxcblx0XHRbIE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgXTogZ2wuT05FX01JTlVTX0RTVF9DT0xPUixcblx0XHRbIE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgXTogZ2wuT05FX01JTlVTX0RTVF9BTFBIQSxcblx0XHRbIENvbnN0YW50Q29sb3JGYWN0b3IgXTogZ2wuQ09OU1RBTlRfQ09MT1IsXG5cdFx0WyBPbmVNaW51c0NvbnN0YW50Q29sb3JGYWN0b3IgXTogZ2wuT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SLFxuXHRcdFsgQ29uc3RhbnRBbHBoYUZhY3RvciBdOiBnbC5DT05TVEFOVF9BTFBIQSxcblx0XHRbIE9uZU1pbnVzQ29uc3RhbnRBbHBoYUZhY3RvciBdOiBnbC5PTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEFcblx0fTtcblxuXHRmdW5jdGlvbiBzZXRCbGVuZGluZyggYmxlbmRpbmcsIGJsZW5kRXF1YXRpb24sIGJsZW5kU3JjLCBibGVuZERzdCwgYmxlbmRFcXVhdGlvbkFscGhhLCBibGVuZFNyY0FscGhhLCBibGVuZERzdEFscGhhLCBibGVuZENvbG9yLCBibGVuZEFscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XG5cblx0XHRpZiAoIGJsZW5kaW5nID09PSBOb0JsZW5kaW5nICkge1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0ZGlzYWJsZSggZ2wuQkxFTkQgKTtcblx0XHRcdFx0Y3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggY3VycmVudEJsZW5kaW5nRW5hYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGVuYWJsZSggZ2wuQkxFTkQgKTtcblx0XHRcdGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBibGVuZGluZyAhPT0gQ3VzdG9tQmxlbmRpbmcgKSB7XG5cblx0XHRcdGlmICggYmxlbmRpbmcgIT09IGN1cnJlbnRCbGVuZGluZyB8fCBwcmVtdWx0aXBsaWVkQWxwaGEgIT09IGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSApIHtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnRCbGVuZEVxdWF0aW9uICE9PSBBZGRFcXVhdGlvbiB8fCBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICE9PSBBZGRFcXVhdGlvbiApIHtcblxuXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG5cblx0XHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IEFkZEVxdWF0aW9uO1xuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBBZGRFcXVhdGlvbjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBibGVuZGluZyApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSBOb3JtYWxCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEFkZGl0aXZlQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuT05FLCBnbC5PTkUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgU3VidHJhY3RpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLk9ORSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBNdWx0aXBseUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5TUkNfQUxQSEEgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiAnLCBibGVuZGluZyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c3dpdGNoICggYmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgTm9ybWFsQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBBZGRpdGl2ZUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIFN1YnRyYWN0aXZlQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5PTkUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgTXVsdGlwbHlCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiAnLCBibGVuZGluZyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VycmVudEJsZW5kU3JjID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZENvbG9yLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRjdXJyZW50QmxlbmRBbHBoYSA9IDA7XG5cblx0XHRcdFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XG5cdFx0XHRcdGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IHByZW11bHRpcGxpZWRBbHBoYTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHQvLyBjdXN0b20gYmxlbmRpbmdcblxuXHRcdGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xuXHRcdGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xuXHRcdGJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhIHx8IGJsZW5kRHN0O1xuXG5cdFx0aWYgKCBibGVuZEVxdWF0aW9uICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbiB8fCBibGVuZEVxdWF0aW9uQWxwaGEgIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XG5cblx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZXF1YXRpb25Ub0dMWyBibGVuZEVxdWF0aW9uIF0sIGVxdWF0aW9uVG9HTFsgYmxlbmRFcXVhdGlvbkFscGhhIF0gKTtcblxuXHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xuXHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYTtcblxuXHRcdH1cblxuXHRcdGlmICggYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhICkge1xuXG5cdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZmFjdG9yVG9HTFsgYmxlbmRTcmMgXSwgZmFjdG9yVG9HTFsgYmxlbmREc3QgXSwgZmFjdG9yVG9HTFsgYmxlbmRTcmNBbHBoYSBdLCBmYWN0b3JUb0dMWyBibGVuZERzdEFscGhhIF0gKTtcblxuXHRcdFx0Y3VycmVudEJsZW5kU3JjID0gYmxlbmRTcmM7XG5cdFx0XHRjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcblx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcblx0XHRcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYTtcblxuXHRcdH1cblxuXHRcdGlmICggYmxlbmRDb2xvci5lcXVhbHMoIGN1cnJlbnRCbGVuZENvbG9yICkgPT09IGZhbHNlIHx8IGJsZW5kQWxwaGEgIT09IGN1cnJlbnRCbGVuZEFscGhhICkge1xuXG5cdFx0XHRnbC5ibGVuZENvbG9yKCBibGVuZENvbG9yLnIsIGJsZW5kQ29sb3IuZywgYmxlbmRDb2xvci5iLCBibGVuZEFscGhhICk7XG5cblx0XHRcdGN1cnJlbnRCbGVuZENvbG9yLmNvcHkoIGJsZW5kQ29sb3IgKTtcblx0XHRcdGN1cnJlbnRCbGVuZEFscGhhID0gYmxlbmRBbHBoYTtcblxuXHRcdH1cblxuXHRcdGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nO1xuXHRcdGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZyb250RmFjZUNXICkge1xuXG5cdFx0bWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZVxuXHRcdFx0PyBkaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKVxuXHRcdFx0OiBlbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5cdFx0bGV0IGZsaXBTaWRlZCA9ICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKTtcblx0XHRpZiAoIGZyb250RmFjZUNXICkgZmxpcFNpZGVkID0gISBmbGlwU2lkZWQ7XG5cblx0XHRzZXRGbGlwU2lkZWQoIGZsaXBTaWRlZCApO1xuXG5cdFx0KCBtYXRlcmlhbC5ibGVuZGluZyA9PT0gTm9ybWFsQmxlbmRpbmcgJiYgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IGZhbHNlIClcblx0XHRcdD8gc2V0QmxlbmRpbmcoIE5vQmxlbmRpbmcgKVxuXHRcdFx0OiBzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCwgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhLCBtYXRlcmlhbC5ibGVuZFNyY0FscGhhLCBtYXRlcmlhbC5ibGVuZERzdEFscGhhLCBtYXRlcmlhbC5ibGVuZENvbG9yLCBtYXRlcmlhbC5ibGVuZEFscGhhLCBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEgKTtcblxuXHRcdGRlcHRoQnVmZmVyLnNldEZ1bmMoIG1hdGVyaWFsLmRlcHRoRnVuYyApO1xuXHRcdGRlcHRoQnVmZmVyLnNldFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xuXHRcdGRlcHRoQnVmZmVyLnNldE1hc2soIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblx0XHRjb2xvckJ1ZmZlci5zZXRNYXNrKCBtYXRlcmlhbC5jb2xvcldyaXRlICk7XG5cblx0XHRjb25zdCBzdGVuY2lsV3JpdGUgPSBtYXRlcmlhbC5zdGVuY2lsV3JpdGU7XG5cdFx0c3RlbmNpbEJ1ZmZlci5zZXRUZXN0KCBzdGVuY2lsV3JpdGUgKTtcblx0XHRpZiAoIHN0ZW5jaWxXcml0ZSApIHtcblxuXHRcdFx0c3RlbmNpbEJ1ZmZlci5zZXRNYXNrKCBtYXRlcmlhbC5zdGVuY2lsV3JpdGVNYXNrICk7XG5cdFx0XHRzdGVuY2lsQnVmZmVyLnNldEZ1bmMoIG1hdGVyaWFsLnN0ZW5jaWxGdW5jLCBtYXRlcmlhbC5zdGVuY2lsUmVmLCBtYXRlcmlhbC5zdGVuY2lsRnVuY01hc2sgKTtcblx0XHRcdHN0ZW5jaWxCdWZmZXIuc2V0T3AoIG1hdGVyaWFsLnN0ZW5jaWxGYWlsLCBtYXRlcmlhbC5zdGVuY2lsWkZhaWwsIG1hdGVyaWFsLnN0ZW5jaWxaUGFzcyApO1xuXG5cdFx0fVxuXG5cdFx0c2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XG5cblx0XHRtYXRlcmlhbC5hbHBoYVRvQ292ZXJhZ2UgPT09IHRydWVcblx0XHRcdD8gZW5hYmxlKCBnbC5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UgKVxuXHRcdFx0OiBkaXNhYmxlKCBnbC5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UgKTtcblxuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBzZXRGbGlwU2lkZWQoIGZsaXBTaWRlZCApIHtcblxuXHRcdGlmICggY3VycmVudEZsaXBTaWRlZCAhPT0gZmxpcFNpZGVkICkge1xuXG5cdFx0XHRpZiAoIGZsaXBTaWRlZCApIHtcblxuXHRcdFx0XHRnbC5mcm9udEZhY2UoIGdsLkNXICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50RmxpcFNpZGVkID0gZmxpcFNpZGVkO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRDdWxsRmFjZSggY3VsbEZhY2UgKSB7XG5cblx0XHRpZiAoIGN1bGxGYWNlICE9PSBDdWxsRmFjZU5vbmUgKSB7XG5cblx0XHRcdGVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHRcdGlmICggY3VsbEZhY2UgIT09IGN1cnJlbnRDdWxsRmFjZSApIHtcblxuXHRcdFx0XHRpZiAoIGN1bGxGYWNlID09PSBDdWxsRmFjZUJhY2sgKSB7XG5cblx0XHRcdFx0XHRnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGN1bGxGYWNlID09PSBDdWxsRmFjZUZyb250ICkge1xuXG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGdsLmN1bGxGYWNlKCBnbC5GUk9OVF9BTkRfQkFDSyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHR9XG5cblx0XHRjdXJyZW50Q3VsbEZhY2UgPSBjdWxsRmFjZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0TGluZVdpZHRoKCB3aWR0aCApIHtcblxuXHRcdGlmICggd2lkdGggIT09IGN1cnJlbnRMaW5lV2lkdGggKSB7XG5cblx0XHRcdGlmICggbGluZVdpZHRoQXZhaWxhYmxlICkgZ2wubGluZVdpZHRoKCB3aWR0aCApO1xuXG5cdFx0XHRjdXJyZW50TGluZVdpZHRoID0gd2lkdGg7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFBvbHlnb25PZmZzZXQoIHBvbHlnb25PZmZzZXQsIGZhY3RvciwgdW5pdHMgKSB7XG5cblx0XHRpZiAoIHBvbHlnb25PZmZzZXQgKSB7XG5cblx0XHRcdGVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMgKSB7XG5cblx0XHRcdFx0Z2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xuXG5cdFx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xuXHRcdFx0XHRjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2Npc3NvclRlc3QoIHNjaXNzb3JUZXN0ICkge1xuXG5cdFx0aWYgKCBzY2lzc29yVGVzdCApIHtcblxuXHRcdFx0ZW5hYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGRpc2FibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyB0ZXh0dXJlXG5cblx0ZnVuY3Rpb24gYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICkge1xuXG5cdFx0aWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xuXG5cdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCApIHtcblxuXHRcdFx0Z2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XG5cdFx0XHRjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSwgd2ViZ2xTbG90ICkge1xuXG5cdFx0aWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0d2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0d2ViZ2xTbG90ID0gY3VycmVudFRleHR1cmVTbG90O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRsZXQgYm91bmRUZXh0dXJlID0gY3VycmVudEJvdW5kVGV4dHVyZXNbIHdlYmdsU2xvdCBdO1xuXG5cdFx0aWYgKCBib3VuZFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ym91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xuXHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXNbIHdlYmdsU2xvdCBdID0gYm91bmRUZXh0dXJlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XG5cblx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XG5cdFx0XHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcblxuXHRcdFx0fVxuXG5cdFx0XHRnbC5iaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgfHwgZW1wdHlUZXh0dXJlc1sgd2ViZ2xUeXBlIF0gKTtcblxuXHRcdFx0Ym91bmRUZXh0dXJlLnR5cGUgPSB3ZWJnbFR5cGU7XG5cdFx0XHRib3VuZFRleHR1cmUudGV4dHVyZSA9IHdlYmdsVGV4dHVyZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdW5iaW5kVGV4dHVyZSgpIHtcblxuXHRcdGNvbnN0IGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcblxuXHRcdGlmICggYm91bmRUZXh0dXJlICE9PSB1bmRlZmluZWQgJiYgYm91bmRUZXh0dXJlLnR5cGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z2wuYmluZFRleHR1cmUoIGJvdW5kVGV4dHVyZS50eXBlLCBudWxsICk7XG5cblx0XHRcdGJvdW5kVGV4dHVyZS50eXBlID0gdW5kZWZpbmVkO1xuXHRcdFx0Ym91bmRUZXh0dXJlLnRleHR1cmUgPSB1bmRlZmluZWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXByZXNzZWRUZXhJbWFnZTJEKCkge1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Z2wuY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcblxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleEltYWdlM0QoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UzRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB0ZXhTdWJJbWFnZTJEKCkge1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Z2wudGV4U3ViSW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB0ZXhTdWJJbWFnZTNEKCkge1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Z2wudGV4U3ViSW1hZ2UzRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjb21wcmVzc2VkVGV4U3ViSW1hZ2UyRCgpIHtcblxuXHRcdHRyeSB7XG5cblx0XHRcdGdsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXByZXNzZWRUZXhTdWJJbWFnZTNEKCkge1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Z2wuY29tcHJlc3NlZFRleFN1YkltYWdlM0QuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcblxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdGV4U3RvcmFnZTJEKCkge1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Z2wudGV4U3RvcmFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRleFN0b3JhZ2UzRCgpIHtcblxuXHRcdHRyeSB7XG5cblx0XHRcdGdsLnRleFN0b3JhZ2UzRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB0ZXhJbWFnZTJEKCkge1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Z2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB0ZXhJbWFnZTNEKCkge1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Z2wudGV4SW1hZ2UzRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIHNjaXNzb3IoIHNjaXNzb3IgKSB7XG5cblx0XHRpZiAoIGN1cnJlbnRTY2lzc29yLmVxdWFscyggc2Npc3NvciApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Z2wuc2Npc3Nvciggc2Npc3Nvci54LCBzY2lzc29yLnksIHNjaXNzb3Iueiwgc2Npc3Nvci53ICk7XG5cdFx0XHRjdXJyZW50U2Npc3Nvci5jb3B5KCBzY2lzc29yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHZpZXdwb3J0KCB2aWV3cG9ydCApIHtcblxuXHRcdGlmICggY3VycmVudFZpZXdwb3J0LmVxdWFscyggdmlld3BvcnQgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGdsLnZpZXdwb3J0KCB2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC56LCB2aWV3cG9ydC53ICk7XG5cdFx0XHRjdXJyZW50Vmlld3BvcnQuY29weSggdmlld3BvcnQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlVUJPTWFwcGluZyggdW5pZm9ybXNHcm91cCwgcHJvZ3JhbSApIHtcblxuXHRcdGxldCBtYXBwaW5nID0gdWJvUHJvZ3JhbU1hcC5nZXQoIHByb2dyYW0gKTtcblxuXHRcdGlmICggbWFwcGluZyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXBwaW5nID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdFx0dWJvUHJvZ3JhbU1hcC5zZXQoIHByb2dyYW0sIG1hcHBpbmcgKTtcblxuXHRcdH1cblxuXHRcdGxldCBibG9ja0luZGV4ID0gbWFwcGluZy5nZXQoIHVuaWZvcm1zR3JvdXAgKTtcblxuXHRcdGlmICggYmxvY2tJbmRleCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRibG9ja0luZGV4ID0gZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgoIHByb2dyYW0sIHVuaWZvcm1zR3JvdXAubmFtZSApO1xuXG5cdFx0XHRtYXBwaW5nLnNldCggdW5pZm9ybXNHcm91cCwgYmxvY2tJbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB1bmlmb3JtQmxvY2tCaW5kaW5nKCB1bmlmb3Jtc0dyb3VwLCBwcm9ncmFtICkge1xuXG5cdFx0Y29uc3QgbWFwcGluZyA9IHVib1Byb2dyYW1NYXAuZ2V0KCBwcm9ncmFtICk7XG5cdFx0Y29uc3QgYmxvY2tJbmRleCA9IG1hcHBpbmcuZ2V0KCB1bmlmb3Jtc0dyb3VwICk7XG5cblx0XHRpZiAoIHVib0JpbmRpbmdzLmdldCggcHJvZ3JhbSApICE9PSBibG9ja0luZGV4ICkge1xuXG5cdFx0XHQvLyBiaW5kIHNoYWRlciBzcGVjaWZpYyBibG9jayBpbmRleCB0byBnbG9iYWwgYmxvY2sgcG9pbnRcblx0XHRcdGdsLnVuaWZvcm1CbG9ja0JpbmRpbmcoIHByb2dyYW0sIGJsb2NrSW5kZXgsIHVuaWZvcm1zR3JvdXAuX19iaW5kaW5nUG9pbnRJbmRleCApO1xuXG5cdFx0XHR1Ym9CaW5kaW5ncy5zZXQoIHByb2dyYW0sIGJsb2NrSW5kZXggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiByZXNldCgpIHtcblxuXHRcdC8vIHJlc2V0IHN0YXRlXG5cblx0XHRnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xuXHRcdGdsLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xuXHRcdGdsLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblx0XHRnbC5kaXNhYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cdFx0Z2wuZGlzYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XG5cdFx0Z2wuZGlzYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XG5cdFx0Z2wuZGlzYWJsZSggZ2wuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFICk7XG5cblx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuXHRcdGdsLmJsZW5kRnVuYyggZ2wuT05FLCBnbC5aRVJPICk7XG5cdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLk9ORSwgZ2wuWkVSTywgZ2wuT05FLCBnbC5aRVJPICk7XG5cdFx0Z2wuYmxlbmRDb2xvciggMCwgMCwgMCwgMCApO1xuXG5cdFx0Z2wuY29sb3JNYXNrKCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlICk7XG5cdFx0Z2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMCApO1xuXG5cdFx0Z2wuZGVwdGhNYXNrKCB0cnVlICk7XG5cdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVNTICk7XG5cdFx0Z2wuY2xlYXJEZXB0aCggMSApO1xuXG5cdFx0Z2wuc3RlbmNpbE1hc2soIDB4ZmZmZmZmZmYgKTtcblx0XHRnbC5zdGVuY2lsRnVuYyggZ2wuQUxXQVlTLCAwLCAweGZmZmZmZmZmICk7XG5cdFx0Z2wuc3RlbmNpbE9wKCBnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQICk7XG5cdFx0Z2wuY2xlYXJTdGVuY2lsKCAwICk7XG5cblx0XHRnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xuXHRcdGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XG5cblx0XHRnbC5wb2x5Z29uT2Zmc2V0KCAwLCAwICk7XG5cblx0XHRnbC5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRFJBV19GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuUkVBRF9GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdFx0Z2wudXNlUHJvZ3JhbSggbnVsbCApO1xuXG5cdFx0Z2wubGluZVdpZHRoKCAxICk7XG5cblx0XHRnbC5zY2lzc29yKCAwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQgKTtcblx0XHRnbC52aWV3cG9ydCggMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0ICk7XG5cblx0XHQvLyByZXNldCBpbnRlcm5hbHNcblxuXHRcdGVuYWJsZWRDYXBhYmlsaXRpZXMgPSB7fTtcblxuXHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XG5cdFx0Y3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblxuXHRcdGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVycyA9IHt9O1xuXHRcdGN1cnJlbnREcmF3YnVmZmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0ZGVmYXVsdERyYXdidWZmZXJzID0gW107XG5cblx0XHRjdXJyZW50UHJvZ3JhbSA9IG51bGw7XG5cblx0XHRjdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XG5cdFx0Y3VycmVudEJsZW5kaW5nID0gbnVsbDtcblx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG5cdFx0Y3VycmVudEJsZW5kU3JjID0gbnVsbDtcblx0XHRjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuXHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcblx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0Y3VycmVudEJsZW5kQ29sb3IgPSBuZXcgQ29sb3IoIDAsIDAsIDAgKTtcblx0XHRjdXJyZW50QmxlbmRBbHBoYSA9IDA7XG5cdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XG5cblx0XHRjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblx0XHRjdXJyZW50Q3VsbEZhY2UgPSBudWxsO1xuXG5cdFx0Y3VycmVudExpbmVXaWR0aCA9IG51bGw7XG5cblx0XHRjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG5cdFx0Y3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cblx0XHRjdXJyZW50U2Npc3Nvci5zZXQoIDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCApO1xuXHRcdGN1cnJlbnRWaWV3cG9ydC5zZXQoIDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCApO1xuXG5cdFx0Y29sb3JCdWZmZXIucmVzZXQoKTtcblx0XHRkZXB0aEJ1ZmZlci5yZXNldCgpO1xuXHRcdHN0ZW5jaWxCdWZmZXIucmVzZXQoKTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdGJ1ZmZlcnM6IHtcblx0XHRcdGNvbG9yOiBjb2xvckJ1ZmZlcixcblx0XHRcdGRlcHRoOiBkZXB0aEJ1ZmZlcixcblx0XHRcdHN0ZW5jaWw6IHN0ZW5jaWxCdWZmZXJcblx0XHR9LFxuXG5cdFx0ZW5hYmxlOiBlbmFibGUsXG5cdFx0ZGlzYWJsZTogZGlzYWJsZSxcblxuXHRcdGJpbmRGcmFtZWJ1ZmZlcjogYmluZEZyYW1lYnVmZmVyLFxuXHRcdGRyYXdCdWZmZXJzOiBkcmF3QnVmZmVycyxcblxuXHRcdHVzZVByb2dyYW06IHVzZVByb2dyYW0sXG5cblx0XHRzZXRCbGVuZGluZzogc2V0QmxlbmRpbmcsXG5cdFx0c2V0TWF0ZXJpYWw6IHNldE1hdGVyaWFsLFxuXG5cdFx0c2V0RmxpcFNpZGVkOiBzZXRGbGlwU2lkZWQsXG5cdFx0c2V0Q3VsbEZhY2U6IHNldEN1bGxGYWNlLFxuXG5cdFx0c2V0TGluZVdpZHRoOiBzZXRMaW5lV2lkdGgsXG5cdFx0c2V0UG9seWdvbk9mZnNldDogc2V0UG9seWdvbk9mZnNldCxcblxuXHRcdHNldFNjaXNzb3JUZXN0OiBzZXRTY2lzc29yVGVzdCxcblxuXHRcdGFjdGl2ZVRleHR1cmU6IGFjdGl2ZVRleHR1cmUsXG5cdFx0YmluZFRleHR1cmU6IGJpbmRUZXh0dXJlLFxuXHRcdHVuYmluZFRleHR1cmU6IHVuYmluZFRleHR1cmUsXG5cdFx0Y29tcHJlc3NlZFRleEltYWdlMkQ6IGNvbXByZXNzZWRUZXhJbWFnZTJELFxuXHRcdGNvbXByZXNzZWRUZXhJbWFnZTNEOiBjb21wcmVzc2VkVGV4SW1hZ2UzRCxcblx0XHR0ZXhJbWFnZTJEOiB0ZXhJbWFnZTJELFxuXHRcdHRleEltYWdlM0Q6IHRleEltYWdlM0QsXG5cblx0XHR1cGRhdGVVQk9NYXBwaW5nOiB1cGRhdGVVQk9NYXBwaW5nLFxuXHRcdHVuaWZvcm1CbG9ja0JpbmRpbmc6IHVuaWZvcm1CbG9ja0JpbmRpbmcsXG5cblx0XHR0ZXhTdG9yYWdlMkQ6IHRleFN0b3JhZ2UyRCxcblx0XHR0ZXhTdG9yYWdlM0Q6IHRleFN0b3JhZ2UzRCxcblx0XHR0ZXhTdWJJbWFnZTJEOiB0ZXhTdWJJbWFnZTJELFxuXHRcdHRleFN1YkltYWdlM0Q6IHRleFN1YkltYWdlM0QsXG5cdFx0Y29tcHJlc3NlZFRleFN1YkltYWdlMkQ6IGNvbXByZXNzZWRUZXhTdWJJbWFnZTJELFxuXHRcdGNvbXByZXNzZWRUZXhTdWJJbWFnZTNEOiBjb21wcmVzc2VkVGV4U3ViSW1hZ2UzRCxcblxuXHRcdHNjaXNzb3I6IHNjaXNzb3IsXG5cdFx0dmlld3BvcnQ6IHZpZXdwb3J0LFxuXG5cdFx0cmVzZXQ6IHJlc2V0XG5cblx0fTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTFRleHR1cmVzKCBfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHV0aWxzLCBpbmZvICkge1xuXG5cdGNvbnN0IG11bHRpc2FtcGxlZFJUVEV4dCA9IGV4dGVuc2lvbnMuaGFzKCAnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyApID8gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUnICkgOiBudWxsO1xuXHRjb25zdCBzdXBwb3J0c0ludmFsaWRhdGVGcmFtZWJ1ZmZlciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiAvT2N1bHVzQnJvd3Nlci9nLnRlc3QoIG5hdmlnYXRvci51c2VyQWdlbnQgKTtcblxuXHRjb25zdCBfaW1hZ2VEaW1lbnNpb25zID0gbmV3IFZlY3RvcjIoKTtcblx0Y29uc3QgX3ZpZGVvVGV4dHVyZXMgPSBuZXcgV2Vha01hcCgpO1xuXHRsZXQgX2NhbnZhcztcblxuXHRjb25zdCBfc291cmNlcyA9IG5ldyBXZWFrTWFwKCk7IC8vIG1hcHMgV2ViZ2xUZXh0dXJlIG9iamVjdHMgdG8gaW5zdGFuY2VzIG9mIFNvdXJjZVxuXG5cdC8vIGNvcmRvdmEgaU9TIChhcyBvZiA1LjApIHN0aWxsIHVzZXMgVUlXZWJWaWV3LCB3aGljaCBwcm92aWRlcyBPZmZzY3JlZW5DYW52YXMsXG5cdC8vIGFsc28gT2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKSwgYnV0IG5vdCBPZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpIVxuXHQvLyBTb21lIGltcGxlbWVudGF0aW9ucyBtYXkgb25seSBpbXBsZW1lbnQgT2Zmc2NyZWVuQ2FudmFzIHBhcnRpYWxseSAoZS5nLiBsYWNraW5nIDJkKS5cblxuXHRsZXQgdXNlT2Zmc2NyZWVuQ2FudmFzID0gZmFsc2U7XG5cblx0dHJ5IHtcblxuXHRcdHVzZU9mZnNjcmVlbkNhbnZhcyA9IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXHRcdFx0JiYgKCBuZXcgT2Zmc2NyZWVuQ2FudmFzKCAxLCAxICkuZ2V0Q29udGV4dCggJzJkJyApICkgIT09IG51bGw7XG5cblx0fSBjYXRjaCAoIGVyciApIHtcblxuXHRcdC8vIElnbm9yZSBhbnkgZXJyb3JzXG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyggd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdC8vIFVzZSBPZmZzY3JlZW5DYW52YXMgd2hlbiBhdmFpbGFibGUuIFNwZWNpYWxseSBuZWVkZWQgaW4gd2ViIHdvcmtlcnNcblxuXHRcdHJldHVybiB1c2VPZmZzY3JlZW5DYW52YXMgP1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcblx0XHRcdG5ldyBPZmZzY3JlZW5DYW52YXMoIHdpZHRoLCBoZWlnaHQgKSA6IGNyZWF0ZUVsZW1lbnROUyggJ2NhbnZhcycgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzaXplSW1hZ2UoIGltYWdlLCBuZWVkc05ld0NhbnZhcywgbWF4U2l6ZSApIHtcblxuXHRcdGxldCBzY2FsZSA9IDE7XG5cblx0XHRjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyggaW1hZ2UgKTtcblxuXHRcdC8vIGhhbmRsZSBjYXNlIGlmIHRleHR1cmUgZXhjZWVkcyBtYXggc2l6ZVxuXG5cdFx0aWYgKCBkaW1lbnNpb25zLndpZHRoID4gbWF4U2l6ZSB8fCBkaW1lbnNpb25zLmhlaWdodCA+IG1heFNpemUgKSB7XG5cblx0XHRcdHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gb25seSBwZXJmb3JtIHJlc2l6ZSBpZiBuZWNlc3NhcnlcblxuXHRcdGlmICggc2NhbGUgPCAxICkge1xuXG5cdFx0XHQvLyBvbmx5IHBlcmZvcm0gcmVzaXplIGZvciBjZXJ0YWluIGltYWdlIHR5cGVzXG5cblx0XHRcdGlmICggKCB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICkgfHxcblx0XHRcdFx0KCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgKSB8fFxuXHRcdFx0XHQoIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCApIHx8XG5cdFx0XHRcdCggdHlwZW9mIFZpZGVvRnJhbWUgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgVmlkZW9GcmFtZSApICkge1xuXG5cdFx0XHRcdGNvbnN0IHdpZHRoID0gTWF0aC5mbG9vciggc2NhbGUgKiBkaW1lbnNpb25zLndpZHRoICk7XG5cdFx0XHRcdGNvbnN0IGhlaWdodCA9IE1hdGguZmxvb3IoIHNjYWxlICogZGltZW5zaW9ucy5oZWlnaHQgKTtcblxuXHRcdFx0XHRpZiAoIF9jYW52YXMgPT09IHVuZGVmaW5lZCApIF9jYW52YXMgPSBjcmVhdGVDYW52YXMoIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdFx0XHQvLyBjdWJlIHRleHR1cmVzIGNhbid0IHJldXNlIHRoZSBzYW1lIGNhbnZhc1xuXG5cdFx0XHRcdGNvbnN0IGNhbnZhcyA9IG5lZWRzTmV3Q2FudmFzID8gY3JlYXRlQ2FudmFzKCB3aWR0aCwgaGVpZ2h0ICkgOiBfY2FudmFzO1xuXG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0XHRcdGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGhhcyBiZWVuIHJlc2l6ZWQgZnJvbSAoJyArIGRpbWVuc2lvbnMud2lkdGggKyAneCcgKyBkaW1lbnNpb25zLmhlaWdodCArICcpIHRvICgnICsgd2lkdGggKyAneCcgKyBoZWlnaHQgKyAnKS4nICk7XG5cblx0XHRcdFx0cmV0dXJuIGNhbnZhcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoICdkYXRhJyBpbiBpbWFnZSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEltYWdlIGluIERhdGFUZXh0dXJlIGlzIHRvbyBiaWcgKCcgKyBkaW1lbnNpb25zLndpZHRoICsgJ3gnICsgZGltZW5zaW9ucy5oZWlnaHQgKyAnKS4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBpbWFnZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGltYWdlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKSB7XG5cblx0XHRyZXR1cm4gdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlcjtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVNaXBtYXAoIHRhcmdldCApIHtcblxuXHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggdGFyZ2V0ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEludGVybmFsRm9ybWF0KCBpbnRlcm5hbEZvcm1hdE5hbWUsIGdsRm9ybWF0LCBnbFR5cGUsIGNvbG9yU3BhY2UsIGZvcmNlTGluZWFyVHJhbnNmZXIgPSBmYWxzZSApIHtcblxuXHRcdGlmICggaW50ZXJuYWxGb3JtYXROYW1lICE9PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIF9nbFsgaW50ZXJuYWxGb3JtYXROYW1lIF0gIT09IHVuZGVmaW5lZCApIHJldHVybiBfZ2xbIGludGVybmFsRm9ybWF0TmFtZSBdO1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIHVzZSBub24tZXhpc3RpbmcgV2ViR0wgaW50ZXJuYWwgZm9ybWF0IFxcJycgKyBpbnRlcm5hbEZvcm1hdE5hbWUgKyAnXFwnJyApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGludGVybmFsRm9ybWF0ID0gZ2xGb3JtYXQ7XG5cblx0XHRpZiAoIGdsRm9ybWF0ID09PSBfZ2wuUkVEICkge1xuXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjMyRjtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuSEFMRl9GTE9BVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlIxNkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0JZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SODtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IF9nbC5SRURfSU5URUdFUiApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjhVSTtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SMTZVSTtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjMyVUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkJZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SOEk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlNIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjE2STtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjMySTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IF9nbC5SRyApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5GTE9BVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHMzJGO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5IQUxGX0ZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkcxNkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0JZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzg7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdsRm9ybWF0ID09PSBfZ2wuUkdfSU5URUdFUiApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkc4VUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX1NIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkcxNlVJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9JTlQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzMyVUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkJZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzhJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5TSE9SVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHMTZJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5JTlQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzMySTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IF9nbC5SR0IgKSB7XG5cblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfSU5UXzVfOV85XzlfUkVWICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCOV9FNTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IF9nbC5SR0JBICkge1xuXG5cdFx0XHRjb25zdCB0cmFuc2ZlciA9IGZvcmNlTGluZWFyVHJhbnNmZXIgPyBMaW5lYXJUcmFuc2ZlciA6IENvbG9yTWFuYWdlbWVudC5nZXRUcmFuc2ZlciggY29sb3JTcGFjZSApO1xuXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCQTMyRjtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuSEFMRl9GTE9BVCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQkExNkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0JZVEUgKSBpbnRlcm5hbEZvcm1hdCA9ICggdHJhbnNmZXIgPT09IFNSR0JUcmFuc2ZlciApID8gX2dsLlNSR0I4X0FMUEhBOCA6IF9nbC5SR0JBODtcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNCApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQkE0O1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCNV9BMTtcblxuXHRcdH1cblxuXHRcdGlmICggaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SMTZGIHx8IGludGVybmFsRm9ybWF0ID09PSBfZ2wuUjMyRiB8fFxuXHRcdFx0aW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SRzE2RiB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlJHMzJGIHx8XG5cdFx0XHRpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlJHQkExNkYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SR0JBMzJGICkge1xuXG5cdFx0XHRleHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW50ZXJuYWxGb3JtYXQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEludGVybmFsRGVwdGhGb3JtYXQoIHVzZVN0ZW5jaWwsIGRlcHRoVHlwZSApIHtcblxuXHRcdGxldCBnbEludGVybmFsRm9ybWF0O1xuXHRcdGlmICggdXNlU3RlbmNpbCApIHtcblxuXHRcdFx0aWYgKCBkZXB0aFR5cGUgPT09IG51bGwgfHwgZGVwdGhUeXBlID09PSBVbnNpZ25lZEludFR5cGUgfHwgZGVwdGhUeXBlID09PSBVbnNpZ25lZEludDI0OFR5cGUgKSB7XG5cblx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSDI0X1NURU5DSUw4O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkZXB0aFR5cGUgPT09IEZsb2F0VHlwZSApIHtcblxuXHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIMzJGX1NURU5DSUw4O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkZXB0aFR5cGUgPT09IFVuc2lnbmVkU2hvcnRUeXBlICkge1xuXG5cdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEgyNF9TVEVOQ0lMODtcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnRGVwdGhUZXh0dXJlOiAxNiBiaXQgZGVwdGggYXR0YWNobWVudCBpcyBub3Qgc3VwcG9ydGVkIHdpdGggc3RlbmNpbC4gVXNpbmcgMjQtYml0IGF0dGFjaG1lbnQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGRlcHRoVHlwZSA9PT0gbnVsbCB8fCBkZXB0aFR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSB8fCBkZXB0aFR5cGUgPT09IFVuc2lnbmVkSW50MjQ4VHlwZSApIHtcblxuXHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDI0O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkZXB0aFR5cGUgPT09IEZsb2F0VHlwZSApIHtcblxuXHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDMyRjtcblxuXHRcdFx0fSBlbHNlIGlmICggZGVwdGhUeXBlID09PSBVbnNpZ25lZFNob3J0VHlwZSApIHtcblxuXHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDE2O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2xJbnRlcm5hbEZvcm1hdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TWlwTGV2ZWxzKCB0ZXh0dXJlLCBpbWFnZSApIHtcblxuXHRcdGlmICggdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICkgPT09IHRydWUgfHwgKCB0ZXh0dXJlLmlzRnJhbWVidWZmZXJUZXh0dXJlICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIgKSApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGgubG9nMiggTWF0aC5tYXgoIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKSApICsgMTtcblxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUubWlwbWFwcyAhPT0gdW5kZWZpbmVkICYmIHRleHR1cmUubWlwbWFwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHQvLyB1c2VyLWRlZmluZWQgbWlwbWFwc1xuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZS5taXBtYXBzLmxlbmd0aDtcblxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSAmJiBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgKSB7XG5cblx0XHRcdHJldHVybiBpbWFnZS5taXBtYXBzLmxlbmd0aDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIHRleHR1cmUgd2l0aG91dCBtaXBtYXBzIChvbmx5IGJhc2UgbGV2ZWwpXG5cblx0XHRcdHJldHVybiAxO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcblxuXHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHRkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xuXG5cdFx0XHRfdmlkZW9UZXh0dXJlcy5kZWxldGUoIHRleHR1cmUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gb25SZW5kZXJUYXJnZXREaXNwb3NlKCBldmVudCApIHtcblxuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG5cdFx0ZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHQvLyBjaGVjayBpZiBpdCdzIG5lY2Vzc2FyeSB0byByZW1vdmUgdGhlIFdlYkdMVGV4dHVyZSBvYmplY3RcblxuXHRcdGNvbnN0IHNvdXJjZSA9IHRleHR1cmUuc291cmNlO1xuXHRcdGNvbnN0IHdlYmdsVGV4dHVyZXMgPSBfc291cmNlcy5nZXQoIHNvdXJjZSApO1xuXG5cdFx0aWYgKCB3ZWJnbFRleHR1cmVzICkge1xuXG5cdFx0XHRjb25zdCB3ZWJnbFRleHR1cmUgPSB3ZWJnbFRleHR1cmVzWyB0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5IF07XG5cdFx0XHR3ZWJnbFRleHR1cmUudXNlZFRpbWVzIC0tO1xuXG5cdFx0XHQvLyB0aGUgV2ViR0xUZXh0dXJlIG9iamVjdCBpcyBub3QgdXNlZCBhbnltb3JlLCByZW1vdmUgaXRcblxuXHRcdFx0aWYgKCB3ZWJnbFRleHR1cmUudXNlZFRpbWVzID09PSAwICkge1xuXG5cdFx0XHRcdGRlbGV0ZVRleHR1cmUoIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgdGhlIHdlYWsgbWFwIGVudHJ5IGlmIG5vIFdlYkdMVGV4dHVyZSB1c2VzIHRoZSBzb3VyY2UgYW55bW9yZVxuXG5cdFx0XHRpZiAoIE9iamVjdC5rZXlzKCB3ZWJnbFRleHR1cmVzICkubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdF9zb3VyY2VzLmRlbGV0ZSggc291cmNlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHByb3BlcnRpZXMucmVtb3ZlKCB0ZXh0dXJlICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRlbGV0ZVRleHR1cmUoIHRleHR1cmUgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cblx0XHRjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcblx0XHRjb25zdCB3ZWJnbFRleHR1cmVzID0gX3NvdXJjZXMuZ2V0KCBzb3VyY2UgKTtcblx0XHRkZWxldGUgd2ViZ2xUZXh0dXJlc1sgdGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleSBdO1xuXG5cdFx0aW5mby5tZW1vcnkudGV4dHVyZXMgLS07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKSB7XG5cblx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZGlzcG9zZSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICkgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0ubGVuZ3RoOyBsZXZlbCArKyApIF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXVsgbGV2ZWwgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBsZXZlbCA9IDA7IGxldmVsIDwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIubGVuZ3RoOyBsZXZlbCArKyApIF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGxldmVsIF0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyICk7XG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyICkgX2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbIGkgXSApIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciApIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYXR0YWNobWVudFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZXNbIGkgXSApO1xuXG5cdFx0XHRpZiAoIGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICkge1xuXG5cdFx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCBhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0XHRcdGluZm8ubWVtb3J5LnRleHR1cmVzIC0tO1xuXG5cdFx0XHR9XG5cblx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKCB0ZXh0dXJlc1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHRwcm9wZXJ0aWVzLnJlbW92ZSggcmVuZGVyVGFyZ2V0ICk7XG5cblx0fVxuXG5cdC8vXG5cblx0bGV0IHRleHR1cmVVbml0cyA9IDA7XG5cblx0ZnVuY3Rpb24gcmVzZXRUZXh0dXJlVW5pdHMoKSB7XG5cblx0XHR0ZXh0dXJlVW5pdHMgPSAwO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBhbGxvY2F0ZVRleHR1cmVVbml0KCkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZVVuaXQgPSB0ZXh0dXJlVW5pdHM7XG5cblx0XHRpZiAoIHRleHR1cmVVbml0ID49IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xUZXh0dXJlczogVHJ5aW5nIHRvIHVzZSAnICsgdGV4dHVyZVVuaXQgKyAnIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAnICsgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICk7XG5cblx0XHR9XG5cblx0XHR0ZXh0dXJlVW5pdHMgKz0gMTtcblxuXHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VGV4dHVyZUNhY2hlS2V5KCB0ZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdGFycmF5LnB1c2goIHRleHR1cmUud3JhcFMgKTtcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLndyYXBUICk7XG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS53cmFwUiB8fCAwICk7XG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS5tYWdGaWx0ZXIgKTtcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLm1pbkZpbHRlciApO1xuXHRcdGFycmF5LnB1c2goIHRleHR1cmUuYW5pc290cm9weSApO1xuXHRcdGFycmF5LnB1c2goIHRleHR1cmUuaW50ZXJuYWxGb3JtYXQgKTtcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLmZvcm1hdCApO1xuXHRcdGFycmF5LnB1c2goIHRleHR1cmUudHlwZSApO1xuXHRcdGFycmF5LnB1c2goIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICk7XG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS5mbGlwWSApO1xuXHRcdGFycmF5LnB1c2goIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS5jb2xvclNwYWNlICk7XG5cblx0XHRyZXR1cm4gYXJyYXkuam9pbigpO1xuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIHNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSApIHVwZGF0ZVZpZGVvVGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgJiYgdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcblxuXHRcdFx0Y29uc3QgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG5cdFx0XHRpZiAoIGltYWdlID09PSBudWxsICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IG5vIGltYWdlIGRhdGEgZm91bmQuJyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBpbWFnZS5jb21wbGV0ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZScgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VGV4dHVyZTJEQXJyYXkoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cblx0XHRcdHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkRfQVJSQVksIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFRleHR1cmUzRCggdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcblxuXHRcdFx0dXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8zRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cblx0XHRcdHVwbG9hZEN1YmVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXG5cdH1cblxuXHRjb25zdCB3cmFwcGluZ1RvR0wgPSB7XG5cdFx0WyBSZXBlYXRXcmFwcGluZyBdOiBfZ2wuUkVQRUFULFxuXHRcdFsgQ2xhbXBUb0VkZ2VXcmFwcGluZyBdOiBfZ2wuQ0xBTVBfVE9fRURHRSxcblx0XHRbIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgXTogX2dsLk1JUlJPUkVEX1JFUEVBVFxuXHR9O1xuXG5cdGNvbnN0IGZpbHRlclRvR0wgPSB7XG5cdFx0WyBOZWFyZXN0RmlsdGVyIF06IF9nbC5ORUFSRVNULFxuXHRcdFsgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIgXTogX2dsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QsXG5cdFx0WyBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyIF06IF9nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVIsXG5cblx0XHRbIExpbmVhckZpbHRlciBdOiBfZ2wuTElORUFSLFxuXHRcdFsgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciBdOiBfZ2wuTElORUFSX01JUE1BUF9ORUFSRVNULFxuXHRcdFsgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyIF06IF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUlxuXHR9O1xuXG5cdGNvbnN0IGNvbXBhcmVUb0dMID0ge1xuXHRcdFsgTmV2ZXJDb21wYXJlIF06IF9nbC5ORVZFUixcblx0XHRbIEFsd2F5c0NvbXBhcmUgXTogX2dsLkFMV0FZUyxcblx0XHRbIExlc3NDb21wYXJlIF06IF9nbC5MRVNTLFxuXHRcdFsgTGVzc0VxdWFsQ29tcGFyZSBdOiBfZ2wuTEVRVUFMLFxuXHRcdFsgRXF1YWxDb21wYXJlIF06IF9nbC5FUVVBTCxcblx0XHRbIEdyZWF0ZXJFcXVhbENvbXBhcmUgXTogX2dsLkdFUVVBTCxcblx0XHRbIEdyZWF0ZXJDb21wYXJlIF06IF9nbC5HUkVBVEVSLFxuXHRcdFsgTm90RXF1YWxDb21wYXJlIF06IF9nbC5OT1RFUVVBTFxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSApIHtcblxuXHRcdGlmICggdGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5oYXMoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgPT09IGZhbHNlICYmXG5cdFx0XHQoIHRleHR1cmUubWFnRmlsdGVyID09PSBMaW5lYXJGaWx0ZXIgfHwgdGV4dHVyZS5tYWdGaWx0ZXIgPT09IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIgfHwgdGV4dHVyZS5tYWdGaWx0ZXIgPT09IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgfHwgdGV4dHVyZS5tYWdGaWx0ZXIgPT09IExpbmVhck1pcG1hcExpbmVhckZpbHRlciB8fFxuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPT09IExpbmVhckZpbHRlciB8fCB0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciB8fCB0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciB8fCB0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyICkgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVuYWJsZSB0byB1c2UgbGluZWFyIGZpbHRlcmluZyB3aXRoIGZsb2F0aW5nIHBvaW50IHRleHR1cmVzLiBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZS4nICk7XG5cblx0XHR9XG5cblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgd3JhcHBpbmdUb0dMWyB0ZXh0dXJlLndyYXBTIF0gKTtcblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgd3JhcHBpbmdUb0dMWyB0ZXh0dXJlLndyYXBUIF0gKTtcblxuXHRcdGlmICggdGV4dHVyZVR5cGUgPT09IF9nbC5URVhUVVJFXzNEIHx8IHRleHR1cmVUeXBlID09PSBfZ2wuVEVYVFVSRV8yRF9BUlJBWSApIHtcblxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1IsIHdyYXBwaW5nVG9HTFsgdGV4dHVyZS53cmFwUiBdICk7XG5cblx0XHR9XG5cblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlclRvR0xbIHRleHR1cmUubWFnRmlsdGVyIF0gKTtcblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlclRvR0xbIHRleHR1cmUubWluRmlsdGVyIF0gKTtcblxuXHRcdGlmICggdGV4dHVyZS5jb21wYXJlRnVuY3Rpb24gKSB7XG5cblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfQ09NUEFSRV9NT0RFLCBfZ2wuQ09NUEFSRV9SRUZfVE9fVEVYVFVSRSApO1xuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9DT01QQVJFX0ZVTkMsIGNvbXBhcmVUb0dMWyB0ZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiBdICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbnMuaGFzKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApID09PSB0cnVlICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmUubWFnRmlsdGVyID09PSBOZWFyZXN0RmlsdGVyICkgcmV0dXJuO1xuXHRcdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyICkgcmV0dXJuO1xuXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmhhcyggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gZmFsc2UgKSByZXR1cm47IC8vIHZlcmlmeSBleHRlbnNpb25cblxuXHRcdFx0aWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxIHx8IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSApIHtcblxuXHRcdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIGNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xuXHRcdFx0XHRwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlICkge1xuXG5cdFx0bGV0IGZvcmNlVXBsb2FkID0gZmFsc2U7XG5cblx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcblxuXHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBTb3VyY2UgPC0+IFdlYkdMVGV4dHVyZXMgbWFwcGluZyBpZiBuZWNlc3NhcnlcblxuXHRcdGNvbnN0IHNvdXJjZSA9IHRleHR1cmUuc291cmNlO1xuXHRcdGxldCB3ZWJnbFRleHR1cmVzID0gX3NvdXJjZXMuZ2V0KCBzb3VyY2UgKTtcblxuXHRcdGlmICggd2ViZ2xUZXh0dXJlcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR3ZWJnbFRleHR1cmVzID0ge307XG5cdFx0XHRfc291cmNlcy5zZXQoIHNvdXJjZSwgd2ViZ2xUZXh0dXJlcyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIFdlYkdMVGV4dHVyZSBvYmplY3QgZm9yIHRoZSBnaXZlbiB0ZXh0dXJlIHBhcmFtZXRlcnNcblxuXHRcdGNvbnN0IHRleHR1cmVDYWNoZUtleSA9IGdldFRleHR1cmVDYWNoZUtleSggdGV4dHVyZSApO1xuXG5cdFx0aWYgKCB0ZXh0dXJlQ2FjaGVLZXkgIT09IHRleHR1cmVQcm9wZXJ0aWVzLl9fY2FjaGVLZXkgKSB7XG5cblx0XHRcdC8vIGlmIG5vdCwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIFdlYkdMVGV4dHVyZVxuXG5cdFx0XHRpZiAoIHdlYmdsVGV4dHVyZXNbIHRleHR1cmVDYWNoZUtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gY3JlYXRlIG5ldyBlbnRyeVxuXG5cdFx0XHRcdHdlYmdsVGV4dHVyZXNbIHRleHR1cmVDYWNoZUtleSBdID0ge1xuXHRcdFx0XHRcdHRleHR1cmU6IF9nbC5jcmVhdGVUZXh0dXJlKCksXG5cdFx0XHRcdFx0dXNlZFRpbWVzOiAwXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMgKys7XG5cblx0XHRcdFx0Ly8gd2hlbiBhIG5ldyBpbnN0YW5jZSBvZiBXZWJHTFRleHR1cmUgd2FzIGNyZWF0ZWQsIGEgdGV4dHVyZSB1cGxvYWQgaXMgcmVxdWlyZWRcblx0XHRcdFx0Ly8gZXZlbiBpZiB0aGUgaW1hZ2UgY29udGVudHMgYXJlIGlkZW50aWNhbFxuXG5cdFx0XHRcdGZvcmNlVXBsb2FkID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR3ZWJnbFRleHR1cmVzWyB0ZXh0dXJlQ2FjaGVLZXkgXS51c2VkVGltZXMgKys7XG5cblx0XHRcdC8vIGV2ZXJ5IHRpbWUgdGhlIHRleHR1cmUgY2FjaGUga2V5IGNoYW5nZXMsIGl0J3MgbmVjZXNzYXJ5IHRvIGNoZWNrIGlmIGFuIGluc3RhbmNlIG9mXG5cdFx0XHQvLyBXZWJHTFRleHR1cmUgY2FuIGJlIGRlbGV0ZWQgaW4gb3JkZXIgdG8gYXZvaWQgYSBtZW1vcnkgbGVhay5cblxuXHRcdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlID0gd2ViZ2xUZXh0dXJlc1sgdGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleSBdO1xuXG5cdFx0XHRpZiAoIHdlYmdsVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHdlYmdsVGV4dHVyZXNbIHRleHR1cmVQcm9wZXJ0aWVzLl9fY2FjaGVLZXkgXS51c2VkVGltZXMgLS07XG5cblx0XHRcdFx0aWYgKCB3ZWJnbFRleHR1cmUudXNlZFRpbWVzID09PSAwICkge1xuXG5cdFx0XHRcdFx0ZGVsZXRlVGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdG9yZSByZWZlcmVuY2VzIHRvIGNhY2hlIGtleSBhbmQgV2ViR0xUZXh0dXJlIG9iamVjdFxuXG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5ID0gdGV4dHVyZUNhY2hlS2V5O1xuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSB3ZWJnbFRleHR1cmVzWyB0ZXh0dXJlQ2FjaGVLZXkgXS50ZXh0dXJlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZvcmNlVXBsb2FkO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdGxldCB0ZXh0dXJlVHlwZSA9IF9nbC5URVhUVVJFXzJEO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHRleHR1cmVUeXBlID0gX2dsLlRFWFRVUkVfMkRfQVJSQVk7XG5cdFx0aWYgKCB0ZXh0dXJlLmlzRGF0YTNEVGV4dHVyZSApIHRleHR1cmVUeXBlID0gX2dsLlRFWFRVUkVfM0Q7XG5cblx0XHRjb25zdCBmb3JjZVVwbG9hZCA9IGluaXRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSApO1xuXHRcdGNvbnN0IHNvdXJjZSA9IHRleHR1cmUuc291cmNlO1xuXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIHRleHR1cmVUeXBlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXG5cdFx0Y29uc3Qgc291cmNlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBzb3VyY2UgKTtcblxuXHRcdGlmICggc291cmNlLnZlcnNpb24gIT09IHNvdXJjZVByb3BlcnRpZXMuX192ZXJzaW9uIHx8IGZvcmNlVXBsb2FkID09PSB0cnVlICkge1xuXG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cblx0XHRcdGNvbnN0IHdvcmtpbmdQcmltYXJpZXMgPSBDb2xvck1hbmFnZW1lbnQuZ2V0UHJpbWFyaWVzKCBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2UgKTtcblx0XHRcdGNvbnN0IHRleHR1cmVQcmltYXJpZXMgPSB0ZXh0dXJlLmNvbG9yU3BhY2UgPT09IE5vQ29sb3JTcGFjZSA/IG51bGwgOiBDb2xvck1hbmFnZW1lbnQuZ2V0UHJpbWFyaWVzKCB0ZXh0dXJlLmNvbG9yU3BhY2UgKTtcblx0XHRcdGNvbnN0IHVucGFja0NvbnZlcnNpb24gPSB0ZXh0dXJlLmNvbG9yU3BhY2UgPT09IE5vQ29sb3JTcGFjZSB8fCB3b3JraW5nUHJpbWFyaWVzID09PSB0ZXh0dXJlUHJpbWFyaWVzID8gX2dsLk5PTkUgOiBfZ2wuQlJPV1NFUl9ERUZBVUxUX1dFQkdMO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsIHVucGFja0NvbnZlcnNpb24gKTtcblxuXHRcdFx0bGV0IGltYWdlID0gcmVzaXplSW1hZ2UoIHRleHR1cmUuaW1hZ2UsIGZhbHNlLCBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUgKTtcblx0XHRcdGltYWdlID0gdmVyaWZ5Q29sb3JTcGFjZSggdGV4dHVyZSwgaW1hZ2UgKTtcblxuXHRcdFx0Y29uc3QgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS5jb2xvclNwYWNlICk7XG5cblx0XHRcdGNvbnN0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xuXHRcdFx0bGV0IGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCggdGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5jb2xvclNwYWNlLCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICk7XG5cblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSApO1xuXG5cdFx0XHRsZXQgbWlwbWFwO1xuXHRcdFx0Y29uc3QgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcblxuXHRcdFx0Y29uc3QgdXNlVGV4U3RvcmFnZSA9ICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSAhPT0gdHJ1ZSApO1xuXHRcdFx0Y29uc3QgYWxsb2NhdGVNZW1vcnkgPSAoIHNvdXJjZVByb3BlcnRpZXMuX192ZXJzaW9uID09PSB1bmRlZmluZWQgKSB8fCAoIGZvcmNlVXBsb2FkID09PSB0cnVlICk7XG5cdFx0XHRjb25zdCBkYXRhUmVhZHkgPSBzb3VyY2UuZGF0YVJlYWR5O1xuXHRcdFx0Y29uc3QgbGV2ZWxzID0gZ2V0TWlwTGV2ZWxzKCB0ZXh0dXJlLCBpbWFnZSApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUuaXNEZXB0aFRleHR1cmUgKSB7XG5cblx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IGdldEludGVybmFsRGVwdGhGb3JtYXQoIHRleHR1cmUuZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQsIHRleHR1cmUudHlwZSApO1xuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0aWYgKCBhbGxvY2F0ZU1lbW9yeSApIHtcblxuXHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMSwgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhVGV4dHVyZSApIHtcblxuXHRcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcblx0XHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cblx0XHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwc1sgMCBdLndpZHRoLCBtaXBtYXBzWyAwIF0uaGVpZ2h0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBkYXRhUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggYWxsb2NhdGVNZW1vcnkgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSApIHtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICYmIGFsbG9jYXRlTWVtb3J5ICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlM0QoIF9nbC5URVhUVVJFXzJEX0FSUkFZLCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcHNbIDAgXS53aWR0aCwgbWlwbWFwc1sgMCBdLmhlaWdodCwgaW1hZ2UuZGVwdGggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cblx0XHRcdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBnbEZvcm1hdCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkYXRhUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmxheWVyVXBkYXRlcy5zaXplID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAoIGNvbnN0IGxheWVySW5kZXggb2YgdGV4dHVyZS5sYXllclVwZGF0ZXMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGxheWVyU2l6ZSA9IG1pcG1hcC53aWR0aCAqIG1pcG1hcC5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIGksIDAsIDAsIGxheWVySW5kZXgsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMSwgZ2xGb3JtYXQsIG1pcG1hcC5kYXRhLnNsaWNlKCBsYXllclNpemUgKiBsYXllckluZGV4LCBsYXllclNpemUgKiAoIGxheWVySW5kZXggKyAxICkgKSwgMCwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dHVyZS5jbGVhckxheWVyVXBkYXRlcygpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIGksIDAsIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgaW1hZ2UuZGVwdGgsIGdsRm9ybWF0LCBtaXBtYXAuZGF0YSwgMCwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlM0QoIF9nbC5URVhUVVJFXzJEX0FSUkFZLCBpLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGltYWdlLmRlcHRoLCAwLCBtaXBtYXAuZGF0YSwgMCwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpJyApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRhdGFSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIGksIDAsIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgaW1hZ2UuZGVwdGgsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlM0QoIF9nbC5URVhUVVJFXzJEX0FSUkFZLCBpLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGltYWdlLmRlcHRoLCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwc1sgMCBdLndpZHRoLCBtaXBtYXBzWyAwIF0uaGVpZ2h0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZ2xGb3JtYXQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBnbEZvcm1hdCwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKCknICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgKSB7XG5cblx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBhbGxvY2F0ZU1lbW9yeSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTNEKCBfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBkYXRhUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdGV4dHVyZS5sYXllclVwZGF0ZXMuc2l6ZSA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gV2hlbiB0eXBlIGlzIEdMX1VOU0lHTkVEX0JZVEUsIGVhY2ggb2YgdGhlc2UgYnl0ZXMgaXNcblx0XHRcdFx0XHRcdFx0Ly8gaW50ZXJwcmV0ZWQgYXMgb25lIGNvbG9yIGNvbXBvbmVudCwgZGVwZW5kaW5nIG9uIGZvcm1hdC4gV2hlblxuXHRcdFx0XHRcdFx0XHQvLyB0eXBlIGlzIG9uZSBvZiBHTF9VTlNJR05FRF9TSE9SVF81XzZfNSxcblx0XHRcdFx0XHRcdFx0Ly8gR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCwgR0xfVU5TSUdORURfU0hPUlRfNV81XzVfMSwgZWFjaFxuXHRcdFx0XHRcdFx0XHQvLyB1bnNpZ25lZCB2YWx1ZSBpcyBpbnRlcnByZXRlZCBhcyBjb250YWluaW5nIGFsbCB0aGUgY29tcG9uZW50c1xuXHRcdFx0XHRcdFx0XHQvLyBmb3IgYSBzaW5nbGUgcGl4ZWwsIHdpdGggdGhlIGNvbG9yIGNvbXBvbmVudHMgYXJyYW5nZWRcblx0XHRcdFx0XHRcdFx0Ly8gYWNjb3JkaW5nIHRvIGZvcm1hdC5cblx0XHRcdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvT3BlbkdMLVJlZnBhZ2VzL2VzMS4xL3hodG1sL2dsVGV4SW1hZ2UyRC54bWxcblx0XHRcdFx0XHRcdFx0bGV0IHRleGVsU2l6ZTtcblx0XHRcdFx0XHRcdFx0c3dpdGNoICggZ2xUeXBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBfZ2wuVU5TSUdORURfQllURTpcblx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoIGdsRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgX2dsLkFMUEhBOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRleGVsU2l6ZSA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgX2dsLkxVTUlOQU5DRTpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXhlbFNpemUgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIF9nbC5MVU1JTkFOQ0VfQUxQSEE6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4ZWxTaXplID0gMjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBfZ2wuUkdCOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRleGVsU2l6ZSA9IDM7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgX2dsLlJHQkE6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4ZWxTaXplID0gNDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggYFVua25vd24gdGV4ZWwgc2l6ZSBmb3IgZm9ybWF0ICR7Z2xGb3JtYXR9LmAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ6XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBfZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTpcblx0XHRcdFx0XHRcdFx0XHRjYXNlIF9nbC5VTlNJR05FRF9TSE9SVF81XzZfNTpcblx0XHRcdFx0XHRcdFx0XHRcdHRleGVsU2l6ZSA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBVbmtub3duIHRleGVsIHNpemUgZm9yIHR5cGUgJHtnbFR5cGV9LmAgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgbGF5ZXJTaXplID0gaW1hZ2Uud2lkdGggKiBpbWFnZS5oZWlnaHQgKiB0ZXhlbFNpemU7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggY29uc3QgbGF5ZXJJbmRleCBvZiB0ZXh0dXJlLmxheWVyVXBkYXRlcyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlM0QoIF9nbC5URVhUVVJFXzJEX0FSUkFZLCAwLCAwLCAwLCBsYXllckluZGV4LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAxLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhLnNsaWNlKCBsYXllclNpemUgKiBsYXllckluZGV4LCBsYXllclNpemUgKiAoIGxheWVySW5kZXggKyAxICkgKSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLmNsZWFyTGF5ZXJVcGRhdGVzKCk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIDAsIDAsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YTNEVGV4dHVyZSApIHtcblxuXHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGFsbG9jYXRlTWVtb3J5ICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlM0QoIF9nbC5URVhUVVJFXzNELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGRhdGFSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UzRCggX2dsLlRFWFRVUkVfM0QsIDAsIDAsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlM0QoIF9nbC5URVhUVVJFXzNELCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0ZyYW1lYnVmZmVyVGV4dHVyZSApIHtcblxuXHRcdFx0XHRpZiAoIGFsbG9jYXRlTWVtb3J5ICkge1xuXG5cdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGxldCB3aWR0aCA9IGltYWdlLndpZHRoLCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxldmVsczsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXG5cdFx0XHRcdFx0XHRcdHdpZHRoID4+PSAxO1xuXHRcdFx0XHRcdFx0XHRoZWlnaHQgPj49IDE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gcmVndWxhciBUZXh0dXJlIChpbWFnZSwgdmlkZW8sIGNhbnZhcylcblxuXHRcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcblx0XHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cblx0XHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGRpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKCBtaXBtYXBzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIDAsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBhbGxvY2F0ZU1lbW9yeSApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyggaW1hZ2UgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApICkge1xuXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCB0ZXh0dXJlVHlwZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNvdXJjZVByb3BlcnRpZXMuX192ZXJzaW9uID0gc291cmNlLnZlcnNpb247XG5cblx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuXHRcdH1cblxuXHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBsb2FkQ3ViZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCAhPT0gNiApIHJldHVybjtcblxuXHRcdGNvbnN0IGZvcmNlVXBsb2FkID0gaW5pdFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlICk7XG5cdFx0Y29uc3Qgc291cmNlID0gdGV4dHVyZS5zb3VyY2U7XG5cblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cblx0XHRjb25zdCBzb3VyY2VQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHNvdXJjZSApO1xuXG5cdFx0aWYgKCBzb3VyY2UudmVyc2lvbiAhPT0gc291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gfHwgZm9yY2VVcGxvYWQgPT09IHRydWUgKSB7XG5cblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblxuXHRcdFx0Y29uc3Qgd29ya2luZ1ByaW1hcmllcyA9IENvbG9yTWFuYWdlbWVudC5nZXRQcmltYXJpZXMoIENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSApO1xuXHRcdFx0Y29uc3QgdGV4dHVyZVByaW1hcmllcyA9IHRleHR1cmUuY29sb3JTcGFjZSA9PT0gTm9Db2xvclNwYWNlID8gbnVsbCA6IENvbG9yTWFuYWdlbWVudC5nZXRQcmltYXJpZXMoIHRleHR1cmUuY29sb3JTcGFjZSApO1xuXHRcdFx0Y29uc3QgdW5wYWNrQ29udmVyc2lvbiA9IHRleHR1cmUuY29sb3JTcGFjZSA9PT0gTm9Db2xvclNwYWNlIHx8IHdvcmtpbmdQcmltYXJpZXMgPT09IHRleHR1cmVQcmltYXJpZXMgPyBfZ2wuTk9ORSA6IF9nbC5CUk9XU0VSX0RFRkFVTFRfV0VCR0w7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgdW5wYWNrQ29udmVyc2lvbiApO1xuXG5cdFx0XHRjb25zdCBpc0NvbXByZXNzZWQgPSAoIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSB8fCB0ZXh0dXJlLmltYWdlWyAwIF0uaXNDb21wcmVzc2VkVGV4dHVyZSApO1xuXHRcdFx0Y29uc3QgaXNEYXRhVGV4dHVyZSA9ICggdGV4dHVyZS5pbWFnZVsgMCBdICYmIHRleHR1cmUuaW1hZ2VbIDAgXS5pc0RhdGFUZXh0dXJlICk7XG5cblx0XHRcdGNvbnN0IGN1YmVJbWFnZSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSByZXNpemVJbWFnZSggdGV4dHVyZS5pbWFnZVsgaSBdLCB0cnVlLCBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IHZlcmlmeUNvbG9yU3BhY2UoIHRleHR1cmUsIGN1YmVJbWFnZVsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcblx0XHRcdFx0Z2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS5jb2xvclNwYWNlICksXG5cdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApLFxuXHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQoIHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuY29sb3JTcGFjZSApO1xuXG5cdFx0XHRjb25zdCB1c2VUZXhTdG9yYWdlID0gKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICE9PSB0cnVlICk7XG5cdFx0XHRjb25zdCBhbGxvY2F0ZU1lbW9yeSA9ICggc291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gPT09IHVuZGVmaW5lZCApIHx8ICggZm9yY2VVcGxvYWQgPT09IHRydWUgKTtcblx0XHRcdGNvbnN0IGRhdGFSZWFkeSA9IHNvdXJjZS5kYXRhUmVhZHk7XG5cdFx0XHRsZXQgbGV2ZWxzID0gZ2V0TWlwTGV2ZWxzKCB0ZXh0dXJlLCBpbWFnZSApO1xuXG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUgKTtcblxuXHRcdFx0bGV0IG1pcG1hcHM7XG5cblx0XHRcdGlmICggaXNDb21wcmVzc2VkICkge1xuXG5cdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSAmJiBhbGxvY2F0ZU1lbW9yeSApIHtcblxuXHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0bWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBtaXBtYXBzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZ2xGb3JtYXQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBnbEZvcm1hdCwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC5zZXRUZXh0dXJlQ3ViZSgpJyApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRhdGFSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcblxuXHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkgKSB7XG5cblx0XHRcdFx0XHQvLyBUT0RPOiBVbmlmb3JtbHkgaGFuZGxlIG1pcG1hcCBkZWZpbml0aW9uc1xuXHRcdFx0XHRcdC8vIE5vcm1hbCB0ZXh0dXJlcyBhbmQgY29tcHJlc3NlZCBjdWJlIHRleHR1cmVzIGRlZmluZSBiYXNlIGxldmVsICsgbWlwcyB3aXRoIHRoZWlyIG1pcG1hcCBhcnJheVxuXHRcdFx0XHRcdC8vIFVuY29tcHJlc3NlZCBjdWJlIHRleHR1cmVzIHVzZSB0aGVpciBtaXBtYXAgYXJyYXkgb25seSBmb3IgbWlwcyAobm8gYmFzZSBsZXZlbClcblxuXHRcdFx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICkgbGV2ZWxzICsrO1xuXG5cdFx0XHRcdFx0Y29uc3QgZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnMoIGN1YmVJbWFnZVsgMCBdICk7XG5cblx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGlzRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGRhdGFSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCAwLCAwLCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEludGVybmFsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgbWlwbWFwcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBtaXBtYXBJbWFnZSA9IG1pcG1hcC5pbWFnZVsgaSBdLmltYWdlO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiArIDEsIDAsIDAsIG1pcG1hcEltYWdlLndpZHRoLCBtaXBtYXBJbWFnZS5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcEltYWdlLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGogKyAxLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXBJbWFnZS53aWR0aCwgbWlwbWFwSW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXBJbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBkYXRhUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgMCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgbWlwbWFwcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggZGF0YVJlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiArIDEsIDAsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5pbWFnZVsgaSBdICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqICsgMSwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmltYWdlWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKSApIHtcblxuXHRcdFx0XHQvLyBXZSBhc3N1bWUgaW1hZ2VzIGZvciBjdWJlIG1hcCBoYXZlIHRoZSBzYW1lIHNpemUuXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNvdXJjZVByb3BlcnRpZXMuX192ZXJzaW9uID0gc291cmNlLnZlcnNpb247XG5cblx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuXHRcdH1cblxuXHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuXHR9XG5cblx0Ly8gUmVuZGVyIHRhcmdldHNcblxuXHQvLyBTZXR1cCBzdG9yYWdlIGZvciB0YXJnZXQgdGV4dHVyZSBhbmQgYmluZCBpdCB0byBjb3JyZWN0IGZyYW1lYnVmZmVyXG5cdGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBsZXZlbCApIHtcblxuXHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuY29sb3JTcGFjZSApO1xuXHRcdGNvbnN0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xuXHRcdGNvbnN0IGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCggdGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5jb2xvclNwYWNlICk7XG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdGlmICggISByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyApIHtcblxuXHRcdFx0Y29uc3Qgd2lkdGggPSBNYXRoLm1heCggMSwgcmVuZGVyVGFyZ2V0LndpZHRoID4+IGxldmVsICk7XG5cdFx0XHRjb25zdCBoZWlnaHQgPSBNYXRoLm1heCggMSwgcmVuZGVyVGFyZ2V0LmhlaWdodCA+PiBsZXZlbCApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVUYXJnZXQgPT09IF9nbC5URVhUVVJFXzNEIHx8IHRleHR1cmVUYXJnZXQgPT09IF9nbC5URVhUVVJFXzJEX0FSUkFZICkge1xuXG5cdFx0XHRcdHN0YXRlLnRleEltYWdlM0QoIHRleHR1cmVUYXJnZXQsIGxldmVsLCBnbEludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCByZW5kZXJUYXJnZXQuZGVwdGgsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCB0ZXh0dXJlVGFyZ2V0LCBsZXZlbCwgZ2xJbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblxuXHRcdGlmICggdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSApIHtcblxuXHRcdFx0bXVsdGlzYW1wbGVkUlRURXh0LmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQoIF9nbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSwgMCwgZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyggcmVuZGVyVGFyZ2V0ICkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmVUYXJnZXQgPT09IF9nbC5URVhUVVJFXzJEIHx8ICggdGV4dHVyZVRhcmdldCA+PSBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICYmIHRleHR1cmVUYXJnZXQgPD0gX2dsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWiApICkgeyAvLyBzZWUgIzI0NzUzXG5cblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlLCBsZXZlbCApO1xuXG5cdFx0fVxuXG5cdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuXHR9XG5cblx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgaW50ZXJuYWwgZGVwdGgvc3RlbmNpbCBidWZmZXJzIGFuZCBiaW5kIHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCwgaXNNdWx0aXNhbXBsZSApIHtcblxuXHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICkge1xuXG5cdFx0XHQvLyByZXRyaWV2ZSB0aGUgZGVwdGggYXR0YWNobWVudCB0eXBlc1xuXHRcdFx0Y29uc3QgZGVwdGhUZXh0dXJlID0gcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZTtcblx0XHRcdGNvbnN0IGRlcHRoVHlwZSA9IGRlcHRoVGV4dHVyZSAmJiBkZXB0aFRleHR1cmUuaXNEZXB0aFRleHR1cmUgPyBkZXB0aFRleHR1cmUudHlwZSA6IG51bGw7XG5cdFx0XHRjb25zdCBnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxEZXB0aEZvcm1hdCggcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIsIGRlcHRoVHlwZSApO1xuXHRcdFx0Y29uc3QgZ2xBdHRhY2htZW50VHlwZSA9IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID8gX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA6IF9nbC5ERVBUSF9BVFRBQ0hNRU5UO1xuXG5cdFx0XHQvLyBzZXQgdXAgdGhlIGF0dGFjaG1lbnRcblx0XHRcdGNvbnN0IHNhbXBsZXMgPSBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKCByZW5kZXJUYXJnZXQgKTtcblx0XHRcdGNvbnN0IGlzVXNlTXVsdGlzYW1wbGVkUlRUID0gdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKTtcblx0XHRcdGlmICggaXNVc2VNdWx0aXNhbXBsZWRSVFQgKSB7XG5cblx0XHRcdFx0bXVsdGlzYW1wbGVkUlRURXh0LnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZUVYVCggX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGlzTXVsdGlzYW1wbGUgKSB7XG5cblx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSggX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBnbEF0dGFjaG1lbnRUeXBlLCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmVzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRleHR1cmVzWyBpIF07XG5cblx0XHRcdFx0Y29uc3QgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS5jb2xvclNwYWNlICk7XG5cdFx0XHRcdGNvbnN0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xuXHRcdFx0XHRjb25zdCBnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQoIHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuY29sb3JTcGFjZSApO1xuXHRcdFx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0aWYgKCBpc011bHRpc2FtcGxlICYmIHVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSggX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSApIHtcblxuXHRcdFx0XHRcdG11bHRpc2FtcGxlZFJUVEV4dC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQoIF9nbC5SRU5ERVJCVUZGRVIsIHNhbXBsZXMsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuXG5cdH1cblxuXHQvLyBTZXR1cCByZXNvdXJjZXMgZm9yIGEgRGVwdGggVGV4dHVyZSBmb3IgYSBGQk8gKG5lZWRzIGFuIGV4dGVuc2lvbilcblx0ZnVuY3Rpb24gc2V0dXBEZXB0aFRleHR1cmUoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRjb25zdCBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgKTtcblx0XHRpZiAoIGlzQ3ViZSApIHRocm93IG5ldyBFcnJvciggJ0RlcHRoIFRleHR1cmUgd2l0aCBjdWJlIHJlbmRlciB0YXJnZXRzIGlzIG5vdCBzdXBwb3J0ZWQnICk7XG5cblx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblxuXHRcdGlmICggISAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgJiYgcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuRGVwdGhUZXh0dXJlJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBsb2FkIGFuIGVtcHR5IGRlcHRoIHRleHR1cmUgd2l0aCBmcmFtZWJ1ZmZlciBzaXplXG5cdFx0aWYgKCAhIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkuX193ZWJnbFRleHR1cmUgfHxcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCAhPT0gcmVuZGVyVGFyZ2V0LndpZHRoIHx8XG5cdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ICE9PSByZW5kZXJUYXJnZXQuaGVpZ2h0ICkge1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRzZXRUZXh0dXJlMkQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUsIDAgKTtcblxuXHRcdGNvbnN0IHdlYmdsRGVwdGhUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcblx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZm9ybWF0ID09PSBEZXB0aEZvcm1hdCApIHtcblxuXHRcdFx0aWYgKCB1c2VNdWx0aXNhbXBsZWRSVFQoIHJlbmRlclRhcmdldCApICkge1xuXG5cdFx0XHRcdG11bHRpc2FtcGxlZFJUVEV4dC5mcmFtZWJ1ZmZlclRleHR1cmUyRE11bHRpc2FtcGxlRVhUKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAsIHNhbXBsZXMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xuXG5cdFx0XHRpZiAoIHVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkgKSB7XG5cblx0XHRcdFx0bXVsdGlzYW1wbGVkUlRURXh0LmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwLCBzYW1wbGVzICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdVbmtub3duIGRlcHRoVGV4dHVyZSBmb3JtYXQnICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFNldHVwIEdMIHJlc291cmNlcyBmb3IgYSBub24tdGV4dHVyZSBkZXB0aCBidWZmZXJcblx0ZnVuY3Rpb24gc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHRjb25zdCBpc0N1YmUgPSAoIHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA9PT0gdHJ1ZSApO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICYmICEgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyICkge1xuXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHRocm93IG5ldyBFcnJvciggJ3RhcmdldC5kZXB0aFRleHR1cmUgbm90IHN1cHBvcnRlZCBpbiBDdWJlIHJlbmRlciB0YXJnZXRzJyApO1xuXG5cdFx0XHRzZXR1cERlcHRoVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBmYWxzZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIsIHJlbmRlclRhcmdldCwgZmFsc2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuXHR9XG5cblx0Ly8gcmViaW5kIGZyYW1lYnVmZmVyIHdpdGggZXh0ZXJuYWwgdGV4dHVyZXNcblx0ZnVuY3Rpb24gcmViaW5kVGV4dHVyZXMoIHJlbmRlclRhcmdldCwgY29sb3JUZXh0dXJlLCBkZXB0aFRleHR1cmUgKSB7XG5cblx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0aWYgKCBjb2xvclRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFXzJELCAwICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRlcHRoVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzZXR1cERlcHRoUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gU2V0IHVwIEdMIHJlc291cmNlcyBmb3IgdGhlIHJlbmRlciB0YXJnZXRcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuXHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cblx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlcztcblxuXHRcdGNvbnN0IGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID09PSB0cnVlICk7XG5cdFx0Y29uc3QgaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgPSAoIHRleHR1cmVzLmxlbmd0aCA+IDEgKTtcblxuXHRcdGlmICggISBpc011bHRpcGxlUmVuZGVyVGFyZ2V0cyApIHtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cdFx0XHRpbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdH1cblxuXHRcdC8vIFNldHVwIGZyYW1lYnVmZmVyXG5cblx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUubWlwbWFwcyAmJiB0ZXh0dXJlLm1pcG1hcHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGV4dHVyZS5taXBtYXBzLmxlbmd0aDsgbGV2ZWwgKysgKSB7XG5cblx0XHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF1bIGxldmVsIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLm1pcG1hcHMgJiYgdGV4dHVyZS5taXBtYXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRleHR1cmUubWlwbWFwcy5sZW5ndGg7IGxldmVsICsrICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGxldmVsIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGF0dGFjaG1lbnRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmVzWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggYXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0YXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0XHRcdFx0XHRpbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAoIHJlbmRlclRhcmdldC5zYW1wbGVzID4gMCApICYmIHVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyID0gW107XG5cblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRleHR1cmVzWyBpIF07XG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuXHRcdFx0XHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlclsgaSBdICk7XG5cblx0XHRcdFx0XHRjb25zdCBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLmNvbG9yU3BhY2UgKTtcblx0XHRcdFx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcblx0XHRcdFx0XHRjb25zdCBnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQoIHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuY29sb3JTcGFjZSwgcmVuZGVyVGFyZ2V0LmlzWFJSZW5kZXJUYXJnZXQgPT09IHRydWUgKTtcblx0XHRcdFx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSggX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cblx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0cnVlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIFNldHVwIGNvbG9yIGJ1ZmZlclxuXG5cdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggdGV4dHVyZS5taXBtYXBzICYmIHRleHR1cmUubWlwbWFwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGxldmVsID0gMDsgbGV2ZWwgPCB0ZXh0dXJlLm1pcG1hcHMubGVuZ3RoOyBsZXZlbCArKyApIHtcblxuXHRcdFx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF1bIGxldmVsIF0sIHJlbmRlclRhcmdldCwgdGV4dHVyZSwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgbGV2ZWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCwgdGV4dHVyZSwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApICkge1xuXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblxuXHRcdH0gZWxzZSBpZiAoIGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0YWNobWVudCA9IHRleHR1cmVzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGF0dGFjaG1lbnRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIGF0dGFjaG1lbnQgKTtcblxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cdFx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgYXR0YWNobWVudCApO1xuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgYXR0YWNobWVudCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgX2dsLlRFWFRVUkVfMkQsIDAgKTtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggYXR0YWNobWVudCApICkge1xuXG5cdFx0XHRcdFx0Z2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGxldCBnbFRleHR1cmVUeXBlID0gX2dsLlRFWFRVUkVfMkQ7XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmlzV2ViR0wzRFJlbmRlclRhcmdldCB8fCByZW5kZXJUYXJnZXQuaXNXZWJHTEFycmF5UmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHRcdGdsVGV4dHVyZVR5cGUgPSByZW5kZXJUYXJnZXQuaXNXZWJHTDNEUmVuZGVyVGFyZ2V0ID8gX2dsLlRFWFRVUkVfM0QgOiBfZ2wuVEVYVFVSRV8yRF9BUlJBWTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBnbFRleHR1cmVUeXBlLCB0ZXh0dXJlICk7XG5cblx0XHRcdGlmICggdGV4dHVyZS5taXBtYXBzICYmIHRleHR1cmUubWlwbWFwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGV4dHVyZS5taXBtYXBzLmxlbmd0aDsgbGV2ZWwgKysgKSB7XG5cblx0XHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGxldmVsIF0sIHJlbmRlclRhcmdldCwgdGV4dHVyZSwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbFRleHR1cmVUeXBlLCBsZXZlbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZSwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbFRleHR1cmVUeXBlLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKSApIHtcblxuXHRcdFx0XHRnZW5lcmF0ZU1pcG1hcCggZ2xUZXh0dXJlVHlwZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblxuXHRcdH1cblxuXHRcdC8vIFNldHVwIGRlcHRoIGFuZCBzdGVuY2lsIGJ1ZmZlcnNcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICkge1xuXG5cdFx0XHRzZXR1cERlcHRoUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRleHR1cmVzWyBpIF07XG5cblx0XHRcdGlmICggdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID8gX2dsLlRFWFRVUkVfQ1VCRV9NQVAgOiBfZ2wuVEVYVFVSRV8yRDtcblx0XHRcdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcblxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCB3ZWJnbFRleHR1cmUgKTtcblx0XHRcdFx0Z2VuZXJhdGVNaXBtYXAoIHRhcmdldCApO1xuXHRcdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgaW52YWxpZGF0aW9uQXJyYXlSZWFkID0gW107XG5cdGNvbnN0IGludmFsaWRhdGlvbkFycmF5RHJhdyA9IFtdO1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldC5zYW1wbGVzID4gMCApIHtcblxuXHRcdFx0aWYgKCB1c2VNdWx0aXNhbXBsZWRSVFQoIHJlbmRlclRhcmdldCApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlcztcblx0XHRcdFx0Y29uc3Qgd2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG5cdFx0XHRcdGNvbnN0IGhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XG5cdFx0XHRcdGxldCBtYXNrID0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XG5cdFx0XHRcdGNvbnN0IGRlcHRoU3R5bGUgPSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA/IF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQgOiBfZ2wuREVQVEhfQVRUQUNITUVOVDtcblx0XHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHRcdFx0Y29uc3QgaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgPSAoIHRleHR1cmVzLmxlbmd0aCA+IDEgKTtcblxuXHRcdFx0XHQvLyBJZiBNUlQgd2UgbmVlZCB0byByZW1vdmUgRkJPIGF0dGFjaG1lbnRzXG5cdFx0XHRcdGlmICggaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApO1xuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblxuXHRcdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCwgMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApO1xuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnJlc29sdmVEZXB0aEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgKSBtYXNrIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xuXG5cdFx0XHRcdFx0XHQvLyByZXNvbHZpbmcgc3RlbmNpbCBpcyBzbG93IHdpdGggYSBEM0QgYmFja2VuZC4gZGlzYWJsZSBpdCBmb3IgYWxsIHRyYW5zbWlzc2lvbiByZW5kZXIgdGFyZ2V0cyAoc2VlICMyNzc5OSlcblxuXHRcdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQucmVzb2x2ZVN0ZW5jaWxCdWZmZXIgKSBtYXNrIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmVzWyBpIF0gKS5fX3dlYmdsVGV4dHVyZTtcblx0XHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkRSQVdfRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsVGV4dHVyZSwgMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLmJsaXRGcmFtZWJ1ZmZlciggMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgbWFzaywgX2dsLk5FQVJFU1QgKTtcblxuXHRcdFx0XHRcdGlmICggc3VwcG9ydHNJbnZhbGlkYXRlRnJhbWVidWZmZXIgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGludmFsaWRhdGlvbkFycmF5UmVhZC5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0aW52YWxpZGF0aW9uQXJyYXlEcmF3Lmxlbmd0aCA9IDA7XG5cblx0XHRcdFx0XHRcdGludmFsaWRhdGlvbkFycmF5UmVhZC5wdXNoKCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICk7XG5cblx0XHRcdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5yZXNvbHZlRGVwdGhCdWZmZXIgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdGludmFsaWRhdGlvbkFycmF5UmVhZC5wdXNoKCBkZXB0aFN0eWxlICk7XG5cdFx0XHRcdFx0XHRcdGludmFsaWRhdGlvbkFycmF5RHJhdy5wdXNoKCBkZXB0aFN0eWxlICk7XG5cblx0XHRcdFx0XHRcdFx0X2dsLmludmFsaWRhdGVGcmFtZWJ1ZmZlciggX2dsLkRSQVdfRlJBTUVCVUZGRVIsIGludmFsaWRhdGlvbkFycmF5RHJhdyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdF9nbC5pbnZhbGlkYXRlRnJhbWVidWZmZXIoIF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCBpbnZhbGlkYXRpb25BcnJheVJlYWQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuUkVBRF9GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCBudWxsICk7XG5cblx0XHRcdFx0Ly8gSWYgTVJUIHNpbmNlIHByZS1ibGl0IHdlIHJlbW92ZWQgdGhlIEZCTyB3ZSBuZWVkIHRvIHJlY29uc3RydWN0IHRoZSBhdHRhY2htZW50c1xuXHRcdFx0XHRpZiAoIGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIgKTtcblx0XHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlclsgaSBdICk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHdlYmdsVGV4dHVyZSA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlc1sgaSBdICkuX193ZWJnbFRleHR1cmU7XG5cblx0XHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRFJBV19GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsVGV4dHVyZSwgMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5yZXNvbHZlRGVwdGhCdWZmZXIgPT09IGZhbHNlICYmIHN1cHBvcnRzSW52YWxpZGF0ZUZyYW1lYnVmZmVyICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZGVwdGhTdHlsZSA9IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID8gX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA6IF9nbC5ERVBUSF9BVFRBQ0hNRU5UO1xuXG5cdFx0XHRcdFx0X2dsLmludmFsaWRhdGVGcmFtZWJ1ZmZlciggX2dsLkRSQVdfRlJBTUVCVUZGRVIsIFsgZGVwdGhTdHlsZSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFNhbXBsZXMoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdHJldHVybiBNYXRoLm1pbiggY2FwYWJpbGl0aWVzLm1heFNhbXBsZXMsIHJlbmRlclRhcmdldC5zYW1wbGVzICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJldHVybiByZW5kZXJUYXJnZXQuc2FtcGxlcyA+IDAgJiYgZXh0ZW5zaW9ucy5oYXMoICdXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUnICkgPT09IHRydWUgJiYgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3VzZVJlbmRlclRvVGV4dHVyZSAhPT0gZmFsc2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVZpZGVvVGV4dHVyZSggdGV4dHVyZSApIHtcblxuXHRcdGNvbnN0IGZyYW1lID0gaW5mby5yZW5kZXIuZnJhbWU7XG5cblx0XHQvLyBDaGVjayB0aGUgbGFzdCBmcmFtZSB3ZSB1cGRhdGVkIHRoZSBWaWRlb1RleHR1cmVcblxuXHRcdGlmICggX3ZpZGVvVGV4dHVyZXMuZ2V0KCB0ZXh0dXJlICkgIT09IGZyYW1lICkge1xuXG5cdFx0XHRfdmlkZW9UZXh0dXJlcy5zZXQoIHRleHR1cmUsIGZyYW1lICk7XG5cdFx0XHR0ZXh0dXJlLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB2ZXJpZnlDb2xvclNwYWNlKCB0ZXh0dXJlLCBpbWFnZSApIHtcblxuXHRcdGNvbnN0IGNvbG9yU3BhY2UgPSB0ZXh0dXJlLmNvbG9yU3BhY2U7XG5cdFx0Y29uc3QgZm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XG5cdFx0Y29uc3QgdHlwZSA9IHRleHR1cmUudHlwZTtcblxuXHRcdGlmICggdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlID09PSB0cnVlIHx8IHRleHR1cmUuaXNWaWRlb1RleHR1cmUgPT09IHRydWUgKSByZXR1cm4gaW1hZ2U7XG5cblx0XHRpZiAoIGNvbG9yU3BhY2UgIT09IExpbmVhclNSR0JDb2xvclNwYWNlICYmIGNvbG9yU3BhY2UgIT09IE5vQ29sb3JTcGFjZSApIHtcblxuXHRcdFx0Ly8gc1JHQlxuXG5cdFx0XHRpZiAoIENvbG9yTWFuYWdlbWVudC5nZXRUcmFuc2ZlciggY29sb3JTcGFjZSApID09PSBTUkdCVHJhbnNmZXIgKSB7XG5cblx0XHRcdFx0Ly8gaW4gV2ViR0wgMiB1bmNvbXByZXNzZWQgdGV4dHVyZXMgY2FuIG9ubHkgYmUgc1JHQiBlbmNvZGVkIGlmIHRoZXkgaGF2ZSB0aGUgUkdCQTggZm9ybWF0XG5cblx0XHRcdFx0aWYgKCBmb3JtYXQgIT09IFJHQkFGb3JtYXQgfHwgdHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMVGV4dHVyZXM6IHNSR0IgZW5jb2RlZCB0ZXh0dXJlcyBoYXZlIHRvIHVzZSBSR0JBRm9ybWF0IGFuZCBVbnNpZ25lZEJ5dGVUeXBlLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMVGV4dHVyZXM6IFVuc3VwcG9ydGVkIHRleHR1cmUgY29sb3Igc3BhY2U6JywgY29sb3JTcGFjZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW1hZ2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoIGltYWdlICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICkge1xuXG5cdFx0XHQvLyBpZiBpbnRyaW5zaWMgZGF0YSBhcmUgbm90IGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gd2lkdGgvaGVpZ2h0XG5cblx0XHRcdF9pbWFnZURpbWVuc2lvbnMud2lkdGggPSBpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2Uud2lkdGg7XG5cdFx0XHRfaW1hZ2VEaW1lbnNpb25zLmhlaWdodCA9IGltYWdlLm5hdHVyYWxIZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIFZpZGVvRnJhbWUgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgVmlkZW9GcmFtZSApIHtcblxuXHRcdFx0X2ltYWdlRGltZW5zaW9ucy53aWR0aCA9IGltYWdlLmRpc3BsYXlXaWR0aDtcblx0XHRcdF9pbWFnZURpbWVuc2lvbnMuaGVpZ2h0ID0gaW1hZ2UuZGlzcGxheUhlaWdodDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9pbWFnZURpbWVuc2lvbnMud2lkdGggPSBpbWFnZS53aWR0aDtcblx0XHRcdF9pbWFnZURpbWVuc2lvbnMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIF9pbWFnZURpbWVuc2lvbnM7XG5cblx0fVxuXG5cdC8vXG5cblx0dGhpcy5hbGxvY2F0ZVRleHR1cmVVbml0ID0gYWxsb2NhdGVUZXh0dXJlVW5pdDtcblx0dGhpcy5yZXNldFRleHR1cmVVbml0cyA9IHJlc2V0VGV4dHVyZVVuaXRzO1xuXG5cdHRoaXMuc2V0VGV4dHVyZTJEID0gc2V0VGV4dHVyZTJEO1xuXHR0aGlzLnNldFRleHR1cmUyREFycmF5ID0gc2V0VGV4dHVyZTJEQXJyYXk7XG5cdHRoaXMuc2V0VGV4dHVyZTNEID0gc2V0VGV4dHVyZTNEO1xuXHR0aGlzLnNldFRleHR1cmVDdWJlID0gc2V0VGV4dHVyZUN1YmU7XG5cdHRoaXMucmViaW5kVGV4dHVyZXMgPSByZWJpbmRUZXh0dXJlcztcblx0dGhpcy5zZXR1cFJlbmRlclRhcmdldCA9IHNldHVwUmVuZGVyVGFyZ2V0O1xuXHR0aGlzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCA9IHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcDtcblx0dGhpcy51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldCA9IHVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0O1xuXHR0aGlzLnNldHVwRGVwdGhSZW5kZXJidWZmZXIgPSBzZXR1cERlcHRoUmVuZGVyYnVmZmVyO1xuXHR0aGlzLnNldHVwRnJhbWVCdWZmZXJUZXh0dXJlID0gc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmU7XG5cdHRoaXMudXNlTXVsdGlzYW1wbGVkUlRUID0gdXNlTXVsdGlzYW1wbGVkUlRUO1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMVXRpbHMoIGdsLCBleHRlbnNpb25zICkge1xuXG5cdGZ1bmN0aW9uIGNvbnZlcnQoIHAsIGNvbG9yU3BhY2UgPSBOb0NvbG9yU3BhY2UgKSB7XG5cblx0XHRsZXQgZXh0ZW5zaW9uO1xuXG5cdFx0Y29uc3QgdHJhbnNmZXIgPSBDb2xvck1hbmFnZW1lbnQuZ2V0VHJhbnNmZXIoIGNvbG9yU3BhY2UgKTtcblxuXHRcdGlmICggcCA9PT0gVW5zaWduZWRCeXRlVHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDQ0NDRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XG5cdFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkSW50NTk5OVR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfSU5UXzVfOV85XzlfUkVWO1xuXG5cdFx0aWYgKCBwID09PSBCeXRlVHlwZSApIHJldHVybiBnbC5CWVRFO1xuXHRcdGlmICggcCA9PT0gU2hvcnRUeXBlICkgcmV0dXJuIGdsLlNIT1JUO1xuXHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydFR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlQ7XG5cdFx0aWYgKCBwID09PSBJbnRUeXBlICkgcmV0dXJuIGdsLklOVDtcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkSW50VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9JTlQ7XG5cdFx0aWYgKCBwID09PSBGbG9hdFR5cGUgKSByZXR1cm4gZ2wuRkxPQVQ7XG5cdFx0aWYgKCBwID09PSBIYWxmRmxvYXRUeXBlICkgcmV0dXJuIGdsLkhBTEZfRkxPQVQ7XG5cblx0XHRpZiAoIHAgPT09IEFscGhhRm9ybWF0ICkgcmV0dXJuIGdsLkFMUEhBO1xuXHRcdGlmICggcCA9PT0gUkdCRm9ybWF0ICkgcmV0dXJuIGdsLlJHQjtcblx0XHRpZiAoIHAgPT09IFJHQkFGb3JtYXQgKSByZXR1cm4gZ2wuUkdCQTtcblx0XHRpZiAoIHAgPT09IEx1bWluYW5jZUZvcm1hdCApIHJldHVybiBnbC5MVU1JTkFOQ0U7XG5cdFx0aWYgKCBwID09PSBMdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBnbC5MVU1JTkFOQ0VfQUxQSEE7XG5cdFx0aWYgKCBwID09PSBEZXB0aEZvcm1hdCApIHJldHVybiBnbC5ERVBUSF9DT01QT05FTlQ7XG5cdFx0aWYgKCBwID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSByZXR1cm4gZ2wuREVQVEhfU1RFTkNJTDtcblxuXHRcdC8vIFdlYkdMMiBmb3JtYXRzLlxuXG5cdFx0aWYgKCBwID09PSBSZWRGb3JtYXQgKSByZXR1cm4gZ2wuUkVEO1xuXHRcdGlmICggcCA9PT0gUmVkSW50ZWdlckZvcm1hdCApIHJldHVybiBnbC5SRURfSU5URUdFUjtcblx0XHRpZiAoIHAgPT09IFJHRm9ybWF0ICkgcmV0dXJuIGdsLlJHO1xuXHRcdGlmICggcCA9PT0gUkdJbnRlZ2VyRm9ybWF0ICkgcmV0dXJuIGdsLlJHX0lOVEVHRVI7XG5cdFx0aWYgKCBwID09PSBSR0JBSW50ZWdlckZvcm1hdCApIHJldHVybiBnbC5SR0JBX0lOVEVHRVI7XG5cblx0XHQvLyBTM1RDXG5cblx0XHRpZiAoIHAgPT09IFJHQl9TM1RDX0RYVDFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkge1xuXG5cdFx0XHRpZiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiJyApO1xuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFQ7XG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhUO1xuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQzX0VYVDtcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBQVlJUQ1xuXG5cdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkge1xuXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcblx0XHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEVUQ1xuXG5cdFx0aWYgKCBwID09PSBSR0JfRVRDMV9Gb3JtYXQgfHwgcCA9PT0gUkdCX0VUQzJfRm9ybWF0IHx8IHAgPT09IFJHQkFfRVRDMl9FQUNfRm9ybWF0ICkge1xuXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCX0VUQzFfRm9ybWF0IHx8IHAgPT09IFJHQl9FVEMyX0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0VUQzIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0I4X0VUQzI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9FVEMyX0VBQ19Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUMgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gQVNUQ1xuXG5cdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNHg0X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfNXg0X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfNXg1X0Zvcm1hdCB8fFxuXHRcdFx0cCA9PT0gUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQgfHxcblx0XHRcdHAgPT09IFJHQkFfQVNUQ184eDZfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ184eDhfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCB8fFxuXHRcdFx0cCA9PT0gUkdCQV9BU1RDXzEweDZfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTB4MTBfRm9ybWF0IHx8XG5cdFx0XHRwID09PSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQgKSB7XG5cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGMnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzR4NF9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ180eDRfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDRfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzV4NF9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzV4NV9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzV4NV9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4NV9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDZfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4Nl9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4NV9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDZfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4Nl9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDhfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4OF9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEweDVfRm9ybWF0ICkgcmV0dXJuICggdHJhbnNmZXIgPT09IFNSR0JUcmFuc2ZlciApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4NV9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4NV9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEweDZfRm9ybWF0ICkgcmV0dXJuICggdHJhbnNmZXIgPT09IFNSR0JUcmFuc2ZlciApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4Nl9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4Nl9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEweDhfRm9ybWF0ICkgcmV0dXJuICggdHJhbnNmZXIgPT09IFNSR0JUcmFuc2ZlciApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4OF9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4OF9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDEwX0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHgxMF9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEwX0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMngxMF9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCApIHJldHVybiAoIHRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEyX0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMngxMl9LSFI7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEJQVENcblxuXHRcdGlmICggcCA9PT0gUkdCQV9CUFRDX0Zvcm1hdCB8fCBwID09PSBSR0JfQlBUQ19TSUdORURfRm9ybWF0IHx8IHAgPT09IFJHQl9CUFRDX1VOU0lHTkVEX0Zvcm1hdCApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9icHRjJyApO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfQlBUQ19Gb3JtYXQgKSByZXR1cm4gKCB0cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCX0FMUEhBX0JQVENfVU5PUk1fRVhUIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9CUFRDX1VOT1JNX0VYVDtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JfQlBUQ19TSUdORURfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9CUFRDX1NJR05FRF9GTE9BVF9FWFQ7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCX0JQVENfVU5TSUdORURfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9CUFRDX1VOU0lHTkVEX0ZMT0FUX0VYVDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gUkdUQ1xuXG5cdFx0aWYgKCBwID09PSBSRURfUkdUQzFfRm9ybWF0IHx8IHAgPT09IFNJR05FRF9SRURfUkdUQzFfRm9ybWF0IHx8IHAgPT09IFJFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgfHwgcCA9PT0gU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgKSB7XG5cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfY29tcHJlc3Npb25fcmd0YycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0JQVENfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JFRF9SR1RDMV9FWFQ7XG5cdFx0XHRcdGlmICggcCA9PT0gU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU0lHTkVEX1JFRF9SR1RDMV9FWFQ7XG5cdFx0XHRcdGlmICggcCA9PT0gUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SRURfR1JFRU5fUkdUQzJfRVhUO1xuXHRcdFx0XHRpZiAoIHAgPT09IFNJR05FRF9SRURfR1JFRU5fUkdUQzJfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1NJR05FRF9SRURfR1JFRU5fUkdUQzJfRVhUO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBwID09PSBVbnNpZ25lZEludDI0OFR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfSU5UXzI0Xzg7XG5cblx0XHQvLyBpZiBcInBcIiBjYW4ndCBiZSByZXNvbHZlZCwgYXNzdW1lIHRoZSB1c2VyIGRlZmluZXMgYSBXZWJHTCBjb25zdGFudCBhcyBhIHN0cmluZyAoZmFsbGJhY2svd29ya2Fyb3VuZCBmb3IgcGFja2VkIFJHQiBmb3JtYXRzKVxuXG5cdFx0cmV0dXJuICggZ2xbIHAgXSAhPT0gdW5kZWZpbmVkICkgPyBnbFsgcCBdIDogbnVsbDtcblxuXHR9XG5cblx0cmV0dXJuIHsgY29udmVydDogY29udmVydCB9O1xuXG59XG5cbmNsYXNzIEFycmF5Q2FtZXJhIGV4dGVuZHMgUGVyc3BlY3RpdmVDYW1lcmEge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSA9IFtdICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNBcnJheUNhbWVyYSA9IHRydWU7XG5cblx0XHR0aGlzLmNhbWVyYXMgPSBhcnJheTtcblxuXHR9XG5cbn1cblxuY2xhc3MgR3JvdXAgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0dyb3VwID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdHcm91cCc7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9tb3ZlRXZlbnQgPSB7IHR5cGU6ICdtb3ZlJyB9O1xuXG5jbGFzcyBXZWJYUkNvbnRyb2xsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5fdGFyZ2V0UmF5ID0gbnVsbDtcblx0XHR0aGlzLl9ncmlwID0gbnVsbDtcblx0XHR0aGlzLl9oYW5kID0gbnVsbDtcblxuXHR9XG5cblx0Z2V0SGFuZFNwYWNlKCkge1xuXG5cdFx0aWYgKCB0aGlzLl9oYW5kID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9oYW5kID0gbmV3IEdyb3VwKCk7XG5cdFx0XHR0aGlzLl9oYW5kLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2hhbmQudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLl9oYW5kLmpvaW50cyA9IHt9O1xuXHRcdFx0dGhpcy5faGFuZC5pbnB1dFN0YXRlID0geyBwaW5jaGluZzogZmFsc2UgfTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9oYW5kO1xuXG5cdH1cblxuXHRnZXRUYXJnZXRSYXlTcGFjZSgpIHtcblxuXHRcdGlmICggdGhpcy5fdGFyZ2V0UmF5ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl90YXJnZXRSYXkgPSBuZXcgR3JvdXAoKTtcblx0XHRcdHRoaXMuX3RhcmdldFJheS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkubGluZWFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5Lmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5LmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fdGFyZ2V0UmF5O1xuXG5cdH1cblxuXHRnZXRHcmlwU3BhY2UoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2dyaXAgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2dyaXAgPSBuZXcgR3JvdXAoKTtcblx0XHRcdHRoaXMuX2dyaXAubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZ3JpcC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9ncmlwLmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9ncmlwLmxpbmVhclZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHRoaXMuX2dyaXAuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9ncmlwLmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fZ3JpcDtcblxuXHR9XG5cblx0ZGlzcGF0Y2hFdmVudCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuX3RhcmdldFJheSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5LmRpc3BhdGNoRXZlbnQoIGV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX2dyaXAgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2dyaXAuZGlzcGF0Y2hFdmVudCggZXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5faGFuZCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5faGFuZC5kaXNwYXRjaEV2ZW50KCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbm5lY3QoIGlucHV0U291cmNlICkge1xuXG5cdFx0aWYgKCBpbnB1dFNvdXJjZSAmJiBpbnB1dFNvdXJjZS5oYW5kICkge1xuXG5cdFx0XHRjb25zdCBoYW5kID0gdGhpcy5faGFuZDtcblxuXHRcdFx0aWYgKCBoYW5kICkge1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IGlucHV0am9pbnQgb2YgaW5wdXRTb3VyY2UuaGFuZC52YWx1ZXMoKSApIHtcblxuXHRcdFx0XHRcdC8vIEluaXRpYWxpemUgaGFuZCB3aXRoIGpvaW50cyB3aGVuIGNvbm5lY3RlZFxuXHRcdFx0XHRcdHRoaXMuX2dldEhhbmRKb2ludCggaGFuZCwgaW5wdXRqb2ludCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdjb25uZWN0ZWQnLCBkYXRhOiBpbnB1dFNvdXJjZSB9ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGlzY29ubmVjdCggaW5wdXRTb3VyY2UgKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc2Nvbm5lY3RlZCcsIGRhdGE6IGlucHV0U291cmNlIH0gKTtcblxuXHRcdGlmICggdGhpcy5fdGFyZ2V0UmF5ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl90YXJnZXRSYXkudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9ncmlwICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9ncmlwLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5faGFuZCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5faGFuZC52aXNpYmxlID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dXBkYXRlKCBpbnB1dFNvdXJjZSwgZnJhbWUsIHJlZmVyZW5jZVNwYWNlICkge1xuXG5cdFx0bGV0IGlucHV0UG9zZSA9IG51bGw7XG5cdFx0bGV0IGdyaXBQb3NlID0gbnVsbDtcblx0XHRsZXQgaGFuZFBvc2UgPSBudWxsO1xuXG5cdFx0Y29uc3QgdGFyZ2V0UmF5ID0gdGhpcy5fdGFyZ2V0UmF5O1xuXHRcdGNvbnN0IGdyaXAgPSB0aGlzLl9ncmlwO1xuXHRcdGNvbnN0IGhhbmQgPSB0aGlzLl9oYW5kO1xuXG5cdFx0aWYgKCBpbnB1dFNvdXJjZSAmJiBmcmFtZS5zZXNzaW9uLnZpc2liaWxpdHlTdGF0ZSAhPT0gJ3Zpc2libGUtYmx1cnJlZCcgKSB7XG5cblx0XHRcdGlmICggaGFuZCAmJiBpbnB1dFNvdXJjZS5oYW5kICkge1xuXG5cdFx0XHRcdGhhbmRQb3NlID0gdHJ1ZTtcblxuXHRcdFx0XHRmb3IgKCBjb25zdCBpbnB1dGpvaW50IG9mIGlucHV0U291cmNlLmhhbmQudmFsdWVzKCkgKSB7XG5cblx0XHRcdFx0XHQvLyBVcGRhdGUgdGhlIGpvaW50cyBncm91cHMgd2l0aCB0aGUgWFJKb2ludCBwb3Nlc1xuXHRcdFx0XHRcdGNvbnN0IGpvaW50UG9zZSA9IGZyYW1lLmdldEpvaW50UG9zZSggaW5wdXRqb2ludCwgcmVmZXJlbmNlU3BhY2UgKTtcblxuXHRcdFx0XHRcdC8vIFRoZSB0cmFuc2Zvcm0gb2YgdGhpcyBqb2ludCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCB0aGUgam9pbnQgcG9zZSBvbiBlYWNoIGZyYW1lXG5cdFx0XHRcdFx0Y29uc3Qgam9pbnQgPSB0aGlzLl9nZXRIYW5kSm9pbnQoIGhhbmQsIGlucHV0am9pbnQgKTtcblxuXHRcdFx0XHRcdGlmICggam9pbnRQb3NlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRqb2ludC5tYXRyaXguZnJvbUFycmF5KCBqb2ludFBvc2UudHJhbnNmb3JtLm1hdHJpeCApO1xuXHRcdFx0XHRcdFx0am9pbnQubWF0cml4LmRlY29tcG9zZSggam9pbnQucG9zaXRpb24sIGpvaW50LnJvdGF0aW9uLCBqb2ludC5zY2FsZSApO1xuXHRcdFx0XHRcdFx0am9pbnQubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRqb2ludC5qb2ludFJhZGl1cyA9IGpvaW50UG9zZS5yYWRpdXM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqb2ludC52aXNpYmxlID0gam9pbnRQb3NlICE9PSBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDdXN0b20gZXZlbnRzXG5cblx0XHRcdFx0Ly8gQ2hlY2sgcGluY2h6XG5cdFx0XHRcdGNvbnN0IGluZGV4VGlwID0gaGFuZC5qb2ludHNbICdpbmRleC1maW5nZXItdGlwJyBdO1xuXHRcdFx0XHRjb25zdCB0aHVtYlRpcCA9IGhhbmQuam9pbnRzWyAndGh1bWItdGlwJyBdO1xuXHRcdFx0XHRjb25zdCBkaXN0YW5jZSA9IGluZGV4VGlwLnBvc2l0aW9uLmRpc3RhbmNlVG8oIHRodW1iVGlwLnBvc2l0aW9uICk7XG5cblx0XHRcdFx0Y29uc3QgZGlzdGFuY2VUb1BpbmNoID0gMC4wMjtcblx0XHRcdFx0Y29uc3QgdGhyZXNob2xkID0gMC4wMDU7XG5cblx0XHRcdFx0aWYgKCBoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgJiYgZGlzdGFuY2UgPiBkaXN0YW5jZVRvUGluY2ggKyB0aHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHRcdHR5cGU6ICdwaW5jaGVuZCcsXG5cdFx0XHRcdFx0XHRoYW5kZWRuZXNzOiBpbnB1dFNvdXJjZS5oYW5kZWRuZXNzLFxuXHRcdFx0XHRcdFx0dGFyZ2V0OiB0aGlzXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoICEgaGFuZC5pbnB1dFN0YXRlLnBpbmNoaW5nICYmIGRpc3RhbmNlIDw9IGRpc3RhbmNlVG9QaW5jaCAtIHRocmVzaG9sZCApIHtcblxuXHRcdFx0XHRcdGhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7XG5cdFx0XHRcdFx0XHR0eXBlOiAncGluY2hzdGFydCcsXG5cdFx0XHRcdFx0XHRoYW5kZWRuZXNzOiBpbnB1dFNvdXJjZS5oYW5kZWRuZXNzLFxuXHRcdFx0XHRcdFx0dGFyZ2V0OiB0aGlzXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGdyaXAgIT09IG51bGwgJiYgaW5wdXRTb3VyY2UuZ3JpcFNwYWNlICkge1xuXG5cdFx0XHRcdFx0Z3JpcFBvc2UgPSBmcmFtZS5nZXRQb3NlKCBpbnB1dFNvdXJjZS5ncmlwU3BhY2UsIHJlZmVyZW5jZVNwYWNlICk7XG5cblx0XHRcdFx0XHRpZiAoIGdyaXBQb3NlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRncmlwLm1hdHJpeC5mcm9tQXJyYXkoIGdyaXBQb3NlLnRyYW5zZm9ybS5tYXRyaXggKTtcblx0XHRcdFx0XHRcdGdyaXAubWF0cml4LmRlY29tcG9zZSggZ3JpcC5wb3NpdGlvbiwgZ3JpcC5yb3RhdGlvbiwgZ3JpcC5zY2FsZSApO1xuXHRcdFx0XHRcdFx0Z3JpcC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBncmlwUG9zZS5saW5lYXJWZWxvY2l0eSApIHtcblxuXHRcdFx0XHRcdFx0XHRncmlwLmhhc0xpbmVhclZlbG9jaXR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0Z3JpcC5saW5lYXJWZWxvY2l0eS5jb3B5KCBncmlwUG9zZS5saW5lYXJWZWxvY2l0eSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGdyaXAuaGFzTGluZWFyVmVsb2NpdHkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGdyaXBQb3NlLmFuZ3VsYXJWZWxvY2l0eSApIHtcblxuXHRcdFx0XHRcdFx0XHRncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGdyaXAuYW5ndWxhclZlbG9jaXR5LmNvcHkoIGdyaXBQb3NlLmFuZ3VsYXJWZWxvY2l0eSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGdyaXAuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0YXJnZXRSYXkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aW5wdXRQb3NlID0gZnJhbWUuZ2V0UG9zZSggaW5wdXRTb3VyY2UudGFyZ2V0UmF5U3BhY2UsIHJlZmVyZW5jZVNwYWNlICk7XG5cblx0XHRcdFx0Ly8gU29tZSBydW50aW1lcyAobmFtZWx5IFZpdmUgQ29zbW9zIHdpdGggVml2ZSBPcGVuWFIgUnVudGltZSkgaGF2ZSBvbmx5IGdyaXAgc3BhY2UgYW5kIHJheSBzcGFjZSBpcyBlcXVhbCB0byBpdFxuXHRcdFx0XHRpZiAoIGlucHV0UG9zZSA9PT0gbnVsbCAmJiBncmlwUG9zZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGlucHV0UG9zZSA9IGdyaXBQb3NlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGlucHV0UG9zZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHRhcmdldFJheS5tYXRyaXguZnJvbUFycmF5KCBpbnB1dFBvc2UudHJhbnNmb3JtLm1hdHJpeCApO1xuXHRcdFx0XHRcdHRhcmdldFJheS5tYXRyaXguZGVjb21wb3NlKCB0YXJnZXRSYXkucG9zaXRpb24sIHRhcmdldFJheS5yb3RhdGlvbiwgdGFyZ2V0UmF5LnNjYWxlICk7XG5cdFx0XHRcdFx0dGFyZ2V0UmF5Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnB1dFBvc2UubGluZWFyVmVsb2NpdHkgKSB7XG5cblx0XHRcdFx0XHRcdHRhcmdldFJheS5oYXNMaW5lYXJWZWxvY2l0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkubGluZWFyVmVsb2NpdHkuY29weSggaW5wdXRQb3NlLmxpbmVhclZlbG9jaXR5ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzTGluZWFyVmVsb2NpdHkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaW5wdXRQb3NlLmFuZ3VsYXJWZWxvY2l0eSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0UmF5Lmhhc0FuZ3VsYXJWZWxvY2l0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkuYW5ndWxhclZlbG9jaXR5LmNvcHkoIGlucHV0UG9zZS5hbmd1bGFyVmVsb2NpdHkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRhcmdldFJheS5oYXNBbmd1bGFyVmVsb2NpdHkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggX21vdmVFdmVudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cblx0XHR9XG5cblx0XHRpZiAoIHRhcmdldFJheSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGFyZ2V0UmF5LnZpc2libGUgPSAoIGlucHV0UG9zZSAhPT0gbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBncmlwICE9PSBudWxsICkge1xuXG5cdFx0XHRncmlwLnZpc2libGUgPSAoIGdyaXBQb3NlICE9PSBudWxsICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGhhbmQgIT09IG51bGwgKSB7XG5cblx0XHRcdGhhbmQudmlzaWJsZSA9ICggaGFuZFBvc2UgIT09IG51bGwgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvLyBwcml2YXRlIG1ldGhvZFxuXG5cdF9nZXRIYW5kSm9pbnQoIGhhbmQsIGlucHV0am9pbnQgKSB7XG5cblx0XHRpZiAoIGhhbmQuam9pbnRzWyBpbnB1dGpvaW50LmpvaW50TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGpvaW50ID0gbmV3IEdyb3VwKCk7XG5cdFx0XHRqb2ludC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRqb2ludC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRoYW5kLmpvaW50c1sgaW5wdXRqb2ludC5qb2ludE5hbWUgXSA9IGpvaW50O1xuXG5cdFx0XHRoYW5kLmFkZCggam9pbnQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kLmpvaW50c1sgaW5wdXRqb2ludC5qb2ludE5hbWUgXTtcblxuXHR9XG5cbn1cblxuY29uc3QgX29jY2x1c2lvbl92ZXJ0ZXggPSBgXG52b2lkIG1haW4oKSB7XG5cblx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG5cbn1gO1xuXG5jb25zdCBfb2NjbHVzaW9uX2ZyYWdtZW50ID0gYFxudW5pZm9ybSBzYW1wbGVyMkRBcnJheSBkZXB0aENvbG9yO1xudW5pZm9ybSBmbG9hdCBkZXB0aFdpZHRoO1xudW5pZm9ybSBmbG9hdCBkZXB0aEhlaWdodDtcblxudm9pZCBtYWluKCkge1xuXG5cdHZlYzIgY29vcmQgPSB2ZWMyKCBnbF9GcmFnQ29vcmQueCAvIGRlcHRoV2lkdGgsIGdsX0ZyYWdDb29yZC55IC8gZGVwdGhIZWlnaHQgKTtcblxuXHRpZiAoIGNvb3JkLnggPj0gMS4wICkge1xuXG5cdFx0Z2xfRnJhZ0RlcHRoID0gdGV4dHVyZSggZGVwdGhDb2xvciwgdmVjMyggY29vcmQueCAtIDEuMCwgY29vcmQueSwgMSApICkucjtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Z2xfRnJhZ0RlcHRoID0gdGV4dHVyZSggZGVwdGhDb2xvciwgdmVjMyggY29vcmQueCwgY29vcmQueSwgMCApICkucjtcblxuXHR9XG5cbn1gO1xuXG5jbGFzcyBXZWJYUkRlcHRoU2Vuc2luZyB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLnRleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMubWVzaCA9IG51bGw7XG5cblx0XHR0aGlzLmRlcHRoTmVhciA9IDA7XG5cdFx0dGhpcy5kZXB0aEZhciA9IDA7XG5cblx0fVxuXG5cdGluaXQoIHJlbmRlcmVyLCBkZXB0aERhdGEsIHJlbmRlclN0YXRlICkge1xuXG5cdFx0aWYgKCB0aGlzLnRleHR1cmUgPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXG5cdFx0XHRjb25zdCB0ZXhQcm9wcyA9IHJlbmRlcmVyLnByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cdFx0XHR0ZXhQcm9wcy5fX3dlYmdsVGV4dHVyZSA9IGRlcHRoRGF0YS50ZXh0dXJlO1xuXG5cdFx0XHRpZiAoICggZGVwdGhEYXRhLmRlcHRoTmVhciAhPSByZW5kZXJTdGF0ZS5kZXB0aE5lYXIgKSB8fCAoIGRlcHRoRGF0YS5kZXB0aEZhciAhPSByZW5kZXJTdGF0ZS5kZXB0aEZhciApICkge1xuXG5cdFx0XHRcdHRoaXMuZGVwdGhOZWFyID0gZGVwdGhEYXRhLmRlcHRoTmVhcjtcblx0XHRcdFx0dGhpcy5kZXB0aEZhciA9IGRlcHRoRGF0YS5kZXB0aEZhcjtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRnZXRNZXNoKCBjYW1lcmFYUiApIHtcblxuXHRcdGlmICggdGhpcy50ZXh0dXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIHRoaXMubWVzaCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zdCB2aWV3cG9ydCA9IGNhbWVyYVhSLmNhbWVyYXNbIDAgXS52aWV3cG9ydDtcblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IF9vY2NsdXNpb25fdmVydGV4LFxuXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBfb2NjbHVzaW9uX2ZyYWdtZW50LFxuXHRcdFx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdFx0XHRkZXB0aENvbG9yOiB7IHZhbHVlOiB0aGlzLnRleHR1cmUgfSxcblx0XHRcdFx0XHRcdGRlcHRoV2lkdGg6IHsgdmFsdWU6IHZpZXdwb3J0LnogfSxcblx0XHRcdFx0XHRcdGRlcHRoSGVpZ2h0OiB7IHZhbHVlOiB2aWV3cG9ydC53IH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR0aGlzLm1lc2ggPSBuZXcgTWVzaCggbmV3IFBsYW5lR2VvbWV0cnkoIDIwLCAyMCApLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tZXNoO1xuXG5cdH1cblxuXHRyZXNldCgpIHtcblxuXHRcdHRoaXMudGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy5tZXNoID0gbnVsbDtcblxuXHR9XG5cbn1cblxuY2xhc3MgV2ViWFJNYW5hZ2VyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcmVuZGVyZXIsIGdsICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGxldCBzZXNzaW9uID0gbnVsbDtcblxuXHRcdGxldCBmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yID0gMS4wO1xuXG5cdFx0bGV0IHJlZmVyZW5jZVNwYWNlID0gbnVsbDtcblx0XHRsZXQgcmVmZXJlbmNlU3BhY2VUeXBlID0gJ2xvY2FsLWZsb29yJztcblx0XHQvLyBTZXQgZGVmYXVsdCBmb3ZlYXRpb24gdG8gbWF4aW11bS5cblx0XHRsZXQgZm92ZWF0aW9uID0gMS4wO1xuXHRcdGxldCBjdXN0b21SZWZlcmVuY2VTcGFjZSA9IG51bGw7XG5cblx0XHRsZXQgcG9zZSA9IG51bGw7XG5cdFx0bGV0IGdsQmluZGluZyA9IG51bGw7XG5cdFx0bGV0IGdsUHJvakxheWVyID0gbnVsbDtcblx0XHRsZXQgZ2xCYXNlTGF5ZXIgPSBudWxsO1xuXHRcdGxldCB4ckZyYW1lID0gbnVsbDtcblxuXHRcdGNvbnN0IGRlcHRoU2Vuc2luZyA9IG5ldyBXZWJYUkRlcHRoU2Vuc2luZygpO1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuXG5cdFx0bGV0IGluaXRpYWxSZW5kZXJUYXJnZXQgPSBudWxsO1xuXHRcdGxldCBuZXdSZW5kZXJUYXJnZXQgPSBudWxsO1xuXG5cdFx0Y29uc3QgY29udHJvbGxlcnMgPSBbXTtcblx0XHRjb25zdCBjb250cm9sbGVySW5wdXRTb3VyY2VzID0gW107XG5cblx0XHRjb25zdCBjdXJyZW50U2l6ZSA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0bGV0IGN1cnJlbnRQaXhlbFJhdGlvID0gbnVsbDtcblxuXHRcdC8vXG5cblx0XHRjb25zdCBjYW1lcmFMID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0Y2FtZXJhTC5sYXllcnMuZW5hYmxlKCAxICk7XG5cdFx0Y2FtZXJhTC52aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCk7XG5cblx0XHRjb25zdCBjYW1lcmFSID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0Y2FtZXJhUi5sYXllcnMuZW5hYmxlKCAyICk7XG5cdFx0Y2FtZXJhUi52aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCk7XG5cblx0XHRjb25zdCBjYW1lcmFzID0gWyBjYW1lcmFMLCBjYW1lcmFSIF07XG5cblx0XHRjb25zdCBjYW1lcmFYUiA9IG5ldyBBcnJheUNhbWVyYSgpO1xuXHRcdGNhbWVyYVhSLmxheWVycy5lbmFibGUoIDEgKTtcblx0XHRjYW1lcmFYUi5sYXllcnMuZW5hYmxlKCAyICk7XG5cblx0XHRsZXQgX2N1cnJlbnREZXB0aE5lYXIgPSBudWxsO1xuXHRcdGxldCBfY3VycmVudERlcHRoRmFyID0gbnVsbDtcblxuXHRcdC8vXG5cblx0XHR0aGlzLmNhbWVyYUF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5pc1ByZXNlbnRpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdGxldCBjb250cm9sbGVyID0gY29udHJvbGxlcnNbIGluZGV4IF07XG5cblx0XHRcdGlmICggY29udHJvbGxlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnRyb2xsZXIgPSBuZXcgV2ViWFJDb250cm9sbGVyKCk7XG5cdFx0XHRcdGNvbnRyb2xsZXJzWyBpbmRleCBdID0gY29udHJvbGxlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29udHJvbGxlci5nZXRUYXJnZXRSYXlTcGFjZSgpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Q29udHJvbGxlckdyaXAgPSBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRsZXQgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBpbmRleCBdO1xuXG5cdFx0XHRpZiAoIGNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb250cm9sbGVyID0gbmV3IFdlYlhSQ29udHJvbGxlcigpO1xuXHRcdFx0XHRjb250cm9sbGVyc1sgaW5kZXggXSA9IGNvbnRyb2xsZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvbnRyb2xsZXIuZ2V0R3JpcFNwYWNlKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRIYW5kID0gZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0bGV0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgaW5kZXggXTtcblxuXHRcdFx0aWYgKCBjb250cm9sbGVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcblx0XHRcdFx0Y29udHJvbGxlcnNbIGluZGV4IF0gPSBjb250cm9sbGVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb250cm9sbGVyLmdldEhhbmRTcGFjZSgpO1xuXG5cdFx0fTtcblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBvblNlc3Npb25FdmVudCggZXZlbnQgKSB7XG5cblx0XHRcdGNvbnN0IGNvbnRyb2xsZXJJbmRleCA9IGNvbnRyb2xsZXJJbnB1dFNvdXJjZXMuaW5kZXhPZiggZXZlbnQuaW5wdXRTb3VyY2UgKTtcblxuXHRcdFx0aWYgKCBjb250cm9sbGVySW5kZXggPT09IC0gMSApIHtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBjb250cm9sbGVySW5kZXggXTtcblxuXHRcdFx0aWYgKCBjb250cm9sbGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29udHJvbGxlci51cGRhdGUoIGV2ZW50LmlucHV0U291cmNlLCBldmVudC5mcmFtZSwgY3VzdG9tUmVmZXJlbmNlU3BhY2UgfHwgcmVmZXJlbmNlU3BhY2UgKTtcblx0XHRcdFx0Y29udHJvbGxlci5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6IGV2ZW50LnR5cGUsIGRhdGE6IGV2ZW50LmlucHV0U291cmNlIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25TZXNzaW9uRW5kKCkge1xuXG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzZWxlY3QnLCBvblNlc3Npb25FdmVudCApO1xuXHRcdFx0c2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCAnc2VsZWN0c3RhcnQnLCBvblNlc3Npb25FdmVudCApO1xuXHRcdFx0c2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCAnc2VsZWN0ZW5kJywgb25TZXNzaW9uRXZlbnQgKTtcblx0XHRcdHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3NxdWVlemUnLCBvblNlc3Npb25FdmVudCApO1xuXHRcdFx0c2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCAnc3F1ZWV6ZXN0YXJ0Jywgb25TZXNzaW9uRXZlbnQgKTtcblx0XHRcdHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3NxdWVlemVlbmQnLCBvblNlc3Npb25FdmVudCApO1xuXHRcdFx0c2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCAnZW5kJywgb25TZXNzaW9uRW5kICk7XG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdpbnB1dHNvdXJjZXNjaGFuZ2UnLCBvbklucHV0U291cmNlc0NoYW5nZSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb250cm9sbGVycy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5wdXRTb3VyY2UgPSBjb250cm9sbGVySW5wdXRTb3VyY2VzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBpbnB1dFNvdXJjZSA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbIGkgXSA9IG51bGw7XG5cblx0XHRcdFx0Y29udHJvbGxlcnNbIGkgXS5kaXNjb25uZWN0KCBpbnB1dFNvdXJjZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9jdXJyZW50RGVwdGhOZWFyID0gbnVsbDtcblx0XHRcdF9jdXJyZW50RGVwdGhGYXIgPSBudWxsO1xuXG5cdFx0XHRkZXB0aFNlbnNpbmcucmVzZXQoKTtcblxuXHRcdFx0Ly8gcmVzdG9yZSBmcmFtZWJ1ZmZlci9yZW5kZXJpbmcgc3RhdGVcblxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBpbml0aWFsUmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdGdsQmFzZUxheWVyID0gbnVsbDtcblx0XHRcdGdsUHJvakxheWVyID0gbnVsbDtcblx0XHRcdGdsQmluZGluZyA9IG51bGw7XG5cdFx0XHRzZXNzaW9uID0gbnVsbDtcblx0XHRcdG5ld1JlbmRlclRhcmdldCA9IG51bGw7XG5cblx0XHRcdC8vXG5cblx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cblx0XHRcdHNjb3BlLmlzUHJlc2VudGluZyA9IGZhbHNlO1xuXG5cdFx0XHRyZW5kZXJlci5zZXRQaXhlbFJhdGlvKCBjdXJyZW50UGl4ZWxSYXRpbyApO1xuXHRcdFx0cmVuZGVyZXIuc2V0U2l6ZSggY3VycmVudFNpemUud2lkdGgsIGN1cnJlbnRTaXplLmhlaWdodCwgZmFsc2UgKTtcblxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnc2Vzc2lvbmVuZCcgfSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRGcmFtZWJ1ZmZlclNjYWxlRmFjdG9yID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0ZnJhbWVidWZmZXJTY2FsZUZhY3RvciA9IHZhbHVlO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmlzUHJlc2VudGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJYUk1hbmFnZXI6IENhbm5vdCBjaGFuZ2UgZnJhbWVidWZmZXIgc2NhbGUgd2hpbGUgcHJlc2VudGluZy4nICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFJlZmVyZW5jZVNwYWNlVHlwZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHJlZmVyZW5jZVNwYWNlVHlwZSA9IHZhbHVlO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmlzUHJlc2VudGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJYUk1hbmFnZXI6IENhbm5vdCBjaGFuZ2UgcmVmZXJlbmNlIHNwYWNlIHR5cGUgd2hpbGUgcHJlc2VudGluZy4nICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLmdldFJlZmVyZW5jZVNwYWNlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gY3VzdG9tUmVmZXJlbmNlU3BhY2UgfHwgcmVmZXJlbmNlU3BhY2U7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRSZWZlcmVuY2VTcGFjZSA9IGZ1bmN0aW9uICggc3BhY2UgKSB7XG5cblx0XHRcdGN1c3RvbVJlZmVyZW5jZVNwYWNlID0gc3BhY2U7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRCYXNlTGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBnbFByb2pMYXllciAhPT0gbnVsbCA/IGdsUHJvakxheWVyIDogZ2xCYXNlTGF5ZXI7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRCaW5kaW5nID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gZ2xCaW5kaW5nO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB4ckZyYW1lO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHNlc3Npb247XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRTZXNzaW9uID0gYXN5bmMgZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0c2Vzc2lvbiA9IHZhbHVlO1xuXG5cdFx0XHRpZiAoIHNlc3Npb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aW5pdGlhbFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG5cdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lciggJ3NlbGVjdCcsIG9uU2Vzc2lvbkV2ZW50ICk7XG5cdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lciggJ3NlbGVjdHN0YXJ0Jywgb25TZXNzaW9uRXZlbnQgKTtcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCAnc2VsZWN0ZW5kJywgb25TZXNzaW9uRXZlbnQgKTtcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCAnc3F1ZWV6ZScsIG9uU2Vzc2lvbkV2ZW50ICk7XG5cdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lciggJ3NxdWVlemVzdGFydCcsIG9uU2Vzc2lvbkV2ZW50ICk7XG5cdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lciggJ3NxdWVlemVlbmQnLCBvblNlc3Npb25FdmVudCApO1xuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoICdlbmQnLCBvblNlc3Npb25FbmQgKTtcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXRzb3VyY2VzY2hhbmdlJywgb25JbnB1dFNvdXJjZXNDaGFuZ2UgKTtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMueHJDb21wYXRpYmxlICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0YXdhaXQgZ2wubWFrZVhSQ29tcGF0aWJsZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXJyZW50UGl4ZWxSYXRpbyA9IHJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKTtcblx0XHRcdFx0cmVuZGVyZXIuZ2V0U2l6ZSggY3VycmVudFNpemUgKTtcblxuXHRcdFx0XHRpZiAoIHNlc3Npb24ucmVuZGVyU3RhdGUubGF5ZXJzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBsYXllckluaXQgPSB7XG5cdFx0XHRcdFx0XHRhbnRpYWxpYXM6IGF0dHJpYnV0ZXMuYW50aWFsaWFzLFxuXHRcdFx0XHRcdFx0YWxwaGE6IHRydWUsXG5cdFx0XHRcdFx0XHRkZXB0aDogYXR0cmlidXRlcy5kZXB0aCxcblx0XHRcdFx0XHRcdHN0ZW5jaWw6IGF0dHJpYnV0ZXMuc3RlbmNpbCxcblx0XHRcdFx0XHRcdGZyYW1lYnVmZmVyU2NhbGVGYWN0b3I6IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3Jcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Z2xCYXNlTGF5ZXIgPSBuZXcgWFJXZWJHTExheWVyKCBzZXNzaW9uLCBnbCwgbGF5ZXJJbml0ICk7XG5cblx0XHRcdFx0XHRzZXNzaW9uLnVwZGF0ZVJlbmRlclN0YXRlKCB7IGJhc2VMYXllcjogZ2xCYXNlTGF5ZXIgfSApO1xuXG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyggMSApO1xuXHRcdFx0XHRcdHJlbmRlcmVyLnNldFNpemUoIGdsQmFzZUxheWVyLmZyYW1lYnVmZmVyV2lkdGgsIGdsQmFzZUxheWVyLmZyYW1lYnVmZmVySGVpZ2h0LCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0bmV3UmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KFxuXHRcdFx0XHRcdFx0Z2xCYXNlTGF5ZXIuZnJhbWVidWZmZXJXaWR0aCxcblx0XHRcdFx0XHRcdGdsQmFzZUxheWVyLmZyYW1lYnVmZmVySGVpZ2h0LFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRmb3JtYXQ6IFJHQkFGb3JtYXQsXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFVuc2lnbmVkQnl0ZVR5cGUsXG5cdFx0XHRcdFx0XHRcdGNvbG9yU3BhY2U6IHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UsXG5cdFx0XHRcdFx0XHRcdHN0ZW5jaWxCdWZmZXI6IGF0dHJpYnV0ZXMuc3RlbmNpbFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGxldCBkZXB0aEZvcm1hdCA9IG51bGw7XG5cdFx0XHRcdFx0bGV0IGRlcHRoVHlwZSA9IG51bGw7XG5cdFx0XHRcdFx0bGV0IGdsRGVwdGhGb3JtYXQgPSBudWxsO1xuXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmRlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRnbERlcHRoRm9ybWF0ID0gYXR0cmlidXRlcy5zdGVuY2lsID8gZ2wuREVQVEgyNF9TVEVOQ0lMOCA6IGdsLkRFUFRIX0NPTVBPTkVOVDI0O1xuXHRcdFx0XHRcdFx0ZGVwdGhGb3JtYXQgPSBhdHRyaWJ1dGVzLnN0ZW5jaWwgPyBEZXB0aFN0ZW5jaWxGb3JtYXQgOiBEZXB0aEZvcm1hdDtcblx0XHRcdFx0XHRcdGRlcHRoVHlwZSA9IGF0dHJpYnV0ZXMuc3RlbmNpbCA/IFVuc2lnbmVkSW50MjQ4VHlwZSA6IFVuc2lnbmVkSW50VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHByb2plY3Rpb25sYXllckluaXQgPSB7XG5cdFx0XHRcdFx0XHRjb2xvckZvcm1hdDogZ2wuUkdCQTgsXG5cdFx0XHRcdFx0XHRkZXB0aEZvcm1hdDogZ2xEZXB0aEZvcm1hdCxcblx0XHRcdFx0XHRcdHNjYWxlRmFjdG9yOiBmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGdsQmluZGluZyA9IG5ldyBYUldlYkdMQmluZGluZyggc2Vzc2lvbiwgZ2wgKTtcblxuXHRcdFx0XHRcdGdsUHJvakxheWVyID0gZ2xCaW5kaW5nLmNyZWF0ZVByb2plY3Rpb25MYXllciggcHJvamVjdGlvbmxheWVySW5pdCApO1xuXG5cdFx0XHRcdFx0c2Vzc2lvbi51cGRhdGVSZW5kZXJTdGF0ZSggeyBsYXllcnM6IFsgZ2xQcm9qTGF5ZXIgXSB9ICk7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5zZXRQaXhlbFJhdGlvKCAxICk7XG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0U2l6ZSggZ2xQcm9qTGF5ZXIudGV4dHVyZVdpZHRoLCBnbFByb2pMYXllci50ZXh0dXJlSGVpZ2h0LCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0bmV3UmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KFxuXHRcdFx0XHRcdFx0Z2xQcm9qTGF5ZXIudGV4dHVyZVdpZHRoLFxuXHRcdFx0XHRcdFx0Z2xQcm9qTGF5ZXIudGV4dHVyZUhlaWdodCxcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Zm9ybWF0OiBSR0JBRm9ybWF0LFxuXHRcdFx0XHRcdFx0XHR0eXBlOiBVbnNpZ25lZEJ5dGVUeXBlLFxuXHRcdFx0XHRcdFx0XHRkZXB0aFRleHR1cmU6IG5ldyBEZXB0aFRleHR1cmUoIGdsUHJvakxheWVyLnRleHR1cmVXaWR0aCwgZ2xQcm9qTGF5ZXIudGV4dHVyZUhlaWdodCwgZGVwdGhUeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZXB0aEZvcm1hdCApLFxuXHRcdFx0XHRcdFx0XHRzdGVuY2lsQnVmZmVyOiBhdHRyaWJ1dGVzLnN0ZW5jaWwsXG5cdFx0XHRcdFx0XHRcdGNvbG9yU3BhY2U6IHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UsXG5cdFx0XHRcdFx0XHRcdHNhbXBsZXM6IGF0dHJpYnV0ZXMuYW50aWFsaWFzID8gNCA6IDAsXG5cdFx0XHRcdFx0XHRcdHJlc29sdmVEZXB0aEJ1ZmZlcjogKCBnbFByb2pMYXllci5pZ25vcmVEZXB0aFZhbHVlcyA9PT0gZmFsc2UgKVxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuZXdSZW5kZXJUYXJnZXQuaXNYUlJlbmRlclRhcmdldCA9IHRydWU7IC8vIFRPRE8gUmVtb3ZlIHRoaXMgd2hlbiBwb3NzaWJsZSwgc2VlICMyMzI3OFxuXG5cdFx0XHRcdHRoaXMuc2V0Rm92ZWF0aW9uKCBmb3ZlYXRpb24gKTtcblxuXHRcdFx0XHRjdXN0b21SZWZlcmVuY2VTcGFjZSA9IG51bGw7XG5cdFx0XHRcdHJlZmVyZW5jZVNwYWNlID0gYXdhaXQgc2Vzc2lvbi5yZXF1ZXN0UmVmZXJlbmNlU3BhY2UoIHJlZmVyZW5jZVNwYWNlVHlwZSApO1xuXG5cdFx0XHRcdGFuaW1hdGlvbi5zZXRDb250ZXh0KCBzZXNzaW9uICk7XG5cdFx0XHRcdGFuaW1hdGlvbi5zdGFydCgpO1xuXG5cdFx0XHRcdHNjb3BlLmlzUHJlc2VudGluZyA9IHRydWU7XG5cblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnc2Vzc2lvbnN0YXJ0JyB9ICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEVudmlyb25tZW50QmxlbmRNb2RlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIHNlc3Npb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHNlc3Npb24uZW52aXJvbm1lbnRCbGVuZE1vZGU7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBvbklucHV0U291cmNlc0NoYW5nZSggZXZlbnQgKSB7XG5cblx0XHRcdC8vIE5vdGlmeSBkaXNjb25uZWN0ZWRcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZXZlbnQucmVtb3ZlZC5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5wdXRTb3VyY2UgPSBldmVudC5yZW1vdmVkWyBpIF07XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gY29udHJvbGxlcklucHV0U291cmNlcy5pbmRleE9mKCBpbnB1dFNvdXJjZSApO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPj0gMCApIHtcblxuXHRcdFx0XHRcdGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbIGluZGV4IF0gPSBudWxsO1xuXHRcdFx0XHRcdGNvbnRyb2xsZXJzWyBpbmRleCBdLmRpc2Nvbm5lY3QoIGlucHV0U291cmNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vdGlmeSBjb25uZWN0ZWRcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZXZlbnQuYWRkZWQubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGlucHV0U291cmNlID0gZXZlbnQuYWRkZWRbIGkgXTtcblxuXHRcdFx0XHRsZXQgY29udHJvbGxlckluZGV4ID0gY29udHJvbGxlcklucHV0U291cmNlcy5pbmRleE9mKCBpbnB1dFNvdXJjZSApO1xuXG5cdFx0XHRcdGlmICggY29udHJvbGxlckluZGV4ID09PSAtIDEgKSB7XG5cblx0XHRcdFx0XHQvLyBBc3NpZ24gaW5wdXQgc291cmNlIGEgY29udHJvbGxlciB0aGF0IGN1cnJlbnRseSBoYXMgbm8gaW5wdXQgc291cmNlXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb250cm9sbGVycy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggaSA+PSBjb250cm9sbGVySW5wdXRTb3VyY2VzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb250cm9sbGVySW5wdXRTb3VyY2VzLnB1c2goIGlucHV0U291cmNlICk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXJJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb250cm9sbGVySW5wdXRTb3VyY2VzWyBpIF0gPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29udHJvbGxlcklucHV0U291cmNlc1sgaSBdID0gaW5wdXRTb3VyY2U7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXJJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBJZiBhbGwgY29udHJvbGxlcnMgZG8gY3VycmVudGx5IHJlY2VpdmUgaW5wdXQgd2UgaWdub3JlIG5ldyBvbmVzXG5cblx0XHRcdFx0XHRpZiAoIGNvbnRyb2xsZXJJbmRleCA9PT0gLSAxICkgYnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgY29udHJvbGxlckluZGV4IF07XG5cblx0XHRcdFx0aWYgKCBjb250cm9sbGVyICkge1xuXG5cdFx0XHRcdFx0Y29udHJvbGxlci5jb25uZWN0KCBpbnB1dFNvdXJjZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGNhbWVyYUxQb3MgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IGNhbWVyYVJQb3MgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0LyoqXG5cdFx0ICogQXNzdW1lcyAyIGNhbWVyYXMgdGhhdCBhcmUgcGFyYWxsZWwgYW5kIHNoYXJlIGFuIFgtYXhpcywgYW5kIHRoYXRcblx0XHQgKiB0aGUgY2FtZXJhcycgcHJvamVjdGlvbiBhbmQgd29ybGQgbWF0cmljZXMgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0LlxuXHRcdCAqIEFuZCB0aGF0IG5lYXIgYW5kIGZhciBwbGFuZXMgYXJlIGlkZW50aWNhbCBmb3IgYm90aCBjYW1lcmFzLlxuXHRcdCAqIFZpc3VhbGl6YXRpb24gb2YgdGhpcyB0ZWNobmlxdWU6IGh0dHBzOi8vY29tcHV0ZXJncmFwaGljcy5zdGFja2V4Y2hhbmdlLmNvbS9hLzQ3NjVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzZXRQcm9qZWN0aW9uRnJvbVVuaW9uKCBjYW1lcmEsIGNhbWVyYUwsIGNhbWVyYVIgKSB7XG5cblx0XHRcdGNhbWVyYUxQb3Muc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmFMLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRjYW1lcmFSUG9zLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhUi5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRjb25zdCBpcGQgPSBjYW1lcmFMUG9zLmRpc3RhbmNlVG8oIGNhbWVyYVJQb3MgKTtcblxuXHRcdFx0Y29uc3QgcHJvakwgPSBjYW1lcmFMLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XG5cdFx0XHRjb25zdCBwcm9qUiA9IGNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cztcblxuXHRcdFx0Ly8gVlIgc3lzdGVtcyB3aWxsIGhhdmUgaWRlbnRpY2FsIGZhciBhbmQgbmVhciBwbGFuZXMsIGFuZFxuXHRcdFx0Ly8gbW9zdCBsaWtlbHkgaWRlbnRpY2FsIHRvcCBhbmQgYm90dG9tIGZydXN0dW0gZXh0ZW50cy5cblx0XHRcdC8vIFVzZSB0aGUgbGVmdCBjYW1lcmEgZm9yIHRoZXNlIHZhbHVlcy5cblx0XHRcdGNvbnN0IG5lYXIgPSBwcm9qTFsgMTQgXSAvICggcHJvakxbIDEwIF0gLSAxICk7XG5cdFx0XHRjb25zdCBmYXIgPSBwcm9qTFsgMTQgXSAvICggcHJvakxbIDEwIF0gKyAxICk7XG5cdFx0XHRjb25zdCB0b3BGb3YgPSAoIHByb2pMWyA5IF0gKyAxICkgLyBwcm9qTFsgNSBdO1xuXHRcdFx0Y29uc3QgYm90dG9tRm92ID0gKCBwcm9qTFsgOSBdIC0gMSApIC8gcHJvakxbIDUgXTtcblxuXHRcdFx0Y29uc3QgbGVmdEZvdiA9ICggcHJvakxbIDggXSAtIDEgKSAvIHByb2pMWyAwIF07XG5cdFx0XHRjb25zdCByaWdodEZvdiA9ICggcHJvalJbIDggXSArIDEgKSAvIHByb2pSWyAwIF07XG5cdFx0XHRjb25zdCBsZWZ0ID0gbmVhciAqIGxlZnRGb3Y7XG5cdFx0XHRjb25zdCByaWdodCA9IG5lYXIgKiByaWdodEZvdjtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBuZXcgY2FtZXJhJ3MgcG9zaXRpb24gb2Zmc2V0IGZyb20gdGhlXG5cdFx0XHQvLyBsZWZ0IGNhbWVyYS4geE9mZnNldCBzaG91bGQgYmUgcm91Z2hseSBoYWxmIGBpcGRgLlxuXHRcdFx0Y29uc3Qgek9mZnNldCA9IGlwZCAvICggLSBsZWZ0Rm92ICsgcmlnaHRGb3YgKTtcblx0XHRcdGNvbnN0IHhPZmZzZXQgPSB6T2Zmc2V0ICogLSBsZWZ0Rm92O1xuXG5cdFx0XHQvLyBUT0RPOiBCZXR0ZXIgd2F5IHRvIGFwcGx5IHRoaXMgb2Zmc2V0P1xuXHRcdFx0Y2FtZXJhTC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIGNhbWVyYS5wb3NpdGlvbiwgY2FtZXJhLnF1YXRlcm5pb24sIGNhbWVyYS5zY2FsZSApO1xuXHRcdFx0Y2FtZXJhLnRyYW5zbGF0ZVgoIHhPZmZzZXQgKTtcblx0XHRcdGNhbWVyYS50cmFuc2xhdGVaKCB6T2Zmc2V0ICk7XG5cdFx0XHRjYW1lcmEubWF0cml4V29ybGQuY29tcG9zZSggY2FtZXJhLnBvc2l0aW9uLCBjYW1lcmEucXVhdGVybmlvbiwgY2FtZXJhLnNjYWxlICk7XG5cdFx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXG5cdFx0XHQvLyBGaW5kIHRoZSB1bmlvbiBvZiB0aGUgZnJ1c3R1bSB2YWx1ZXMgb2YgdGhlIGNhbWVyYXMgYW5kIHNjYWxlXG5cdFx0XHQvLyB0aGUgdmFsdWVzIHNvIHRoYXQgdGhlIG5lYXIgcGxhbmUncyBwb3NpdGlvbiBkb2VzIG5vdCBjaGFuZ2UgaW4gd29ybGQgc3BhY2UsXG5cdFx0XHQvLyBhbHRob3VnaCBtdXN0IG5vdyBiZSByZWxhdGl2ZSB0byB0aGUgbmV3IHVuaW9uIGNhbWVyYS5cblx0XHRcdGNvbnN0IG5lYXIyID0gbmVhciArIHpPZmZzZXQ7XG5cdFx0XHRjb25zdCBmYXIyID0gZmFyICsgek9mZnNldDtcblx0XHRcdGNvbnN0IGxlZnQyID0gbGVmdCAtIHhPZmZzZXQ7XG5cdFx0XHRjb25zdCByaWdodDIgPSByaWdodCArICggaXBkIC0geE9mZnNldCApO1xuXHRcdFx0Y29uc3QgdG9wMiA9IHRvcEZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcblx0XHRcdGNvbnN0IGJvdHRvbTIgPSBib3R0b21Gb3YgKiBmYXIgLyBmYXIyICogbmVhcjI7XG5cblx0XHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSggbGVmdDIsIHJpZ2h0MiwgdG9wMiwgYm90dG9tMiwgbmVhcjIsIGZhcjIgKTtcblx0XHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApLmludmVydCgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKCBjYW1lcmEsIHBhcmVudCApIHtcblxuXHRcdFx0aWYgKCBwYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggcGFyZW50Lm1hdHJpeFdvcmxkLCBjYW1lcmEubWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlQ2FtZXJhID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0XHRcdGlmICggc2Vzc2lvbiA9PT0gbnVsbCApIHJldHVybjtcblxuXHRcdFx0aWYgKCBkZXB0aFNlbnNpbmcudGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRjYW1lcmEubmVhciA9IGRlcHRoU2Vuc2luZy5kZXB0aE5lYXI7XG5cdFx0XHRcdGNhbWVyYS5mYXIgPSBkZXB0aFNlbnNpbmcuZGVwdGhGYXI7XG5cblx0XHRcdH1cblxuXHRcdFx0Y2FtZXJhWFIubmVhciA9IGNhbWVyYVIubmVhciA9IGNhbWVyYUwubmVhciA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0Y2FtZXJhWFIuZmFyID0gY2FtZXJhUi5mYXIgPSBjYW1lcmFMLmZhciA9IGNhbWVyYS5mYXI7XG5cblx0XHRcdGlmICggX2N1cnJlbnREZXB0aE5lYXIgIT09IGNhbWVyYVhSLm5lYXIgfHwgX2N1cnJlbnREZXB0aEZhciAhPT0gY2FtZXJhWFIuZmFyICkge1xuXG5cdFx0XHRcdC8vIE5vdGUgdGhhdCB0aGUgbmV3IHJlbmRlclN0YXRlIHdvbid0IGFwcGx5IHVudGlsIHRoZSBuZXh0IGZyYW1lLiBTZWUgIzE4MzIwXG5cblx0XHRcdFx0c2Vzc2lvbi51cGRhdGVSZW5kZXJTdGF0ZSgge1xuXHRcdFx0XHRcdGRlcHRoTmVhcjogY2FtZXJhWFIubmVhcixcblx0XHRcdFx0XHRkZXB0aEZhcjogY2FtZXJhWFIuZmFyXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRfY3VycmVudERlcHRoTmVhciA9IGNhbWVyYVhSLm5lYXI7XG5cdFx0XHRcdF9jdXJyZW50RGVwdGhGYXIgPSBjYW1lcmFYUi5mYXI7XG5cblx0XHRcdFx0Y2FtZXJhTC5uZWFyID0gX2N1cnJlbnREZXB0aE5lYXI7XG5cdFx0XHRcdGNhbWVyYUwuZmFyID0gX2N1cnJlbnREZXB0aEZhcjtcblx0XHRcdFx0Y2FtZXJhUi5uZWFyID0gX2N1cnJlbnREZXB0aE5lYXI7XG5cdFx0XHRcdGNhbWVyYVIuZmFyID0gX2N1cnJlbnREZXB0aEZhcjtcblxuXHRcdFx0XHRjYW1lcmFMLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdFx0Y2FtZXJhUi51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHRcdGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcGFyZW50ID0gY2FtZXJhLnBhcmVudDtcblx0XHRcdGNvbnN0IGNhbWVyYXMgPSBjYW1lcmFYUi5jYW1lcmFzO1xuXG5cdFx0XHR1cGRhdGVDYW1lcmEoIGNhbWVyYVhSLCBwYXJlbnQgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY2FtZXJhcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dXBkYXRlQ2FtZXJhKCBjYW1lcmFzWyBpIF0sIHBhcmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHVwZGF0ZSBwcm9qZWN0aW9uIG1hdHJpeCBmb3IgcHJvcGVyIHZpZXcgZnJ1c3R1bSBjdWxsaW5nXG5cblx0XHRcdGlmICggY2FtZXJhcy5sZW5ndGggPT09IDIgKSB7XG5cblx0XHRcdFx0c2V0UHJvamVjdGlvbkZyb21VbmlvbiggY2FtZXJhWFIsIGNhbWVyYUwsIGNhbWVyYVIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBhc3N1bWUgc2luZ2xlIGNhbWVyYSBzZXR1cCAoQVIpXG5cblx0XHRcdFx0Y2FtZXJhWFIucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBjYW1lcmFMLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgdXNlciBjYW1lcmEgYW5kIGl0cyBjaGlsZHJlblxuXG5cdFx0XHR1cGRhdGVVc2VyQ2FtZXJhKCBjYW1lcmEsIGNhbWVyYVhSLCBwYXJlbnQgKTtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVVc2VyQ2FtZXJhKCBjYW1lcmEsIGNhbWVyYVhSLCBwYXJlbnQgKSB7XG5cblx0XHRcdGlmICggcGFyZW50ID09PSBudWxsICkge1xuXG5cdFx0XHRcdGNhbWVyYS5tYXRyaXguY29weSggY2FtZXJhWFIubWF0cml4V29ybGQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjYW1lcmEubWF0cml4LmNvcHkoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRjYW1lcmEubWF0cml4LmludmVydCgpO1xuXHRcdFx0XHRjYW1lcmEubWF0cml4Lm11bHRpcGx5KCBjYW1lcmFYUi5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNhbWVyYS5tYXRyaXguZGVjb21wb3NlKCBjYW1lcmEucG9zaXRpb24sIGNhbWVyYS5xdWF0ZXJuaW9uLCBjYW1lcmEuc2NhbGUgKTtcblx0XHRcdGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBjYW1lcmFYUi5wcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSggY2FtZXJhWFIucHJvamVjdGlvbk1hdHJpeEludmVyc2UgKTtcblxuXHRcdFx0aWYgKCBjYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuXHRcdFx0XHRjYW1lcmEuZm92ID0gUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oIDEgLyBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgNSBdICk7XG5cdFx0XHRcdGNhbWVyYS56b29tID0gMTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBjYW1lcmFYUjtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEZvdmVhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCBnbFByb2pMYXllciA9PT0gbnVsbCAmJiBnbEJhc2VMYXllciA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmb3ZlYXRpb247XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRGb3ZlYXRpb24gPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHQvLyAwID0gbm8gZm92ZWF0aW9uID0gZnVsbCByZXNvbHV0aW9uXG5cdFx0XHQvLyAxID0gbWF4aW11bSBmb3ZlYXRpb24gPSB0aGUgZWRnZXMgcmVuZGVyIGF0IGxvd2VyIHJlc29sdXRpb25cblxuXHRcdFx0Zm92ZWF0aW9uID0gdmFsdWU7XG5cblx0XHRcdGlmICggZ2xQcm9qTGF5ZXIgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Z2xQcm9qTGF5ZXIuZml4ZWRGb3ZlYXRpb24gPSB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdsQmFzZUxheWVyICE9PSBudWxsICYmIGdsQmFzZUxheWVyLmZpeGVkRm92ZWF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Z2xCYXNlTGF5ZXIuZml4ZWRGb3ZlYXRpb24gPSB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuaGFzRGVwdGhTZW5zaW5nID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gZGVwdGhTZW5zaW5nLnRleHR1cmUgIT09IG51bGw7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXREZXB0aFNlbnNpbmdNZXNoID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gZGVwdGhTZW5zaW5nLmdldE1lc2goIGNhbWVyYVhSICk7XG5cblx0XHR9O1xuXG5cdFx0Ly8gQW5pbWF0aW9uIExvb3BcblxuXHRcdGxldCBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgPSBudWxsO1xuXG5cdFx0ZnVuY3Rpb24gb25BbmltYXRpb25GcmFtZSggdGltZSwgZnJhbWUgKSB7XG5cblx0XHRcdHBvc2UgPSBmcmFtZS5nZXRWaWV3ZXJQb3NlKCBjdXN0b21SZWZlcmVuY2VTcGFjZSB8fCByZWZlcmVuY2VTcGFjZSApO1xuXHRcdFx0eHJGcmFtZSA9IGZyYW1lO1xuXG5cdFx0XHRpZiAoIHBvc2UgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3Qgdmlld3MgPSBwb3NlLnZpZXdzO1xuXG5cdFx0XHRcdGlmICggZ2xCYXNlTGF5ZXIgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXRGcmFtZWJ1ZmZlciggbmV3UmVuZGVyVGFyZ2V0LCBnbEJhc2VMYXllci5mcmFtZWJ1ZmZlciApO1xuXHRcdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbmV3UmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBjYW1lcmFYUk5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgaXQncyBuZWNlc3NhcnkgdG8gcmVidWlsZCBjYW1lcmFYUidzIGNhbWVyYSBsaXN0XG5cblx0XHRcdFx0aWYgKCB2aWV3cy5sZW5ndGggIT09IGNhbWVyYVhSLmNhbWVyYXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Y2FtZXJhWFIuY2FtZXJhcy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdGNhbWVyYVhSTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2aWV3cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2aWV3ID0gdmlld3NbIGkgXTtcblxuXHRcdFx0XHRcdGxldCB2aWV3cG9ydCA9IG51bGw7XG5cblx0XHRcdFx0XHRpZiAoIGdsQmFzZUxheWVyICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHR2aWV3cG9ydCA9IGdsQmFzZUxheWVyLmdldFZpZXdwb3J0KCB2aWV3ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBnbFN1YkltYWdlID0gZ2xCaW5kaW5nLmdldFZpZXdTdWJJbWFnZSggZ2xQcm9qTGF5ZXIsIHZpZXcgKTtcblx0XHRcdFx0XHRcdHZpZXdwb3J0ID0gZ2xTdWJJbWFnZS52aWV3cG9ydDtcblxuXHRcdFx0XHRcdFx0Ly8gRm9yIHNpZGUtYnktc2lkZSBwcm9qZWN0aW9uLCB3ZSBvbmx5IHByb2R1Y2UgYSBzaW5nbGUgdGV4dHVyZSBmb3IgYm90aCBleWVzLlxuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldFRleHR1cmVzKFxuXHRcdFx0XHRcdFx0XHRcdG5ld1JlbmRlclRhcmdldCxcblx0XHRcdFx0XHRcdFx0XHRnbFN1YkltYWdlLmNvbG9yVGV4dHVyZSxcblx0XHRcdFx0XHRcdFx0XHRnbFByb2pMYXllci5pZ25vcmVEZXB0aFZhbHVlcyA/IHVuZGVmaW5lZCA6IGdsU3ViSW1hZ2UuZGVwdGhTdGVuY2lsVGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbmV3UmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBjYW1lcmEgPSBjYW1lcmFzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGNhbWVyYSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHRcdFx0XHRcdGNhbWVyYS5sYXllcnMuZW5hYmxlKCBpICk7XG5cdFx0XHRcdFx0XHRjYW1lcmEudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdFx0XHRcdFx0Y2FtZXJhc1sgaSBdID0gY2FtZXJhO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FtZXJhLm1hdHJpeC5mcm9tQXJyYXkoIHZpZXcudHJhbnNmb3JtLm1hdHJpeCApO1xuXHRcdFx0XHRcdGNhbWVyYS5tYXRyaXguZGVjb21wb3NlKCBjYW1lcmEucG9zaXRpb24sIGNhbWVyYS5xdWF0ZXJuaW9uLCBjYW1lcmEuc2NhbGUgKTtcblx0XHRcdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5mcm9tQXJyYXkoIHZpZXcucHJvamVjdGlvbk1hdHJpeCApO1xuXHRcdFx0XHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApLmludmVydCgpO1xuXHRcdFx0XHRcdGNhbWVyYS52aWV3cG9ydC5zZXQoIHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQgKTtcblxuXHRcdFx0XHRcdGlmICggaSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0Y2FtZXJhWFIubWF0cml4LmNvcHkoIGNhbWVyYS5tYXRyaXggKTtcblx0XHRcdFx0XHRcdGNhbWVyYVhSLm1hdHJpeC5kZWNvbXBvc2UoIGNhbWVyYVhSLnBvc2l0aW9uLCBjYW1lcmFYUi5xdWF0ZXJuaW9uLCBjYW1lcmFYUi5zY2FsZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjYW1lcmFYUk5lZWRzVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRjYW1lcmFYUi5jYW1lcmFzLnB1c2goIGNhbWVyYSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdGNvbnN0IGVuYWJsZWRGZWF0dXJlcyA9IHNlc3Npb24uZW5hYmxlZEZlYXR1cmVzO1xuXG5cdFx0XHRcdGlmICggZW5hYmxlZEZlYXR1cmVzICYmIGVuYWJsZWRGZWF0dXJlcy5pbmNsdWRlcyggJ2RlcHRoLXNlbnNpbmcnICkgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBkZXB0aERhdGEgPSBnbEJpbmRpbmcuZ2V0RGVwdGhJbmZvcm1hdGlvbiggdmlld3NbIDAgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBkZXB0aERhdGEgJiYgZGVwdGhEYXRhLmlzVmFsaWQgJiYgZGVwdGhEYXRhLnRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdGRlcHRoU2Vuc2luZy5pbml0KCByZW5kZXJlciwgZGVwdGhEYXRhLCBzZXNzaW9uLnJlbmRlclN0YXRlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvbnRyb2xsZXJzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZSA9IGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbIGkgXTtcblx0XHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBpbnB1dFNvdXJjZSAhPT0gbnVsbCAmJiBjb250cm9sbGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb250cm9sbGVyLnVwZGF0ZSggaW5wdXRTb3VyY2UsIGZyYW1lLCBjdXN0b21SZWZlcmVuY2VTcGFjZSB8fCByZWZlcmVuY2VTcGFjZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayApIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayggdGltZSwgZnJhbWUgKTtcblxuXHRcdFx0aWYgKCBmcmFtZS5kZXRlY3RlZFBsYW5lcyApIHtcblxuXHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdwbGFuZXNkZXRlY3RlZCcsIGRhdGE6IGZyYW1lIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR4ckZyYW1lID0gbnVsbDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBXZWJHTEFuaW1hdGlvbigpO1xuXG5cdFx0YW5pbWF0aW9uLnNldEFuaW1hdGlvbkxvb3AoIG9uQW5pbWF0aW9uRnJhbWUgKTtcblxuXHRcdHRoaXMuc2V0QW5pbWF0aW9uTG9vcCA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdH1cblxufVxuXG5jb25zdCBfZTEgPSAvKkBfX1BVUkVfXyovIG5ldyBFdWxlcigpO1xuY29uc3QgX20xID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5mdW5jdGlvbiBXZWJHTE1hdGVyaWFscyggcmVuZGVyZXIsIHByb3BlcnRpZXMgKSB7XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hcCwgdW5pZm9ybSApIHtcblxuXHRcdGlmICggbWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdG1hcC51cGRhdGVNYXRyaXgoKTtcblxuXHRcdH1cblxuXHRcdHVuaWZvcm0udmFsdWUuY29weSggbWFwLm1hdHJpeCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoRm9nVW5pZm9ybXMoIHVuaWZvcm1zLCBmb2cgKSB7XG5cblx0XHRmb2cuY29sb3IuZ2V0UkdCKCB1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSwgZ2V0VW5saXRVbmlmb3JtQ29sb3JTcGFjZSggcmVuZGVyZXIgKSApO1xuXG5cdFx0aWYgKCBmb2cuaXNGb2cgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcblx0XHRcdHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XG5cblx0XHR9IGVsc2UgaWYgKCBmb2cuaXNGb2dFeHAyICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zKCB1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsICkge1xuXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoVG9vbk1hdGVyaWFsICkge1xuXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXHRcdFx0cmVmcmVzaFVuaWZvcm1zVG9vbiggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hQaHlzaWNhbE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKCB1bmlmb3JtcywgbWF0ZXJpYWwsIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hNYXRjYXBNYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc01hdGNhcCggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hEZXB0aE1hdGVyaWFsICkge1xuXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc0Rpc3RhbmNlKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaE5vcm1hbE1hdGVyaWFsICkge1xuXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNMaW5lQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzUG9pbnRzTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BvaW50cyggdW5pZm9ybXMsIG1hdGVyaWFsLCBwaXhlbFJhdGlvLCBoZWlnaHQgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzU3ByaXRlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHJlZnJlc2hVbmlmb3Jtc1Nwcml0ZXMoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNTaGFkb3dNYXRlcmlhbCApIHtcblxuXHRcdFx0dW5pZm9ybXMuY29sb3IudmFsdWUuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCApIHtcblxuXHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7IC8vICMxNTU4MVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5jb2xvciApIHtcblxuXHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcblxuXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUuY29weSggbWF0ZXJpYWwuZW1pc3NpdmUgKS5tdWx0aXBseVNjYWxhciggbWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5tYXAsIHVuaWZvcm1zLm1hcFRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmFscGhhTWFwLCB1bmlmb3Jtcy5hbHBoYU1hcFRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmJ1bXBNYXAsIHVuaWZvcm1zLmJ1bXBNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSAqPSAtIDE7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5ub3JtYWxNYXAsIHVuaWZvcm1zLm5vcm1hbE1hcFRyYW5zZm9ybSApO1xuXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLCB1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmVtaXNzaXZlTWFwLCB1bmlmb3Jtcy5lbWlzc2l2ZU1hcFRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLnNwZWN1bGFyTWFwLCB1bmlmb3Jtcy5zcGVjdWxhck1hcFRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5hbHBoYVRlc3QgPiAwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbHBoYVRlc3QudmFsdWUgPSBtYXRlcmlhbC5hbHBoYVRlc3Q7XG5cblx0XHR9XG5cblx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblxuXHRcdGNvbnN0IGVudk1hcCA9IG1hdGVyaWFsUHJvcGVydGllcy5lbnZNYXA7XG5cdFx0Y29uc3QgZW52TWFwUm90YXRpb24gPSBtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwUm90YXRpb247XG5cblx0XHRpZiAoIGVudk1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuZW52TWFwLnZhbHVlID0gZW52TWFwO1xuXG5cdFx0XHRfZTEuY29weSggZW52TWFwUm90YXRpb24gKTtcblxuXHRcdFx0Ly8gYWNjb21tb2RhdGUgbGVmdC1oYW5kZWQgZnJhbWVcblx0XHRcdF9lMS54ICo9IC0gMTsgX2UxLnkgKj0gLSAxOyBfZTEueiAqPSAtIDE7XG5cblx0XHRcdGlmICggZW52TWFwLmlzQ3ViZVRleHR1cmUgJiYgZW52TWFwLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gZW52aXJvbm1lbnQgbWFwcyB3aGljaCBhcmUgbm90IGN1YmUgcmVuZGVyIHRhcmdldHMgb3IgUE1SRU1zIGZvbGxvdyBhIGRpZmZlcmVudCBjb252ZW50aW9uXG5cdFx0XHRcdF9lMS55ICo9IC0gMTtcblx0XHRcdFx0X2UxLnogKj0gLSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdHVuaWZvcm1zLmVudk1hcFJvdGF0aW9uLnZhbHVlLnNldEZyb21NYXRyaXg0KCBfbTEubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCBfZTEgKSApO1xuXG5cdFx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBlbnZNYXAuaXNDdWJlVGV4dHVyZSAmJiBlbnZNYXAuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSApID8gLSAxIDogMTtcblxuXHRcdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuXHRcdFx0dW5pZm9ybXMuaW9yLnZhbHVlID0gbWF0ZXJpYWwuaW9yO1xuXHRcdFx0dW5pZm9ybXMucmVmcmFjdGlvblJhdGlvLnZhbHVlID0gbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcblx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5saWdodE1hcCwgdW5pZm9ybXMubGlnaHRNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuYW9NYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFvTWFwLnZhbHVlID0gbWF0ZXJpYWwuYW9NYXA7XG5cdFx0XHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuYW9NYXAsIHVuaWZvcm1zLmFvTWFwVHJhbnNmb3JtICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5tYXAsIHVuaWZvcm1zLm1hcFRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xuXHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQb2ludHMoIHVuaWZvcm1zLCBtYXRlcmlhbCwgcGl4ZWxSYXRpbywgaGVpZ2h0ICkge1xuXG5cdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXHRcdHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplICogcGl4ZWxSYXRpbztcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IGhlaWdodCAqIDAuNTtcblxuXHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5tYXAsIHVuaWZvcm1zLnV2VHJhbnNmb3JtICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuYWxwaGFNYXAsIHVuaWZvcm1zLmFscGhhTWFwVHJhbnNmb3JtICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmFscGhhVGVzdCA+IDAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFscGhhVGVzdC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhVGVzdDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU3ByaXRlcyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXHRcdHVuaWZvcm1zLnJvdGF0aW9uLnZhbHVlID0gbWF0ZXJpYWwucm90YXRpb247XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwubWFwLCB1bmlmb3Jtcy5tYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5hbHBoYU1hcCwgdW5pZm9ybXMuYWxwaGFNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCApIHtcblxuXHRcdFx0dW5pZm9ybXMuYWxwaGFUZXN0LnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFUZXN0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUuY29weSggbWF0ZXJpYWwuc3BlY3VsYXIgKTtcblx0XHR1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBNYXRoLm1heCggbWF0ZXJpYWwuc2hpbmluZXNzLCAxZS00ICk7IC8vIHRvIHByZXZlbnQgcG93KCAwLjAsIDAuMCApXG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Rvb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdGlmICggbWF0ZXJpYWwuZ3JhZGllbnRNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmdyYWRpZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZ3JhZGllbnRNYXA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5tZXRhbG5lc3MudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3M7XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubWV0YWxuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwubWV0YWxuZXNzTWFwLCB1bmlmb3Jtcy5tZXRhbG5lc3NNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdH1cblxuXHRcdHVuaWZvcm1zLnJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzcztcblxuXHRcdGlmICggbWF0ZXJpYWwucm91Z2huZXNzTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5yb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XG5cblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAsIHVuaWZvcm1zLnJvdWdobmVzc01hcFRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5lbnZNYXAgKSB7XG5cblx0XHRcdC8vdW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwOyAvLyBwYXJ0IG9mIHVuaWZvcm1zIGNvbW1vblxuXG5cdFx0XHR1bmlmb3Jtcy5lbnZNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXBJbnRlbnNpdHk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKCB1bmlmb3JtcywgbWF0ZXJpYWwsIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCApIHtcblxuXHRcdHVuaWZvcm1zLmlvci52YWx1ZSA9IG1hdGVyaWFsLmlvcjsgLy8gYWxzbyBwYXJ0IG9mIHVuaWZvcm1zIGNvbW1vblxuXG5cdFx0aWYgKCBtYXRlcmlhbC5zaGVlbiA+IDAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLnNoZWVuQ29sb3IudmFsdWUuY29weSggbWF0ZXJpYWwuc2hlZW5Db2xvciApLm11bHRpcGx5U2NhbGFyKCBtYXRlcmlhbC5zaGVlbiApO1xuXG5cdFx0XHR1bmlmb3Jtcy5zaGVlblJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNoZWVuQ29sb3JNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuc2hlZW5Db2xvck1hcC52YWx1ZSA9IG1hdGVyaWFsLnNoZWVuQ29sb3JNYXA7XG5cblx0XHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLnNoZWVuQ29sb3JNYXAsIHVuaWZvcm1zLnNoZWVuQ29sb3JNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLnNoZWVuUm91Z2huZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXA7XG5cblx0XHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwLCB1bmlmb3Jtcy5zaGVlblJvdWdobmVzc01hcFRyYW5zZm9ybSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmNsZWFyY29hdCA+IDAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdDtcblx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdFJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcztcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5jbGVhcmNvYXRNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0TWFwLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0TWFwO1xuXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5jbGVhcmNvYXRNYXAsIHVuaWZvcm1zLmNsZWFyY29hdE1hcFRyYW5zZm9ybSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdFJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcDtcblxuXHRcdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwLCB1bmlmb3Jtcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXROb3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXA7XG5cblx0XHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCwgdW5pZm9ybXMuY2xlYXJjb2F0Tm9ybWFsTWFwVHJhbnNmb3JtICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgKTtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmRpc3BlcnNpb24gPiAwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5kaXNwZXJzaW9uLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGVyc2lvbjtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2UgPiAwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5pcmlkZXNjZW5jZS52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlO1xuXHRcdFx0dW5pZm9ybXMuaXJpZGVzY2VuY2VJT1IudmFsdWUgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZUlPUjtcblx0XHRcdHVuaWZvcm1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bS52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbIDAgXTtcblx0XHRcdHVuaWZvcm1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bS52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbIDEgXTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZU1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5pcmlkZXNjZW5jZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwO1xuXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5pcmlkZXNjZW5jZU1hcCwgdW5pZm9ybXMuaXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXA7XG5cblx0XHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLCB1bmlmb3Jtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcFRyYW5zZm9ybSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLnRyYW5zbWlzc2lvbi52YWx1ZSA9IG1hdGVyaWFsLnRyYW5zbWlzc2lvbjtcblx0XHRcdHVuaWZvcm1zLnRyYW5zbWlzc2lvblNhbXBsZXJNYXAudmFsdWUgPSB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRcdHVuaWZvcm1zLnRyYW5zbWlzc2lvblNhbXBsZXJTaXplLnZhbHVlLnNldCggdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LndpZHRoLCB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLnRyYW5zbWlzc2lvbk1hcC52YWx1ZSA9IG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcDtcblxuXHRcdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwLCB1bmlmb3Jtcy50cmFuc21pc3Npb25NYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR1bmlmb3Jtcy50aGlja25lc3MudmFsdWUgPSBtYXRlcmlhbC50aGlja25lc3M7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwudGhpY2tuZXNzTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLnRoaWNrbmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLnRoaWNrbmVzc01hcDtcblxuXHRcdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwudGhpY2tuZXNzTWFwLCB1bmlmb3Jtcy50aGlja25lc3NNYXBUcmFuc2Zvcm0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR1bmlmb3Jtcy5hdHRlbnVhdGlvbkRpc3RhbmNlLnZhbHVlID0gbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZTtcblx0XHRcdHVuaWZvcm1zLmF0dGVudWF0aW9uQ29sb3IudmFsdWUuY29weSggbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5hbmlzb3Ryb3B5ID4gMCApIHtcblxuXHRcdFx0dW5pZm9ybXMuYW5pc290cm9weVZlY3Rvci52YWx1ZS5zZXQoIG1hdGVyaWFsLmFuaXNvdHJvcHkgKiBNYXRoLmNvcyggbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uICksIG1hdGVyaWFsLmFuaXNvdHJvcHkgKiBNYXRoLnNpbiggbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uICkgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmFuaXNvdHJvcHlNYXAudmFsdWUgPSBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwO1xuXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwLCB1bmlmb3Jtcy5hbmlzb3Ryb3B5TWFwVHJhbnNmb3JtICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHVuaWZvcm1zLnNwZWN1bGFySW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHk7XG5cdFx0dW5pZm9ybXMuc3BlY3VsYXJDb2xvci52YWx1ZS5jb3B5KCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICk7XG5cblx0XHRpZiAoIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyQ29sb3JNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwO1xuXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcCwgdW5pZm9ybXMuc3BlY3VsYXJDb2xvck1hcFRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcDtcblxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwLCB1bmlmb3Jtcy5zcGVjdWxhckludGVuc2l0eU1hcFRyYW5zZm9ybSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNNYXRjYXAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdGlmICggbWF0ZXJpYWwubWF0Y2FwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5tYXRjYXAudmFsdWUgPSBtYXRlcmlhbC5tYXRjYXA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rpc3RhbmNlKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHRjb25zdCBsaWdodCA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLmxpZ2h0O1xuXG5cdFx0dW5pZm9ybXMucmVmZXJlbmNlUG9zaXRpb24udmFsdWUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdHVuaWZvcm1zLm5lYXJEaXN0YW5jZS52YWx1ZSA9IGxpZ2h0LnNoYWRvdy5jYW1lcmEubmVhcjtcblx0XHR1bmlmb3Jtcy5mYXJEaXN0YW5jZS52YWx1ZSA9IGxpZ2h0LnNoYWRvdy5jYW1lcmEuZmFyO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHJlZnJlc2hGb2dVbmlmb3JtczogcmVmcmVzaEZvZ1VuaWZvcm1zLFxuXHRcdHJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zOiByZWZyZXNoTWF0ZXJpYWxVbmlmb3Jtc1xuXHR9O1xuXG59XG5cbmZ1bmN0aW9uIFdlYkdMVW5pZm9ybXNHcm91cHMoIGdsLCBpbmZvLCBjYXBhYmlsaXRpZXMsIHN0YXRlICkge1xuXG5cdGxldCBidWZmZXJzID0ge307XG5cdGxldCB1cGRhdGVMaXN0ID0ge307XG5cdGxldCBhbGxvY2F0ZWRCaW5kaW5nUG9pbnRzID0gW107XG5cblx0Y29uc3QgbWF4QmluZGluZ1BvaW50cyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1VOSUZPUk1fQlVGRkVSX0JJTkRJTkdTICk7IC8vIGJpbmRpbmcgcG9pbnRzIGFyZSBnbG9iYWwgd2hlcmVhcyBibG9jayBpbmRpY2VzIGFyZSBwZXIgc2hhZGVyIHByb2dyYW1cblxuXHRmdW5jdGlvbiBiaW5kKCB1bmlmb3Jtc0dyb3VwLCBwcm9ncmFtICkge1xuXG5cdFx0Y29uc3Qgd2ViZ2xQcm9ncmFtID0gcHJvZ3JhbS5wcm9ncmFtO1xuXHRcdHN0YXRlLnVuaWZvcm1CbG9ja0JpbmRpbmcoIHVuaWZvcm1zR3JvdXAsIHdlYmdsUHJvZ3JhbSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGUoIHVuaWZvcm1zR3JvdXAsIHByb2dyYW0gKSB7XG5cblx0XHRsZXQgYnVmZmVyID0gYnVmZmVyc1sgdW5pZm9ybXNHcm91cC5pZCBdO1xuXG5cdFx0aWYgKCBidWZmZXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cHJlcGFyZVVuaWZvcm1zR3JvdXAoIHVuaWZvcm1zR3JvdXAgKTtcblxuXHRcdFx0YnVmZmVyID0gY3JlYXRlQnVmZmVyKCB1bmlmb3Jtc0dyb3VwICk7XG5cdFx0XHRidWZmZXJzWyB1bmlmb3Jtc0dyb3VwLmlkIF0gPSBidWZmZXI7XG5cblx0XHRcdHVuaWZvcm1zR3JvdXAuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblVuaWZvcm1zR3JvdXBzRGlzcG9zZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZW5zdXJlIHRvIHVwZGF0ZSB0aGUgYmluZGluZyBwb2ludHMvYmxvY2sgaW5kaWNlcyBtYXBwaW5nIGZvciB0aGlzIHByb2dyYW1cblxuXHRcdGNvbnN0IHdlYmdsUHJvZ3JhbSA9IHByb2dyYW0ucHJvZ3JhbTtcblx0XHRzdGF0ZS51cGRhdGVVQk9NYXBwaW5nKCB1bmlmb3Jtc0dyb3VwLCB3ZWJnbFByb2dyYW0gKTtcblxuXHRcdC8vIHVwZGF0ZSBVQk8gb25jZSBwZXIgZnJhbWVcblxuXHRcdGNvbnN0IGZyYW1lID0gaW5mby5yZW5kZXIuZnJhbWU7XG5cblx0XHRpZiAoIHVwZGF0ZUxpc3RbIHVuaWZvcm1zR3JvdXAuaWQgXSAhPT0gZnJhbWUgKSB7XG5cblx0XHRcdHVwZGF0ZUJ1ZmZlckRhdGEoIHVuaWZvcm1zR3JvdXAgKTtcblxuXHRcdFx0dXBkYXRlTGlzdFsgdW5pZm9ybXNHcm91cC5pZCBdID0gZnJhbWU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciggdW5pZm9ybXNHcm91cCApIHtcblxuXHRcdC8vIHRoZSBzZXR1cCBvZiBhbiBVQk8gaXMgaW5kZXBlbmRlbnQgb2YgYSBwYXJ0aWN1bGFyIHNoYWRlciBwcm9ncmFtIGJ1dCBnbG9iYWxcblxuXHRcdGNvbnN0IGJpbmRpbmdQb2ludEluZGV4ID0gYWxsb2NhdGVCaW5kaW5nUG9pbnRJbmRleCgpO1xuXHRcdHVuaWZvcm1zR3JvdXAuX19iaW5kaW5nUG9pbnRJbmRleCA9IGJpbmRpbmdQb2ludEluZGV4O1xuXG5cdFx0Y29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Y29uc3Qgc2l6ZSA9IHVuaWZvcm1zR3JvdXAuX19zaXplO1xuXHRcdGNvbnN0IHVzYWdlID0gdW5pZm9ybXNHcm91cC51c2FnZTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLlVOSUZPUk1fQlVGRkVSLCBidWZmZXIgKTtcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5VTklGT1JNX0JVRkZFUiwgc2l6ZSwgdXNhZ2UgKTtcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5VTklGT1JNX0JVRkZFUiwgbnVsbCApO1xuXHRcdGdsLmJpbmRCdWZmZXJCYXNlKCBnbC5VTklGT1JNX0JVRkZFUiwgYmluZGluZ1BvaW50SW5kZXgsIGJ1ZmZlciApO1xuXG5cdFx0cmV0dXJuIGJ1ZmZlcjtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYWxsb2NhdGVCaW5kaW5nUG9pbnRJbmRleCgpIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1heEJpbmRpbmdQb2ludHM7IGkgKysgKSB7XG5cblx0XHRcdGlmICggYWxsb2NhdGVkQmluZGluZ1BvaW50cy5pbmRleE9mKCBpICkgPT09IC0gMSApIHtcblxuXHRcdFx0XHRhbGxvY2F0ZWRCaW5kaW5nUG9pbnRzLnB1c2goIGkgKTtcblx0XHRcdFx0cmV0dXJuIGk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBNYXhpbXVtIG51bWJlciBvZiBzaW11bHRhbmVvdXNseSB1c2FibGUgdW5pZm9ybXMgZ3JvdXBzIHJlYWNoZWQuJyApO1xuXG5cdFx0cmV0dXJuIDA7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlckRhdGEoIHVuaWZvcm1zR3JvdXAgKSB7XG5cblx0XHRjb25zdCBidWZmZXIgPSBidWZmZXJzWyB1bmlmb3Jtc0dyb3VwLmlkIF07XG5cdFx0Y29uc3QgdW5pZm9ybXMgPSB1bmlmb3Jtc0dyb3VwLnVuaWZvcm1zO1xuXHRcdGNvbnN0IGNhY2hlID0gdW5pZm9ybXNHcm91cC5fX2NhY2hlO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuVU5JRk9STV9CVUZGRVIsIGJ1ZmZlciApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHVuaWZvcm1zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB1bmlmb3JtQXJyYXkgPSBBcnJheS5pc0FycmF5KCB1bmlmb3Jtc1sgaSBdICkgPyB1bmlmb3Jtc1sgaSBdIDogWyB1bmlmb3Jtc1sgaSBdIF07XG5cblx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSB1bmlmb3JtQXJyYXkubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybSA9IHVuaWZvcm1BcnJheVsgaiBdO1xuXG5cdFx0XHRcdGlmICggaGFzVW5pZm9ybUNoYW5nZWQoIHVuaWZvcm0sIGksIGosIGNhY2hlICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBvZmZzZXQgPSB1bmlmb3JtLl9fb2Zmc2V0O1xuXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSggdW5pZm9ybS52YWx1ZSApID8gdW5pZm9ybS52YWx1ZSA6IFsgdW5pZm9ybS52YWx1ZSBdO1xuXG5cdFx0XHRcdFx0bGV0IGFycmF5T2Zmc2V0ID0gMDtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBrID0gMDsgayA8IHZhbHVlcy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gdmFsdWVzWyBrIF07XG5cblx0XHRcdFx0XHRcdGNvbnN0IGluZm8gPSBnZXRVbmlmb3JtU2l6ZSggdmFsdWUgKTtcblxuXHRcdFx0XHRcdFx0Ly8gVE9ETyBhZGQgaW50ZWdlciBhbmQgc3RydWN0IHN1cHBvcnRcblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyApIHtcblxuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgMCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoIGdsLlVOSUZPUk1fQlVGRkVSLCBvZmZzZXQgKyBhcnJheU9mZnNldCwgdW5pZm9ybS5fX2RhdGEgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdmFsdWUuaXNNYXRyaXgzICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIG1hbnVhbGx5IGNvbnZlcnRpbmcgM3gzIHRvIDN4NFxuXG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyAwIF0gPSB2YWx1ZS5lbGVtZW50c1sgMCBdO1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgMSBdID0gdmFsdWUuZWxlbWVudHNbIDEgXTtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDIgXSA9IHZhbHVlLmVsZW1lbnRzWyAyIF07XG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyAzIF0gPSAwO1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgNCBdID0gdmFsdWUuZWxlbWVudHNbIDMgXTtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDUgXSA9IHZhbHVlLmVsZW1lbnRzWyA0IF07XG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyA2IF0gPSB2YWx1ZS5lbGVtZW50c1sgNSBdO1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgNyBdID0gMDtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDggXSA9IHZhbHVlLmVsZW1lbnRzWyA2IF07XG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyA5IF0gPSB2YWx1ZS5lbGVtZW50c1sgNyBdO1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgMTAgXSA9IHZhbHVlLmVsZW1lbnRzWyA4IF07XG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyAxMSBdID0gMDtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZS50b0FycmF5KCB1bmlmb3JtLl9fZGF0YSwgYXJyYXlPZmZzZXQgKTtcblxuXHRcdFx0XHRcdFx0XHRhcnJheU9mZnNldCArPSBpbmZvLnN0b3JhZ2UgLyBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoIGdsLlVOSUZPUk1fQlVGRkVSLCBvZmZzZXQsIHVuaWZvcm0uX19kYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5VTklGT1JNX0JVRkZFUiwgbnVsbCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYXNVbmlmb3JtQ2hhbmdlZCggdW5pZm9ybSwgaW5kZXgsIGluZGV4QXJyYXksIGNhY2hlICkge1xuXG5cdFx0Y29uc3QgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXHRcdGNvbnN0IGluZGV4U3RyaW5nID0gaW5kZXggKyAnXycgKyBpbmRleEFycmF5O1xuXG5cdFx0aWYgKCBjYWNoZVsgaW5kZXhTdHJpbmcgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBjYWNoZSBlbnRyeSBkb2VzIG5vdCBleGlzdCBzbyBmYXJcblxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICkge1xuXG5cdFx0XHRcdGNhY2hlWyBpbmRleFN0cmluZyBdID0gdmFsdWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y2FjaGVbIGluZGV4U3RyaW5nIF0gPSB2YWx1ZS5jbG9uZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgY2FjaGVkT2JqZWN0ID0gY2FjaGVbIGluZGV4U3RyaW5nIF07XG5cblx0XHRcdC8vIGNvbXBhcmUgY3VycmVudCB2YWx1ZSB3aXRoIGNhY2hlZCBlbnRyeVxuXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgKSB7XG5cblx0XHRcdFx0aWYgKCBjYWNoZWRPYmplY3QgIT09IHZhbHVlICkge1xuXG5cdFx0XHRcdFx0Y2FjaGVbIGluZGV4U3RyaW5nIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBjYWNoZWRPYmplY3QuZXF1YWxzKCB2YWx1ZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGNhY2hlZE9iamVjdC5jb3B5KCB2YWx1ZSApO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlVW5pZm9ybXNHcm91cCggdW5pZm9ybXNHcm91cCApIHtcblxuXHRcdC8vIGRldGVybWluZSB0b3RhbCBidWZmZXIgc2l6ZSBhY2NvcmRpbmcgdG8gdGhlIFNURDE0MCBsYXlvdXRcblx0XHQvLyBIaW50OiBTVEQxNDAgaXMgdGhlIG9ubHkgc3VwcG9ydGVkIGxheW91dCBpbiBXZWJHTCAyXG5cblx0XHRjb25zdCB1bmlmb3JtcyA9IHVuaWZvcm1zR3JvdXAudW5pZm9ybXM7XG5cblx0XHRsZXQgb2Zmc2V0ID0gMDsgLy8gZ2xvYmFsIGJ1ZmZlciBvZmZzZXQgaW4gYnl0ZXNcblx0XHRjb25zdCBjaHVua1NpemUgPSAxNjsgLy8gc2l6ZSBvZiBhIGNodW5rIGluIGJ5dGVzXG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB1bmlmb3Jtcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB1bmlmb3JtQXJyYXkgPSBBcnJheS5pc0FycmF5KCB1bmlmb3Jtc1sgaSBdICkgPyB1bmlmb3Jtc1sgaSBdIDogWyB1bmlmb3Jtc1sgaSBdIF07XG5cblx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSB1bmlmb3JtQXJyYXkubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybSA9IHVuaWZvcm1BcnJheVsgaiBdO1xuXG5cdFx0XHRcdGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoIHVuaWZvcm0udmFsdWUgKSA/IHVuaWZvcm0udmFsdWUgOiBbIHVuaWZvcm0udmFsdWUgXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgayA9IDAsIGtsID0gdmFsdWVzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2YWx1ZXNbIGsgXTtcblxuXHRcdFx0XHRcdGNvbnN0IGluZm8gPSBnZXRVbmlmb3JtU2l6ZSggdmFsdWUgKTtcblxuXHRcdFx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgY2h1bmsgb2Zmc2V0XG5cdFx0XHRcdFx0Y29uc3QgY2h1bmtPZmZzZXRVbmlmb3JtID0gb2Zmc2V0ICUgY2h1bmtTaXplO1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGNodW5rIG92ZXJmbG93XG5cdFx0XHRcdFx0aWYgKCBjaHVua09mZnNldFVuaWZvcm0gIT09IDAgJiYgKCBjaHVua1NpemUgLSBjaHVua09mZnNldFVuaWZvcm0gKSA8IGluZm8uYm91bmRhcnkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEFkZCBwYWRkaW5nIGFuZCBhZGp1c3Qgb2Zmc2V0XG5cdFx0XHRcdFx0XHRvZmZzZXQgKz0gKCBjaHVua1NpemUgLSBjaHVua09mZnNldFVuaWZvcm0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRoZSBmb2xsb3dpbmcgdHdvIHByb3BlcnRpZXMgd2lsbCBiZSB1c2VkIGZvciBwYXJ0aWFsIGJ1ZmZlciB1cGRhdGVzXG5cblx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoIGluZm8uc3RvcmFnZSAvIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCApO1xuXHRcdFx0XHRcdHVuaWZvcm0uX19vZmZzZXQgPSBvZmZzZXQ7XG5cblxuXHRcdFx0XHRcdC8vIFVwZGF0ZSB0aGUgZ2xvYmFsIG9mZnNldFxuXHRcdFx0XHRcdG9mZnNldCArPSBpbmZvLnN0b3JhZ2U7XG5cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGVuc3VyZSBjb3JyZWN0IGZpbmFsIHBhZGRpbmdcblxuXHRcdGNvbnN0IGNodW5rT2Zmc2V0ID0gb2Zmc2V0ICUgY2h1bmtTaXplO1xuXG5cdFx0aWYgKCBjaHVua09mZnNldCA+IDAgKSBvZmZzZXQgKz0gKCBjaHVua1NpemUgLSBjaHVua09mZnNldCApO1xuXG5cdFx0Ly9cblxuXHRcdHVuaWZvcm1zR3JvdXAuX19zaXplID0gb2Zmc2V0O1xuXHRcdHVuaWZvcm1zR3JvdXAuX19jYWNoZSA9IHt9O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFVuaWZvcm1TaXplKCB2YWx1ZSApIHtcblxuXHRcdGNvbnN0IGluZm8gPSB7XG5cdFx0XHRib3VuZGFyeTogMCwgLy8gYnl0ZXNcblx0XHRcdHN0b3JhZ2U6IDAgLy8gYnl0ZXNcblx0XHR9O1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIHNpemVzIGFjY29yZGluZyB0byBTVEQxNDBcblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyApIHtcblxuXHRcdFx0Ly8gZmxvYXQvaW50L2Jvb2xcblxuXHRcdFx0aW5mby5ib3VuZGFyeSA9IDQ7XG5cdFx0XHRpbmZvLnN0b3JhZ2UgPSA0O1xuXG5cdFx0fSBlbHNlIGlmICggdmFsdWUuaXNWZWN0b3IyICkge1xuXG5cdFx0XHQvLyB2ZWMyXG5cblx0XHRcdGluZm8uYm91bmRhcnkgPSA4O1xuXHRcdFx0aW5mby5zdG9yYWdlID0gODtcblxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlLmlzVmVjdG9yMyB8fCB2YWx1ZS5pc0NvbG9yICkge1xuXG5cdFx0XHQvLyB2ZWMzXG5cblx0XHRcdGluZm8uYm91bmRhcnkgPSAxNjtcblx0XHRcdGluZm8uc3RvcmFnZSA9IDEyOyAvLyBldmlsOiB2ZWMzIG11c3Qgc3RhcnQgb24gYSAxNi1ieXRlIGJvdW5kYXJ5IGJ1dCBpdCBvbmx5IGNvbnN1bWVzIDEyIGJ5dGVzXG5cblx0XHR9IGVsc2UgaWYgKCB2YWx1ZS5pc1ZlY3RvcjQgKSB7XG5cblx0XHRcdC8vIHZlYzRcblxuXHRcdFx0aW5mby5ib3VuZGFyeSA9IDE2O1xuXHRcdFx0aW5mby5zdG9yYWdlID0gMTY7XG5cblx0XHR9IGVsc2UgaWYgKCB2YWx1ZS5pc01hdHJpeDMgKSB7XG5cblx0XHRcdC8vIG1hdDMgKGluIFNURDE0MCBhIDN4MyBtYXRyaXggaXMgcmVwcmVzZW50ZWQgYXMgM3g0KVxuXG5cdFx0XHRpbmZvLmJvdW5kYXJ5ID0gNDg7XG5cdFx0XHRpbmZvLnN0b3JhZ2UgPSA0ODtcblxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlLmlzTWF0cml4NCApIHtcblxuXHRcdFx0Ly8gbWF0NFxuXG5cdFx0XHRpbmZvLmJvdW5kYXJ5ID0gNjQ7XG5cdFx0XHRpbmZvLnN0b3JhZ2UgPSA2NDtcblxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBzYW1wbGVycyBjYW4gbm90IGJlIHBhcnQgb2YgYW4gdW5pZm9ybXMgZ3JvdXAuJyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdW5pZm9ybSB2YWx1ZSB0eXBlLicsIHZhbHVlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW5mbztcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Vbmlmb3Jtc0dyb3Vwc0Rpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0Y29uc3QgdW5pZm9ybXNHcm91cCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdHVuaWZvcm1zR3JvdXAucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblVuaWZvcm1zR3JvdXBzRGlzcG9zZSApO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBhbGxvY2F0ZWRCaW5kaW5nUG9pbnRzLmluZGV4T2YoIHVuaWZvcm1zR3JvdXAuX19iaW5kaW5nUG9pbnRJbmRleCApO1xuXHRcdGFsbG9jYXRlZEJpbmRpbmdQb2ludHMuc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0Z2wuZGVsZXRlQnVmZmVyKCBidWZmZXJzWyB1bmlmb3Jtc0dyb3VwLmlkIF0gKTtcblxuXHRcdGRlbGV0ZSBidWZmZXJzWyB1bmlmb3Jtc0dyb3VwLmlkIF07XG5cdFx0ZGVsZXRlIHVwZGF0ZUxpc3RbIHVuaWZvcm1zR3JvdXAuaWQgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuXHRcdGZvciAoIGNvbnN0IGlkIGluIGJ1ZmZlcnMgKSB7XG5cblx0XHRcdGdsLmRlbGV0ZUJ1ZmZlciggYnVmZmVyc1sgaWQgXSApO1xuXG5cdFx0fVxuXG5cdFx0YWxsb2NhdGVkQmluZGluZ1BvaW50cyA9IFtdO1xuXHRcdGJ1ZmZlcnMgPSB7fTtcblx0XHR1cGRhdGVMaXN0ID0ge307XG5cblx0fVxuXG5cdHJldHVybiB7XG5cblx0XHRiaW5kOiBiaW5kLFxuXHRcdHVwZGF0ZTogdXBkYXRlLFxuXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXG5cdH07XG5cbn1cblxuY2xhc3MgV2ViR0xSZW5kZXJlciB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgPSB7fSApIHtcblxuXHRcdGNvbnN0IHtcblx0XHRcdGNhbnZhcyA9IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcblx0XHRcdGNvbnRleHQgPSBudWxsLFxuXHRcdFx0ZGVwdGggPSB0cnVlLFxuXHRcdFx0c3RlbmNpbCA9IGZhbHNlLFxuXHRcdFx0YWxwaGEgPSBmYWxzZSxcblx0XHRcdGFudGlhbGlhcyA9IGZhbHNlLFxuXHRcdFx0cHJlbXVsdGlwbGllZEFscGhhID0gdHJ1ZSxcblx0XHRcdHByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IGZhbHNlLFxuXHRcdFx0cG93ZXJQcmVmZXJlbmNlID0gJ2RlZmF1bHQnLFxuXHRcdFx0ZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA9IGZhbHNlLFxuXHRcdH0gPSBwYXJhbWV0ZXJzO1xuXG5cdFx0dGhpcy5pc1dlYkdMUmVuZGVyZXIgPSB0cnVlO1xuXG5cdFx0bGV0IF9hbHBoYTtcblxuXHRcdGlmICggY29udGV4dCAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBjb250ZXh0IGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0ICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFdlYkdMIDEgaXMgbm90IHN1cHBvcnRlZCBzaW5jZSByMTYzLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfYWxwaGEgPSBjb250ZXh0LmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfYWxwaGEgPSBhbHBoYTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHVpbnRDbGVhckNvbG9yID0gbmV3IFVpbnQzMkFycmF5KCA0ICk7XG5cdFx0Y29uc3QgaW50Q2xlYXJDb2xvciA9IG5ldyBJbnQzMkFycmF5KCA0ICk7XG5cblx0XHRsZXQgY3VycmVudFJlbmRlckxpc3QgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50UmVuZGVyU3RhdGUgPSBudWxsO1xuXG5cdFx0Ly8gcmVuZGVyKCkgY2FuIGJlIGNhbGxlZCBmcm9tIHdpdGhpbiBhIGNhbGxiYWNrIHRyaWdnZXJlZCBieSBhbm90aGVyIHJlbmRlci5cblx0XHQvLyBXZSB0cmFjayB0aGlzIHNvIHRoYXQgdGhlIG5lc3RlZCByZW5kZXIgY2FsbCBnZXRzIGl0cyBsaXN0IGFuZCBzdGF0ZSBpc29sYXRlZCBmcm9tIHRoZSBwYXJlbnQgcmVuZGVyIGNhbGwuXG5cblx0XHRjb25zdCByZW5kZXJMaXN0U3RhY2sgPSBbXTtcblx0XHRjb25zdCByZW5kZXJTdGF0ZVN0YWNrID0gW107XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXG5cdFx0dGhpcy5kb21FbGVtZW50ID0gY2FudmFzO1xuXG5cdFx0Ly8gRGVidWcgY29uZmlndXJhdGlvbiBjb250YWluZXJcblx0XHR0aGlzLmRlYnVnID0ge1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZXMgZXJyb3IgY2hlY2tpbmcgYW5kIHJlcG9ydGluZyB3aGVuIHNoYWRlciBwcm9ncmFtcyBhcmUgYmVpbmcgY29tcGlsZWRcblx0XHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRjaGVja1NoYWRlckVycm9yczogdHJ1ZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogQ2FsbGJhY2sgZm9yIGN1c3RvbSBlcnJvciByZXBvcnRpbmcuXG5cdFx0XHQgKiBAdHlwZSB7P0Z1bmN0aW9ufVxuXHRcdFx0ICovXG5cdFx0XHRvblNoYWRlckVycm9yOiBudWxsXG5cdFx0fTtcblxuXHRcdC8vIGNsZWFyaW5nXG5cblx0XHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTtcblxuXHRcdC8vIHNjZW5lIGdyYXBoXG5cblx0XHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcblxuXHRcdC8vIHVzZXItZGVmaW5lZCBjbGlwcGluZ1xuXG5cdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IFtdO1xuXHRcdHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZTtcblxuXHRcdC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xuXG5cdFx0dGhpcy5fb3V0cHV0Q29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlO1xuXG5cdFx0Ly8gdG9uZSBtYXBwaW5nXG5cblx0XHR0aGlzLnRvbmVNYXBwaW5nID0gTm9Ub25lTWFwcGluZztcblx0XHR0aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxLjA7XG5cblx0XHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXG5cblx0XHRjb25zdCBfdGhpcyA9IHRoaXM7XG5cblx0XHRsZXQgX2lzQ29udGV4dExvc3QgPSBmYWxzZTtcblxuXHRcdC8vIGludGVybmFsIHN0YXRlIGNhY2hlXG5cblx0XHRsZXQgX2N1cnJlbnRBY3RpdmVDdWJlRmFjZSA9IDA7XG5cdFx0bGV0IF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgPSAwO1xuXHRcdGxldCBfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XG5cdFx0bGV0IF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcblxuXHRcdGxldCBfY3VycmVudENhbWVyYSA9IG51bGw7XG5cblx0XHRjb25zdCBfY3VycmVudFZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcblx0XHRjb25zdCBfY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdGxldCBfY3VycmVudFNjaXNzb3JUZXN0ID0gbnVsbDtcblxuXHRcdGNvbnN0IF9jdXJyZW50Q2xlYXJDb2xvciA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcblx0XHRsZXQgX2N1cnJlbnRDbGVhckFscGhhID0gMDtcblxuXHRcdC8vXG5cblx0XHRsZXQgX3dpZHRoID0gY2FudmFzLndpZHRoO1xuXHRcdGxldCBfaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblxuXHRcdGxldCBfcGl4ZWxSYXRpbyA9IDE7XG5cdFx0bGV0IF9vcGFxdWVTb3J0ID0gbnVsbDtcblx0XHRsZXQgX3RyYW5zcGFyZW50U29ydCA9IG51bGw7XG5cblx0XHRjb25zdCBfdmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICk7XG5cdFx0Y29uc3QgX3NjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICk7XG5cdFx0bGV0IF9zY2lzc29yVGVzdCA9IGZhbHNlO1xuXG5cdFx0Ly8gZnJ1c3R1bVxuXG5cdFx0Y29uc3QgX2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpO1xuXG5cdFx0Ly8gY2xpcHBpbmdcblxuXHRcdGxldCBfY2xpcHBpbmdFbmFibGVkID0gZmFsc2U7XG5cdFx0bGV0IF9sb2NhbENsaXBwaW5nRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXG5cblx0XHRjb25zdCBfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRjb25zdCBfdmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRjb25zdCBfZW1wdHlTY2VuZSA9IHsgYmFja2dyb3VuZDogbnVsbCwgZm9nOiBudWxsLCBlbnZpcm9ubWVudDogbnVsbCwgb3ZlcnJpZGVNYXRlcmlhbDogbnVsbCwgaXNTY2VuZTogdHJ1ZSB9O1xuXG5cdFx0bGV0IF9yZW5kZXJCYWNrZ3JvdW5kID0gZmFsc2U7XG5cblx0XHRmdW5jdGlvbiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkge1xuXG5cdFx0XHRyZXR1cm4gX2N1cnJlbnRSZW5kZXJUYXJnZXQgPT09IG51bGwgPyBfcGl4ZWxSYXRpbyA6IDE7XG5cblx0XHR9XG5cblx0XHQvLyBpbml0aWFsaXplXG5cblx0XHRsZXQgX2dsID0gY29udGV4dDtcblxuXHRcdGZ1bmN0aW9uIGdldENvbnRleHQoIGNvbnRleHROYW1lLCBjb250ZXh0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0cmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCBjb250ZXh0TmFtZSwgY29udGV4dEF0dHJpYnV0ZXMgKTtcblxuXHRcdH1cblxuXHRcdHRyeSB7XG5cblx0XHRcdGNvbnN0IGNvbnRleHRBdHRyaWJ1dGVzID0ge1xuXHRcdFx0XHRhbHBoYTogdHJ1ZSxcblx0XHRcdFx0ZGVwdGgsXG5cdFx0XHRcdHN0ZW5jaWwsXG5cdFx0XHRcdGFudGlhbGlhcyxcblx0XHRcdFx0cHJlbXVsdGlwbGllZEFscGhhLFxuXHRcdFx0XHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG5cdFx0XHRcdHBvd2VyUHJlZmVyZW5jZSxcblx0XHRcdFx0ZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCxcblx0XHRcdH07XG5cblx0XHRcdC8vIE9mZnNjcmVlbkNhbnZhcyBkb2VzIG5vdCBoYXZlIHNldEF0dHJpYnV0ZSwgc2VlICMyMjgxMVxuXHRcdFx0aWYgKCAnc2V0QXR0cmlidXRlJyBpbiBjYW52YXMgKSBjYW52YXMuc2V0QXR0cmlidXRlKCAnZGF0YS1lbmdpbmUnLCBgdGhyZWUuanMgciR7UkVWSVNJT059YCApO1xuXG5cdFx0XHQvLyBldmVudCBsaXN0ZW5lcnMgbXVzdCBiZSByZWdpc3RlcmVkIGJlZm9yZSBXZWJHTCBjb250ZXh0IGlzIGNyZWF0ZWQsIHNlZSAjMTI3NTNcblx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cdFx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgb25Db250ZXh0UmVzdG9yZSwgZmFsc2UgKTtcblx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcicsIG9uQ29udGV4dENyZWF0aW9uRXJyb3IsIGZhbHNlICk7XG5cblx0XHRcdGlmICggX2dsID09PSBudWxsICkge1xuXG5cdFx0XHRcdGNvbnN0IGNvbnRleHROYW1lID0gJ3dlYmdsMic7XG5cblx0XHRcdFx0X2dsID0gZ2V0Q29udGV4dCggY29udGV4dE5hbWUsIGNvbnRleHRBdHRyaWJ1dGVzICk7XG5cblx0XHRcdFx0aWYgKCBfZ2wgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGdldENvbnRleHQoIGNvbnRleHROYW1lICkgKSB7XG5cblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgZXJyb3IubWVzc2FnZSApO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cblx0XHR9XG5cblx0XHRsZXQgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzLCBzdGF0ZSwgaW5mbztcblx0XHRsZXQgcHJvcGVydGllcywgdGV4dHVyZXMsIGN1YmVtYXBzLCBjdWJldXZtYXBzLCBhdHRyaWJ1dGVzLCBnZW9tZXRyaWVzLCBvYmplY3RzO1xuXHRcdGxldCBwcm9ncmFtQ2FjaGUsIG1hdGVyaWFscywgcmVuZGVyTGlzdHMsIHJlbmRlclN0YXRlcywgY2xpcHBpbmcsIHNoYWRvd01hcDtcblxuXHRcdGxldCBiYWNrZ3JvdW5kLCBtb3JwaHRhcmdldHMsIGJ1ZmZlclJlbmRlcmVyLCBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XG5cblx0XHRsZXQgdXRpbHMsIGJpbmRpbmdTdGF0ZXMsIHVuaWZvcm1zR3JvdXBzO1xuXG5cdFx0ZnVuY3Rpb24gaW5pdEdMQ29udGV4dCgpIHtcblxuXHRcdFx0ZXh0ZW5zaW9ucyA9IG5ldyBXZWJHTEV4dGVuc2lvbnMoIF9nbCApO1xuXHRcdFx0ZXh0ZW5zaW9ucy5pbml0KCk7XG5cblx0XHRcdHV0aWxzID0gbmV3IFdlYkdMVXRpbHMoIF9nbCwgZXh0ZW5zaW9ucyApO1xuXG5cdFx0XHRjYXBhYmlsaXRpZXMgPSBuZXcgV2ViR0xDYXBhYmlsaXRpZXMoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycywgdXRpbHMgKTtcblxuXHRcdFx0c3RhdGUgPSBuZXcgV2ViR0xTdGF0ZSggX2dsICk7XG5cblx0XHRcdGluZm8gPSBuZXcgV2ViR0xJbmZvKCBfZ2wgKTtcblx0XHRcdHByb3BlcnRpZXMgPSBuZXcgV2ViR0xQcm9wZXJ0aWVzKCk7XG5cdFx0XHR0ZXh0dXJlcyA9IG5ldyBXZWJHTFRleHR1cmVzKCBfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHV0aWxzLCBpbmZvICk7XG5cdFx0XHRjdWJlbWFwcyA9IG5ldyBXZWJHTEN1YmVNYXBzKCBfdGhpcyApO1xuXHRcdFx0Y3ViZXV2bWFwcyA9IG5ldyBXZWJHTEN1YmVVVk1hcHMoIF90aGlzICk7XG5cdFx0XHRhdHRyaWJ1dGVzID0gbmV3IFdlYkdMQXR0cmlidXRlcyggX2dsICk7XG5cdFx0XHRiaW5kaW5nU3RhdGVzID0gbmV3IFdlYkdMQmluZGluZ1N0YXRlcyggX2dsLCBhdHRyaWJ1dGVzICk7XG5cdFx0XHRnZW9tZXRyaWVzID0gbmV3IFdlYkdMR2VvbWV0cmllcyggX2dsLCBhdHRyaWJ1dGVzLCBpbmZvLCBiaW5kaW5nU3RhdGVzICk7XG5cdFx0XHRvYmplY3RzID0gbmV3IFdlYkdMT2JqZWN0cyggX2dsLCBnZW9tZXRyaWVzLCBhdHRyaWJ1dGVzLCBpbmZvICk7XG5cdFx0XHRtb3JwaHRhcmdldHMgPSBuZXcgV2ViR0xNb3JwaHRhcmdldHMoIF9nbCwgY2FwYWJpbGl0aWVzLCB0ZXh0dXJlcyApO1xuXHRcdFx0Y2xpcHBpbmcgPSBuZXcgV2ViR0xDbGlwcGluZyggcHJvcGVydGllcyApO1xuXHRcdFx0cHJvZ3JhbUNhY2hlID0gbmV3IFdlYkdMUHJvZ3JhbXMoIF90aGlzLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzLCBiaW5kaW5nU3RhdGVzLCBjbGlwcGluZyApO1xuXHRcdFx0bWF0ZXJpYWxzID0gbmV3IFdlYkdMTWF0ZXJpYWxzKCBfdGhpcywgcHJvcGVydGllcyApO1xuXHRcdFx0cmVuZGVyTGlzdHMgPSBuZXcgV2ViR0xSZW5kZXJMaXN0cygpO1xuXHRcdFx0cmVuZGVyU3RhdGVzID0gbmV3IFdlYkdMUmVuZGVyU3RhdGVzKCBleHRlbnNpb25zICk7XG5cdFx0XHRiYWNrZ3JvdW5kID0gbmV3IFdlYkdMQmFja2dyb3VuZCggX3RoaXMsIGN1YmVtYXBzLCBjdWJldXZtYXBzLCBzdGF0ZSwgb2JqZWN0cywgX2FscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEgKTtcblx0XHRcdHNoYWRvd01hcCA9IG5ldyBXZWJHTFNoYWRvd01hcCggX3RoaXMsIG9iamVjdHMsIGNhcGFiaWxpdGllcyApO1xuXHRcdFx0dW5pZm9ybXNHcm91cHMgPSBuZXcgV2ViR0xVbmlmb3Jtc0dyb3VwcyggX2dsLCBpbmZvLCBjYXBhYmlsaXRpZXMsIHN0YXRlICk7XG5cblx0XHRcdGJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgaW5mbyApO1xuXHRcdFx0aW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIGluZm8gKTtcblxuXHRcdFx0aW5mby5wcm9ncmFtcyA9IHByb2dyYW1DYWNoZS5wcm9ncmFtcztcblxuXHRcdFx0X3RoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzO1xuXHRcdFx0X3RoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cdFx0XHRfdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcblx0XHRcdF90aGlzLnJlbmRlckxpc3RzID0gcmVuZGVyTGlzdHM7XG5cdFx0XHRfdGhpcy5zaGFkb3dNYXAgPSBzaGFkb3dNYXA7XG5cdFx0XHRfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXHRcdFx0X3RoaXMuaW5mbyA9IGluZm87XG5cblx0XHR9XG5cblx0XHRpbml0R0xDb250ZXh0KCk7XG5cblx0XHQvLyB4clxuXG5cdFx0Y29uc3QgeHIgPSBuZXcgV2ViWFJNYW5hZ2VyKCBfdGhpcywgX2dsICk7XG5cblx0XHR0aGlzLnhyID0geHI7XG5cblx0XHQvLyBBUElcblxuXHRcdHRoaXMuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIF9nbDtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldENvbnRleHRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX2dsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5mb3JjZUNvbnRleHRMb3NzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKTtcblx0XHRcdGlmICggZXh0ZW5zaW9uICkgZXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5mb3JjZUNvbnRleHRSZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKTtcblx0XHRcdGlmICggZXh0ZW5zaW9uICkgZXh0ZW5zaW9uLnJlc3RvcmVDb250ZXh0KCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX3BpeGVsUmF0aW87XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRfcGl4ZWxSYXRpbyA9IHZhbHVlO1xuXG5cdFx0XHR0aGlzLnNldFNpemUoIF93aWR0aCwgX2hlaWdodCwgZmFsc2UgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoIHRhcmdldCApIHtcblxuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoIF93aWR0aCwgX2hlaWdodCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUgPSB0cnVlICkge1xuXG5cdFx0XHRpZiAoIHhyLmlzUHJlc2VudGluZyApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBDYW5cXCd0IGNoYW5nZSBzaXplIHdoaWxlIFZSIGRldmljZSBpcyBwcmVzZW50aW5nLicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdF93aWR0aCA9IHdpZHRoO1xuXHRcdFx0X2hlaWdodCA9IGhlaWdodDtcblxuXHRcdFx0Y2FudmFzLndpZHRoID0gTWF0aC5mbG9vciggd2lkdGggKiBfcGl4ZWxSYXRpbyApO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGhlaWdodCAqIF9waXhlbFJhdGlvICk7XG5cblx0XHRcdGlmICggdXBkYXRlU3R5bGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdFx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXREcmF3aW5nQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnNldCggX3dpZHRoICogX3BpeGVsUmF0aW8sIF9oZWlnaHQgKiBfcGl4ZWxSYXRpbyApLmZsb29yKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXREcmF3aW5nQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbyApIHtcblxuXHRcdFx0X3dpZHRoID0gd2lkdGg7XG5cdFx0XHRfaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0XHRfcGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cblx0XHRcdGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIHdpZHRoICogcGl4ZWxSYXRpbyApO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGhlaWdodCAqIHBpeGVsUmF0aW8gKTtcblxuXHRcdFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Q3VycmVudFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XG5cblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggX2N1cnJlbnRWaWV3cG9ydCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIHRhcmdldCApIHtcblxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBfdmlld3BvcnQgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0XHRpZiAoIHguaXNWZWN0b3I0ICkge1xuXG5cdFx0XHRcdF92aWV3cG9ydC5zZXQoIHgueCwgeC55LCB4LnosIHgudyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF92aWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKS5yb3VuZCgpICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRTY2lzc29yID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XG5cblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggX3NjaXNzb3IgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRcdGlmICggeC5pc1ZlY3RvcjQgKSB7XG5cblx0XHRcdFx0X3NjaXNzb3Iuc2V0KCB4LngsIHgueSwgeC56LCB4LncgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfc2Npc3Nvci5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5zY2lzc29yKCBfY3VycmVudFNjaXNzb3IuY29weSggX3NjaXNzb3IgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKS5yb3VuZCgpICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIF9zY2lzc29yVGVzdDtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKCBib29sZWFuICkge1xuXG5cdFx0XHRzdGF0ZS5zZXRTY2lzc29yVGVzdCggX3NjaXNzb3JUZXN0ID0gYm9vbGVhbiApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0T3BhcXVlU29ydCA9IGZ1bmN0aW9uICggbWV0aG9kICkge1xuXG5cdFx0XHRfb3BhcXVlU29ydCA9IG1ldGhvZDtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFRyYW5zcGFyZW50U29ydCA9IGZ1bmN0aW9uICggbWV0aG9kICkge1xuXG5cdFx0XHRfdHJhbnNwYXJlbnRTb3J0ID0gbWV0aG9kO1xuXG5cdFx0fTtcblxuXHRcdC8vIENsZWFyaW5nXG5cblx0XHR0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoIHRhcmdldCApIHtcblxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBiYWNrZ3JvdW5kLmdldENsZWFyQ29sb3IoKSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0YmFja2dyb3VuZC5zZXRDbGVhckNvbG9yLmFwcGx5KCBiYWNrZ3JvdW5kLCBhcmd1bWVudHMgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBiYWNrZ3JvdW5kLmdldENsZWFyQWxwaGEoKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGJhY2tncm91bmQuc2V0Q2xlYXJBbHBoYS5hcHBseSggYmFja2dyb3VuZCwgYXJndW1lbnRzICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICggY29sb3IgPSB0cnVlLCBkZXB0aCA9IHRydWUsIHN0ZW5jaWwgPSB0cnVlICkge1xuXG5cdFx0XHRsZXQgYml0cyA9IDA7XG5cblx0XHRcdGlmICggY29sb3IgKSB7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgd2UncmUgdHJ5aW5nIHRvIGNsZWFyIGFuIGludGVnZXIgdGFyZ2V0XG5cdFx0XHRcdGxldCBpc0ludGVnZXJGb3JtYXQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCBfY3VycmVudFJlbmRlclRhcmdldCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHRhcmdldEZvcm1hdCA9IF9jdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUuZm9ybWF0O1xuXHRcdFx0XHRcdGlzSW50ZWdlckZvcm1hdCA9IHRhcmdldEZvcm1hdCA9PT0gUkdCQUludGVnZXJGb3JtYXQgfHxcblx0XHRcdFx0XHRcdHRhcmdldEZvcm1hdCA9PT0gUkdJbnRlZ2VyRm9ybWF0IHx8XG5cdFx0XHRcdFx0XHR0YXJnZXRGb3JtYXQgPT09IFJlZEludGVnZXJGb3JtYXQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVzZSB0aGUgYXBwcm9wcmlhdGUgY2xlYXIgZnVuY3Rpb25zIHRvIGNsZWFyIHRoZSB0YXJnZXQgaWYgaXQncyBhIHNpZ25lZFxuXHRcdFx0XHQvLyBvciB1bnNpZ25lZCBpbnRlZ2VyIHRhcmdldFxuXHRcdFx0XHRpZiAoIGlzSW50ZWdlckZvcm1hdCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHRhcmdldFR5cGUgPSBfY3VycmVudFJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGU7XG5cdFx0XHRcdFx0Y29uc3QgaXNVbnNpZ25lZFR5cGUgPSB0YXJnZXRUeXBlID09PSBVbnNpZ25lZEJ5dGVUeXBlIHx8XG5cdFx0XHRcdFx0XHR0YXJnZXRUeXBlID09PSBVbnNpZ25lZEludFR5cGUgfHxcblx0XHRcdFx0XHRcdHRhcmdldFR5cGUgPT09IFVuc2lnbmVkU2hvcnRUeXBlIHx8XG5cdFx0XHRcdFx0XHR0YXJnZXRUeXBlID09PSBVbnNpZ25lZEludDI0OFR5cGUgfHxcblx0XHRcdFx0XHRcdHRhcmdldFR5cGUgPT09IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSB8fFxuXHRcdFx0XHRcdFx0dGFyZ2V0VHlwZSA9PT0gVW5zaWduZWRTaG9ydDU1NTFUeXBlO1xuXG5cdFx0XHRcdFx0Y29uc3QgY2xlYXJDb2xvciA9IGJhY2tncm91bmQuZ2V0Q2xlYXJDb2xvcigpO1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBiYWNrZ3JvdW5kLmdldENsZWFyQWxwaGEoKTtcblx0XHRcdFx0XHRjb25zdCByID0gY2xlYXJDb2xvci5yO1xuXHRcdFx0XHRcdGNvbnN0IGcgPSBjbGVhckNvbG9yLmc7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGNsZWFyQ29sb3IuYjtcblxuXHRcdFx0XHRcdGlmICggaXNVbnNpZ25lZFR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdHVpbnRDbGVhckNvbG9yWyAwIF0gPSByO1xuXHRcdFx0XHRcdFx0dWludENsZWFyQ29sb3JbIDEgXSA9IGc7XG5cdFx0XHRcdFx0XHR1aW50Q2xlYXJDb2xvclsgMiBdID0gYjtcblx0XHRcdFx0XHRcdHVpbnRDbGVhckNvbG9yWyAzIF0gPSBhO1xuXHRcdFx0XHRcdFx0X2dsLmNsZWFyQnVmZmVydWl2KCBfZ2wuQ09MT1IsIDAsIHVpbnRDbGVhckNvbG9yICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpbnRDbGVhckNvbG9yWyAwIF0gPSByO1xuXHRcdFx0XHRcdFx0aW50Q2xlYXJDb2xvclsgMSBdID0gZztcblx0XHRcdFx0XHRcdGludENsZWFyQ29sb3JbIDIgXSA9IGI7XG5cdFx0XHRcdFx0XHRpbnRDbGVhckNvbG9yWyAzIF0gPSBhO1xuXHRcdFx0XHRcdFx0X2dsLmNsZWFyQnVmZmVyaXYoIF9nbC5DT0xPUiwgMCwgaW50Q2xlYXJDb2xvciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcblx0XHRcdGlmICggc3RlbmNpbCApIHtcblxuXHRcdFx0XHRiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cdFx0XHRcdHRoaXMuc3RhdGUuYnVmZmVycy5zdGVuY2lsLnNldE1hc2soIDB4ZmZmZmZmZmYgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuY2xlYXIoIGJpdHMgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuY2xlYXIoIHRydWUsIGZhbHNlLCBmYWxzZSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5jbGVhciggZmFsc2UsIHRydWUsIGZhbHNlICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuY2xlYXIoIGZhbHNlLCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0fTtcblxuXHRcdC8vXG5cblx0XHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cdFx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgb25Db250ZXh0UmVzdG9yZSwgZmFsc2UgKTtcblx0XHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcicsIG9uQ29udGV4dENyZWF0aW9uRXJyb3IsIGZhbHNlICk7XG5cblx0XHRcdHJlbmRlckxpc3RzLmRpc3Bvc2UoKTtcblx0XHRcdHJlbmRlclN0YXRlcy5kaXNwb3NlKCk7XG5cdFx0XHRwcm9wZXJ0aWVzLmRpc3Bvc2UoKTtcblx0XHRcdGN1YmVtYXBzLmRpc3Bvc2UoKTtcblx0XHRcdGN1YmV1dm1hcHMuZGlzcG9zZSgpO1xuXHRcdFx0b2JqZWN0cy5kaXNwb3NlKCk7XG5cdFx0XHRiaW5kaW5nU3RhdGVzLmRpc3Bvc2UoKTtcblx0XHRcdHVuaWZvcm1zR3JvdXBzLmRpc3Bvc2UoKTtcblx0XHRcdHByb2dyYW1DYWNoZS5kaXNwb3NlKCk7XG5cblx0XHRcdHhyLmRpc3Bvc2UoKTtcblxuXHRcdFx0eHIucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Nlc3Npb25zdGFydCcsIG9uWFJTZXNzaW9uU3RhcnQgKTtcblx0XHRcdHhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzZXNzaW9uZW5kJywgb25YUlNlc3Npb25FbmQgKTtcblxuXHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblxuXHRcdH07XG5cblx0XHQvLyBFdmVudHNcblxuXHRcdGZ1bmN0aW9uIG9uQ29udGV4dExvc3QoIGV2ZW50ICkge1xuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENvbnRleHQgTG9zdC4nICk7XG5cblx0XHRcdF9pc0NvbnRleHRMb3N0ID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uQ29udGV4dFJlc3RvcmUoIC8qIGV2ZW50ICovICkge1xuXG5cdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENvbnRleHQgUmVzdG9yZWQuJyApO1xuXG5cdFx0XHRfaXNDb250ZXh0TG9zdCA9IGZhbHNlO1xuXG5cdFx0XHRjb25zdCBpbmZvQXV0b1Jlc2V0ID0gaW5mby5hdXRvUmVzZXQ7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXBFbmFibGVkID0gc2hhZG93TWFwLmVuYWJsZWQ7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXBBdXRvVXBkYXRlID0gc2hhZG93TWFwLmF1dG9VcGRhdGU7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXBOZWVkc1VwZGF0ZSA9IHNoYWRvd01hcC5uZWVkc1VwZGF0ZTtcblx0XHRcdGNvbnN0IHNoYWRvd01hcFR5cGUgPSBzaGFkb3dNYXAudHlwZTtcblxuXHRcdFx0aW5pdEdMQ29udGV4dCgpO1xuXG5cdFx0XHRpbmZvLmF1dG9SZXNldCA9IGluZm9BdXRvUmVzZXQ7XG5cdFx0XHRzaGFkb3dNYXAuZW5hYmxlZCA9IHNoYWRvd01hcEVuYWJsZWQ7XG5cdFx0XHRzaGFkb3dNYXAuYXV0b1VwZGF0ZSA9IHNoYWRvd01hcEF1dG9VcGRhdGU7XG5cdFx0XHRzaGFkb3dNYXAubmVlZHNVcGRhdGUgPSBzaGFkb3dNYXBOZWVkc1VwZGF0ZTtcblx0XHRcdHNoYWRvd01hcC50eXBlID0gc2hhZG93TWFwVHlwZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uQ29udGV4dENyZWF0aW9uRXJyb3IoIGV2ZW50ICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQSBXZWJHTCBjb250ZXh0IGNvdWxkIG5vdCBiZSBjcmVhdGVkLiBSZWFzb246ICcsIGV2ZW50LnN0YXR1c01lc3NhZ2UgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTWF0ZXJpYWxEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBldmVudC50YXJnZXQ7XG5cblx0XHRcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHRcdFx0ZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQnVmZmVyIGRlYWxsb2NhdGlvblxuXG5cdFx0ZnVuY3Rpb24gZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0cmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZXMoIG1hdGVyaWFsICk7XG5cblx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKCBtYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlcyggbWF0ZXJpYWwgKSB7XG5cblx0XHRcdGNvbnN0IHByb2dyYW1zID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICkucHJvZ3JhbXM7XG5cblx0XHRcdGlmICggcHJvZ3JhbXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwcm9ncmFtcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHByb2dyYW0gKSB7XG5cblx0XHRcdFx0XHRwcm9ncmFtQ2FjaGUucmVsZWFzZVByb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0cHJvZ3JhbUNhY2hlLnJlbGVhc2VTaGFkZXJDYWNoZSggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEJ1ZmZlciByZW5kZXJpbmdcblxuXHRcdHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKSB7XG5cblx0XHRcdGlmICggc2NlbmUgPT09IG51bGwgKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyByZW5kZXJCdWZmZXJEaXJlY3Qgc2Vjb25kIHBhcmFtZXRlciB1c2VkIHRvIGJlIGZvZyAoY291bGQgYmUgbnVsbClcblxuXHRcdFx0Y29uc3QgZnJvbnRGYWNlQ1cgPSAoIG9iamVjdC5pc01lc2ggJiYgb2JqZWN0Lm1hdHJpeFdvcmxkLmRldGVybWluYW50KCkgPCAwICk7XG5cblx0XHRcdGNvbnN0IHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0XHRzdGF0ZS5zZXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZyb250RmFjZUNXICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdGxldCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0bGV0IHJhbmdlRmFjdG9yID0gMTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0aW5kZXggPSBnZW9tZXRyaWVzLmdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKTtcblxuXHRcdFx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdFx0cmFuZ2VGYWN0b3IgPSAyO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0bGV0IGRyYXdTdGFydCA9IGRyYXdSYW5nZS5zdGFydCAqIHJhbmdlRmFjdG9yO1xuXHRcdFx0bGV0IGRyYXdFbmQgPSAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICogcmFuZ2VGYWN0b3I7XG5cblx0XHRcdGlmICggZ3JvdXAgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0ZHJhd1N0YXJ0ID0gTWF0aC5tYXgoIGRyYXdTdGFydCwgZ3JvdXAuc3RhcnQgKiByYW5nZUZhY3RvciApO1xuXHRcdFx0XHRkcmF3RW5kID0gTWF0aC5taW4oIGRyYXdFbmQsICggZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCApICogcmFuZ2VGYWN0b3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGRyYXdTdGFydCA9IE1hdGgubWF4KCBkcmF3U3RhcnQsIDAgKTtcblx0XHRcdFx0ZHJhd0VuZCA9IE1hdGgubWluKCBkcmF3RW5kLCBpbmRleC5jb3VudCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGRyYXdTdGFydCA9IE1hdGgubWF4KCBkcmF3U3RhcnQsIDAgKTtcblx0XHRcdFx0ZHJhd0VuZCA9IE1hdGgubWluKCBkcmF3RW5kLCBwb3NpdGlvbi5jb3VudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRyYXdDb3VudCA9IGRyYXdFbmQgLSBkcmF3U3RhcnQ7XG5cblx0XHRcdGlmICggZHJhd0NvdW50IDwgMCB8fCBkcmF3Q291bnQgPT09IEluZmluaXR5ICkgcmV0dXJuO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRiaW5kaW5nU3RhdGVzLnNldHVwKCBvYmplY3QsIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgaW5kZXggKTtcblxuXHRcdFx0bGV0IGF0dHJpYnV0ZTtcblx0XHRcdGxldCByZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0KCBpbmRleCApO1xuXG5cdFx0XHRcdHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuXHRcdFx0XHRyZW5kZXJlci5zZXRJbmRleCggYXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0aWYgKCBvYmplY3QuaXNNZXNoICkge1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkgKTtcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFUyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGluZSApIHtcblxuXHRcdFx0XHRsZXQgbGluZVdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoO1xuXG5cdFx0XHRcdGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxuXG5cdFx0XHRcdHN0YXRlLnNldExpbmVXaWR0aCggbGluZVdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpICk7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuaXNMaW5lU2VnbWVudHMgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lTG9vcCApIHtcblxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX0xPT1AgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVfU1RSSVAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc1BvaW50cyApIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuUE9JTlRTICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc1Nwcml0ZSApIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVTICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvYmplY3QuaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5fbXVsdGlEcmF3SW5zdGFuY2VzICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyZXIucmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzKCBvYmplY3QuX211bHRpRHJhd1N0YXJ0cywgb2JqZWN0Ll9tdWx0aURyYXdDb3VudHMsIG9iamVjdC5fbXVsdGlEcmF3Q291bnQsIG9iamVjdC5fbXVsdGlEcmF3SW5zdGFuY2VzICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJlbmRlcmVyLnJlbmRlck11bHRpRHJhdyggb2JqZWN0Ll9tdWx0aURyYXdTdGFydHMsIG9iamVjdC5fbXVsdGlEcmF3Q291bnRzLCBvYmplY3QuX211bHRpRHJhd0NvdW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICkge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyggZHJhd1N0YXJ0LCBkcmF3Q291bnQsIG9iamVjdC5jb3VudCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdGNvbnN0IG1heEluc3RhbmNlQ291bnQgPSBnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgOiBJbmZpbml0eTtcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VDb3VudCA9IE1hdGgubWluKCBnZW9tZXRyeS5pbnN0YW5jZUNvdW50LCBtYXhJbnN0YW5jZUNvdW50ICk7XG5cblx0XHRcdFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKCBkcmF3U3RhcnQsIGRyYXdDb3VudCwgaW5zdGFuY2VDb3VudCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlciggZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdC8vIENvbXBpbGVcblxuXHRcdGZ1bmN0aW9uIHByZXBhcmVNYXRlcmlhbCggbWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QgKSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWUgJiYgbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSAmJiBtYXRlcmlhbC5mb3JjZVNpbmdsZVBhc3MgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBCYWNrU2lkZTtcblx0XHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRnZXRQcm9ncmFtKCBtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCApO1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBGcm9udFNpZGU7XG5cdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Z2V0UHJvZ3JhbSggbWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QgKTtcblxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRnZXRQcm9ncmFtKCBtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmNvbXBpbGUgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHRhcmdldFNjZW5lID0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCB0YXJnZXRTY2VuZSA9PT0gbnVsbCApIHRhcmdldFNjZW5lID0gc2NlbmU7XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlcy5nZXQoIHRhcmdldFNjZW5lICk7XG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuaW5pdCggY2FtZXJhICk7XG5cblx0XHRcdHJlbmRlclN0YXRlU3RhY2sucHVzaCggY3VycmVudFJlbmRlclN0YXRlICk7XG5cblx0XHRcdC8vIGdhdGhlciBsaWdodHMgZnJvbSBib3RoIHRoZSB0YXJnZXQgc2NlbmUgYW5kIHRoZSBuZXcgb2JqZWN0IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2NlbmUuXG5cblx0XHRcdHRhcmdldFNjZW5lLnRyYXZlcnNlVmlzaWJsZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuaXNMaWdodCAmJiBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoTGlnaHQoIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuY2FzdFNoYWRvdyApIHtcblxuXHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3coIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIHNjZW5lICE9PSB0YXJnZXRTY2VuZSApIHtcblxuXHRcdFx0XHRzY2VuZS50cmF2ZXJzZVZpc2libGUoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuaXNMaWdodCAmJiBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSApIHtcblxuXHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hMaWdodCggb2JqZWN0ICk7XG5cblx0XHRcdFx0XHRcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3coIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0cygpO1xuXG5cdFx0XHQvLyBPbmx5IGluaXRpYWxpemUgbWF0ZXJpYWxzIGluIHRoZSBuZXcgc2NlbmUsIG5vdCB0aGUgdGFyZ2V0U2NlbmUuXG5cblx0XHRcdGNvbnN0IG1hdGVyaWFscyA9IG5ldyBTZXQoKTtcblxuXHRcdFx0c2NlbmUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1hdGVyaWFsLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbDIgPSBtYXRlcmlhbFsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdHByZXBhcmVNYXRlcmlhbCggbWF0ZXJpYWwyLCB0YXJnZXRTY2VuZSwgb2JqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFscy5hZGQoIG1hdGVyaWFsMiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwcmVwYXJlTWF0ZXJpYWwoIG1hdGVyaWFsLCB0YXJnZXRTY2VuZSwgb2JqZWN0ICk7XG5cdFx0XHRcdFx0XHRtYXRlcmlhbHMuYWRkKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZW5kZXJTdGF0ZVN0YWNrLnBvcCgpO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFscztcblxuXHRcdH07XG5cblx0XHQvLyBjb21waWxlQXN5bmNcblxuXHRcdHRoaXMuY29tcGlsZUFzeW5jID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCB0YXJnZXRTY2VuZSA9IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFscyA9IHRoaXMuY29tcGlsZSggc2NlbmUsIGNhbWVyYSwgdGFyZ2V0U2NlbmUgKTtcblxuXHRcdFx0Ly8gV2FpdCBmb3IgYWxsIHRoZSBtYXRlcmlhbHMgaW4gdGhlIG5ldyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCB0aGV5J3JlXG5cdFx0XHQvLyByZWFkeSB0byBiZSB1c2VkIGJlZm9yZSByZXNvbHZpbmcgdGhlIHByb21pc2UuXG5cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSggKCByZXNvbHZlICkgPT4ge1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGNoZWNrTWF0ZXJpYWxzUmVhZHkoKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbHMuZm9yRWFjaCggZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0XHRjb25zdCBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLmN1cnJlbnRQcm9ncmFtO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHByb2dyYW0uaXNSZWFkeSgpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHJlbW92ZSBhbnkgcHJvZ3JhbXMgdGhhdCByZXBvcnQgdGhleSdyZSByZWFkeSB0byB1c2UgZnJvbSB0aGUgbGlzdFxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbHMuZGVsZXRlKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHQvLyBvbmNlIHRoZSBsaXN0IG9mIGNvbXBpbGluZyBtYXRlcmlhbHMgaXMgZW1wdHksIGNhbGwgdGhlIGNhbGxiYWNrXG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFscy5zaXplID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRyZXNvbHZlKCBzY2VuZSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaWYgc29tZSBtYXRlcmlhbHMgYXJlIHN0aWxsIG5vdCByZWFkeSwgd2FpdCBhIGJpdCBhbmQgY2hlY2sgYWdhaW5cblxuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGNoZWNrTWF0ZXJpYWxzUmVhZHksIDEwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9ucy5nZXQoICdLSFJfcGFyYWxsZWxfc2hhZGVyX2NvbXBpbGUnICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBjYW4gY2hlY2sgdGhlIGNvbXBpbGF0aW9uIHN0YXR1cyBvZiB0aGUgbWF0ZXJpYWxzIHdpdGhvdXRcblx0XHRcdFx0XHQvLyBibG9ja2luZyB0aGVuIGRvIHNvIHJpZ2h0IGF3YXkuXG5cblx0XHRcdFx0XHRjaGVja01hdGVyaWFsc1JlYWR5KCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBzdGFydCBieSB3YWl0aW5nIGEgYml0IHRvIGdpdmUgdGhlIG1hdGVyaWFscyB3ZSBqdXN0XG5cdFx0XHRcdFx0Ly8gaW5pdGlhbGl6ZWQgYSBjaGFuY2UgdG8gZmluaXNoLlxuXG5cdFx0XHRcdFx0c2V0VGltZW91dCggY2hlY2tNYXRlcmlhbHNSZWFkeSwgMTAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdH07XG5cblx0XHQvLyBBbmltYXRpb24gTG9vcFxuXG5cdFx0bGV0IG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiBvbkFuaW1hdGlvbkZyYW1lKCB0aW1lICkge1xuXG5cdFx0XHRpZiAoIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayApIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayggdGltZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25YUlNlc3Npb25TdGFydCgpIHtcblxuXHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uWFJTZXNzaW9uRW5kKCkge1xuXG5cdFx0XHRhbmltYXRpb24uc3RhcnQoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBXZWJHTEFuaW1hdGlvbigpO1xuXHRcdGFuaW1hdGlvbi5zZXRBbmltYXRpb25Mb29wKCBvbkFuaW1hdGlvbkZyYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyApIGFuaW1hdGlvbi5zZXRDb250ZXh0KCBzZWxmICk7XG5cblx0XHR0aGlzLnNldEFuaW1hdGlvbkxvb3AgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0XHRvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHhyLnNldEFuaW1hdGlvbkxvb3AoIGNhbGxiYWNrICk7XG5cblx0XHRcdCggY2FsbGJhY2sgPT09IG51bGwgKSA/IGFuaW1hdGlvbi5zdG9wKCkgOiBhbmltYXRpb24uc3RhcnQoKTtcblxuXHRcdH07XG5cblx0XHR4ci5hZGRFdmVudExpc3RlbmVyKCAnc2Vzc2lvbnN0YXJ0Jywgb25YUlNlc3Npb25TdGFydCApO1xuXHRcdHhyLmFkZEV2ZW50TGlzdGVuZXIoICdzZXNzaW9uZW5kJywgb25YUlNlc3Npb25FbmQgKTtcblxuXHRcdC8vIFJlbmRlcmluZ1xuXG5cdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRcdGlmICggY2FtZXJhICE9PSB1bmRlZmluZWQgJiYgY2FtZXJhLmlzQ2FtZXJhICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBfaXNDb250ZXh0TG9zdCA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRcdGlmICggc2NlbmUubWF0cml4V29ybGRBdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG5cdFx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgJiYgY2FtZXJhLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHRpZiAoIHhyLmVuYWJsZWQgPT09IHRydWUgJiYgeHIuaXNQcmVzZW50aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGlmICggeHIuY2FtZXJhQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHhyLnVwZGF0ZUNhbWVyYSggY2FtZXJhICk7XG5cblx0XHRcdFx0Y2FtZXJhID0geHIuZ2V0Q2FtZXJhKCk7IC8vIHVzZSBYUiBjYW1lcmEgZm9yIHJlbmRlcmluZ1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cdFx0XHRpZiAoIHNjZW5lLmlzU2NlbmUgPT09IHRydWUgKSBzY2VuZS5vbkJlZm9yZVJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50UmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlcy5nZXQoIHNjZW5lLCByZW5kZXJTdGF0ZVN0YWNrLmxlbmd0aCApO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLmluaXQoIGNhbWVyYSApO1xuXG5cdFx0XHRyZW5kZXJTdGF0ZVN0YWNrLnB1c2goIGN1cnJlbnRSZW5kZXJTdGF0ZSApO1xuXG5cdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdFx0X2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdF9sb2NhbENsaXBwaW5nRW5hYmxlZCA9IHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQ7XG5cdFx0XHRfY2xpcHBpbmdFbmFibGVkID0gY2xpcHBpbmcuaW5pdCggdGhpcy5jbGlwcGluZ1BsYW5lcywgX2xvY2FsQ2xpcHBpbmdFbmFibGVkICk7XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0ID0gcmVuZGVyTGlzdHMuZ2V0KCBzY2VuZSwgcmVuZGVyTGlzdFN0YWNrLmxlbmd0aCApO1xuXHRcdFx0Y3VycmVudFJlbmRlckxpc3QuaW5pdCgpO1xuXG5cdFx0XHRyZW5kZXJMaXN0U3RhY2sucHVzaCggY3VycmVudFJlbmRlckxpc3QgKTtcblxuXHRcdFx0aWYgKCB4ci5lbmFibGVkID09PSB0cnVlICYmIHhyLmlzUHJlc2VudGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjb25zdCBkZXB0aFNlbnNpbmdNZXNoID0gX3RoaXMueHIuZ2V0RGVwdGhTZW5zaW5nTWVzaCgpO1xuXG5cdFx0XHRcdGlmICggZGVwdGhTZW5zaW5nTWVzaCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHByb2plY3RPYmplY3QoIGRlcHRoU2Vuc2luZ01lc2gsIGNhbWVyYSwgLSBJbmZpbml0eSwgX3RoaXMuc29ydE9iamVjdHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIGNhbWVyYSwgMCwgX3RoaXMuc29ydE9iamVjdHMgKTtcblxuXHRcdFx0Y3VycmVudFJlbmRlckxpc3QuZmluaXNoKCk7XG5cblx0XHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3Quc29ydCggX29wYXF1ZVNvcnQsIF90cmFuc3BhcmVudFNvcnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfcmVuZGVyQmFja2dyb3VuZCA9IHhyLmVuYWJsZWQgPT09IGZhbHNlIHx8IHhyLmlzUHJlc2VudGluZyA9PT0gZmFsc2UgfHwgeHIuaGFzRGVwdGhTZW5zaW5nKCkgPT09IGZhbHNlO1xuXHRcdFx0aWYgKCBfcmVuZGVyQmFja2dyb3VuZCApIHtcblxuXHRcdFx0XHRiYWNrZ3JvdW5kLmFkZFRvUmVuZGVyTGlzdCggY3VycmVudFJlbmRlckxpc3QsIHNjZW5lICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0dGhpcy5pbmZvLnJlbmRlci5mcmFtZSArKztcblxuXHRcdFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlICkgY2xpcHBpbmcuYmVnaW5TaGFkb3dzKCk7XG5cblx0XHRcdGNvbnN0IHNoYWRvd3NBcnJheSA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5zaGFkb3dzQXJyYXk7XG5cblx0XHRcdHNoYWRvd01hcC5yZW5kZXIoIHNoYWRvd3NBcnJheSwgc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUgKSBjbGlwcGluZy5lbmRTaGFkb3dzKCk7XG5cblx0XHRcdC8vXG5cblx0XHRcdGlmICggdGhpcy5pbmZvLmF1dG9SZXNldCA9PT0gdHJ1ZSApIHRoaXMuaW5mby5yZXNldCgpO1xuXG5cdFx0XHQvLyByZW5kZXIgc2NlbmVcblxuXHRcdFx0Y29uc3Qgb3BhcXVlT2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0Lm9wYXF1ZTtcblx0XHRcdGNvbnN0IHRyYW5zbWlzc2l2ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc21pc3NpdmU7XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0cygpO1xuXG5cdFx0XHRpZiAoIGNhbWVyYS5pc0FycmF5Q2FtZXJhICkge1xuXG5cdFx0XHRcdGNvbnN0IGNhbWVyYXMgPSBjYW1lcmEuY2FtZXJhcztcblxuXHRcdFx0XHRpZiAoIHRyYW5zbWlzc2l2ZU9iamVjdHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNhbWVyYXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY2FtZXJhMiA9IGNhbWVyYXNbIGkgXTtcblxuXHRcdFx0XHRcdFx0cmVuZGVyVHJhbnNtaXNzaW9uUGFzcyggb3BhcXVlT2JqZWN0cywgdHJhbnNtaXNzaXZlT2JqZWN0cywgc2NlbmUsIGNhbWVyYTIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBfcmVuZGVyQmFja2dyb3VuZCApIGJhY2tncm91bmQucmVuZGVyKCBzY2VuZSApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNhbWVyYXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNhbWVyYTIgPSBjYW1lcmFzWyBpIF07XG5cblx0XHRcdFx0XHRyZW5kZXJTY2VuZSggY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEyLCBjYW1lcmEyLnZpZXdwb3J0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggdHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwICkgcmVuZGVyVHJhbnNtaXNzaW9uUGFzcyggb3BhcXVlT2JqZWN0cywgdHJhbnNtaXNzaXZlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0XHRcdGlmICggX3JlbmRlckJhY2tncm91bmQgKSBiYWNrZ3JvdW5kLnJlbmRlciggc2NlbmUgKTtcblxuXHRcdFx0XHRyZW5kZXJTY2VuZSggY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRpZiAoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIHJlc29sdmUgbXVsdGlzYW1wbGUgcmVuZGVyYnVmZmVycyB0byBhIHNpbmdsZS1zYW1wbGUgdGV4dHVyZSBpZiBuZWNlc3NhcnlcblxuXHRcdFx0XHR0ZXh0dXJlcy51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldCggX2N1cnJlbnRSZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHQvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xuXG5cdFx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggX2N1cnJlbnRSZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRpZiAoIHNjZW5lLmlzU2NlbmUgPT09IHRydWUgKSBzY2VuZS5vbkFmdGVyUmVuZGVyKCBfdGhpcywgc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0XHQvLyBfZ2wuZmluaXNoKCk7XG5cblx0XHRcdGJpbmRpbmdTdGF0ZXMucmVzZXREZWZhdWx0U3RhdGUoKTtcblx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcblx0XHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcblxuXHRcdFx0cmVuZGVyU3RhdGVTdGFjay5wb3AoKTtcblxuXHRcdFx0aWYgKCByZW5kZXJTdGF0ZVN0YWNrLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVTdGFja1sgcmVuZGVyU3RhdGVTdGFjay5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlICkgY2xpcHBpbmcuc2V0R2xvYmFsU3RhdGUoIF90aGlzLmNsaXBwaW5nUGxhbmVzLCBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUuY2FtZXJhICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZW5kZXJMaXN0U3RhY2sucG9wKCk7XG5cblx0XHRcdGlmICggcmVuZGVyTGlzdFN0YWNrLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QgPSByZW5kZXJMaXN0U3RhY2tbIHJlbmRlckxpc3RTdGFjay5sZW5ndGggLSAxIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QgPSBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJvamVjdE9iamVjdCggb2JqZWN0LCBjYW1lcmEsIGdyb3VwT3JkZXIsIHNvcnRPYmplY3RzICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0Y29uc3QgdmlzaWJsZSA9IG9iamVjdC5sYXllcnMudGVzdCggY2FtZXJhLmxheWVycyApO1xuXG5cdFx0XHRpZiAoIHZpc2libGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuaXNHcm91cCApIHtcblxuXHRcdFx0XHRcdGdyb3VwT3JkZXIgPSBvYmplY3QucmVuZGVyT3JkZXI7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTE9EICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIG9iamVjdC51cGRhdGUoIGNhbWVyYSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xpZ2h0ICkge1xuXG5cdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hMaWdodCggb2JqZWN0ICk7XG5cblx0XHRcdFx0XHRpZiAoIG9iamVjdC5jYXN0U2hhZG93ICkge1xuXG5cdFx0XHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUucHVzaFNoYWRvdyggb2JqZWN0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzU3ByaXRlICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIG9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNTcHJpdGUoIG9iamVjdCApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNvcnRPYmplY3RzICkge1xuXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkIClcblx0XHRcdFx0XHRcdFx0XHQuYXBwbHlNYXRyaXg0KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwudmlzaWJsZSApIHtcblxuXHRcdFx0XHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjMueiwgbnVsbCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cyApIHtcblxuXHRcdFx0XHRcdGlmICggISBvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0aWYgKCBzb3J0T2JqZWN0cyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBvYmplY3QuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBvYmplY3QuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdFx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuY29weSggb2JqZWN0LmJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdFx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkIClcblx0XHRcdFx0XHRcdFx0XHQuYXBwbHlNYXRyaXg0KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBncm91cE1hdGVyaWFsICYmIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QucHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjMueiwgZ3JvdXAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QucHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIF92ZWN0b3IzLnosIG51bGwgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRwcm9qZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBjYW1lcmEsIGdyb3VwT3JkZXIsIHNvcnRPYmplY3RzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlclNjZW5lKCBjdXJyZW50UmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSwgdmlld3BvcnQgKSB7XG5cblx0XHRcdGNvbnN0IG9wYXF1ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC5vcGFxdWU7XG5cdFx0XHRjb25zdCB0cmFuc21pc3NpdmVPYmplY3RzID0gY3VycmVudFJlbmRlckxpc3QudHJhbnNtaXNzaXZlO1xuXHRcdFx0Y29uc3QgdHJhbnNwYXJlbnRPYmplY3RzID0gY3VycmVudFJlbmRlckxpc3QudHJhbnNwYXJlbnQ7XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0c1ZpZXcoIGNhbWVyYSApO1xuXG5cdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUgKSBjbGlwcGluZy5zZXRHbG9iYWxTdGF0ZSggX3RoaXMuY2xpcHBpbmdQbGFuZXMsIGNhbWVyYSApO1xuXG5cdFx0XHRpZiAoIHZpZXdwb3J0ICkgc3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQuY29weSggdmlld3BvcnQgKSApO1xuXG5cdFx0XHRpZiAoIG9wYXF1ZU9iamVjdHMubGVuZ3RoID4gMCApIHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEgKTtcblx0XHRcdGlmICggdHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwICkgcmVuZGVyT2JqZWN0cyggdHJhbnNtaXNzaXZlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xuXHRcdFx0aWYgKCB0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID4gMCApIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0XHQvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxuXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoIHRydWUgKTtcblx0XHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayggdHJ1ZSApO1xuXHRcdFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRNYXNrKCB0cnVlICk7XG5cblx0XHRcdHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXJUcmFuc21pc3Npb25QYXNzKCBvcGFxdWVPYmplY3RzLCB0cmFuc21pc3NpdmVPYmplY3RzLCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0XHRjb25zdCBvdmVycmlkZU1hdGVyaWFsID0gc2NlbmUuaXNTY2VuZSA9PT0gdHJ1ZSA/IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgOiBudWxsO1xuXG5cdFx0XHRpZiAoIG92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLnRyYW5zbWlzc2lvblJlbmRlclRhcmdldFsgY2FtZXJhLmlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUudHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0WyBjYW1lcmEuaWQgXSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCggMSwgMSwge1xuXHRcdFx0XHRcdGdlbmVyYXRlTWlwbWFwczogdHJ1ZSxcblx0XHRcdFx0XHR0eXBlOiAoIGV4dGVuc2lvbnMuaGFzKCAnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JyApIHx8IGV4dGVuc2lvbnMuaGFzKCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcgKSApID8gSGFsZkZsb2F0VHlwZSA6IFVuc2lnbmVkQnl0ZVR5cGUsXG5cdFx0XHRcdFx0bWluRmlsdGVyOiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdFx0XHRcdFx0c2FtcGxlczogNCxcblx0XHRcdFx0XHRzdGVuY2lsQnVmZmVyOiBzdGVuY2lsLFxuXHRcdFx0XHRcdHJlc29sdmVEZXB0aEJ1ZmZlcjogZmFsc2UsXG5cdFx0XHRcdFx0cmVzb2x2ZVN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxuXHRcdFx0XHRcdGNvbG9yU3BhY2U6IENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSxcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIGRlYnVnXG5cblx0XHRcdFx0Lypcblx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgUGxhbmVHZW9tZXRyeSgpO1xuXHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBtYXA6IF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQudGV4dHVyZSB9ICk7XG5cblx0XHRcdFx0Y29uc3QgbWVzaCA9IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0c2NlbmUuYWRkKCBtZXNoICk7XG5cdFx0XHRcdCovXG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ID0gY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLnRyYW5zbWlzc2lvblJlbmRlclRhcmdldFsgY2FtZXJhLmlkIF07XG5cblx0XHRcdGNvbnN0IGFjdGl2ZVZpZXdwb3J0ID0gY2FtZXJhLnZpZXdwb3J0IHx8IF9jdXJyZW50Vmlld3BvcnQ7XG5cdFx0XHR0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQuc2V0U2l6ZSggYWN0aXZlVmlld3BvcnQueiwgYWN0aXZlVmlld3BvcnQudyApO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gX3RoaXMuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0XHRfdGhpcy5zZXRSZW5kZXJUYXJnZXQoIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRfdGhpcy5nZXRDbGVhckNvbG9yKCBfY3VycmVudENsZWFyQ29sb3IgKTtcblx0XHRcdF9jdXJyZW50Q2xlYXJBbHBoYSA9IF90aGlzLmdldENsZWFyQWxwaGEoKTtcblx0XHRcdGlmICggX2N1cnJlbnRDbGVhckFscGhhIDwgMSApIF90aGlzLnNldENsZWFyQ29sb3IoIDB4ZmZmZmZmLCAwLjUgKTtcblxuXHRcdFx0aWYgKCBfcmVuZGVyQmFja2dyb3VuZCApIHtcblxuXHRcdFx0XHRiYWNrZ3JvdW5kLnJlbmRlciggc2NlbmUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfdGhpcy5jbGVhcigpO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIHRoZSBmZWF0dXJlcyB3aGljaCBjYW4gYWZmZWN0IHRoZSBmcmFnIGNvbG9yIGZvciBvcGFxdWUgb2JqZWN0cyBwYXNzLlxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHRoZXkgYXJlIGFwcGxpZWQgdHdpY2UgaW4gb3BhcXVlIG9iamVjdHMgcGFzcyBhbmQgdHJhbnNtaXNzaW9uIG9iamVjdHMgcGFzcy5cblx0XHRcdGNvbnN0IGN1cnJlbnRUb25lTWFwcGluZyA9IF90aGlzLnRvbmVNYXBwaW5nO1xuXHRcdFx0X3RoaXMudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXG5cdFx0XHQvLyBSZW1vdmUgdmlld3BvcnQgZnJvbSBjYW1lcmEgdG8gYXZvaWQgbmVzdGVkIHJlbmRlciBjYWxscyByZXNldHRpbmcgdmlld3BvcnQgdG8gaXQgKGUuZyBSZWZsZWN0b3IpLlxuXHRcdFx0Ly8gVHJhbnNtaXNzaW9uIHJlbmRlciBwYXNzIHJlcXVpcmVzIHZpZXdwb3J0IHRvIG1hdGNoIHRoZSB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQuXG5cdFx0XHRjb25zdCBjdXJyZW50Q2FtZXJhVmlld3BvcnQgPSBjYW1lcmEudmlld3BvcnQ7XG5cdFx0XHRpZiAoIGNhbWVyYS52aWV3cG9ydCAhPT0gdW5kZWZpbmVkICkgY2FtZXJhLnZpZXdwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuc2V0dXBMaWdodHNWaWV3KCBjYW1lcmEgKTtcblxuXHRcdFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlICkgY2xpcHBpbmcuc2V0R2xvYmFsU3RhdGUoIF90aGlzLmNsaXBwaW5nUGxhbmVzLCBjYW1lcmEgKTtcblxuXHRcdFx0cmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0XHR0ZXh0dXJlcy51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldCggdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICk7XG5cdFx0XHR0ZXh0dXJlcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbnMuaGFzKCAnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyApID09PSBmYWxzZSApIHsgLy8gc2VlICMyODEzMVxuXG5cdFx0XHRcdGxldCByZW5kZXJUYXJnZXROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRyYW5zbWlzc2l2ZU9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSB0cmFuc21pc3NpdmVPYmplY3RzWyBpIF07XG5cblx0XHRcdFx0XHRjb25zdCBvYmplY3QgPSByZW5kZXJJdGVtLm9iamVjdDtcblx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XG5cdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSByZW5kZXJJdGVtLm1hdGVyaWFsO1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gcmVuZGVySXRlbS5ncm91cDtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSAmJiBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY3VycmVudFNpZGUgPSBtYXRlcmlhbC5zaWRlO1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gQmFja1NpZGU7XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdHJlbmRlck9iamVjdCggb2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBjdXJyZW50U2lkZTtcblx0XHRcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0TmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldE5lZWRzVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZXMudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCApO1xuXHRcdFx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF90aGlzLnNldFJlbmRlclRhcmdldCggY3VycmVudFJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRfdGhpcy5zZXRDbGVhckNvbG9yKCBfY3VycmVudENsZWFyQ29sb3IsIF9jdXJyZW50Q2xlYXJBbHBoYSApO1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRDYW1lcmFWaWV3cG9ydCAhPT0gdW5kZWZpbmVkICkgY2FtZXJhLnZpZXdwb3J0ID0gY3VycmVudENhbWVyYVZpZXdwb3J0O1xuXG5cdFx0XHRfdGhpcy50b25lTWFwcGluZyA9IGN1cnJlbnRUb25lTWFwcGluZztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRcdGNvbnN0IG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5pc1NjZW5lID09PSB0cnVlID8gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA6IG51bGw7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFsgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IHJlbmRlckl0ZW0ub2JqZWN0O1xuXHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gbnVsbCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xuXHRcdFx0XHRjb25zdCBncm91cCA9IHJlbmRlckl0ZW0uZ3JvdXA7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSApIHtcblxuXHRcdFx0XHRcdHJlbmRlck9iamVjdCggb2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApIHtcblxuXHRcdFx0b2JqZWN0Lm9uQmVmb3JlUmVuZGVyKCBfdGhpcywgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xuXG5cdFx0XHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0b2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcblxuXHRcdFx0bWF0ZXJpYWwub25CZWZvcmVSZW5kZXIoIF90aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgb2JqZWN0LCBncm91cCApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICYmIG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUgJiYgbWF0ZXJpYWwuZm9yY2VTaW5nbGVQYXNzID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gQmFja1NpZGU7XG5cdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRnJvbnRTaWRlO1xuXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBzY2VuZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XG5cblx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9IERvdWJsZVNpZGU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3Qub25BZnRlclJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFByb2dyYW0oIG1hdGVyaWFsLCBzY2VuZSwgb2JqZWN0ICkge1xuXG5cdFx0XHRpZiAoIHNjZW5lLmlzU2NlbmUgIT09IHRydWUgKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyBzY2VuZSBjb3VsZCBiZSBhIE1lc2gsIExpbmUsIFBvaW50cywgLi4uXG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xuXG5cdFx0XHRjb25zdCBsaWdodHMgPSBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUubGlnaHRzO1xuXHRcdFx0Y29uc3Qgc2hhZG93c0FycmF5ID0gY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLnNoYWRvd3NBcnJheTtcblxuXHRcdFx0Y29uc3QgbGlnaHRzU3RhdGVWZXJzaW9uID0gbGlnaHRzLnN0YXRlLnZlcnNpb247XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyggbWF0ZXJpYWwsIGxpZ2h0cy5zdGF0ZSwgc2hhZG93c0FycmF5LCBzY2VuZSwgb2JqZWN0ICk7XG5cdFx0XHRjb25zdCBwcm9ncmFtQ2FjaGVLZXkgPSBwcm9ncmFtQ2FjaGUuZ2V0UHJvZ3JhbUNhY2hlS2V5KCBwYXJhbWV0ZXJzICk7XG5cblx0XHRcdGxldCBwcm9ncmFtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtcztcblxuXHRcdFx0Ly8gYWx3YXlzIHVwZGF0ZSBlbnZpcm9ubWVudCBhbmQgZm9nIC0gY2hhbmdpbmcgdGhlc2UgdHJpZ2dlciBhbiBnZXRQcm9ncmFtIGNhbGwsIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHByb2dyYW0gZG9lc24ndCBjaGFuZ2VcblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmVudmlyb25tZW50ID0gbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IHNjZW5lLmVudmlyb25tZW50IDogbnVsbDtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5mb2cgPSBzY2VuZS5mb2c7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwID0gKCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gY3ViZXV2bWFwcyA6IGN1YmVtYXBzICkuZ2V0KCBtYXRlcmlhbC5lbnZNYXAgfHwgbWF0ZXJpYWxQcm9wZXJ0aWVzLmVudmlyb25tZW50ICk7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwUm90YXRpb24gPSAoIG1hdGVyaWFsUHJvcGVydGllcy5lbnZpcm9ubWVudCAhPT0gbnVsbCAmJiBtYXRlcmlhbC5lbnZNYXAgPT09IG51bGwgKSA/IHNjZW5lLmVudmlyb25tZW50Um90YXRpb24gOiBtYXRlcmlhbC5lbnZNYXBSb3RhdGlvbjtcblxuXHRcdFx0aWYgKCBwcm9ncmFtcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIG5ldyBtYXRlcmlhbFxuXG5cdFx0XHRcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHRcdFx0XHRwcm9ncmFtcyA9IG5ldyBNYXAoKTtcblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW1zID0gcHJvZ3JhbXM7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IHByb2dyYW0gPSBwcm9ncmFtcy5nZXQoIHByb2dyYW1DYWNoZUtleSApO1xuXG5cdFx0XHRpZiAoIHByb2dyYW0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBlYXJseSBvdXQgaWYgcHJvZ3JhbSBhbmQgbGlnaHQgc3RhdGUgaXMgaWRlbnRpY2FsXG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMuY3VycmVudFByb2dyYW0gPT09IHByb2dyYW0gJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c1N0YXRlVmVyc2lvbiA9PT0gbGlnaHRzU3RhdGVWZXJzaW9uICkge1xuXG5cdFx0XHRcdFx0dXBkYXRlQ29tbW9uTWF0ZXJpYWxQcm9wZXJ0aWVzKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHByb2dyYW07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMudW5pZm9ybXMgPSBwcm9ncmFtQ2FjaGUuZ2V0VW5pZm9ybXMoIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0bWF0ZXJpYWwub25CdWlsZCggb2JqZWN0LCBwYXJhbWV0ZXJzLCBfdGhpcyApO1xuXG5cdFx0XHRcdG1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZSggcGFyYW1ldGVycywgX3RoaXMgKTtcblxuXHRcdFx0XHRwcm9ncmFtID0gcHJvZ3JhbUNhY2hlLmFjcXVpcmVQcm9ncmFtKCBwYXJhbWV0ZXJzLCBwcm9ncmFtQ2FjaGVLZXkgKTtcblx0XHRcdFx0cHJvZ3JhbXMuc2V0KCBwcm9ncmFtQ2FjaGVLZXksIHByb2dyYW0gKTtcblxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXMgPSBwYXJhbWV0ZXJzLnVuaWZvcm1zO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHVuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zO1xuXG5cdFx0XHRpZiAoICggISBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmICEgbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCApIHx8IG1hdGVyaWFsLmNsaXBwaW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNsaXBwaW5nUGxhbmVzID0gY2xpcHBpbmcudW5pZm9ybTtcblxuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGVDb21tb25NYXRlcmlhbFByb3BlcnRpZXMoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XG5cblx0XHRcdC8vIHN0b3JlIHRoZSBsaWdodCBzZXR1cCBpdCB3YXMgY3JlYXRlZCBmb3JcblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm5lZWRzTGlnaHRzID0gbWF0ZXJpYWxOZWVkc0xpZ2h0cyggbWF0ZXJpYWwgKTtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNTdGF0ZVZlcnNpb24gPSBsaWdodHNTdGF0ZVZlcnNpb247XG5cblx0XHRcdGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm5lZWRzTGlnaHRzICkge1xuXG5cdFx0XHRcdC8vIHdpcmUgdXAgdGhlIG1hdGVyaWFsIHRvIHRoaXMgcmVuZGVyZXIncyBsaWdodGluZyBzdGF0ZVxuXG5cdFx0XHRcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnN0YXRlLmFtYmllbnQ7XG5cdFx0XHRcdHVuaWZvcm1zLmxpZ2h0UHJvYmUudmFsdWUgPSBsaWdodHMuc3RhdGUucHJvYmU7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0U2hhZG93cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvdztcblx0XHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90O1xuXHRcdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRTaGFkb3dzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3c7XG5cdFx0XHRcdHVuaWZvcm1zLnJlY3RBcmVhTGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhO1xuXHRcdFx0XHR1bmlmb3Jtcy5sdGNfMS52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5yZWN0QXJlYUxUQzE7XG5cdFx0XHRcdHVuaWZvcm1zLmx0Y18yLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhTFRDMjtcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnQ7XG5cdFx0XHRcdHVuaWZvcm1zLnBvaW50TGlnaHRTaGFkb3dzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93O1xuXHRcdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLmhlbWk7XG5cblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4O1xuXHRcdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3dNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodE1hdHJpeC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90TGlnaHRNYXRyaXg7XG5cdFx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodE1hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90TGlnaHRNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb2ludFNoYWRvd01hdHJpeC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludFNoYWRvd01hdHJpeDtcblx0XHRcdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IGFkZCBhcmVhIGxpZ2h0cyBzaGFkb3cgaW5mbyB0byB1bmlmb3Jtc1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIHByb2dyYW07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbmlmb3JtTGlzdCggbWF0ZXJpYWxQcm9wZXJ0aWVzICkge1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgcHJvZ1VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLmN1cnJlbnRQcm9ncmFtLmdldFVuaWZvcm1zKCk7XG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPSBXZWJHTFVuaWZvcm1zLnNlcVdpdGhWYWx1ZSggcHJvZ1VuaWZvcm1zLnNlcSwgbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3Q7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVDb21tb25NYXRlcmlhbFByb3BlcnRpZXMoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm91dHB1dENvbG9yU3BhY2UgPSBwYXJhbWV0ZXJzLm91dHB1dENvbG9yU3BhY2U7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuYmF0Y2hpbmcgPSBwYXJhbWV0ZXJzLmJhdGNoaW5nO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmJhdGNoaW5nQ29sb3IgPSBwYXJhbWV0ZXJzLmJhdGNoaW5nQ29sb3I7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuaW5zdGFuY2luZyA9IHBhcmFtZXRlcnMuaW5zdGFuY2luZztcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5pbnN0YW5jaW5nQ29sb3IgPSBwYXJhbWV0ZXJzLmluc3RhbmNpbmdDb2xvcjtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5pbnN0YW5jaW5nTW9ycGggPSBwYXJhbWV0ZXJzLmluc3RhbmNpbmdNb3JwaDtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5za2lubmluZyA9IHBhcmFtZXRlcnMuc2tpbm5pbmc7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhUYXJnZXRzID0gcGFyYW1ldGVycy5tb3JwaFRhcmdldHM7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhOb3JtYWxzID0gcGFyYW1ldGVycy5tb3JwaE5vcm1hbHM7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhDb2xvcnMgPSBwYXJhbWV0ZXJzLm1vcnBoQ29sb3JzO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0c0NvdW50ID0gcGFyYW1ldGVycy5tb3JwaFRhcmdldHNDb3VudDtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyA9IHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXM7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubnVtSW50ZXJzZWN0aW9uID0gcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnZlcnRleEFscGhhcyA9IHBhcmFtZXRlcnMudmVydGV4QWxwaGFzO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnZlcnRleFRhbmdlbnRzID0gcGFyYW1ldGVycy52ZXJ0ZXhUYW5nZW50cztcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy50b25lTWFwcGluZyA9IHBhcmFtZXRlcnMudG9uZU1hcHBpbmc7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCApIHtcblxuXHRcdFx0aWYgKCBzY2VuZS5pc1NjZW5lICE9PSB0cnVlICkgc2NlbmUgPSBfZW1wdHlTY2VuZTsgLy8gc2NlbmUgY291bGQgYmUgYSBNZXNoLCBMaW5lLCBQb2ludHMsIC4uLlxuXG5cdFx0XHR0ZXh0dXJlcy5yZXNldFRleHR1cmVVbml0cygpO1xuXG5cdFx0XHRjb25zdCBmb2cgPSBzY2VuZS5mb2c7XG5cdFx0XHRjb25zdCBlbnZpcm9ubWVudCA9IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBzY2VuZS5lbnZpcm9ubWVudCA6IG51bGw7XG5cdFx0XHRjb25zdCBjb2xvclNwYWNlID0gKCBfY3VycmVudFJlbmRlclRhcmdldCA9PT0gbnVsbCApID8gX3RoaXMub3V0cHV0Q29sb3JTcGFjZSA6ICggX2N1cnJlbnRSZW5kZXJUYXJnZXQuaXNYUlJlbmRlclRhcmdldCA9PT0gdHJ1ZSA/IF9jdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUuY29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlICk7XG5cdFx0XHRjb25zdCBlbnZNYXAgPSAoIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBjdWJldXZtYXBzIDogY3ViZW1hcHMgKS5nZXQoIG1hdGVyaWFsLmVudk1hcCB8fCBlbnZpcm9ubWVudCApO1xuXHRcdFx0Y29uc3QgdmVydGV4QWxwaGFzID0gbWF0ZXJpYWwudmVydGV4Q29sb3JzID09PSB0cnVlICYmICEhIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZSA9PT0gNDtcblx0XHRcdGNvbnN0IHZlcnRleFRhbmdlbnRzID0gISEgZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50ICYmICggISEgbWF0ZXJpYWwubm9ybWFsTWFwIHx8IG1hdGVyaWFsLmFuaXNvdHJvcHkgPiAwICk7XG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldHMgPSAhISBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBtb3JwaE5vcm1hbHMgPSAhISBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsO1xuXHRcdFx0Y29uc3QgbW9ycGhDb2xvcnMgPSAhISBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7XG5cblx0XHRcdGxldCB0b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwudG9uZU1hcHBlZCApIHtcblxuXHRcdFx0XHRpZiAoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsIHx8IF9jdXJyZW50UmVuZGVyVGFyZ2V0LmlzWFJSZW5kZXJUYXJnZXQgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR0b25lTWFwcGluZyA9IF90aGlzLnRvbmVNYXBwaW5nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvcjtcblx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0c0NvdW50ID0gKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkgPyBtb3JwaEF0dHJpYnV0ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblx0XHRcdGNvbnN0IGxpZ2h0cyA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5saWdodHM7XG5cblx0XHRcdGlmICggX2NsaXBwaW5nRW5hYmxlZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRpZiAoIF9sb2NhbENsaXBwaW5nRW5hYmxlZCA9PT0gdHJ1ZSB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdXNlQ2FjaGUgPVxuXHRcdFx0XHRcdFx0Y2FtZXJhID09PSBfY3VycmVudENhbWVyYSAmJlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwuaWQgPT09IF9jdXJyZW50TWF0ZXJpYWxJZDtcblxuXHRcdFx0XHRcdC8vIHdlIG1pZ2h0IHdhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGggc29tZSBDbGlwcGluZ0dyb3VwXG5cdFx0XHRcdFx0Ly8gb2JqZWN0IGluc3RlYWQgb2YgdGhlIG1hdGVyaWFsLCBvbmNlIGl0IGJlY29tZXMgZmVhc2libGVcblx0XHRcdFx0XHQvLyAoIzg0NjUsICM4Mzc5KVxuXHRcdFx0XHRcdGNsaXBwaW5nLnNldFN0YXRlKCBtYXRlcmlhbCwgY2FtZXJhLCB1c2VDYWNoZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRsZXQgbmVlZHNQcm9ncmFtQ2hhbmdlID0gZmFsc2U7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwudmVyc2lvbiA9PT0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fdmVyc2lvbiApIHtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cyAmJiAoIG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNTdGF0ZVZlcnNpb24gIT09IGxpZ2h0cy5zdGF0ZS52ZXJzaW9uICkgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5vdXRwdXRDb2xvclNwYWNlICE9PSBjb2xvclNwYWNlICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNCYXRjaGVkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuYmF0Y2hpbmcgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCAhIG9iamVjdC5pc0JhdGNoZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5iYXRjaGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzQmF0Y2hlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmJhdGNoaW5nQ29sb3IgPT09IHRydWUgJiYgb2JqZWN0LmNvbG9yVGV4dHVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzQmF0Y2hlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmJhdGNoaW5nQ29sb3IgPT09IGZhbHNlICYmIG9iamVjdC5jb2xvclRleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmcgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCAhIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5za2lubmluZyA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoICEgb2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLnNraW5uaW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5pbnN0YW5jaW5nQ29sb3IgPT09IHRydWUgJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmdDb2xvciA9PT0gZmFsc2UgJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmdNb3JwaCA9PT0gdHJ1ZSAmJiBvYmplY3QubW9ycGhUZXh0dXJlID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5pbnN0YW5jaW5nTW9ycGggPT09IGZhbHNlICYmIG9iamVjdC5tb3JwaFRleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5lbnZNYXAgIT09IGVudk1hcCApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZm9nID09PSB0cnVlICYmIG1hdGVyaWFsUHJvcGVydGllcy5mb2cgIT09IGZvZyApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0XHQoIG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyAhPT0gY2xpcHBpbmcubnVtUGxhbmVzIHx8XG5cdFx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUludGVyc2VjdGlvbiAhPT0gY2xpcHBpbmcubnVtSW50ZXJzZWN0aW9uICkgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy52ZXJ0ZXhBbHBoYXMgIT09IHZlcnRleEFscGhhcyApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLnZlcnRleFRhbmdlbnRzICE9PSB2ZXJ0ZXhUYW5nZW50cyApIHtcblxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0cyAhPT0gbW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhOb3JtYWxzICE9PSBtb3JwaE5vcm1hbHMgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaENvbG9ycyAhPT0gbW9ycGhDb2xvcnMgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy50b25lTWFwcGluZyAhPT0gdG9uZU1hcHBpbmcgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaFRhcmdldHNDb3VudCAhPT0gbW9ycGhUYXJnZXRzQ291bnQgKSB7XG5cblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuX192ZXJzaW9uID0gbWF0ZXJpYWwudmVyc2lvbjtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRsZXQgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5jdXJyZW50UHJvZ3JhbTtcblxuXHRcdFx0aWYgKCBuZWVkc1Byb2dyYW1DaGFuZ2UgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0cHJvZ3JhbSA9IGdldFByb2dyYW0oIG1hdGVyaWFsLCBzY2VuZSwgb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XG5cdFx0XHRsZXQgcmVmcmVzaE1hdGVyaWFsID0gZmFsc2U7XG5cdFx0XHRsZXQgcmVmcmVzaExpZ2h0cyA9IGZhbHNlO1xuXG5cdFx0XHRjb25zdCBwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxuXHRcdFx0XHRtX3VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zO1xuXG5cdFx0XHRpZiAoIHN0YXRlLnVzZVByb2dyYW0oIHByb2dyYW0ucHJvZ3JhbSApICkge1xuXG5cdFx0XHRcdHJlZnJlc2hQcm9ncmFtID0gdHJ1ZTtcblx0XHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblx0XHRcdFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pZCAhPT0gX2N1cnJlbnRNYXRlcmlhbElkICkge1xuXG5cdFx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xuXG5cdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZWZyZXNoUHJvZ3JhbSB8fCBfY3VycmVudENhbWVyYSAhPT0gY2FtZXJhICkge1xuXG5cdFx0XHRcdC8vIGNvbW1vbiBjYW1lcmEgdW5pZm9ybXNcblxuXHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdwcm9qZWN0aW9uTWF0cml4JywgY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAndmlld01hdHJpeCcsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuXHRcdFx0XHRjb25zdCB1Q2FtUG9zID0gcF91bmlmb3Jtcy5tYXAuY2FtZXJhUG9zaXRpb247XG5cblx0XHRcdFx0aWYgKCB1Q2FtUG9zICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR1Q2FtUG9zLnNldFZhbHVlKCBfZ2wsIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2xvZ0RlcHRoQnVmRkMnLFxuXHRcdFx0XHRcdFx0Mi4wIC8gKCBNYXRoLmxvZyggY2FtZXJhLmZhciArIDEuMCApIC8gTWF0aC5MTjIgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjb25zaWRlciBtb3ZpbmcgaXNPcnRob2dyYXBoaWMgdG8gVW5pZm9ybUxpYiBhbmQgV2ViR0xNYXRlcmlhbHMsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjY0NjcjaXNzdWVjb21tZW50LTE2NDUxODUwNjdcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHxcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHxcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsIHx8XG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxuXHRcdFx0XHRcdG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdpc09ydGhvZ3JhcGhpYycsIGNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSA9PT0gdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIF9jdXJyZW50Q2FtZXJhICE9PSBjYW1lcmEgKSB7XG5cblx0XHRcdFx0XHRfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcblxuXHRcdFx0XHRcdC8vIGxpZ2h0aW5nIHVuaWZvcm1zIGRlcGVuZCBvbiB0aGUgY2FtZXJhIHNvIGVuZm9yY2UgYW4gdXBkYXRlXG5cdFx0XHRcdFx0Ly8gbm93LCBpbiBjYXNlIHRoaXMgbWF0ZXJpYWwgc3VwcG9ydHMgbGlnaHRzIC0gb3IgbGF0ZXIsIHdoZW5cblx0XHRcdFx0XHQvLyB0aGUgbmV4dCBtYXRlcmlhbCB0aGF0IGRvZXMgZ2V0cyBhY3RpdmF0ZWQ6XG5cblx0XHRcdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1x0XHQvLyBzZXQgdG8gdHJ1ZSBvbiBtYXRlcmlhbCBjaGFuZ2Vcblx0XHRcdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcdFx0Ly8gcmVtYWlucyBzZXQgdW50aWwgdXBkYXRlIGRvbmVcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2tpbm5pbmcgYW5kIG1vcnBoIHRhcmdldCB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2Vcblx0XHRcdC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgYW5kIG1vcnBoIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcblx0XHRcdC8vIG90aGVyd2lzZSB0ZXh0dXJlcyB1c2VkIGZvciBza2lubmluZyBhbmQgbW9ycGhpbmcgY2FuIHRha2Ugb3ZlciB0ZXh0dXJlIHVuaXRzIHJlc2VydmVkIGZvciBvdGhlciBtYXRlcmlhbCB0ZXh0dXJlc1xuXG5cdFx0XHRpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoIF9nbCwgb2JqZWN0LCAnYmluZE1hdHJpeCcgKTtcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiaW5kTWF0cml4SW52ZXJzZScgKTtcblxuXHRcdFx0XHRjb25zdCBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcblxuXHRcdFx0XHRpZiAoIHNrZWxldG9uICkge1xuXG5cdFx0XHRcdFx0aWYgKCBza2VsZXRvbi5ib25lVGV4dHVyZSA9PT0gbnVsbCApIHNrZWxldG9uLmNvbXB1dGVCb25lVGV4dHVyZSgpO1xuXG5cdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnYm9uZVRleHR1cmUnLCBza2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvYmplY3QuaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0XHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIG9iamVjdCwgJ2JhdGNoaW5nVGV4dHVyZScgKTtcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnYmF0Y2hpbmdUZXh0dXJlJywgb2JqZWN0Ll9tYXRyaWNlc1RleHR1cmUsIHRleHR1cmVzICk7XG5cblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiYXRjaGluZ0NvbG9yVGV4dHVyZScgKTtcblx0XHRcdFx0aWYgKCBvYmplY3QuX2NvbG9yc1RleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdiYXRjaGluZ0NvbG9yVGV4dHVyZScsIG9iamVjdC5fY29sb3JzVGV4dHVyZSwgdGV4dHVyZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkIHx8IG1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCB8fCAoIG1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdFx0bW9ycGh0YXJnZXRzLnVwZGF0ZSggb2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVmcmVzaE1hdGVyaWFsIHx8IG1hdGVyaWFsUHJvcGVydGllcy5yZWNlaXZlU2hhZG93ICE9PSBvYmplY3QucmVjZWl2ZVNoYWRvdyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMucmVjZWl2ZVNoYWRvdyA9IG9iamVjdC5yZWNlaXZlU2hhZG93O1xuXHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdyZWNlaXZlU2hhZG93Jywgb2JqZWN0LnJlY2VpdmVTaGFkb3cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjQ0NjcjaXNzdWVjb21tZW50LTEyMDkwMzE1MTJcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hHb3VyYXVkTWF0ZXJpYWwgJiYgbWF0ZXJpYWwuZW52TWFwICE9PSBudWxsICkge1xuXG5cdFx0XHRcdG1fdW5pZm9ybXMuZW52TWFwLnZhbHVlID0gZW52TWFwO1xuXG5cdFx0XHRcdG1fdW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggZW52TWFwLmlzQ3ViZVRleHR1cmUgJiYgZW52TWFwLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgKSA/IC0gMSA6IDE7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsICYmIG1hdGVyaWFsLmVudk1hcCA9PT0gbnVsbCAmJiBzY2VuZS5lbnZpcm9ubWVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRtX3VuaWZvcm1zLmVudk1hcEludGVuc2l0eS52YWx1ZSA9IHNjZW5lLmVudmlyb25tZW50SW50ZW5zaXR5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3RvbmVNYXBwaW5nRXhwb3N1cmUnLCBfdGhpcy50b25lTWFwcGluZ0V4cG9zdXJlICk7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubmVlZHNMaWdodHMgKSB7XG5cblx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBtYXRlcmlhbCByZXF1aXJlcyBsaWdodGluZyBpbmZvXG5cblx0XHRcdFx0XHQvLyBub3RlOiBhbGwgbGlnaHRpbmcgdW5pZm9ybXMgYXJlIGFsd2F5cyBzZXQgY29ycmVjdGx5XG5cdFx0XHRcdFx0Ly8gdGhleSBzaW1wbHkgcmVmZXJlbmNlIHRoZSByZW5kZXJlcidzIHN0YXRlIGZvciB0aGVpclxuXHRcdFx0XHRcdC8vIHZhbHVlc1xuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0Ly8gdXNlIHRoZSBjdXJyZW50IG1hdGVyaWFsJ3MgLm5lZWRzVXBkYXRlIGZsYWdzIHRvIHNldFxuXHRcdFx0XHRcdC8vIHRoZSBHTCBzdGF0ZSB3aGVuIHJlcXVpcmVkXG5cblx0XHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgcmVmcmVzaExpZ2h0cyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xuXG5cdFx0XHRcdGlmICggZm9nICYmIG1hdGVyaWFsLmZvZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5yZWZyZXNoRm9nVW5pZm9ybXMoIG1fdW5pZm9ybXMsIGZvZyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXRlcmlhbHMucmVmcmVzaE1hdGVyaWFsVW5pZm9ybXMoIG1fdW5pZm9ybXMsIG1hdGVyaWFsLCBfcGl4ZWxSYXRpbywgX2hlaWdodCwgY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLnRyYW5zbWlzc2lvblJlbmRlclRhcmdldFsgY2FtZXJhLmlkIF0gKTtcblxuXHRcdFx0XHRXZWJHTFVuaWZvcm1zLnVwbG9hZCggX2dsLCBnZXRVbmlmb3JtTGlzdCggbWF0ZXJpYWxQcm9wZXJ0aWVzICksIG1fdW5pZm9ybXMsIHRleHR1cmVzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmIG1hdGVyaWFsLnVuaWZvcm1zTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRXZWJHTFVuaWZvcm1zLnVwbG9hZCggX2dsLCBnZXRVbmlmb3JtTGlzdCggbWF0ZXJpYWxQcm9wZXJ0aWVzICksIG1fdW5pZm9ybXMsIHRleHR1cmVzICk7XG5cdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaXNTcHJpdGVNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdjZW50ZXInLCBvYmplY3QuY2VudGVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29tbW9uIG1hdHJpY2VzXG5cblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ21vZGVsVmlld01hdHJpeCcsIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ25vcm1hbE1hdHJpeCcsIG9iamVjdC5ub3JtYWxNYXRyaXggKTtcblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ21vZGVsTWF0cml4Jywgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdC8vIFVCT3NcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0Y29uc3QgZ3JvdXBzID0gbWF0ZXJpYWwudW5pZm9ybXNHcm91cHM7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNHcm91cHMudXBkYXRlKCBncm91cCwgcHJvZ3JhbSApO1xuXHRcdFx0XHRcdHVuaWZvcm1zR3JvdXBzLmJpbmQoIGdyb3VwLCBwcm9ncmFtICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgdW5pZm9ybXMgYXJlIG1hcmtlZCBhcyBjbGVhbiwgdGhleSBkb24ndCBuZWVkIHRvIGJlIGxvYWRlZCB0byB0aGUgR1BVLlxuXG5cdFx0ZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIHVuaWZvcm1zLCB2YWx1ZSApIHtcblxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLmxpZ2h0UHJvYmUubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuXHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodFNoYWRvd3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodFNoYWRvd3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnJlY3RBcmVhTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBtYXRlcmlhbE5lZWRzTGlnaHRzKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fFxuXHRcdFx0XHRtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgfHxcblx0XHRcdFx0KCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmIG1hdGVyaWFsLmxpZ2h0cyA9PT0gdHJ1ZSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRBY3RpdmVDdWJlRmFjZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIF9jdXJyZW50QWN0aXZlQ3ViZUZhY2U7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRBY3RpdmVNaXBtYXBMZXZlbCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWw7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBfY3VycmVudFJlbmRlclRhcmdldDtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFJlbmRlclRhcmdldFRleHR1cmVzID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIGNvbG9yVGV4dHVyZSwgZGVwdGhUZXh0dXJlICkge1xuXG5cdFx0XHRwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSA9IGNvbG9yVGV4dHVyZTtcblx0XHRcdHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkuX193ZWJnbFRleHR1cmUgPSBkZXB0aFRleHR1cmU7XG5cblx0XHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyA9IHRydWU7XG5cblx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19hdXRvQWxsb2NhdGVEZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZSA9PT0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoICEgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyICkge1xuXG5cdFx0XHRcdC8vIFRoZSBtdWx0aXNhbXBsZV9yZW5kZXJfdG9fdGV4dHVyZSBleHRlbnNpb24gZG9lc24ndCB3b3JrIHByb3Blcmx5IGlmIHRoZXJlXG5cdFx0XHRcdC8vIGFyZSBtaWRmcmFtZSBmbHVzaGVzIGFuZCBhbiBleHRlcm5hbCBkZXB0aCBidWZmZXIuIERpc2FibGUgdXNlIG9mIHRoZSBleHRlbnNpb24uXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9ucy5oYXMoICdXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUnICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBSZW5kZXItdG8tdGV4dHVyZSBleHRlbnNpb24gd2FzIGRpc2FibGVkIGJlY2F1c2UgYW4gZXh0ZXJuYWwgdGV4dHVyZSB3YXMgcHJvdmlkZWQnICk7XG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3VzZVJlbmRlclRvVGV4dHVyZSA9IGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0RnJhbWVidWZmZXIgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgZGVmYXVsdEZyYW1lYnVmZmVyICkge1xuXG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBkZWZhdWx0RnJhbWVidWZmZXI7XG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fdXNlRGVmYXVsdEZyYW1lYnVmZmVyID0gZGVmYXVsdEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQ7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgYWN0aXZlQ3ViZUZhY2UgPSAwLCBhY3RpdmVNaXBtYXBMZXZlbCA9IDAgKSB7XG5cblx0XHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuXHRcdFx0X2N1cnJlbnRBY3RpdmVDdWJlRmFjZSA9IGFjdGl2ZUN1YmVGYWNlO1xuXHRcdFx0X2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbCA9IGFjdGl2ZU1pcG1hcExldmVsO1xuXG5cdFx0XHRsZXQgdXNlRGVmYXVsdEZyYW1lYnVmZmVyID0gdHJ1ZTtcblx0XHRcdGxldCBmcmFtZWJ1ZmZlciA9IG51bGw7XG5cdFx0XHRsZXQgaXNDdWJlID0gZmFsc2U7XG5cdFx0XHRsZXQgaXNSZW5kZXJUYXJnZXQzRCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3VzZURlZmF1bHRGcmFtZWJ1ZmZlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdG8gcmViaW5kIHRoZSBmcmFtZWJ1ZmZlci5cblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHRcdFx0XHRcdHVzZURlZmF1bHRGcmFtZWJ1ZmZlciA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlcy5zZXR1cFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2hhc0V4dGVybmFsVGV4dHVyZXMgKSB7XG5cblx0XHRcdFx0XHQvLyBDb2xvciBhbmQgZGVwdGggdGV4dHVyZSBtdXN0IGJlIHJlYm91bmQgaW4gb3JkZXIgZm9yIHRoZSBzd2FwY2hhaW4gdG8gdXBkYXRlLlxuXHRcdFx0XHRcdHRleHR1cmVzLnJlYmluZFRleHR1cmVzKCByZW5kZXJUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlLCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlIHx8IHRleHR1cmUuaXNEYXRhQXJyYXlUZXh0dXJlIHx8IHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0aXNSZW5kZXJUYXJnZXQzRCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IF9fd2ViZ2xGcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIF9fd2ViZ2xGcmFtZWJ1ZmZlclsgYWN0aXZlQ3ViZUZhY2UgXSApICkge1xuXG5cdFx0XHRcdFx0XHRmcmFtZWJ1ZmZlciA9IF9fd2ViZ2xGcmFtZWJ1ZmZlclsgYWN0aXZlQ3ViZUZhY2UgXVsgYWN0aXZlTWlwbWFwTGV2ZWwgXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGZyYW1lYnVmZmVyID0gX193ZWJnbEZyYW1lYnVmZmVyWyBhY3RpdmVDdWJlRmFjZSBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aXNDdWJlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIHJlbmRlclRhcmdldC5zYW1wbGVzID4gMCApICYmIHRleHR1cmVzLnVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0ZnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIF9fd2ViZ2xGcmFtZWJ1ZmZlciApICkge1xuXG5cdFx0XHRcdFx0XHRmcmFtZWJ1ZmZlciA9IF9fd2ViZ2xGcmFtZWJ1ZmZlclsgYWN0aXZlTWlwbWFwTGV2ZWwgXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGZyYW1lYnVmZmVyID0gX193ZWJnbEZyYW1lYnVmZmVyO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIHJlbmRlclRhcmdldC52aWV3cG9ydCApO1xuXHRcdFx0XHRfY3VycmVudFNjaXNzb3IuY29weSggcmVuZGVyVGFyZ2V0LnNjaXNzb3IgKTtcblx0XHRcdFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IHJlbmRlclRhcmdldC5zY2lzc29yVGVzdDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApLmZsb29yKCk7XG5cdFx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApLmZsb29yKCk7XG5cdFx0XHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSBfc2Npc3NvclRlc3Q7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZnJhbWVidWZmZXJCb3VuZCA9IHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRpZiAoIGZyYW1lYnVmZmVyQm91bmQgJiYgdXNlRGVmYXVsdEZyYW1lYnVmZmVyICkge1xuXG5cdFx0XHRcdHN0YXRlLmRyYXdCdWZmZXJzKCByZW5kZXJUYXJnZXQsIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQgKTtcblx0XHRcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3NvciApO1xuXHRcdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9jdXJyZW50U2Npc3NvclRlc3QgKTtcblxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaXNSZW5kZXJUYXJnZXQzRCApIHtcblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXHRcdFx0XHRjb25zdCBsYXllciA9IGFjdGl2ZUN1YmVGYWNlIHx8IDA7XG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmVMYXllciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBhY3RpdmVNaXBtYXBMZXZlbCB8fCAwLCBsYXllciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTsgLy8gcmVzZXQgY3VycmVudCBtYXRlcmlhbCB0byBlbnN1cmUgY29ycmVjdCB1bmlmb3JtIGJpbmRpbmdzXG5cblx0XHR9O1xuXG5cdFx0dGhpcy5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJ1ZmZlciwgYWN0aXZlQ3ViZUZhY2VJbmRleCApIHtcblxuXHRcdFx0aWYgKCAhICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4nICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgZnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyO1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCAmJiBhY3RpdmVDdWJlRmFjZUluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlclsgYWN0aXZlQ3ViZUZhY2VJbmRleCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlRm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XG5cdFx0XHRcdFx0Y29uc3QgdGV4dHVyZVR5cGUgPSB0ZXh0dXJlLnR5cGU7XG5cblx0XHRcdFx0XHRpZiAoICEgY2FwYWJpbGl0aWVzLnRleHR1cmVGb3JtYXRSZWFkYWJsZSggdGV4dHVyZUZvcm1hdCApICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuJyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhIGNhcGFiaWxpdGllcy50ZXh0dXJlVHlwZVJlYWRhYmxlKCB0ZXh0dXJlVHlwZSApICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFVuc2lnbmVkQnl0ZVR5cGUgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCB0eXBlLicgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50IGVuc3VyZXMgdmFsaWQgcmVhZCByZXF1ZXN0cyAobm8gb3V0LW9mLWJvdW5kcyBwaXhlbHMsIHNlZSAjODYwNClcblxuXHRcdFx0XHRcdGlmICggKCB4ID49IDAgJiYgeCA8PSAoIHJlbmRlclRhcmdldC53aWR0aCAtIHdpZHRoICkgKSAmJiAoIHkgPj0gMCAmJiB5IDw9ICggcmVuZGVyVGFyZ2V0LmhlaWdodCAtIGhlaWdodCApICkgKSB7XG5cblx0XHRcdFx0XHRcdF9nbC5yZWFkUGl4ZWxzKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlRm9ybWF0ICksIHV0aWxzLmNvbnZlcnQoIHRleHR1cmVUeXBlICksIGJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZmluYWxseSB7XG5cblx0XHRcdFx0XHQvLyByZXN0b3JlIGZyYW1lYnVmZmVyIG9mIGN1cnJlbnQgcmVuZGVyIHRhcmdldCBpZiBuZWNlc3NhcnlcblxuXHRcdFx0XHRcdGNvbnN0IGZyYW1lYnVmZmVyID0gKCBfY3VycmVudFJlbmRlclRhcmdldCAhPT0gbnVsbCApID8gcHJvcGVydGllcy5nZXQoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyIDogbnVsbDtcblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHNBc3luYyA9IGFzeW5jIGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIsIGFjdGl2ZUN1YmVGYWNlSW5kZXggKSB7XG5cblx0XHRcdGlmICggISAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldCApICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IGZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ICYmIGFjdGl2ZUN1YmVGYWNlSW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyWyBhY3RpdmVDdWJlRmFjZUluZGV4IF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmcmFtZWJ1ZmZlciApIHtcblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlLmZvcm1hdDtcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlVHlwZSA9IHRleHR1cmUudHlwZTtcblxuXHRcdFx0XHRcdGlmICggISBjYXBhYmlsaXRpZXMudGV4dHVyZUZvcm1hdFJlYWRhYmxlKCB0ZXh0dXJlRm9ybWF0ICkgKSB7XG5cblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsc0FzeW5jOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhIGNhcGFiaWxpdGllcy50ZXh0dXJlVHlwZVJlYWRhYmxlKCB0ZXh0dXJlVHlwZSApICkge1xuXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHNBc3luYzogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBVbnNpZ25lZEJ5dGVUeXBlIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgdHlwZS4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0aGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudCBlbnN1cmVzIHZhbGlkIHJlYWQgcmVxdWVzdHMgKG5vIG91dC1vZi1ib3VuZHMgcGl4ZWxzLCBzZWUgIzg2MDQpXG5cdFx0XHRcdFx0aWYgKCAoIHggPj0gMCAmJiB4IDw9ICggcmVuZGVyVGFyZ2V0LndpZHRoIC0gd2lkdGggKSApICYmICggeSA+PSAwICYmIHkgPD0gKCByZW5kZXJUYXJnZXQuaGVpZ2h0IC0gaGVpZ2h0ICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZ2xCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLlBJWEVMX1BBQ0tfQlVGRkVSLCBnbEJ1ZmZlciApO1xuXHRcdFx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyLmJ5dGVMZW5ndGgsIF9nbC5TVFJFQU1fUkVBRCApO1xuXHRcdFx0XHRcdFx0X2dsLnJlYWRQaXhlbHMoIHgsIHksIHdpZHRoLCBoZWlnaHQsIHV0aWxzLmNvbnZlcnQoIHRleHR1cmVGb3JtYXQgKSwgdXRpbHMuY29udmVydCggdGV4dHVyZVR5cGUgKSwgMCApO1xuXHRcdFx0XHRcdFx0X2dsLmZsdXNoKCk7XG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSBjb21tYW5kcyBoYXZlIGZpbmlzaGVkIGV2ZXJ5IDggbXNcblx0XHRcdFx0XHRcdGNvbnN0IHN5bmMgPSBfZ2wuZmVuY2VTeW5jKCBfZ2wuU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsIDAgKTtcblx0XHRcdFx0XHRcdGF3YWl0IHByb2JlQXN5bmMoIF9nbCwgc3luYywgNCApO1xuXG5cdFx0XHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuUElYRUxfUEFDS19CVUZGRVIsIGdsQnVmZmVyICk7XG5cdFx0XHRcdFx0XHRcdF9nbC5nZXRCdWZmZXJTdWJEYXRhKCBfZ2wuUElYRUxfUEFDS19CVUZGRVIsIDAsIGJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXG5cdFx0XHRcdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGdsQnVmZmVyICk7XG5cdFx0XHRcdFx0XHRcdF9nbC5kZWxldGVTeW5jKCBzeW5jICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGJ1ZmZlcjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGZpbmFsbHkge1xuXG5cdFx0XHRcdFx0Ly8gcmVzdG9yZSBmcmFtZWJ1ZmZlciBvZiBjdXJyZW50IHJlbmRlciB0YXJnZXQgaWYgbmVjZXNzYXJ5XG5cblx0XHRcdFx0XHRjb25zdCBmcmFtZWJ1ZmZlciA9ICggX2N1cnJlbnRSZW5kZXJUYXJnZXQgIT09IG51bGwgKSA/IHByb3BlcnRpZXMuZ2V0KCBfY3VycmVudFJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciA6IG51bGw7XG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5jb3B5RnJhbWVidWZmZXJUb1RleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHBvc2l0aW9uID0gbnVsbCwgbGV2ZWwgPSAwICkge1xuXG5cdFx0XHQvLyBzdXBwb3J0IHByZXZpb3VzIHNpZ25hdHVyZSB3aXRoIHBvc2l0aW9uIGZpcnN0XG5cdFx0XHRpZiAoIHRleHR1cmUuaXNUZXh0dXJlICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdC8vIEBkZXByZWNhdGVkLCByMTY1XG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IGNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZSBmdW5jdGlvbiBzaWduYXR1cmUgaGFzIGNoYW5nZWQuJyApO1xuXG5cdFx0XHRcdHBvc2l0aW9uID0gYXJndW1lbnRzWyAwIF0gfHwgbnVsbDtcblx0XHRcdFx0dGV4dHVyZSA9IGFyZ3VtZW50c1sgMSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGxldmVsU2NhbGUgPSBNYXRoLnBvdyggMiwgLSBsZXZlbCApO1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBNYXRoLmZsb29yKCB0ZXh0dXJlLmltYWdlLndpZHRoICogbGV2ZWxTY2FsZSApO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gTWF0aC5mbG9vciggdGV4dHVyZS5pbWFnZS5oZWlnaHQgKiBsZXZlbFNjYWxlICk7XG5cblx0XHRcdGNvbnN0IHggPSBwb3NpdGlvbiAhPT0gbnVsbCA/IHBvc2l0aW9uLnggOiAwO1xuXHRcdFx0Y29uc3QgeSA9IHBvc2l0aW9uICE9PSBudWxsID8gcG9zaXRpb24ueSA6IDA7XG5cblx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdGV4dHVyZSwgMCApO1xuXG5cdFx0XHRfZ2wuY29weVRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbCwgMCwgMCwgeCwgeSwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZSA9IGZ1bmN0aW9uICggc3JjVGV4dHVyZSwgZHN0VGV4dHVyZSwgc3JjUmVnaW9uID0gbnVsbCwgZHN0UG9zaXRpb24gPSBudWxsLCBsZXZlbCA9IDAgKSB7XG5cblx0XHRcdC8vIHN1cHBvcnQgcHJldmlvdXMgc2lnbmF0dXJlIHdpdGggZHN0UG9zaXRpb24gZmlyc3Rcblx0XHRcdGlmICggc3JjVGV4dHVyZS5pc1RleHR1cmUgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0Ly8gQGRlcHJlY2F0ZWQsIHIxNjVcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogY29weVRleHR1cmVUb1RleHR1cmUgZnVuY3Rpb24gc2lnbmF0dXJlIGhhcyBjaGFuZ2VkLicgKTtcblxuXHRcdFx0XHRkc3RQb3NpdGlvbiA9IGFyZ3VtZW50c1sgMCBdIHx8IG51bGw7XG5cdFx0XHRcdHNyY1RleHR1cmUgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdFx0ZHN0VGV4dHVyZSA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0XHRsZXZlbCA9IGFyZ3VtZW50c1sgMyBdIHx8IDA7XG5cdFx0XHRcdHNyY1JlZ2lvbiA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IHdpZHRoLCBoZWlnaHQsIG1pblgsIG1pblk7XG5cdFx0XHRsZXQgZHN0WCwgZHN0WTtcblx0XHRcdGlmICggc3JjUmVnaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHdpZHRoID0gc3JjUmVnaW9uLm1heC54IC0gc3JjUmVnaW9uLm1pbi54O1xuXHRcdFx0XHRoZWlnaHQgPSBzcmNSZWdpb24ubWF4LnkgLSBzcmNSZWdpb24ubWluLnk7XG5cdFx0XHRcdG1pblggPSBzcmNSZWdpb24ubWluLng7XG5cdFx0XHRcdG1pblkgPSBzcmNSZWdpb24ubWluLnk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0d2lkdGggPSBzcmNUZXh0dXJlLmltYWdlLndpZHRoO1xuXHRcdFx0XHRoZWlnaHQgPSBzcmNUZXh0dXJlLmltYWdlLmhlaWdodDtcblx0XHRcdFx0bWluWCA9IDA7XG5cdFx0XHRcdG1pblkgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZHN0UG9zaXRpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0ZHN0WCA9IGRzdFBvc2l0aW9uLng7XG5cdFx0XHRcdGRzdFkgPSBkc3RQb3NpdGlvbi55O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGRzdFggPSAwO1xuXHRcdFx0XHRkc3RZID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIGRzdFRleHR1cmUuZm9ybWF0ICk7XG5cdFx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCBkc3RUZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCBkc3RUZXh0dXJlLCAwICk7XG5cblx0XHRcdC8vIEFzIGFub3RoZXIgdGV4dHVyZSB1cGxvYWQgbWF5IGhhdmUgY2hhbmdlZCBwaXhlbFN0b3JlaVxuXHRcdFx0Ly8gcGFyYW1ldGVycywgbWFrZSBzdXJlIHRoZXkgYXJlIGNvcnJlY3QgZm9yIHRoZSBkc3RUZXh0dXJlXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBkc3RUZXh0dXJlLmZsaXBZICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGRzdFRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgZHN0VGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcblxuXHRcdFx0Y29uc3QgY3VycmVudFVucGFja1Jvd0xlbiA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5VTlBBQ0tfUk9XX0xFTkdUSCApO1xuXHRcdFx0Y29uc3QgY3VycmVudFVucGFja0ltYWdlSGVpZ2h0ID0gX2dsLmdldFBhcmFtZXRlciggX2dsLlVOUEFDS19JTUFHRV9IRUlHSFQgKTtcblx0XHRcdGNvbnN0IGN1cnJlbnRVbnBhY2tTa2lwUGl4ZWxzID0gX2dsLmdldFBhcmFtZXRlciggX2dsLlVOUEFDS19TS0lQX1BJWEVMUyApO1xuXHRcdFx0Y29uc3QgY3VycmVudFVucGFja1NraXBSb3dzID0gX2dsLmdldFBhcmFtZXRlciggX2dsLlVOUEFDS19TS0lQX1JPV1MgKTtcblx0XHRcdGNvbnN0IGN1cnJlbnRVbnBhY2tTa2lwSW1hZ2VzID0gX2dsLmdldFBhcmFtZXRlciggX2dsLlVOUEFDS19TS0lQX0lNQUdFUyApO1xuXG5cdFx0XHRjb25zdCBpbWFnZSA9IHNyY1RleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSA/IHNyY1RleHR1cmUubWlwbWFwc1sgbGV2ZWwgXSA6IHNyY1RleHR1cmUuaW1hZ2U7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19ST1dfTEVOR1RILCBpbWFnZS53aWR0aCApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCwgaW1hZ2UuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMsIG1pblggKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX1JPV1MsIG1pblkgKTtcblxuXHRcdFx0aWYgKCBzcmNUZXh0dXJlLmlzRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdFx0X2dsLnRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbCwgZHN0WCwgZHN0WSwgd2lkdGgsIGhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggc3JjVGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0X2dsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgbGV2ZWwsIGRzdFgsIGRzdFksIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGdsRm9ybWF0LCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdF9nbC50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgbGV2ZWwsIGRzdFgsIGRzdFksIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19ST1dfTEVOR1RILCBjdXJyZW50VW5wYWNrUm93TGVuICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfSU1BR0VfSEVJR0hULCBjdXJyZW50VW5wYWNrSW1hZ2VIZWlnaHQgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX1BJWEVMUywgY3VycmVudFVucGFja1NraXBQaXhlbHMgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX1JPV1MsIGN1cnJlbnRVbnBhY2tTa2lwUm93cyApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1NLSVBfSU1BR0VTLCBjdXJyZW50VW5wYWNrU2tpcEltYWdlcyApO1xuXG5cdFx0XHQvLyBHZW5lcmF0ZSBtaXBtYXBzIG9ubHkgd2hlbiBjb3B5aW5nIGxldmVsIDBcblx0XHRcdGlmICggbGV2ZWwgPT09IDAgJiYgZHN0VGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG5cblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0QgPSBmdW5jdGlvbiAoIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIHNyY1JlZ2lvbiA9IG51bGwsIGRzdFBvc2l0aW9uID0gbnVsbCwgbGV2ZWwgPSAwICkge1xuXG5cdFx0XHQvLyBzdXBwb3J0IHByZXZpb3VzIHNpZ25hdHVyZSB3aXRoIHNvdXJjZSBib3ggZmlyc3Rcblx0XHRcdGlmICggc3JjVGV4dHVyZS5pc1RleHR1cmUgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0Ly8gQGRlcHJlY2F0ZWQsIHIxNjVcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogY29weVRleHR1cmVUb1RleHR1cmUzRCBmdW5jdGlvbiBzaWduYXR1cmUgaGFzIGNoYW5nZWQuJyApO1xuXG5cdFx0XHRcdHNyY1JlZ2lvbiA9IGFyZ3VtZW50c1sgMCBdIHx8IG51bGw7XG5cdFx0XHRcdGRzdFBvc2l0aW9uID0gYXJndW1lbnRzWyAxIF0gfHwgbnVsbDtcblx0XHRcdFx0c3JjVGV4dHVyZSA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0XHRkc3RUZXh0dXJlID0gYXJndW1lbnRzWyAzIF07XG5cdFx0XHRcdGxldmVsID0gYXJndW1lbnRzWyA0IF0gfHwgMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgd2lkdGgsIGhlaWdodCwgZGVwdGgsIG1pblgsIG1pblksIG1pblo7XG5cdFx0XHRsZXQgZHN0WCwgZHN0WSwgZHN0Wjtcblx0XHRcdGNvbnN0IGltYWdlID0gc3JjVGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlID8gc3JjVGV4dHVyZS5taXBtYXBzWyBsZXZlbCBdIDogc3JjVGV4dHVyZS5pbWFnZTtcblx0XHRcdGlmICggc3JjUmVnaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHdpZHRoID0gc3JjUmVnaW9uLm1heC54IC0gc3JjUmVnaW9uLm1pbi54O1xuXHRcdFx0XHRoZWlnaHQgPSBzcmNSZWdpb24ubWF4LnkgLSBzcmNSZWdpb24ubWluLnk7XG5cdFx0XHRcdGRlcHRoID0gc3JjUmVnaW9uLm1heC56IC0gc3JjUmVnaW9uLm1pbi56O1xuXHRcdFx0XHRtaW5YID0gc3JjUmVnaW9uLm1pbi54O1xuXHRcdFx0XHRtaW5ZID0gc3JjUmVnaW9uLm1pbi55O1xuXHRcdFx0XHRtaW5aID0gc3JjUmVnaW9uLm1pbi56O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHdpZHRoID0gaW1hZ2Uud2lkdGg7XG5cdFx0XHRcdGhlaWdodCA9IGltYWdlLmhlaWdodDtcblx0XHRcdFx0ZGVwdGggPSBpbWFnZS5kZXB0aDtcblx0XHRcdFx0bWluWCA9IDA7XG5cdFx0XHRcdG1pblkgPSAwO1xuXHRcdFx0XHRtaW5aID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGRzdFBvc2l0aW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGRzdFggPSBkc3RQb3NpdGlvbi54O1xuXHRcdFx0XHRkc3RZID0gZHN0UG9zaXRpb24ueTtcblx0XHRcdFx0ZHN0WiA9IGRzdFBvc2l0aW9uLno7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZHN0WCA9IDA7XG5cdFx0XHRcdGRzdFkgPSAwO1xuXHRcdFx0XHRkc3RaID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIGRzdFRleHR1cmUuZm9ybWF0ICk7XG5cdFx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCBkc3RUZXh0dXJlLnR5cGUgKTtcblx0XHRcdGxldCBnbFRhcmdldDtcblxuXHRcdFx0aWYgKCBkc3RUZXh0dXJlLmlzRGF0YTNEVGV4dHVyZSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlM0QoIGRzdFRleHR1cmUsIDAgKTtcblx0XHRcdFx0Z2xUYXJnZXQgPSBfZ2wuVEVYVFVSRV8zRDtcblxuXHRcdFx0fSBlbHNlIGlmICggZHN0VGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgfHwgZHN0VGV4dHVyZS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUgKSB7XG5cblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEQXJyYXkoIGRzdFRleHR1cmUsIDAgKTtcblx0XHRcdFx0Z2xUYXJnZXQgPSBfZ2wuVEVYVFVSRV8yRF9BUlJBWTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q6IG9ubHkgc3VwcG9ydHMgVEhSRUUuRGF0YVRleHR1cmUzRCBhbmQgVEhSRUUuRGF0YVRleHR1cmUyREFycmF5LicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIGRzdFRleHR1cmUuZmxpcFkgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZHN0VGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCBkc3RUZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xuXG5cdFx0XHRjb25zdCBjdXJyZW50VW5wYWNrUm93TGVuID0gX2dsLmdldFBhcmFtZXRlciggX2dsLlVOUEFDS19ST1dfTEVOR1RIICk7XG5cdFx0XHRjb25zdCBjdXJyZW50VW5wYWNrSW1hZ2VIZWlnaHQgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCApO1xuXHRcdFx0Y29uc3QgY3VycmVudFVucGFja1NraXBQaXhlbHMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuVU5QQUNLX1NLSVBfUElYRUxTICk7XG5cdFx0XHRjb25zdCBjdXJyZW50VW5wYWNrU2tpcFJvd3MgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuVU5QQUNLX1NLSVBfUk9XUyApO1xuXHRcdFx0Y29uc3QgY3VycmVudFVucGFja1NraXBJbWFnZXMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuVU5QQUNLX1NLSVBfSU1BR0VTICk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19ST1dfTEVOR1RILCBpbWFnZS53aWR0aCApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCwgaW1hZ2UuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMsIG1pblggKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX1JPV1MsIG1pblkgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX0lNQUdFUywgbWluWiApO1xuXG5cdFx0XHRpZiAoIHNyY1RleHR1cmUuaXNEYXRhVGV4dHVyZSB8fCBzcmNUZXh0dXJlLmlzRGF0YTNEVGV4dHVyZSApIHtcblxuXHRcdFx0XHRfZ2wudGV4U3ViSW1hZ2UzRCggZ2xUYXJnZXQsIGxldmVsLCBkc3RYLCBkc3RZLCBkc3RaLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggZHN0VGV4dHVyZS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRfZ2wuY29tcHJlc3NlZFRleFN1YkltYWdlM0QoIGdsVGFyZ2V0LCBsZXZlbCwgZHN0WCwgZHN0WSwgZHN0Wiwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGdsRm9ybWF0LCBpbWFnZS5kYXRhICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdF9nbC50ZXhTdWJJbWFnZTNEKCBnbFRhcmdldCwgbGV2ZWwsIGRzdFgsIGRzdFksIGRzdFosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUk9XX0xFTkdUSCwgY3VycmVudFVucGFja1Jvd0xlbiApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCwgY3VycmVudFVucGFja0ltYWdlSGVpZ2h0ICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMsIGN1cnJlbnRVbnBhY2tTa2lwUGl4ZWxzICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfU0tJUF9ST1dTLCBjdXJyZW50VW5wYWNrU2tpcFJvd3MgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX0lNQUdFUywgY3VycmVudFVucGFja1NraXBJbWFnZXMgKTtcblxuXHRcdFx0Ly8gR2VuZXJhdGUgbWlwbWFwcyBvbmx5IHdoZW4gY29weWluZyBsZXZlbCAwXG5cdFx0XHRpZiAoIGxldmVsID09PSAwICYmIGRzdFRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBnbFRhcmdldCApO1xuXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5pbml0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XG5cblx0XHRcdGlmICggcHJvcGVydGllcy5nZXQoIHRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmVzLnNldHVwUmVuZGVyVGFyZ2V0KCB0YXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuaW5pdFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZS5pc0N1YmVUZXh0dXJlICkge1xuXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmVDdWJlKCB0ZXh0dXJlLCAwICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkge1xuXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUzRCggdGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheSggdGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnJlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdF9jdXJyZW50QWN0aXZlQ3ViZUZhY2UgPSAwO1xuXHRcdFx0X2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbCA9IDA7XG5cdFx0XHRfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XG5cblx0XHRcdHN0YXRlLnJlc2V0KCk7XG5cdFx0XHRiaW5kaW5nU3RhdGVzLnJlc2V0KCk7XG5cblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgX19USFJFRV9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyApIHtcblxuXHRcdFx0X19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudCggJ29ic2VydmUnLCB7IGRldGFpbDogdGhpcyB9ICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0IGNvb3JkaW5hdGVTeXN0ZW0oKSB7XG5cblx0XHRyZXR1cm4gV2ViR0xDb29yZGluYXRlU3lzdGVtO1xuXG5cdH1cblxuXHRnZXQgb3V0cHV0Q29sb3JTcGFjZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9vdXRwdXRDb2xvclNwYWNlO1xuXG5cdH1cblxuXHRzZXQgb3V0cHV0Q29sb3JTcGFjZSggY29sb3JTcGFjZSApIHtcblxuXHRcdHRoaXMuX291dHB1dENvbG9yU3BhY2UgPSBjb2xvclNwYWNlO1xuXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdldENvbnRleHQoKTtcblx0XHRnbC5kcmF3aW5nQnVmZmVyQ29sb3JTcGFjZSA9IGNvbG9yU3BhY2UgPT09IERpc3BsYXlQM0NvbG9yU3BhY2UgPyAnZGlzcGxheS1wMycgOiAnc3JnYic7XG5cdFx0Z2wudW5wYWNrQ29sb3JTcGFjZSA9IENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSA9PT0gTGluZWFyRGlzcGxheVAzQ29sb3JTcGFjZSA/ICdkaXNwbGF5LXAzJyA6ICdzcmdiJztcblxuXHR9XG5cbn1cblxuY2xhc3MgRm9nRXhwMiB7XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBkZW5zaXR5ID0gMC4wMDAyNSApIHtcblxuXHRcdHRoaXMuaXNGb2dFeHAyID0gdHJ1ZTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcblx0XHR0aGlzLmRlbnNpdHkgPSBkZW5zaXR5O1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgRm9nRXhwMiggdGhpcy5jb2xvciwgdGhpcy5kZW5zaXR5ICk7XG5cblx0fVxuXG5cdHRvSlNPTiggLyogbWV0YSAqLyApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiAnRm9nRXhwMicsXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcblx0XHRcdGRlbnNpdHk6IHRoaXMuZGVuc2l0eVxuXHRcdH07XG5cblx0fVxuXG59XG5cbmNsYXNzIEZvZyB7XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBuZWFyID0gMSwgZmFyID0gMTAwMCApIHtcblxuXHRcdHRoaXMuaXNGb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xuXG5cdFx0dGhpcy5uZWFyID0gbmVhcjtcblx0XHR0aGlzLmZhciA9IGZhcjtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IEZvZyggdGhpcy5jb2xvciwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG5cdH1cblxuXHR0b0pTT04oIC8qIG1ldGEgKi8gKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogJ0ZvZycsXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcblx0XHRcdG5lYXI6IHRoaXMubmVhcixcblx0XHRcdGZhcjogdGhpcy5mYXJcblx0XHR9O1xuXG5cdH1cblxufVxuXG5jbGFzcyBTY2VuZSBleHRlbmRzIE9iamVjdDNEIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzU2NlbmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NjZW5lJztcblxuXHRcdHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG5cdFx0dGhpcy5lbnZpcm9ubWVudCA9IG51bGw7XG5cdFx0dGhpcy5mb2cgPSBudWxsO1xuXG5cdFx0dGhpcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IDA7XG5cdFx0dGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gMTtcblx0XHR0aGlzLmJhY2tncm91bmRSb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuXG5cdFx0dGhpcy5lbnZpcm9ubWVudEludGVuc2l0eSA9IDE7XG5cdFx0dGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG5cblx0XHR0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xuXG5cdFx0aWYgKCB0eXBlb2YgX19USFJFRV9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyApIHtcblxuXHRcdFx0X19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudCggJ29ic2VydmUnLCB7IGRldGFpbDogdGhpcyB9ICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0aWYgKCBzb3VyY2UuYmFja2dyb3VuZCAhPT0gbnVsbCApIHRoaXMuYmFja2dyb3VuZCA9IHNvdXJjZS5iYWNrZ3JvdW5kLmNsb25lKCk7XG5cdFx0aWYgKCBzb3VyY2UuZW52aXJvbm1lbnQgIT09IG51bGwgKSB0aGlzLmVudmlyb25tZW50ID0gc291cmNlLmVudmlyb25tZW50LmNsb25lKCk7XG5cdFx0aWYgKCBzb3VyY2UuZm9nICE9PSBudWxsICkgdGhpcy5mb2cgPSBzb3VyY2UuZm9nLmNsb25lKCk7XG5cblx0XHR0aGlzLmJhY2tncm91bmRCbHVycmluZXNzID0gc291cmNlLmJhY2tncm91bmRCbHVycmluZXNzO1xuXHRcdHRoaXMuYmFja2dyb3VuZEludGVuc2l0eSA9IHNvdXJjZS5iYWNrZ3JvdW5kSW50ZW5zaXR5O1xuXHRcdHRoaXMuYmFja2dyb3VuZFJvdGF0aW9uLmNvcHkoIHNvdXJjZS5iYWNrZ3JvdW5kUm90YXRpb24gKTtcblxuXHRcdHRoaXMuZW52aXJvbm1lbnRJbnRlbnNpdHkgPSBzb3VyY2UuZW52aXJvbm1lbnRJbnRlbnNpdHk7XG5cdFx0dGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uLmNvcHkoIHNvdXJjZS5lbnZpcm9ubWVudFJvdGF0aW9uICk7XG5cblx0XHRpZiAoIHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcblxuXHRcdGlmICggdGhpcy5mb2cgIT09IG51bGwgKSBkYXRhLm9iamVjdC5mb2cgPSB0aGlzLmZvZy50b0pTT04oKTtcblxuXHRcdGlmICggdGhpcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA+IDAgKSBkYXRhLm9iamVjdC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IHRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3M7XG5cdFx0aWYgKCB0aGlzLmJhY2tncm91bmRJbnRlbnNpdHkgIT09IDEgKSBkYXRhLm9iamVjdC5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gdGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5O1xuXHRcdGRhdGEub2JqZWN0LmJhY2tncm91bmRSb3RhdGlvbiA9IHRoaXMuYmFja2dyb3VuZFJvdGF0aW9uLnRvQXJyYXkoKTtcblxuXHRcdGlmICggdGhpcy5lbnZpcm9ubWVudEludGVuc2l0eSAhPT0gMSApIGRhdGEub2JqZWN0LmVudmlyb25tZW50SW50ZW5zaXR5ID0gdGhpcy5lbnZpcm9ubWVudEludGVuc2l0eTtcblx0XHRkYXRhLm9iamVjdC5lbnZpcm9ubWVudFJvdGF0aW9uID0gdGhpcy5lbnZpcm9ubWVudFJvdGF0aW9uLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5jbGFzcyBJbnRlcmxlYXZlZEJ1ZmZlciB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBzdHJpZGUgKSB7XG5cblx0XHR0aGlzLmlzSW50ZXJsZWF2ZWRCdWZmZXIgPSB0cnVlO1xuXG5cdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXHRcdHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuXHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gc3RyaWRlIDogMDtcblxuXHRcdHRoaXMudXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XG5cdFx0dGhpcy5fdXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xuXHRcdHRoaXMudXBkYXRlUmFuZ2VzID0gW107XG5cblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0fVxuXG5cdG9uVXBsb2FkQ2FsbGJhY2soKSB7fVxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdH1cblxuXHRnZXQgdXBkYXRlUmFuZ2UoKSB7XG5cblx0XHR3YXJuT25jZSggJ1RIUkVFLkludGVybGVhdmVkQnVmZmVyOiB1cGRhdGVSYW5nZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiByMTY5LiBVc2UgYWRkVXBkYXRlUmFuZ2UoKSBpbnN0ZWFkLicgKTsgLy8gQGRlcHJlY2F0ZWQsIHIxNTlcblx0XHRyZXR1cm4gdGhpcy5fdXBkYXRlUmFuZ2U7XG5cblx0fVxuXG5cdHNldFVzYWdlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudXNhZ2UgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRVcGRhdGVSYW5nZSggc3RhcnQsIGNvdW50ICkge1xuXG5cdFx0dGhpcy51cGRhdGVSYW5nZXMucHVzaCggeyBzdGFydCwgY291bnQgfSApO1xuXG5cdH1cblxuXHRjbGVhclVwZGF0ZVJhbmdlcygpIHtcblxuXHRcdHRoaXMudXBkYXRlUmFuZ2VzLmxlbmd0aCA9IDA7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXHRcdHRoaXMuc3RyaWRlID0gc291cmNlLnN0cmlkZTtcblx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlBdCggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuXHRcdGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcblx0XHRpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0KCB2YWx1ZSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzID0ge307XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID0gdGhpcy5hcnJheS5zbGljZSggMCApLmJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGFycmF5ID0gbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdICk7XG5cblx0XHRjb25zdCBpYiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCBhcnJheSwgdGhpcy5zdHJpZGUgKTtcblx0XHRpYi5zZXRVc2FnZSggdGhpcy51c2FnZSApO1xuXG5cdFx0cmV0dXJuIGliO1xuXG5cdH1cblxuXHRvblVwbG9hZCggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzID0ge307XG5cblx0XHR9XG5cblx0XHQvLyBnZW5lcmF0ZSBVVUlEIGZvciBhcnJheSBidWZmZXIgaWYgbmVjZXNzYXJ5XG5cblx0XHRpZiAoIHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID0gQXJyYXkuZnJvbSggbmV3IFVpbnQzMkFycmF5KCB0aGlzLmFycmF5LmJ1ZmZlciApICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdGJ1ZmZlcjogdGhpcy5hcnJheS5idWZmZXIuX3V1aWQsXG5cdFx0XHR0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRzdHJpZGU6IHRoaXMuc3RyaWRlXG5cdFx0fTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciQ2ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBub3JtYWxpemVkID0gZmFsc2UgKSB7XG5cblx0XHR0aGlzLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLmRhdGEgPSBpbnRlcmxlYXZlZEJ1ZmZlcjtcblx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuXG5cdH1cblxuXHRnZXQgY291bnQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kYXRhLmNvdW50O1xuXG5cdH1cblxuXHRnZXQgYXJyYXkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5O1xuXG5cdH1cblxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5kYXRhLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuZGF0YS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdF92ZWN0b3IkNi5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IkNi5hcHBseU1hdHJpeDQoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IkNi54LCBfdmVjdG9yJDYueSwgX3ZlY3RvciQ2LnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU5vcm1hbE1hdHJpeCggbSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yJDYuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXG5cdFx0XHRfdmVjdG9yJDYuYXBwbHlOb3JtYWxNYXRyaXgoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IkNi54LCBfdmVjdG9yJDYueSwgX3ZlY3RvciQ2LnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3RvciQ2LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcblxuXHRcdFx0X3ZlY3RvciQ2LnRyYW5zZm9ybURpcmVjdGlvbiggbSApO1xuXG5cdFx0XHR0aGlzLnNldFhZWiggaSwgX3ZlY3RvciQ2LngsIF92ZWN0b3IkNi55LCBfdmVjdG9yJDYueiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldENvbXBvbmVudCggaW5kZXgsIGNvbXBvbmVudCApIHtcblxuXHRcdGxldCB2YWx1ZSA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgY29tcG9uZW50IF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHZhbHVlID0gZGVub3JtYWxpemUoIHZhbHVlLCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG5cdHNldENvbXBvbmVudCggaW5kZXgsIGNvbXBvbmVudCwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHZhbHVlID0gbm9ybWFsaXplKCB2YWx1ZSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIGNvbXBvbmVudCBdID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WCggaW5kZXgsIHggKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXSA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WSggaW5kZXgsIHkgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF0gPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFooIGluZGV4LCB6ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRXKCBpbmRleCwgdyApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WCggaW5kZXggKSB7XG5cblx0XHRsZXQgeCA9IHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IGRlbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geDtcblxuXHR9XG5cblx0Z2V0WSggaW5kZXggKSB7XG5cblx0XHRsZXQgeSA9IHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBkZW5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHk7XG5cblx0fVxuXG5cdGdldFooIGluZGV4ICkge1xuXG5cdFx0bGV0IHogPSB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB6O1xuXG5cdH1cblxuXHRnZXRXKCBpbmRleCApIHtcblxuXHRcdGxldCB3ID0gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdztcblxuXHR9XG5cblx0c2V0WFkoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVooIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVpXKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXHRcdFx0dyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5jbG9uZSgpOiBDbG9uaW5nIGFuIGludGVybGVhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZS1pbnRlcmxlYXZlIGJ1ZmZlciBkYXRhLicgKTtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGkgKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgdGhpcy5pdGVtU2l6ZTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyBqIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKCBhcnJheSApLCB0aGlzLml0ZW1TaXplLCB0aGlzLm5vcm1hbGl6ZWQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVycyA9IHt9O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbIHRoaXMuZGF0YS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVyc1sgdGhpcy5kYXRhLnV1aWQgXSA9IHRoaXMuZGF0YS5jbG9uZSggZGF0YSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzWyB0aGlzLmRhdGEudXVpZCBdLCB0aGlzLml0ZW1TaXplLCB0aGlzLm9mZnNldCwgdGhpcy5ub3JtYWxpemVkICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvSlNPTiggZGF0YSApIHtcblxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnRvSlNPTigpOiBTZXJpYWxpemluZyBhbiBpbnRlcmxlYXZlZCBidWZmZXIgYXR0cmlidXRlIHdpbGwgZGUtaW50ZXJsZWF2ZSBidWZmZXIgZGF0YS4nICk7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHRoaXMuaXRlbVNpemU7IGogKysgKSB7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgaiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlLWludGVybGVhdmUgZGF0YSBhbmQgc2F2ZSBpdCBhcyBhbiBvcmRpbmFyeSBidWZmZXIgYXR0cmlidXRlIGZvciBub3dcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG5cdFx0XHRcdHR5cGU6IHRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0YXJyYXk6IGFycmF5LFxuXHRcdFx0XHRub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcblx0XHRcdH07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBzYXZlIGFzIHRydWUgaW50ZXJsZWF2ZWQgYXR0cmlidXRlXG5cblx0XHRcdGlmICggZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVycyA9IHt9O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbIHRoaXMuZGF0YS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVyc1sgdGhpcy5kYXRhLnV1aWQgXSA9IHRoaXMuZGF0YS50b0pTT04oIGRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxuXHRcdFx0XHRpdGVtU2l6ZTogdGhpcy5pdGVtU2l6ZSxcblx0XHRcdFx0ZGF0YTogdGhpcy5kYXRhLnV1aWQsXG5cdFx0XHRcdG9mZnNldDogdGhpcy5vZmZzZXQsXG5cdFx0XHRcdG5vcm1hbGl6ZWQ6IHRoaXMubm9ybWFsaXplZFxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuY2xhc3MgU3ByaXRlTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1Nwcml0ZU1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblxuXHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblxuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxubGV0IF9nZW9tZXRyeTtcblxuY29uc3QgX2ludGVyc2VjdFBvaW50ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3dvcmxkU2NhbGUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbXZQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2FsaWduZWRQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF9yb3RhdGVkUG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5jb25zdCBfdmlld1dvcmxkTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5jb25zdCBfdkEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF91dkEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5jb25zdCBfdXZCID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xuY29uc3QgX3V2QyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxuY2xhc3MgU3ByaXRlIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBtYXRlcmlhbCA9IG5ldyBTcHJpdGVNYXRlcmlhbCgpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNTcHJpdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1Nwcml0ZSc7XG5cblx0XHRpZiAoIF9nZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRfZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0Y29uc3QgZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXHRcdFx0XHQtIDAuNSwgLSAwLjUsIDAsIDAsIDAsXG5cdFx0XHRcdDAuNSwgLSAwLjUsIDAsIDEsIDAsXG5cdFx0XHRcdDAuNSwgMC41LCAwLCAxLCAxLFxuXHRcdFx0XHQtIDAuNSwgMC41LCAwLCAwLCAxXG5cdFx0XHRdICk7XG5cblx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKCBmbG9hdDMyQXJyYXksIDUgKTtcblxuXHRcdFx0X2dlb21ldHJ5LnNldEluZGV4KCBbIDAsIDEsIDIsXHQwLCAyLCAzIF0gKTtcblx0XHRcdF9nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaW50ZXJsZWF2ZWRCdWZmZXIsIDMsIDAsIGZhbHNlICkgKTtcblx0XHRcdF9nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaW50ZXJsZWF2ZWRCdWZmZXIsIDIsIDMsIGZhbHNlICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBfZ2VvbWV0cnk7XG5cdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdFx0dGhpcy5jZW50ZXIgPSBuZXcgVmVjdG9yMiggMC41LCAwLjUgKTtcblxuXHR9XG5cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0aWYgKCByYXljYXN0ZXIuY2FtZXJhID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU3ByaXRlOiBcIlJheWNhc3Rlci5jYW1lcmFcIiBuZWVkcyB0byBiZSBzZXQgaW4gb3JkZXIgdG8gcmF5Y2FzdCBhZ2FpbnN0IHNwcml0ZXMuJyApO1xuXG5cdFx0fVxuXG5cdFx0X3dvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRfdmlld1dvcmxkTWF0cml4LmNvcHkoIHJheWNhc3Rlci5jYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHR0aGlzLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCByYXljYXN0ZXIuY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0X212UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1vZGVsVmlld01hdHJpeCApO1xuXG5cdFx0aWYgKCByYXljYXN0ZXIuY2FtZXJhLmlzUGVyc3BlY3RpdmVDYW1lcmEgJiYgdGhpcy5tYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPT09IGZhbHNlICkge1xuXG5cdFx0XHRfd29ybGRTY2FsZS5tdWx0aXBseVNjYWxhciggLSBfbXZQb3NpdGlvbi56ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCByb3RhdGlvbiA9IHRoaXMubWF0ZXJpYWwucm90YXRpb247XG5cdFx0bGV0IHNpbiwgY29zO1xuXG5cdFx0aWYgKCByb3RhdGlvbiAhPT0gMCApIHtcblxuXHRcdFx0Y29zID0gTWF0aC5jb3MoIHJvdGF0aW9uICk7XG5cdFx0XHRzaW4gPSBNYXRoLnNpbiggcm90YXRpb24gKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG5cdFx0dHJhbnNmb3JtVmVydGV4KCBfdkEuc2V0KCAtIDAuNSwgLSAwLjUsIDAgKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zICk7XG5cdFx0dHJhbnNmb3JtVmVydGV4KCBfdkIuc2V0KCAwLjUsIC0gMC41LCAwICksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyApO1xuXHRcdHRyYW5zZm9ybVZlcnRleCggX3ZDLnNldCggMC41LCAwLjUsIDAgKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zICk7XG5cblx0XHRfdXZBLnNldCggMCwgMCApO1xuXHRcdF91dkIuc2V0KCAxLCAwICk7XG5cdFx0X3V2Qy5zZXQoIDEsIDEgKTtcblxuXHRcdC8vIGNoZWNrIGZpcnN0IHRyaWFuZ2xlXG5cdFx0bGV0IGludGVyc2VjdCA9IHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0VHJpYW5nbGUoIF92QSwgX3ZCLCBfdkMsIGZhbHNlLCBfaW50ZXJzZWN0UG9pbnQgKTtcblxuXHRcdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkge1xuXG5cdFx0XHQvLyBjaGVjayBzZWNvbmQgdHJpYW5nbGVcblx0XHRcdHRyYW5zZm9ybVZlcnRleCggX3ZCLnNldCggLSAwLjUsIDAuNSwgMCApLCBfbXZQb3NpdGlvbiwgY2VudGVyLCBfd29ybGRTY2FsZSwgc2luLCBjb3MgKTtcblx0XHRcdF91dkIuc2V0KCAwLCAxICk7XG5cblx0XHRcdGludGVyc2VjdCA9IHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0VHJpYW5nbGUoIF92QSwgX3ZDLCBfdkIsIGZhbHNlLCBfaW50ZXJzZWN0UG9pbnQgKTtcblx0XHRcdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBfaW50ZXJzZWN0UG9pbnQgKTtcblxuXHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XG5cblx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0cG9pbnQ6IF9pbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxuXHRcdFx0dXY6IFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3RQb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFZlY3RvcjIoKSApLFxuXHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdG9iamVjdDogdGhpc1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHRpZiAoIHNvdXJjZS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHRoaXMuY2VudGVyLmNvcHkoIHNvdXJjZS5jZW50ZXIgKTtcblxuXHRcdHRoaXMubWF0ZXJpYWwgPSBzb3VyY2UubWF0ZXJpYWw7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtVmVydGV4KCB2ZXJ0ZXhQb3NpdGlvbiwgbXZQb3NpdGlvbiwgY2VudGVyLCBzY2FsZSwgc2luLCBjb3MgKSB7XG5cblx0Ly8gY29tcHV0ZSBwb3NpdGlvbiBpbiBjYW1lcmEgc3BhY2Vcblx0X2FsaWduZWRQb3NpdGlvbi5zdWJWZWN0b3JzKCB2ZXJ0ZXhQb3NpdGlvbiwgY2VudGVyICkuYWRkU2NhbGFyKCAwLjUgKS5tdWx0aXBseSggc2NhbGUgKTtcblxuXHQvLyB0byBjaGVjayBpZiByb3RhdGlvbiBpcyBub3QgemVyb1xuXHRpZiAoIHNpbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0X3JvdGF0ZWRQb3NpdGlvbi54ID0gKCBjb3MgKiBfYWxpZ25lZFBvc2l0aW9uLnggKSAtICggc2luICogX2FsaWduZWRQb3NpdGlvbi55ICk7XG5cdFx0X3JvdGF0ZWRQb3NpdGlvbi55ID0gKCBzaW4gKiBfYWxpZ25lZFBvc2l0aW9uLnggKSArICggY29zICogX2FsaWduZWRQb3NpdGlvbi55ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdF9yb3RhdGVkUG9zaXRpb24uY29weSggX2FsaWduZWRQb3NpdGlvbiApO1xuXG5cdH1cblxuXG5cdHZlcnRleFBvc2l0aW9uLmNvcHkoIG12UG9zaXRpb24gKTtcblx0dmVydGV4UG9zaXRpb24ueCArPSBfcm90YXRlZFBvc2l0aW9uLng7XG5cdHZlcnRleFBvc2l0aW9uLnkgKz0gX3JvdGF0ZWRQb3NpdGlvbi55O1xuXG5cdC8vIHRyYW5zZm9ybSB0byB3b3JsZCBzcGFjZVxuXHR2ZXJ0ZXhQb3NpdGlvbi5hcHBseU1hdHJpeDQoIF92aWV3V29ybGRNYXRyaXggKTtcblxufVxuXG5jb25zdCBfdjEkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBMT0QgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5fY3VycmVudExldmVsID0gMDtcblxuXHRcdHRoaXMudHlwZSA9ICdMT0QnO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRcdGxldmVsczoge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogW11cblx0XHRcdH0sXG5cdFx0XHRpc0xPRDoge1xuXHRcdFx0XHR2YWx1ZTogdHJ1ZSxcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIGZhbHNlICk7XG5cblx0XHRjb25zdCBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGxldmVsID0gbGV2ZWxzWyBpIF07XG5cblx0XHRcdHRoaXMuYWRkTGV2ZWwoIGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSwgbGV2ZWwuaHlzdGVyZXNpcyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkTGV2ZWwoIG9iamVjdCwgZGlzdGFuY2UgPSAwLCBoeXN0ZXJlc2lzID0gMCApIHtcblxuXHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XG5cblx0XHRjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdGxldCBsO1xuXG5cdFx0Zm9yICggbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xuXG5cdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGxldmVscy5zcGxpY2UoIGwsIDAsIHsgZGlzdGFuY2U6IGRpc3RhbmNlLCBoeXN0ZXJlc2lzOiBoeXN0ZXJlc2lzLCBvYmplY3Q6IG9iamVjdCB9ICk7XG5cblx0XHR0aGlzLmFkZCggb2JqZWN0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q3VycmVudExldmVsKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRMZXZlbDtcblxuXHR9XG5cblxuXG5cdGdldE9iamVjdEZvckRpc3RhbmNlKCBkaXN0YW5jZSApIHtcblxuXHRcdGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG5cdFx0aWYgKCBsZXZlbHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0bGV0IGksIGw7XG5cblx0XHRcdGZvciAoIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV0IGxldmVsRGlzdGFuY2UgPSBsZXZlbHNbIGkgXS5kaXN0YW5jZTtcblxuXHRcdFx0XHRpZiAoIGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlICkge1xuXG5cdFx0XHRcdFx0bGV2ZWxEaXN0YW5jZSAtPSBsZXZlbERpc3RhbmNlICogbGV2ZWxzWyBpIF0uaHlzdGVyZXNpcztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IGxldmVsRGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxldmVsc1sgaSAtIDEgXS5vYmplY3Q7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRfdjEkMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBfdjEkMiApO1xuXG5cdFx0XHR0aGlzLmdldE9iamVjdEZvckRpc3RhbmNlKCBkaXN0YW5jZSApLnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGUoIGNhbWVyYSApIHtcblxuXHRcdGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG5cdFx0aWYgKCBsZXZlbHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0X3YxJDIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdF92MiQxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IF92MSQyLmRpc3RhbmNlVG8oIF92MiQxICkgLyBjYW1lcmEuem9vbTtcblxuXHRcdFx0bGV2ZWxzWyAwIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXG5cdFx0XHRsZXQgaSwgbDtcblxuXHRcdFx0Zm9yICggaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgbGV2ZWxEaXN0YW5jZSA9IGxldmVsc1sgaSBdLmRpc3RhbmNlO1xuXG5cdFx0XHRcdGlmICggbGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgKSB7XG5cblx0XHRcdFx0XHRsZXZlbERpc3RhbmNlIC09IGxldmVsRGlzdGFuY2UgKiBsZXZlbHNbIGkgXS5oeXN0ZXJlc2lzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlID49IGxldmVsRGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRsZXZlbHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0XHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jdXJyZW50TGV2ZWwgPSBpIC0gMTtcblxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcblxuXHRcdGlmICggdGhpcy5hdXRvVXBkYXRlID09PSBmYWxzZSApIGRhdGEub2JqZWN0LmF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdGRhdGEub2JqZWN0LmxldmVscyA9IFtdO1xuXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuXHRcdFx0ZGF0YS5vYmplY3QubGV2ZWxzLnB1c2goIHtcblx0XHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcblx0XHRcdFx0ZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlLFxuXHRcdFx0XHRoeXN0ZXJlc2lzOiBsZXZlbC5oeXN0ZXJlc2lzXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuY29uc3QgX2Jhc2VQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3NraW5JbmRleCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjQoKTtcbmNvbnN0IF9za2luV2VpZ2h0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yNCgpO1xuXG5jb25zdCBfdmVjdG9yMyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tYXRyaXg0ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3ZlcnRleCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3NwaGVyZSQ0ID0gLypAX19QVVJFX18qLyBuZXcgU3BoZXJlKCk7XG5jb25zdCBfaW52ZXJzZU1hdHJpeCQyID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3JheSQyID0gLypAX19QVVJFX18qLyBuZXcgUmF5KCk7XG5cbmNsYXNzIFNraW5uZWRNZXNoIGV4dGVuZHMgTWVzaCB7XG5cblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMuaXNTa2lubmVkTWVzaCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2tpbm5lZE1lc2gnO1xuXG5cdFx0dGhpcy5iaW5kTW9kZSA9IEF0dGFjaGVkQmluZE1vZGU7XG5cdFx0dGhpcy5iaW5kTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdH1cblxuXHRjb21wdXRlQm91bmRpbmdCb3goKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTtcblxuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5nZXRWZXJ0ZXhQb3NpdGlvbiggaSwgX3ZlcnRleCApO1xuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfdmVydGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUubWFrZUVtcHR5KCk7XG5cblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZ2V0VmVydGV4UG9zaXRpb24oIGksIF92ZXJ0ZXggKTtcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuZXhwYW5kQnlQb2ludCggX3ZlcnRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLmJpbmRNb2RlID0gc291cmNlLmJpbmRNb2RlO1xuXHRcdHRoaXMuYmluZE1hdHJpeC5jb3B5KCBzb3VyY2UuYmluZE1hdHJpeCApO1xuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSggc291cmNlLmJpbmRNYXRyaXhJbnZlcnNlICk7XG5cblx0XHR0aGlzLnNrZWxldG9uID0gc291cmNlLnNrZWxldG9uO1xuXG5cdFx0aWYgKCBzb3VyY2UuYm91bmRpbmdCb3ggIT09IG51bGwgKSB0aGlzLmJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94LmNsb25lKCk7XG5cdFx0aWYgKCBzb3VyY2UuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB0aGlzLmJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuXHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdC8vIHRlc3Qgd2l0aCBib3VuZGluZyBzcGhlcmUgaW4gd29ybGQgc3BhY2VcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRfc3BoZXJlJDQuY29weSggdGhpcy5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdF9zcGhlcmUkNC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cblx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSQ0ICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly8gY29udmVydCByYXkgdG8gbG9jYWwgc3BhY2Ugb2Ygc2tpbm5lZCBtZXNoXG5cblx0XHRfaW52ZXJzZU1hdHJpeCQyLmNvcHkoIG1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cdFx0X3JheSQyLmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIF9pbnZlcnNlTWF0cml4JDIgKTtcblxuXHRcdC8vIHRlc3Qgd2l0aCBib3VuZGluZyBib3ggaW4gbG9jYWwgc3BhY2VcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBfcmF5JDIuaW50ZXJzZWN0c0JveCggdGhpcy5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdH1cblxuXHRcdC8vIHRlc3QgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5fY29tcHV0ZUludGVyc2VjdGlvbnMoIHJheWNhc3RlciwgaW50ZXJzZWN0cywgX3JheSQyICk7XG5cblx0fVxuXG5cdGdldFZlcnRleFBvc2l0aW9uKCBpbmRleCwgdGFyZ2V0ICkge1xuXG5cdFx0c3VwZXIuZ2V0VmVydGV4UG9zaXRpb24oIGluZGV4LCB0YXJnZXQgKTtcblxuXHRcdHRoaXMuYXBwbHlCb25lVHJhbnNmb3JtKCBpbmRleCwgdGFyZ2V0ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRiaW5kKCBza2VsZXRvbiwgYmluZE1hdHJpeCApIHtcblxuXHRcdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcblxuXHRcdGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuXHRcdFx0YmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0XHR9XG5cblx0XHR0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSggYmluZE1hdHJpeCApLmludmVydCgpO1xuXG5cdH1cblxuXHRwb3NlKCkge1xuXG5cdFx0dGhpcy5za2VsZXRvbi5wb3NlKCk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZVNraW5XZWlnaHRzKCkge1xuXG5cdFx0Y29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjQoKTtcblxuXHRcdGNvbnN0IHNraW5XZWlnaHQgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNraW5XZWlnaHQuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggc2tpbldlaWdodCwgaSApO1xuXG5cdFx0XHRjb25zdCBzY2FsZSA9IDEuMCAvIHZlY3Rvci5tYW5oYXR0YW5MZW5ndGgoKTtcblxuXHRcdFx0aWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XG5cblx0XHRcdFx0dmVjdG9yLm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZlY3Rvci5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcblxuXHRcdFx0fVxuXG5cdFx0XHRza2luV2VpZ2h0LnNldFhZWlcoIGksIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnosIHZlY3Rvci53ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdFx0aWYgKCB0aGlzLmJpbmRNb2RlID09PSBBdHRhY2hlZEJpbmRNb2RlICkge1xuXG5cdFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09IERldGFjaGVkQmluZE1vZGUgKSB7XG5cblx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSggdGhpcy5iaW5kTWF0cml4ICkuaW52ZXJ0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2lubmVkTWVzaDogVW5yZWNvZ25pemVkIGJpbmRNb2RlOiAnICsgdGhpcy5iaW5kTW9kZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRhcHBseUJvbmVUcmFuc2Zvcm0oIGluZGV4LCB2ZWN0b3IgKSB7XG5cblx0XHRjb25zdCBza2VsZXRvbiA9IHRoaXMuc2tlbGV0b247XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0X3NraW5JbmRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5JbmRleCwgaW5kZXggKTtcblx0XHRfc2tpbldlaWdodC5mcm9tQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQsIGluZGV4ICk7XG5cblx0XHRfYmFzZVBvc2l0aW9uLmNvcHkoIHZlY3RvciApLmFwcGx5TWF0cml4NCggdGhpcy5iaW5kTWF0cml4ICk7XG5cblx0XHR2ZWN0b3Iuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB3ZWlnaHQgPSBfc2tpbldlaWdodC5nZXRDb21wb25lbnQoIGkgKTtcblxuXHRcdFx0aWYgKCB3ZWlnaHQgIT09IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgYm9uZUluZGV4ID0gX3NraW5JbmRleC5nZXRDb21wb25lbnQoIGkgKTtcblxuXHRcdFx0XHRfbWF0cml4NC5tdWx0aXBseU1hdHJpY2VzKCBza2VsZXRvbi5ib25lc1sgYm9uZUluZGV4IF0ubWF0cml4V29ybGQsIHNrZWxldG9uLmJvbmVJbnZlcnNlc1sgYm9uZUluZGV4IF0gKTtcblxuXHRcdFx0XHR2ZWN0b3IuYWRkU2NhbGVkVmVjdG9yKCBfdmVjdG9yMy5jb3B5KCBfYmFzZVBvc2l0aW9uICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4NCApLCB3ZWlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMuYmluZE1hdHJpeEludmVyc2UgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQm9uZSBleHRlbmRzIE9iamVjdDNEIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzQm9uZSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnQm9uZSc7XG5cblx0fVxuXG59XG5cbmNsYXNzIERhdGFUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cblx0Y29uc3RydWN0b3IoIGRhdGEgPSBudWxsLCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyLCBtaW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyLCBhbmlzb3Ryb3B5LCBjb2xvclNwYWNlICkge1xuXG5cdFx0c3VwZXIoIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgY29sb3JTcGFjZSApO1xuXG5cdFx0dGhpcy5pc0RhdGFUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcblxuXHR9XG5cbn1cblxuY29uc3QgX29mZnNldE1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9pZGVudGl0eU1hdHJpeCQxID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5jbGFzcyBTa2VsZXRvbiB7XG5cblx0Y29uc3RydWN0b3IoIGJvbmVzID0gW10sIGJvbmVJbnZlcnNlcyA9IFtdICkge1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcblx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IGJvbmVJbnZlcnNlcztcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG51bGw7XG5cblx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbnVsbDtcblxuXHRcdHRoaXMuaW5pdCgpO1xuXG5cdH1cblxuXHRpbml0KCkge1xuXG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXG5cdFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBib25lcy5sZW5ndGggKiAxNiApO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIGludmVyc2UgYm9uZSBtYXRyaWNlcyBpZiBuZWNlc3NhcnlcblxuXHRcdGlmICggYm9uZUludmVyc2VzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZVxuXG5cdFx0XHRpZiAoIGJvbmVzLmxlbmd0aCAhPT0gYm9uZUludmVyc2VzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbjogTnVtYmVyIG9mIGludmVyc2UgYm9uZSBtYXRyaWNlcyBkb2VzIG5vdCBtYXRjaCBhbW91bnQgb2YgYm9uZXMuJyApO1xuXG5cdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzID0gW107XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgTWF0cml4NCgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNhbGN1bGF0ZUludmVyc2VzKCkge1xuXG5cdFx0dGhpcy5ib25lSW52ZXJzZXMubGVuZ3RoID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBpbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0aWYgKCB0aGlzLmJvbmVzWyBpIF0gKSB7XG5cblx0XHRcdFx0aW52ZXJzZS5jb3B5KCB0aGlzLmJvbmVzWyBpIF0ubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHBvc2UoKSB7XG5cblx0XHQvLyByZWNvdmVyIHRoZSBiaW5kLXRpbWUgd29ybGQgbWF0cmljZXNcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGJvbmUgKSB7XG5cblx0XHRcdFx0Ym9uZS5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLmJvbmVJbnZlcnNlc1sgaSBdICkuaW52ZXJ0KCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGNvbXB1dGUgdGhlIGxvY2FsIG1hdHJpY2VzLCBwb3NpdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2NhbGVzXG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBib25lICkge1xuXG5cdFx0XHRcdGlmICggYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lICkge1xuXG5cdFx0XHRcdFx0Ym9uZS5tYXRyaXguY29weSggYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblx0XHRcdFx0XHRib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRib25lLm1hdHJpeC5jb3B5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJvbmUubWF0cml4LmRlY29tcG9zZSggYm9uZS5wb3NpdGlvbiwgYm9uZS5xdWF0ZXJuaW9uLCBib25lLnNjYWxlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dXBkYXRlKCkge1xuXG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXHRcdGNvbnN0IGJvbmVNYXRyaWNlcyA9IHRoaXMuYm9uZU1hdHJpY2VzO1xuXHRcdGNvbnN0IGJvbmVUZXh0dXJlID0gdGhpcy5ib25lVGV4dHVyZTtcblxuXHRcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHQvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxuXG5cdFx0XHRjb25zdCBtYXRyaXggPSBib25lc1sgaSBdID8gYm9uZXNbIGkgXS5tYXRyaXhXb3JsZCA6IF9pZGVudGl0eU1hdHJpeCQxO1xuXG5cdFx0XHRfb2Zmc2V0TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgYm9uZUludmVyc2VzWyBpIF0gKTtcblx0XHRcdF9vZmZzZXRNYXRyaXgudG9BcnJheSggYm9uZU1hdHJpY2VzLCBpICogMTYgKTtcblxuXHRcdH1cblxuXHRcdGlmICggYm9uZVRleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdGJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFNrZWxldG9uKCB0aGlzLmJvbmVzLCB0aGlzLmJvbmVJbnZlcnNlcyApO1xuXG5cdH1cblxuXHRjb21wdXRlQm9uZVRleHR1cmUoKSB7XG5cblx0XHQvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXG5cdFx0Ly8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxuXHRcdC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgKiA0IHBpeGVscyA9ICAoOCAqIDgpXG5cdFx0Ly8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXG5cdFx0Ly8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXG5cdFx0Ly8gICAgICAgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXG5cblx0XHRsZXQgc2l6ZSA9IE1hdGguc3FydCggdGhpcy5ib25lcy5sZW5ndGggKiA0ICk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcblx0XHRzaXplID0gTWF0aC5jZWlsKCBzaXplIC8gNCApICogNDtcblx0XHRzaXplID0gTWF0aC5tYXgoIHNpemUsIDQgKTtcblxuXHRcdGNvbnN0IGJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHNpemUgKiBzaXplICogNCApOyAvLyA0IGZsb2F0cyBwZXIgUkdCQSBwaXhlbFxuXHRcdGJvbmVNYXRyaWNlcy5zZXQoIHRoaXMuYm9uZU1hdHJpY2VzICk7IC8vIGNvcHkgY3VycmVudCB2YWx1ZXNcblxuXHRcdGNvbnN0IGJvbmVUZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCBib25lTWF0cmljZXMsIHNpemUsIHNpemUsIFJHQkFGb3JtYXQsIEZsb2F0VHlwZSApO1xuXHRcdGJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gYm9uZU1hdHJpY2VzO1xuXHRcdHRoaXMuYm9uZVRleHR1cmUgPSBib25lVGV4dHVyZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRCb25lQnlOYW1lKCBuYW1lICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cblx0XHRcdGlmICggYm9uZS5uYW1lID09PSBuYW1lICkge1xuXG5cdFx0XHRcdHJldHVybiBib25lO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdH1cblxuXHRkaXNwb3NlKCApIHtcblxuXHRcdGlmICggdGhpcy5ib25lVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZS5kaXNwb3NlKCk7XG5cblx0XHRcdHRoaXMuYm9uZVRleHR1cmUgPSBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiwgYm9uZXMgKSB7XG5cblx0XHR0aGlzLnV1aWQgPSBqc29uLnV1aWQ7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmJvbmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHV1aWQgPSBqc29uLmJvbmVzWyBpIF07XG5cdFx0XHRsZXQgYm9uZSA9IGJvbmVzWyB1dWlkIF07XG5cblx0XHRcdGlmICggYm9uZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uOiBObyBib25lIGZvdW5kIHdpdGggVVVJRDonLCB1dWlkICk7XG5cdFx0XHRcdGJvbmUgPSBuZXcgQm9uZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYm9uZXMucHVzaCggYm9uZSApO1xuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIGpzb24uYm9uZUludmVyc2VzWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ1NrZWxldG9uJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnU2tlbGV0b24udG9KU09OJ1xuXHRcdFx0fSxcblx0XHRcdGJvbmVzOiBbXSxcblx0XHRcdGJvbmVJbnZlcnNlczogW11cblx0XHR9O1xuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYm9uZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYm9uZSA9IGJvbmVzWyBpIF07XG5cdFx0XHRkYXRhLmJvbmVzLnB1c2goIGJvbmUudXVpZCApO1xuXG5cdFx0XHRjb25zdCBib25lSW52ZXJzZSA9IGJvbmVJbnZlcnNlc1sgaSBdO1xuXHRcdFx0ZGF0YS5ib25lSW52ZXJzZXMucHVzaCggYm9uZUludmVyc2UudG9BcnJheSgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuY2xhc3MgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkLCBtZXNoUGVyQXR0cmlidXRlID0gMSApIHtcblxuXHRcdHN1cGVyKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdHRoaXMuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgPSB0aGlzLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0XHRkYXRhLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5jb25zdCBfaW5zdGFuY2VMb2NhbE1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9pbnN0YW5jZVdvcmxkTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5jb25zdCBfaW5zdGFuY2VJbnRlcnNlY3RzID0gW107XG5cbmNvbnN0IF9ib3gzID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuY29uc3QgX2lkZW50aXR5ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX21lc2gkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1lc2goKTtcbmNvbnN0IF9zcGhlcmUkMyA9IC8qQF9fUFVSRV9fKi8gbmV3IFNwaGVyZSgpO1xuXG5jbGFzcyBJbnN0YW5jZWRNZXNoIGV4dGVuZHMgTWVzaCB7XG5cblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5LCBtYXRlcmlhbCwgY291bnQgKSB7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR0aGlzLmlzSW5zdGFuY2VkTWVzaCA9IHRydWU7XG5cblx0XHR0aGlzLmluc3RhbmNlTWF0cml4ID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggY291bnQgKiAxNiApLCAxNiApO1xuXHRcdHRoaXMuaW5zdGFuY2VDb2xvciA9IG51bGw7XG5cdFx0dGhpcy5tb3JwaFRleHR1cmUgPSBudWxsO1xuXG5cdFx0dGhpcy5jb3VudCA9IGNvdW50O1xuXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5zZXRNYXRyaXhBdCggaSwgX2lkZW50aXR5ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBjb3VudCA9IHRoaXMuY291bnQ7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGksIF9pbnN0YW5jZUxvY2FsTWF0cml4ICk7XG5cblx0XHRcdF9ib3gzLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkuYXBwbHlNYXRyaXg0KCBfaW5zdGFuY2VMb2NhbE1hdHJpeCApO1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LnVuaW9uKCBfYm94MyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgY291bnQgPSB0aGlzLmNvdW50O1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGksIF9pbnN0YW5jZUxvY2FsTWF0cml4ICk7XG5cblx0XHRcdF9zcGhlcmUkMy5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApLmFwcGx5TWF0cml4NCggX2luc3RhbmNlTG9jYWxNYXRyaXggKTtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS51bmlvbiggX3NwaGVyZSQzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMuaW5zdGFuY2VNYXRyaXguY29weSggc291cmNlLmluc3RhbmNlTWF0cml4ICk7XG5cblx0XHRpZiAoIHNvdXJjZS5tb3JwaFRleHR1cmUgIT09IG51bGwgKSB0aGlzLm1vcnBoVGV4dHVyZSA9IHNvdXJjZS5tb3JwaFRleHR1cmUuY2xvbmUoKTtcblx0XHRpZiAoIHNvdXJjZS5pbnN0YW5jZUNvbG9yICE9PSBudWxsICkgdGhpcy5pbnN0YW5jZUNvbG9yID0gc291cmNlLmluc3RhbmNlQ29sb3IuY2xvbmUoKTtcblxuXHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XG5cblx0XHRpZiAoIHNvdXJjZS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHRoaXMuYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3guY2xvbmUoKTtcblx0XHRpZiAoIHNvdXJjZS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDb2xvckF0KCBpbmRleCwgY29sb3IgKSB7XG5cblx0XHRjb2xvci5mcm9tQXJyYXkoIHRoaXMuaW5zdGFuY2VDb2xvci5hcnJheSwgaW5kZXggKiAzICk7XG5cblx0fVxuXG5cdGdldE1hdHJpeEF0KCBpbmRleCwgbWF0cml4ICkge1xuXG5cdFx0bWF0cml4LmZyb21BcnJheSggdGhpcy5pbnN0YW5jZU1hdHJpeC5hcnJheSwgaW5kZXggKiAxNiApO1xuXG5cdH1cblxuXHRnZXRNb3JwaEF0KCBpbmRleCwgb2JqZWN0ICkge1xuXG5cdFx0Y29uc3Qgb2JqZWN0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHRjb25zdCBhcnJheSA9IHRoaXMubW9ycGhUZXh0dXJlLnNvdXJjZS5kYXRhLmRhdGE7XG5cblx0XHRjb25zdCBsZW4gPSBvYmplY3RJbmZsdWVuY2VzLmxlbmd0aCArIDE7IC8vIEFsbCBpbmZsdWVuY2VzICsgdGhlIGJhc2VJbmZsdWVuY2VTdW1cblxuXHRcdGNvbnN0IGRhdGFJbmRleCA9IGluZGV4ICogbGVuICsgMTsgLy8gU2tpcCB0aGUgYmFzZUluZmx1ZW5jZVN1bSBhdCB0aGUgYmVnaW5uaW5nXG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBvYmplY3RJbmZsdWVuY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0b2JqZWN0SW5mbHVlbmNlc1sgaSBdID0gYXJyYXlbIGRhdGFJbmRleCArIGkgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0Y29uc3QgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXHRcdGNvbnN0IHJheWNhc3RUaW1lcyA9IHRoaXMuY291bnQ7XG5cblx0XHRfbWVzaCQxLmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRfbWVzaCQxLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuXHRcdGlmICggX21lc2gkMS5tYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Ly8gdGVzdCB3aXRoIGJvdW5kaW5nIHNwaGVyZSBmaXJzdFxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdF9zcGhlcmUkMy5jb3B5KCB0aGlzLmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0X3NwaGVyZSQzLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBfc3BoZXJlJDMgKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHQvLyBub3cgdGVzdCBlYWNoIGluc3RhbmNlXG5cblx0XHRmb3IgKCBsZXQgaW5zdGFuY2VJZCA9IDA7IGluc3RhbmNlSWQgPCByYXljYXN0VGltZXM7IGluc3RhbmNlSWQgKysgKSB7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgd29ybGQgbWF0cml4IGZvciBlYWNoIGluc3RhbmNlXG5cblx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGluc3RhbmNlSWQsIF9pbnN0YW5jZUxvY2FsTWF0cml4ICk7XG5cblx0XHRcdF9pbnN0YW5jZVdvcmxkTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCApO1xuXG5cdFx0XHQvLyB0aGUgbWVzaCByZXByZXNlbnRzIHRoaXMgc2luZ2xlIGluc3RhbmNlXG5cblx0XHRcdF9tZXNoJDEubWF0cml4V29ybGQgPSBfaW5zdGFuY2VXb3JsZE1hdHJpeDtcblxuXHRcdFx0X21lc2gkMS5yYXljYXN0KCByYXljYXN0ZXIsIF9pbnN0YW5jZUludGVyc2VjdHMgKTtcblxuXHRcdFx0Ly8gcHJvY2VzcyB0aGUgcmVzdWx0IG9mIHJheWNhc3RcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gX2luc3RhbmNlSW50ZXJzZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IF9pbnN0YW5jZUludGVyc2VjdHNbIGkgXTtcblx0XHRcdFx0aW50ZXJzZWN0Lmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkO1xuXHRcdFx0XHRpbnRlcnNlY3Qub2JqZWN0ID0gdGhpcztcblx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfaW5zdGFuY2VJbnRlcnNlY3RzLmxlbmd0aCA9IDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldENvbG9yQXQoIGluZGV4LCBjb2xvciApIHtcblxuXHRcdGlmICggdGhpcy5pbnN0YW5jZUNvbG9yID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmluc3RhbmNlQ29sb3IgPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLmluc3RhbmNlTWF0cml4LmNvdW50ICogMyApLCAzICk7XG5cblx0XHR9XG5cblx0XHRjb2xvci50b0FycmF5KCB0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksIGluZGV4ICogMyApO1xuXG5cdH1cblxuXHRzZXRNYXRyaXhBdCggaW5kZXgsIG1hdHJpeCApIHtcblxuXHRcdG1hdHJpeC50b0FycmF5KCB0aGlzLmluc3RhbmNlTWF0cml4LmFycmF5LCBpbmRleCAqIDE2ICk7XG5cblx0fVxuXG5cdHNldE1vcnBoQXQoIGluZGV4LCBvYmplY3QgKSB7XG5cblx0XHRjb25zdCBvYmplY3RJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuXHRcdGNvbnN0IGxlbiA9IG9iamVjdEluZmx1ZW5jZXMubGVuZ3RoICsgMTsgLy8gbW9ycGhCYXNlSW5mbHVlbmNlICsgYWxsIGluZmx1ZW5jZXNcblxuXHRcdGlmICggdGhpcy5tb3JwaFRleHR1cmUgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMubW9ycGhUZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCBuZXcgRmxvYXQzMkFycmF5KCBsZW4gKiB0aGlzLmNvdW50ICksIGxlbiwgdGhpcy5jb3VudCwgUmVkRm9ybWF0LCBGbG9hdFR5cGUgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGFycmF5ID0gdGhpcy5tb3JwaFRleHR1cmUuc291cmNlLmRhdGEuZGF0YTtcblxuXHRcdGxldCBtb3JwaEluZmx1ZW5jZXNTdW0gPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdG1vcnBoSW5mbHVlbmNlc1N1bSArPSBvYmplY3RJbmZsdWVuY2VzWyBpIF07XG5cblx0XHR9XG5cblx0XHRjb25zdCBtb3JwaEJhc2VJbmZsdWVuY2UgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID8gMSA6IDEgLSBtb3JwaEluZmx1ZW5jZXNTdW07XG5cblx0XHRjb25zdCBkYXRhSW5kZXggPSBsZW4gKiBpbmRleDtcblxuXHRcdGFycmF5WyBkYXRhSW5kZXggXSA9IG1vcnBoQmFzZUluZmx1ZW5jZTtcblxuXHRcdGFycmF5LnNldCggb2JqZWN0SW5mbHVlbmNlcywgZGF0YUluZGV4ICsgMSApO1xuXG5cdH1cblxuXHR1cGRhdGVNb3JwaFRhcmdldHMoKSB7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHRcdGlmICggdGhpcy5tb3JwaFRleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMubW9ycGhUZXh0dXJlLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMubW9ycGhUZXh0dXJlID0gbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBzb3J0T3BhcXVlKCBhLCBiICkge1xuXG5cdHJldHVybiBhLnogLSBiLno7XG5cbn1cblxuZnVuY3Rpb24gc29ydFRyYW5zcGFyZW50KCBhLCBiICkge1xuXG5cdHJldHVybiBiLnogLSBhLno7XG5cbn1cblxuY2xhc3MgTXVsdGlEcmF3UmVuZGVyTGlzdCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLmluZGV4ID0gMDtcblx0XHR0aGlzLnBvb2wgPSBbXTtcblx0XHR0aGlzLmxpc3QgPSBbXTtcblxuXHR9XG5cblx0cHVzaCggZHJhd1JhbmdlLCB6ICkge1xuXG5cdFx0Y29uc3QgcG9vbCA9IHRoaXMucG9vbDtcblx0XHRjb25zdCBsaXN0ID0gdGhpcy5saXN0O1xuXHRcdGlmICggdGhpcy5pbmRleCA+PSBwb29sLmxlbmd0aCApIHtcblxuXHRcdFx0cG9vbC5wdXNoKCB7XG5cblx0XHRcdFx0c3RhcnQ6IC0gMSxcblx0XHRcdFx0Y291bnQ6IC0gMSxcblx0XHRcdFx0ejogLSAxLFxuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpdGVtID0gcG9vbFsgdGhpcy5pbmRleCBdO1xuXHRcdGxpc3QucHVzaCggaXRlbSApO1xuXHRcdHRoaXMuaW5kZXggKys7XG5cblx0XHRpdGVtLnN0YXJ0ID0gZHJhd1JhbmdlLnN0YXJ0O1xuXHRcdGl0ZW0uY291bnQgPSBkcmF3UmFuZ2UuY291bnQ7XG5cdFx0aXRlbS56ID0gejtcblxuXHR9XG5cblx0cmVzZXQoKSB7XG5cblx0XHR0aGlzLmxpc3QubGVuZ3RoID0gMDtcblx0XHR0aGlzLmluZGV4ID0gMDtcblxuXHR9XG5cbn1cblxuY29uc3QgSURfQVRUUl9OQU1FID0gJ2JhdGNoSWQnO1xuY29uc3QgX21hdHJpeCQxID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX2ludk1hdHJpeFdvcmxkID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX2lkZW50aXR5TWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3doaXRlQ29sb3IgPSAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMSwgMSwgMSApO1xuY29uc3QgX3Byb2pTY3JlZW5NYXRyaXgkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9mcnVzdHVtID0gLypAX19QVVJFX18qLyBuZXcgRnJ1c3R1bSgpO1xuY29uc3QgX2JveCQxID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuY29uc3QgX3NwaGVyZSQyID0gLypAX19QVVJFX18qLyBuZXcgU3BoZXJlKCk7XG5jb25zdCBfdmVjdG9yJDUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZm9yd2FyZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90ZW1wID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3JlbmRlckxpc3QgPSAvKkBfX1BVUkVfXyovIG5ldyBNdWx0aURyYXdSZW5kZXJMaXN0KCk7XG5jb25zdCBfbWVzaCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1lc2goKTtcbmNvbnN0IF9iYXRjaEludGVyc2VjdHMgPSBbXTtcblxuLy8gQFRPRE86IFNraW5uZWRNZXNoIHN1cHBvcnQ/XG4vLyBAVE9ETzogZ2VvbWV0cnkuZ3JvdXBzIHN1cHBvcnQ/XG4vLyBAVE9ETzogZ2VvbWV0cnkuZHJhd1JhbmdlIHN1cHBvcnQ/XG4vLyBAVE9ETzogZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzIHN1cHBvcnQ/XG4vLyBAVE9ETzogU3VwcG9ydCB1bmlmb3JtIHBhcmFtZXRlciBwZXIgZ2VvbWV0cnlcbi8vIEBUT0RPOiBBZGQgYW4gXCJvcHRpbWl6ZVwiIGZ1bmN0aW9uIHRvIHBhY2sgZ2VvbWV0cnkgYW5kIHJlbW92ZSBkYXRhIGdhcHNcblxuLy8gY29waWVzIGRhdGEgZnJvbSBhdHRyaWJ1dGUgXCJzcmNcIiBpbnRvIFwidGFyZ2V0XCIgc3RhcnRpbmcgYXQgXCJ0YXJnZXRPZmZzZXRcIlxuZnVuY3Rpb24gY29weUF0dHJpYnV0ZURhdGEoIHNyYywgdGFyZ2V0LCB0YXJnZXRPZmZzZXQgPSAwICkge1xuXG5cdGNvbnN0IGl0ZW1TaXplID0gdGFyZ2V0Lml0ZW1TaXplO1xuXHRpZiAoIHNyYy5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIHx8IHNyYy5hcnJheS5jb25zdHJ1Y3RvciAhPT0gdGFyZ2V0LmFycmF5LmNvbnN0cnVjdG9yICkge1xuXG5cdFx0Ly8gdXNlIHRoZSBjb21wb25lbnQgZ2V0dGVycyBhbmQgc2V0dGVycyBpZiB0aGUgYXJyYXkgZGF0YSBjYW5ub3Rcblx0XHQvLyBiZSBjb3BpZWQgZGlyZWN0bHlcblx0XHRjb25zdCB2ZXJ0ZXhDb3VudCA9IHNyYy5jb3VudDtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGMgPSAwOyBjIDwgaXRlbVNpemU7IGMgKysgKSB7XG5cblx0XHRcdFx0dGFyZ2V0LnNldENvbXBvbmVudCggaSArIHRhcmdldE9mZnNldCwgYywgc3JjLmdldENvbXBvbmVudCggaSwgYyApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gZmFzdGVyIGNvcHkgYXBwcm9hY2ggdXNpbmcgdHlwZWQgYXJyYXkgc2V0IGZ1bmN0aW9uXG5cdFx0dGFyZ2V0LmFycmF5LnNldCggc3JjLmFycmF5LCB0YXJnZXRPZmZzZXQgKiBpdGVtU2l6ZSApO1xuXG5cdH1cblxuXHR0YXJnZXQubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG59XG5cbmNsYXNzIEJhdGNoZWRNZXNoIGV4dGVuZHMgTWVzaCB7XG5cblx0Z2V0IG1heEdlb21ldHJ5Q291bnQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbWF4R2VvbWV0cnlDb3VudDtcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIG1heEdlb21ldHJ5Q291bnQsIG1heFZlcnRleENvdW50LCBtYXhJbmRleENvdW50ID0gbWF4VmVydGV4Q291bnQgKiAyLCBtYXRlcmlhbCApIHtcblxuXHRcdHN1cGVyKCBuZXcgQnVmZmVyR2VvbWV0cnkoKSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMuaXNCYXRjaGVkTWVzaCA9IHRydWU7XG5cdFx0dGhpcy5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcblx0XHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcblx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblx0XHR0aGlzLmN1c3RvbVNvcnQgPSBudWxsO1xuXG5cdFx0dGhpcy5fZHJhd1JhbmdlcyA9IFtdO1xuXHRcdHRoaXMuX3Jlc2VydmVkUmFuZ2VzID0gW107XG5cblx0XHR0aGlzLl92aXNpYmlsaXR5ID0gW107XG5cdFx0dGhpcy5fYWN0aXZlID0gW107XG5cdFx0dGhpcy5fYm91bmRzID0gW107XG5cblx0XHR0aGlzLl9tYXhHZW9tZXRyeUNvdW50ID0gbWF4R2VvbWV0cnlDb3VudDtcblx0XHR0aGlzLl9tYXhWZXJ0ZXhDb3VudCA9IG1heFZlcnRleENvdW50O1xuXHRcdHRoaXMuX21heEluZGV4Q291bnQgPSBtYXhJbmRleENvdW50O1xuXG5cdFx0dGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2dlb21ldHJ5Q291bnQgPSAwO1xuXHRcdHRoaXMuX211bHRpRHJhd0NvdW50cyA9IG5ldyBJbnQzMkFycmF5KCBtYXhHZW9tZXRyeUNvdW50ICk7XG5cdFx0dGhpcy5fbXVsdGlEcmF3U3RhcnRzID0gbmV3IEludDMyQXJyYXkoIG1heEdlb21ldHJ5Q291bnQgKTtcblx0XHR0aGlzLl9tdWx0aURyYXdDb3VudCA9IDA7XG5cdFx0dGhpcy5fbXVsdGlEcmF3SW5zdGFuY2VzID0gbnVsbDtcblx0XHR0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IHRydWU7XG5cblx0XHQvLyBMb2NhbCBtYXRyaXggcGVyIGdlb21ldHJ5IGJ5IHVzaW5nIGRhdGEgdGV4dHVyZVxuXHRcdHRoaXMuX21hdHJpY2VzVGV4dHVyZSA9IG51bGw7XG5cblx0XHR0aGlzLl9pbml0TWF0cmljZXNUZXh0dXJlKCk7XG5cblx0XHQvLyBMb2NhbCBjb2xvciBwZXIgZ2VvbWV0cnkgYnkgdXNpbmcgZGF0YSB0ZXh0dXJlXG5cdFx0dGhpcy5fY29sb3JzVGV4dHVyZSA9IG51bGw7XG5cblx0fVxuXG5cdF9pbml0TWF0cmljZXNUZXh0dXJlKCkge1xuXG5cdFx0Ly8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxuXHRcdC8vICAgICAgUkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcblx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IG1hdHJpY2VzICogNCBwaXhlbHMgPSAgKDggKiA4KVxuXHRcdC8vICAgICAgIDE2eDE2IHBpeGVsIHRleHR1cmUgbWF4ICAgNjQgbWF0cmljZXMgKiA0IHBpeGVscyA9ICgxNiAqIDE2KVxuXHRcdC8vICAgICAgIDMyeDMyIHBpeGVsIHRleHR1cmUgbWF4ICAyNTYgbWF0cmljZXMgKiA0IHBpeGVscyA9ICgzMiAqIDMyKVxuXHRcdC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgbWF0cmljZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxuXG5cdFx0bGV0IHNpemUgPSBNYXRoLnNxcnQoIHRoaXMuX21heEdlb21ldHJ5Q291bnQgKiA0ICk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcblx0XHRzaXplID0gTWF0aC5jZWlsKCBzaXplIC8gNCApICogNDtcblx0XHRzaXplID0gTWF0aC5tYXgoIHNpemUsIDQgKTtcblxuXHRcdGNvbnN0IG1hdHJpY2VzQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBzaXplICogc2l6ZSAqIDQgKTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcblx0XHRjb25zdCBtYXRyaWNlc1RleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoIG1hdHJpY2VzQXJyYXksIHNpemUsIHNpemUsIFJHQkFGb3JtYXQsIEZsb2F0VHlwZSApO1xuXG5cdFx0dGhpcy5fbWF0cmljZXNUZXh0dXJlID0gbWF0cmljZXNUZXh0dXJlO1xuXG5cdH1cblxuXHRfaW5pdENvbG9yc1RleHR1cmUoKSB7XG5cblx0XHRsZXQgc2l6ZSA9IE1hdGguc3FydCggdGhpcy5fbWF4R2VvbWV0cnlDb3VudCApO1xuXHRcdHNpemUgPSBNYXRoLmNlaWwoIHNpemUgKTtcblxuXHRcdC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsIGluaXRpYWxpemVkIHRvIHdoaXRlXG5cdFx0Y29uc3QgY29sb3JzQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBzaXplICogc2l6ZSAqIDQgKS5maWxsKCAxICk7XG5cdFx0Y29uc3QgY29sb3JzVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggY29sb3JzQXJyYXksIHNpemUsIHNpemUsIFJHQkFGb3JtYXQsIEZsb2F0VHlwZSApO1xuXHRcdGNvbG9yc1RleHR1cmUuY29sb3JTcGFjZSA9IENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZTtcblxuXHRcdHRoaXMuX2NvbG9yc1RleHR1cmUgPSBjb2xvcnNUZXh0dXJlO1xuXG5cdH1cblxuXHRfaW5pdGlhbGl6ZUdlb21ldHJ5KCByZWZlcmVuY2UgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgbWF4VmVydGV4Q291bnQgPSB0aGlzLl9tYXhWZXJ0ZXhDb3VudDtcblx0XHRjb25zdCBtYXhHZW9tZXRyeUNvdW50ID0gdGhpcy5fbWF4R2VvbWV0cnlDb3VudDtcblx0XHRjb25zdCBtYXhJbmRleENvdW50ID0gdGhpcy5fbWF4SW5kZXhDb3VudDtcblx0XHRpZiAoIHRoaXMuX2dlb21ldHJ5SW5pdGlhbGl6ZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCBhdHRyaWJ1dGVOYW1lIGluIHJlZmVyZW5jZS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdGNvbnN0IHNyY0F0dHJpYnV0ZSA9IHJlZmVyZW5jZS5nZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKTtcblx0XHRcdFx0Y29uc3QgeyBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgfSA9IHNyY0F0dHJpYnV0ZTtcblxuXHRcdFx0XHRjb25zdCBkc3RBcnJheSA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvciggbWF4VmVydGV4Q291bnQgKiBpdGVtU2l6ZSApO1xuXHRcdFx0XHRjb25zdCBkc3RBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBkc3RBcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUsIGRzdEF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVmZXJlbmNlLmdldEluZGV4KCkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5kZXhBcnJheSA9IG1heFZlcnRleENvdW50ID4gNjU1MzZcblx0XHRcdFx0XHQ/IG5ldyBVaW50MzJBcnJheSggbWF4SW5kZXhDb3VudCApXG5cdFx0XHRcdFx0OiBuZXcgVWludDE2QXJyYXkoIG1heEluZGV4Q291bnQgKTtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kZXhBcnJheSwgMSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaWRBcnJheSA9IG1heEdlb21ldHJ5Q291bnQgPiA2NTUzNlxuXHRcdFx0XHQ/IG5ldyBVaW50MzJBcnJheSggbWF4VmVydGV4Q291bnQgKVxuXHRcdFx0XHQ6IG5ldyBVaW50MTZBcnJheSggbWF4VmVydGV4Q291bnQgKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggSURfQVRUUl9OQU1FLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpZEFycmF5LCAxICkgKTtcblxuXHRcdFx0dGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGUgZ2VvbWV0cnkgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBleGlzdGluZyBjb21iaW5lZCBnZW9tZXRyeSBhdHRyaWJ1dGVzXG5cdF92YWxpZGF0ZUdlb21ldHJ5KCBnZW9tZXRyeSApIHtcblxuXHRcdC8vIGNoZWNrIHRoYXQgdGhlIGdlb21ldHJ5IGRvZXNuJ3QgaGF2ZSBhIHZlcnNpb24gb2Ygb3VyIHJlc2VydmVkIGlkIGF0dHJpYnV0ZVxuXHRcdGlmICggZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBJRF9BVFRSX05BTUUgKSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgQmF0Y2hlZE1lc2g6IEdlb21ldHJ5IGNhbm5vdCB1c2UgYXR0cmlidXRlIFwiJHsgSURfQVRUUl9OQU1FIH1cImAgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNoZWNrIHRvIGVuc3VyZSB0aGUgZ2VvbWV0cmllcyBhcmUgdXNpbmcgY29uc2lzdGVudCBhdHRyaWJ1dGVzIGFuZCBpbmRpY2VzXG5cdFx0Y29uc3QgYmF0Y2hHZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0aWYgKCBCb29sZWFuKCBnZW9tZXRyeS5nZXRJbmRleCgpICkgIT09IEJvb2xlYW4oIGJhdGNoR2VvbWV0cnkuZ2V0SW5kZXgoKSApICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdCYXRjaGVkTWVzaDogQWxsIGdlb21ldHJpZXMgbXVzdCBjb25zaXN0ZW50bHkgaGF2ZSBcImluZGV4XCIuJyApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggY29uc3QgYXR0cmlidXRlTmFtZSBpbiBiYXRjaEdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggYXR0cmlidXRlTmFtZSA9PT0gSURfQVRUUl9OQU1FICkge1xuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBnZW9tZXRyeS5oYXNBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBCYXRjaGVkTWVzaDogQWRkZWQgZ2VvbWV0cnkgbWlzc2luZyBcIiR7IGF0dHJpYnV0ZU5hbWUgfVwiLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29uc2lzdGVudCBhdHRyaWJ1dGVzLmAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzcmNBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKTtcblx0XHRcdGNvbnN0IGRzdEF0dHJpYnV0ZSA9IGJhdGNoR2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lICk7XG5cdFx0XHRpZiAoIHNyY0F0dHJpYnV0ZS5pdGVtU2l6ZSAhPT0gZHN0QXR0cmlidXRlLml0ZW1TaXplIHx8IHNyY0F0dHJpYnV0ZS5ub3JtYWxpemVkICE9PSBkc3RBdHRyaWJ1dGUubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdCYXRjaGVkTWVzaDogQWxsIGF0dHJpYnV0ZXMgbXVzdCBoYXZlIGEgY29uc2lzdGVudCBpdGVtU2l6ZSBhbmQgbm9ybWFsaXplZCB2YWx1ZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0c2V0Q3VzdG9tU29ydCggZnVuYyApIHtcblxuXHRcdHRoaXMuY3VzdG9tU29ydCA9IGZ1bmM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBnZW9tZXRyeUNvdW50ID0gdGhpcy5fZ2VvbWV0cnlDb3VudDtcblx0XHRjb25zdCBib3VuZGluZ0JveCA9IHRoaXMuYm91bmRpbmdCb3g7XG5cdFx0Y29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuXG5cdFx0Ym91bmRpbmdCb3gubWFrZUVtcHR5KCk7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnlDb3VudDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBhY3RpdmVbIGkgXSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0dGhpcy5nZXRNYXRyaXhBdCggaSwgX21hdHJpeCQxICk7XG5cdFx0XHR0aGlzLmdldEJvdW5kaW5nQm94QXQoIGksIF9ib3gkMSApLmFwcGx5TWF0cml4NCggX21hdHJpeCQxICk7XG5cdFx0XHRib3VuZGluZ0JveC51bmlvbiggX2JveCQxICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGdlb21ldHJ5Q291bnQgPSB0aGlzLl9nZW9tZXRyeUNvdW50O1xuXHRcdGNvbnN0IGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcblx0XHRjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG5cblx0XHRib3VuZGluZ1NwaGVyZS5tYWtlRW1wdHkoKTtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeUNvdW50OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGFjdGl2ZVsgaSBdID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfbWF0cml4JDEgKTtcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdTcGhlcmVBdCggaSwgX3NwaGVyZSQyICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4JDEgKTtcblx0XHRcdGJvdW5kaW5nU3BoZXJlLnVuaW9uKCBfc3BoZXJlJDIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0YWRkR2VvbWV0cnkoIGdlb21ldHJ5LCB2ZXJ0ZXhDb3VudCA9IC0gMSwgaW5kZXhDb3VudCA9IC0gMSApIHtcblxuXHRcdHRoaXMuX2luaXRpYWxpemVHZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHRcdHRoaXMuX3ZhbGlkYXRlR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cblx0XHQvLyBlbnN1cmUgd2UncmUgbm90IG92ZXIgZ2VvbWV0cnlcblx0XHRpZiAoIHRoaXMuX2dlb21ldHJ5Q291bnQgPj0gdGhpcy5fbWF4R2VvbWV0cnlDb3VudCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQmF0Y2hlZE1lc2g6IE1heGltdW0gZ2VvbWV0cnkgY291bnQgcmVhY2hlZC4nICk7XG5cblx0XHR9XG5cblx0XHQvLyBnZXQgdGhlIG5lY2Vzc2FyeSByYW5nZSBmbyB0aGUgZ2VvbWV0cnlcblx0XHRjb25zdCByZXNlcnZlZFJhbmdlID0ge1xuXHRcdFx0dmVydGV4U3RhcnQ6IC0gMSxcblx0XHRcdHZlcnRleENvdW50OiAtIDEsXG5cdFx0XHRpbmRleFN0YXJ0OiAtIDEsXG5cdFx0XHRpbmRleENvdW50OiAtIDEsXG5cdFx0fTtcblxuXHRcdGxldCBsYXN0UmFuZ2UgPSBudWxsO1xuXHRcdGNvbnN0IHJlc2VydmVkUmFuZ2VzID0gdGhpcy5fcmVzZXJ2ZWRSYW5nZXM7XG5cdFx0Y29uc3QgZHJhd1JhbmdlcyA9IHRoaXMuX2RyYXdSYW5nZXM7XG5cdFx0Y29uc3QgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXHRcdGlmICggdGhpcy5fZ2VvbWV0cnlDb3VudCAhPT0gMCApIHtcblxuXHRcdFx0bGFzdFJhbmdlID0gcmVzZXJ2ZWRSYW5nZXNbIHJlc2VydmVkUmFuZ2VzLmxlbmd0aCAtIDEgXTtcblxuXHRcdH1cblxuXHRcdGlmICggdmVydGV4Q291bnQgPT09IC0gMSApIHtcblxuXHRcdFx0cmVzZXJ2ZWRSYW5nZS52ZXJ0ZXhDb3VudCA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApLmNvdW50O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVzZXJ2ZWRSYW5nZS52ZXJ0ZXhDb3VudCA9IHZlcnRleENvdW50O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBsYXN0UmFuZ2UgPT09IG51bGwgKSB7XG5cblx0XHRcdHJlc2VydmVkUmFuZ2UudmVydGV4U3RhcnQgPSAwO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVzZXJ2ZWRSYW5nZS52ZXJ0ZXhTdGFydCA9IGxhc3RSYW5nZS52ZXJ0ZXhTdGFydCArIGxhc3RSYW5nZS52ZXJ0ZXhDb3VudDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblx0XHRjb25zdCBoYXNJbmRleCA9IGluZGV4ICE9PSBudWxsO1xuXHRcdGlmICggaGFzSW5kZXggKSB7XG5cblx0XHRcdGlmICggaW5kZXhDb3VudFx0PT09IC0gMSApIHtcblxuXHRcdFx0XHRyZXNlcnZlZFJhbmdlLmluZGV4Q291bnQgPSBpbmRleC5jb3VudDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXNlcnZlZFJhbmdlLmluZGV4Q291bnQgPSBpbmRleENvdW50O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbGFzdFJhbmdlID09PSBudWxsICkge1xuXG5cdFx0XHRcdHJlc2VydmVkUmFuZ2UuaW5kZXhTdGFydCA9IDA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVzZXJ2ZWRSYW5nZS5pbmRleFN0YXJ0ID0gbGFzdFJhbmdlLmluZGV4U3RhcnQgKyBsYXN0UmFuZ2UuaW5kZXhDb3VudDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0cmVzZXJ2ZWRSYW5nZS5pbmRleFN0YXJ0ICE9PSAtIDEgJiZcblx0XHRcdHJlc2VydmVkUmFuZ2UuaW5kZXhTdGFydCArIHJlc2VydmVkUmFuZ2UuaW5kZXhDb3VudCA+IHRoaXMuX21heEluZGV4Q291bnQgfHxcblx0XHRcdHJlc2VydmVkUmFuZ2UudmVydGV4U3RhcnQgKyByZXNlcnZlZFJhbmdlLnZlcnRleENvdW50ID4gdGhpcy5fbWF4VmVydGV4Q291bnRcblx0XHQpIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQmF0Y2hlZE1lc2g6IFJlc2VydmVkIHNwYWNlIHJlcXVlc3QgZXhjZWVkcyB0aGUgbWF4aW11bSBidWZmZXIgc2l6ZS4nICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJpbGl0eTtcblx0XHRjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG5cdFx0Y29uc3QgbWF0cmljZXNUZXh0dXJlID0gdGhpcy5fbWF0cmljZXNUZXh0dXJlO1xuXHRcdGNvbnN0IG1hdHJpY2VzQXJyYXkgPSB0aGlzLl9tYXRyaWNlc1RleHR1cmUuaW1hZ2UuZGF0YTtcblx0XHRjb25zdCBjb2xvcnNUZXh0dXJlID0gdGhpcy5fY29sb3JzVGV4dHVyZTtcblxuXHRcdC8vIHB1c2ggbmV3IHZpc2liaWxpdHkgc3RhdGVzXG5cdFx0dmlzaWJpbGl0eS5wdXNoKCB0cnVlICk7XG5cdFx0YWN0aXZlLnB1c2goIHRydWUgKTtcblxuXHRcdC8vIHVwZGF0ZSBpZFxuXHRcdGNvbnN0IGdlb21ldHJ5SWQgPSB0aGlzLl9nZW9tZXRyeUNvdW50O1xuXHRcdHRoaXMuX2dlb21ldHJ5Q291bnQgKys7XG5cblx0XHQvLyBpbml0aWFsaXplIG1hdHJpeCBpbmZvcm1hdGlvblxuXHRcdF9pZGVudGl0eU1hdHJpeC50b0FycmF5KCBtYXRyaWNlc0FycmF5LCBnZW9tZXRyeUlkICogMTYgKTtcblx0XHRtYXRyaWNlc1RleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0Ly8gaW5pdGlhbGl6ZSB0aGUgY29sb3IgdG8gd2hpdGVcblx0XHRpZiAoIGNvbG9yc1RleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdF93aGl0ZUNvbG9yLnRvQXJyYXkoIGNvbG9yc1RleHR1cmUuaW1hZ2UuZGF0YSwgZ2VvbWV0cnlJZCAqIDQgKTtcblx0XHRcdGNvbG9yc1RleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYWRkIHRoZSByZXNlcnZlZCByYW5nZSBhbmQgZHJhdyByYW5nZSBvYmplY3RzXG5cdFx0cmVzZXJ2ZWRSYW5nZXMucHVzaCggcmVzZXJ2ZWRSYW5nZSApO1xuXHRcdGRyYXdSYW5nZXMucHVzaCgge1xuXHRcdFx0c3RhcnQ6IGhhc0luZGV4ID8gcmVzZXJ2ZWRSYW5nZS5pbmRleFN0YXJ0IDogcmVzZXJ2ZWRSYW5nZS52ZXJ0ZXhTdGFydCxcblx0XHRcdGNvdW50OiAtIDFcblx0XHR9ICk7XG5cdFx0Ym91bmRzLnB1c2goIHtcblx0XHRcdGJveEluaXRpYWxpemVkOiBmYWxzZSxcblx0XHRcdGJveDogbmV3IEJveDMoKSxcblxuXHRcdFx0c3BoZXJlSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuXHRcdFx0c3BoZXJlOiBuZXcgU3BoZXJlKClcblx0XHR9ICk7XG5cblx0XHQvLyBzZXQgdGhlIGlkIGZvciB0aGUgZ2VvbWV0cnlcblx0XHRjb25zdCBpZEF0dHJpYnV0ZSA9IHRoaXMuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBJRF9BVFRSX05BTUUgKTtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCByZXNlcnZlZFJhbmdlLnZlcnRleENvdW50OyBpICsrICkge1xuXG5cdFx0XHRpZEF0dHJpYnV0ZS5zZXRYKCByZXNlcnZlZFJhbmdlLnZlcnRleFN0YXJ0ICsgaSwgZ2VvbWV0cnlJZCApO1xuXG5cdFx0fVxuXG5cdFx0aWRBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0Ly8gdXBkYXRlIHRoZSBnZW9tZXRyeVxuXHRcdHRoaXMuc2V0R2VvbWV0cnlBdCggZ2VvbWV0cnlJZCwgZ2VvbWV0cnkgKTtcblxuXHRcdHJldHVybiBnZW9tZXRyeUlkO1xuXG5cdH1cblxuXHRzZXRHZW9tZXRyeUF0KCBpZCwgZ2VvbWV0cnkgKSB7XG5cblx0XHRpZiAoIGlkID49IHRoaXMuX2dlb21ldHJ5Q291bnQgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0JhdGNoZWRNZXNoOiBNYXhpbXVtIGdlb21ldHJ5IGNvdW50IHJlYWNoZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fdmFsaWRhdGVHZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHRcdGNvbnN0IGJhdGNoR2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IGhhc0luZGV4ID0gYmF0Y2hHZW9tZXRyeS5nZXRJbmRleCgpICE9PSBudWxsO1xuXHRcdGNvbnN0IGRzdEluZGV4ID0gYmF0Y2hHZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdGNvbnN0IHNyY0luZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblx0XHRjb25zdCByZXNlcnZlZFJhbmdlID0gdGhpcy5fcmVzZXJ2ZWRSYW5nZXNbIGlkIF07XG5cdFx0aWYgKFxuXHRcdFx0aGFzSW5kZXggJiZcblx0XHRcdHNyY0luZGV4LmNvdW50ID4gcmVzZXJ2ZWRSYW5nZS5pbmRleENvdW50IHx8XG5cdFx0XHRnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ID4gcmVzZXJ2ZWRSYW5nZS52ZXJ0ZXhDb3VudFxuXHRcdCkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdCYXRjaGVkTWVzaDogUmVzZXJ2ZWQgc3BhY2Ugbm90IGxhcmdlIGVub3VnaCBmb3IgcHJvdmlkZWQgZ2VvbWV0cnkuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29weSBnZW9tZXRyeSBvdmVyXG5cdFx0Y29uc3QgdmVydGV4U3RhcnQgPSByZXNlcnZlZFJhbmdlLnZlcnRleFN0YXJ0O1xuXHRcdGNvbnN0IHZlcnRleENvdW50ID0gcmVzZXJ2ZWRSYW5nZS52ZXJ0ZXhDb3VudDtcblx0XHRmb3IgKCBjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGJhdGNoR2VvbWV0cnkuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVOYW1lID09PSBJRF9BVFRSX05BTUUgKSB7XG5cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29weSBhdHRyaWJ1dGUgZGF0YVxuXHRcdFx0Y29uc3Qgc3JjQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lICk7XG5cdFx0XHRjb25zdCBkc3RBdHRyaWJ1dGUgPSBiYXRjaEdlb21ldHJ5LmdldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSApO1xuXHRcdFx0Y29weUF0dHJpYnV0ZURhdGEoIHNyY0F0dHJpYnV0ZSwgZHN0QXR0cmlidXRlLCB2ZXJ0ZXhTdGFydCApO1xuXG5cdFx0XHQvLyBmaWxsIHRoZSByZXN0IGluIHdpdGggemVyb2VzXG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IHNyY0F0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdGZvciAoIGxldCBpID0gc3JjQXR0cmlidXRlLmNvdW50LCBsID0gdmVydGV4Q291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gdmVydGV4U3RhcnQgKyBpO1xuXHRcdFx0XHRmb3IgKCBsZXQgYyA9IDA7IGMgPCBpdGVtU2l6ZTsgYyArKyApIHtcblxuXHRcdFx0XHRcdGRzdEF0dHJpYnV0ZS5zZXRDb21wb25lbnQoIGluZGV4LCBjLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGRzdEF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRkc3RBdHRyaWJ1dGUuYWRkVXBkYXRlUmFuZ2UoIHZlcnRleFN0YXJ0ICogaXRlbVNpemUsIHZlcnRleENvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNvcHkgaW5kZXhcblx0XHRpZiAoIGhhc0luZGV4ICkge1xuXG5cdFx0XHRjb25zdCBpbmRleFN0YXJ0ID0gcmVzZXJ2ZWRSYW5nZS5pbmRleFN0YXJ0O1xuXG5cdFx0XHQvLyBjb3B5IGluZGV4IGRhdGEgb3ZlclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc3JjSW5kZXguY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0ZHN0SW5kZXguc2V0WCggaW5kZXhTdGFydCArIGksIHZlcnRleFN0YXJ0ICsgc3JjSW5kZXguZ2V0WCggaSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZmlsbCB0aGUgcmVzdCBpbiB3aXRoIHplcm9lc1xuXHRcdFx0Zm9yICggbGV0IGkgPSBzcmNJbmRleC5jb3VudCwgbCA9IHJlc2VydmVkUmFuZ2UuaW5kZXhDb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0ZHN0SW5kZXguc2V0WCggaW5kZXhTdGFydCArIGksIHZlcnRleFN0YXJ0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZHN0SW5kZXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0ZHN0SW5kZXguYWRkVXBkYXRlUmFuZ2UoIGluZGV4U3RhcnQsIHJlc2VydmVkUmFuZ2UuaW5kZXhDb3VudCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc3RvcmUgdGhlIGJvdW5kaW5nIGJveGVzXG5cdFx0Y29uc3QgYm91bmQgPSB0aGlzLl9ib3VuZHNbIGlkIF07XG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Ym91bmQuYm94LmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICk7XG5cdFx0XHRib3VuZC5ib3hJbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRib3VuZC5ib3hJbml0aWFsaXplZCA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0Ym91bmQuc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0XHRib3VuZC5zcGhlcmVJbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRib3VuZC5zcGhlcmVJbml0aWFsaXplZCA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2V0IGRyYXdSYW5nZSBjb3VudFxuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IHRoaXMuX2RyYXdSYW5nZXNbIGlkIF07XG5cdFx0Y29uc3QgcG9zQXR0ciA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXHRcdGRyYXdSYW5nZS5jb3VudCA9IGhhc0luZGV4ID8gc3JjSW5kZXguY291bnQgOiBwb3NBdHRyLmNvdW50O1xuXHRcdHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkID0gdHJ1ZTtcblxuXHRcdHJldHVybiBpZDtcblxuXHR9XG5cblx0ZGVsZXRlR2VvbWV0cnkoIGdlb21ldHJ5SWQgKSB7XG5cblx0XHQvLyBOb3RlOiBVc2VyIG5lZWRzIHRvIGNhbGwgb3B0aW1pemUoKSBhZnRlcndhcmQgdG8gcGFjayB0aGUgZGF0YS5cblxuXHRcdGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcblx0XHRpZiAoIGdlb21ldHJ5SWQgPj0gYWN0aXZlLmxlbmd0aCB8fCBhY3RpdmVbIGdlb21ldHJ5SWQgXSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0YWN0aXZlWyBnZW9tZXRyeUlkIF0gPSBmYWxzZTtcblx0XHR0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0SW5zdGFuY2VDb3VudEF0KCBpZCApIHtcblxuXHRcdGlmICggdGhpcy5fbXVsdGlEcmF3SW5zdGFuY2VzID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcy5fbXVsdGlEcmF3SW5zdGFuY2VzWyBpZCBdO1xuXG5cdH1cblxuXHRzZXRJbnN0YW5jZUNvdW50QXQoIGlkLCBpbnN0YW5jZUNvdW50ICkge1xuXG5cdFx0aWYgKCB0aGlzLl9tdWx0aURyYXdJbnN0YW5jZXMgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX211bHRpRHJhd0luc3RhbmNlcyA9IG5ldyBJbnQzMkFycmF5KCB0aGlzLl9tYXhHZW9tZXRyeUNvdW50ICkuZmlsbCggMSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fbXVsdGlEcmF3SW5zdGFuY2VzWyBpZCBdID0gaW5zdGFuY2VDb3VudDtcblxuXHRcdHJldHVybiBpZDtcblxuXHR9XG5cblx0Ly8gZ2V0IGJvdW5kaW5nIGJveCBhbmQgY29tcHV0ZSBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cdGdldEJvdW5kaW5nQm94QXQoIGlkLCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG5cdFx0aWYgKCBhY3RpdmVbIGlkIF0gPT09IGZhbHNlICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdC8vIGNvbXB1dGUgYm91bmRpbmcgYm94XG5cdFx0Y29uc3QgYm91bmQgPSB0aGlzLl9ib3VuZHNbIGlkIF07XG5cdFx0Y29uc3QgYm94ID0gYm91bmQuYm94O1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRpZiAoIGJvdW5kLmJveEluaXRpYWxpemVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ym94Lm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgZHJhd1JhbmdlID0gdGhpcy5fZHJhd1Jhbmdlc1sgaWQgXTtcblx0XHRcdGZvciAoIGxldCBpID0gZHJhd1JhbmdlLnN0YXJ0LCBsID0gZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgaXYgPSBpO1xuXHRcdFx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRcdFx0aXYgPSBpbmRleC5nZXRYKCBpdiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRib3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciQ1LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpdiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ym91bmQuYm94SW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0LmNvcHkoIGJveCApO1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8vIGdldCBib3VuZGluZyBzcGhlcmUgYW5kIGNvbXB1dGUgaXQgaWYgaXQgZG9lc24ndCBleGlzdFxuXHRnZXRCb3VuZGluZ1NwaGVyZUF0KCBpZCwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuXHRcdGlmICggYWN0aXZlWyBpZCBdID09PSBmYWxzZSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBjb21wdXRlIGJvdW5kaW5nIHNwaGVyZVxuXHRcdGNvbnN0IGJvdW5kID0gdGhpcy5fYm91bmRzWyBpZCBdO1xuXHRcdGNvbnN0IHNwaGVyZSA9IGJvdW5kLnNwaGVyZTtcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0aWYgKCBib3VuZC5zcGhlcmVJbml0aWFsaXplZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHNwaGVyZS5tYWtlRW1wdHkoKTtcblxuXHRcdFx0dGhpcy5nZXRCb3VuZGluZ0JveEF0KCBpZCwgX2JveCQxICk7XG5cdFx0XHRfYm94JDEuZ2V0Q2VudGVyKCBzcGhlcmUuY2VudGVyICk7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBkcmF3UmFuZ2UgPSB0aGlzLl9kcmF3UmFuZ2VzWyBpZCBdO1xuXG5cdFx0XHRsZXQgbWF4UmFkaXVzU3EgPSAwO1xuXHRcdFx0Zm9yICggbGV0IGkgPSBkcmF3UmFuZ2Uuc3RhcnQsIGwgPSBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGxldCBpdiA9IGk7XG5cdFx0XHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdFx0XHRpdiA9IGluZGV4LmdldFgoIGl2ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF92ZWN0b3IkNS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaXYgKTtcblx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IkNSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblx0XHRcdGJvdW5kLnNwaGVyZUluaXRpYWxpemVkID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHRhcmdldC5jb3B5KCBzcGhlcmUgKTtcblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRzZXRNYXRyaXhBdCggZ2VvbWV0cnlJZCwgbWF0cml4ICkge1xuXG5cdFx0Ly8gQFRPRE86IE1hcCBnZW9tZXRyeUlkIHRvIGluZGV4IG9mIHRoZSBhcnJheXMgYmVjYXVzZVxuXHRcdC8vICAgICAgICBvcHRpbWl6ZSgpIGNhbiBtYWtlIGdlb21ldHJ5SWQgbWlzbWF0Y2ggdGhlIGluZGV4XG5cblx0XHRjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG5cdFx0Y29uc3QgbWF0cmljZXNUZXh0dXJlID0gdGhpcy5fbWF0cmljZXNUZXh0dXJlO1xuXHRcdGNvbnN0IG1hdHJpY2VzQXJyYXkgPSB0aGlzLl9tYXRyaWNlc1RleHR1cmUuaW1hZ2UuZGF0YTtcblx0XHRjb25zdCBnZW9tZXRyeUNvdW50ID0gdGhpcy5fZ2VvbWV0cnlDb3VudDtcblx0XHRpZiAoIGdlb21ldHJ5SWQgPj0gZ2VvbWV0cnlDb3VudCB8fCBhY3RpdmVbIGdlb21ldHJ5SWQgXSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0bWF0cml4LnRvQXJyYXkoIG1hdHJpY2VzQXJyYXksIGdlb21ldHJ5SWQgKiAxNiApO1xuXHRcdG1hdHJpY2VzVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0TWF0cml4QXQoIGdlb21ldHJ5SWQsIG1hdHJpeCApIHtcblxuXHRcdGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcblx0XHRjb25zdCBtYXRyaWNlc0FycmF5ID0gdGhpcy5fbWF0cmljZXNUZXh0dXJlLmltYWdlLmRhdGE7XG5cdFx0Y29uc3QgZ2VvbWV0cnlDb3VudCA9IHRoaXMuX2dlb21ldHJ5Q291bnQ7XG5cdFx0aWYgKCBnZW9tZXRyeUlkID49IGdlb21ldHJ5Q291bnQgfHwgYWN0aXZlWyBnZW9tZXRyeUlkIF0gPT09IGZhbHNlICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRyaXguZnJvbUFycmF5KCBtYXRyaWNlc0FycmF5LCBnZW9tZXRyeUlkICogMTYgKTtcblxuXHR9XG5cblx0c2V0Q29sb3JBdCggZ2VvbWV0cnlJZCwgY29sb3IgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2NvbG9yc1RleHR1cmUgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2luaXRDb2xvcnNUZXh0dXJlKCk7XG5cblx0XHR9XG5cblx0XHQvLyBAVE9ETzogTWFwIGdlb21ldHJ5SWQgdG8gaW5kZXggb2YgdGhlIGFycmF5cyBiZWNhdXNlXG5cdFx0Ly8gICAgICAgIG9wdGltaXplKCkgY2FuIG1ha2UgZ2VvbWV0cnlJZCBtaXNtYXRjaCB0aGUgaW5kZXhcblxuXHRcdGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcblx0XHRjb25zdCBjb2xvcnNUZXh0dXJlID0gdGhpcy5fY29sb3JzVGV4dHVyZTtcblx0XHRjb25zdCBjb2xvcnNBcnJheSA9IHRoaXMuX2NvbG9yc1RleHR1cmUuaW1hZ2UuZGF0YTtcblx0XHRjb25zdCBnZW9tZXRyeUNvdW50ID0gdGhpcy5fZ2VvbWV0cnlDb3VudDtcblx0XHRpZiAoIGdlb21ldHJ5SWQgPj0gZ2VvbWV0cnlDb3VudCB8fCBhY3RpdmVbIGdlb21ldHJ5SWQgXSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29sb3IudG9BcnJheSggY29sb3JzQXJyYXksIGdlb21ldHJ5SWQgKiA0ICk7XG5cdFx0Y29sb3JzVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29sb3JBdCggZ2VvbWV0cnlJZCwgY29sb3IgKSB7XG5cblx0XHRjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG5cdFx0Y29uc3QgY29sb3JzQXJyYXkgPSB0aGlzLl9jb2xvcnNUZXh0dXJlLmltYWdlLmRhdGE7XG5cdFx0Y29uc3QgZ2VvbWV0cnlDb3VudCA9IHRoaXMuX2dlb21ldHJ5Q291bnQ7XG5cdFx0aWYgKCBnZW9tZXRyeUlkID49IGdlb21ldHJ5Q291bnQgfHwgYWN0aXZlWyBnZW9tZXRyeUlkIF0gPT09IGZhbHNlICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBjb2xvci5mcm9tQXJyYXkoIGNvbG9yc0FycmF5LCBnZW9tZXRyeUlkICogNCApO1xuXG5cdH1cblxuXHRzZXRWaXNpYmxlQXQoIGdlb21ldHJ5SWQsIHZhbHVlICkge1xuXG5cdFx0Y29uc3QgdmlzaWJpbGl0eSA9IHRoaXMuX3Zpc2liaWxpdHk7XG5cdFx0Y29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuXHRcdGNvbnN0IGdlb21ldHJ5Q291bnQgPSB0aGlzLl9nZW9tZXRyeUNvdW50O1xuXG5cdFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGlzIG91dCBvZiByYW5nZSwgbm90IGFjdGl2ZSwgb3IgdmlzaWJpbGl0eSBzdGF0ZVxuXHRcdC8vIGRvZXMgbm90IGNoYW5nZSB0aGVuIHJldHVybiBlYXJseVxuXHRcdGlmIChcblx0XHRcdGdlb21ldHJ5SWQgPj0gZ2VvbWV0cnlDb3VudCB8fFxuXHRcdFx0YWN0aXZlWyBnZW9tZXRyeUlkIF0gPT09IGZhbHNlIHx8XG5cdFx0XHR2aXNpYmlsaXR5WyBnZW9tZXRyeUlkIF0gPT09IHZhbHVlXG5cdFx0KSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dmlzaWJpbGl0eVsgZ2VvbWV0cnlJZCBdID0gdmFsdWU7XG5cdFx0dGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFZpc2libGVBdCggZ2VvbWV0cnlJZCApIHtcblxuXHRcdGNvbnN0IHZpc2liaWxpdHkgPSB0aGlzLl92aXNpYmlsaXR5O1xuXHRcdGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcblx0XHRjb25zdCBnZW9tZXRyeUNvdW50ID0gdGhpcy5fZ2VvbWV0cnlDb3VudDtcblxuXHRcdC8vIHJldHVybiBlYXJseSBpZiB0aGUgZ2VvbWV0cnkgaXMgb3V0IG9mIHJhbmdlIG9yIG5vdCBhY3RpdmVcblx0XHRpZiAoIGdlb21ldHJ5SWQgPj0gZ2VvbWV0cnlDb3VudCB8fCBhY3RpdmVbIGdlb21ldHJ5SWQgXSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB2aXNpYmlsaXR5WyBnZW9tZXRyeUlkIF07XG5cblx0fVxuXG5cdHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdGNvbnN0IHZpc2liaWxpdHkgPSB0aGlzLl92aXNpYmlsaXR5O1xuXHRcdGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcblx0XHRjb25zdCBkcmF3UmFuZ2VzID0gdGhpcy5fZHJhd1Jhbmdlcztcblx0XHRjb25zdCBnZW9tZXRyeUNvdW50ID0gdGhpcy5fZ2VvbWV0cnlDb3VudDtcblx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cdFx0Y29uc3QgYmF0Y2hHZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHQvLyBpdGVyYXRlIG92ZXIgZWFjaCBnZW9tZXRyeVxuXHRcdF9tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblx0XHRfbWVzaC5nZW9tZXRyeS5pbmRleCA9IGJhdGNoR2VvbWV0cnkuaW5kZXg7XG5cdFx0X21lc2guZ2VvbWV0cnkuYXR0cmlidXRlcyA9IGJhdGNoR2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRpZiAoIF9tZXNoLmdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHRfbWVzaC5nZW9tZXRyeS5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIF9tZXNoLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHRfbWVzaC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGdlb21ldHJ5Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdGlmICggISB2aXNpYmlsaXR5WyBpIF0gfHwgISBhY3RpdmVbIGkgXSApIHtcblxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkcmF3UmFuZ2UgPSBkcmF3UmFuZ2VzWyBpIF07XG5cdFx0XHRfbWVzaC5nZW9tZXRyeS5zZXREcmF3UmFuZ2UoIGRyYXdSYW5nZS5zdGFydCwgZHJhd1JhbmdlLmNvdW50ICk7XG5cblx0XHRcdC8vIGdlIHRoZSBpbnRlcnNlY3RzXG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfbWVzaC5tYXRyaXhXb3JsZCApLnByZW11bHRpcGx5KCBtYXRyaXhXb3JsZCApO1xuXHRcdFx0dGhpcy5nZXRCb3VuZGluZ0JveEF0KCBpLCBfbWVzaC5nZW9tZXRyeS5ib3VuZGluZ0JveCApO1xuXHRcdFx0dGhpcy5nZXRCb3VuZGluZ1NwaGVyZUF0KCBpLCBfbWVzaC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdFx0X21lc2gucmF5Y2FzdCggcmF5Y2FzdGVyLCBfYmF0Y2hJbnRlcnNlY3RzICk7XG5cblx0XHRcdC8vIGFkZCBiYXRjaCBpZCB0byB0aGUgaW50ZXJzZWN0c1xuXHRcdFx0Zm9yICggbGV0IGogPSAwLCBsID0gX2JhdGNoSW50ZXJzZWN0cy5sZW5ndGg7IGogPCBsOyBqICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IF9iYXRjaEludGVyc2VjdHNbIGogXTtcblx0XHRcdFx0aW50ZXJzZWN0Lm9iamVjdCA9IHRoaXM7XG5cdFx0XHRcdGludGVyc2VjdC5iYXRjaElkID0gaTtcblx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfYmF0Y2hJbnRlcnNlY3RzLmxlbmd0aCA9IDA7XG5cblx0XHR9XG5cblx0XHRfbWVzaC5tYXRlcmlhbCA9IG51bGw7XG5cdFx0X21lc2guZ2VvbWV0cnkuaW5kZXggPSBudWxsO1xuXHRcdF9tZXNoLmdlb21ldHJ5LmF0dHJpYnV0ZXMgPSB7fTtcblx0XHRfbWVzaC5nZW9tZXRyeS5zZXREcmF3UmFuZ2UoIDAsIEluZmluaXR5ICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5nZW9tZXRyeSA9IHNvdXJjZS5nZW9tZXRyeS5jbG9uZSgpO1xuXHRcdHRoaXMucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkO1xuXHRcdHRoaXMuc29ydE9iamVjdHMgPSBzb3VyY2Uuc29ydE9iamVjdHM7XG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveCAhPT0gbnVsbCA/IHNvdXJjZS5ib3VuZGluZ0JveC5jbG9uZSgpIDogbnVsbDtcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsID8gc291cmNlLmJvdW5kaW5nU3BoZXJlLmNsb25lKCkgOiBudWxsO1xuXG5cdFx0dGhpcy5fZHJhd1JhbmdlcyA9IHNvdXJjZS5fZHJhd1Jhbmdlcy5tYXAoIHJhbmdlID0+ICggeyAuLi5yYW5nZSB9ICkgKTtcblx0XHR0aGlzLl9yZXNlcnZlZFJhbmdlcyA9IHNvdXJjZS5fcmVzZXJ2ZWRSYW5nZXMubWFwKCByYW5nZSA9PiAoIHsgLi4ucmFuZ2UgfSApICk7XG5cblx0XHR0aGlzLl92aXNpYmlsaXR5ID0gc291cmNlLl92aXNpYmlsaXR5LnNsaWNlKCk7XG5cdFx0dGhpcy5fYWN0aXZlID0gc291cmNlLl9hY3RpdmUuc2xpY2UoKTtcblx0XHR0aGlzLl9ib3VuZHMgPSBzb3VyY2UuX2JvdW5kcy5tYXAoIGJvdW5kID0+ICgge1xuXHRcdFx0Ym94SW5pdGlhbGl6ZWQ6IGJvdW5kLmJveEluaXRpYWxpemVkLFxuXHRcdFx0Ym94OiBib3VuZC5ib3guY2xvbmUoKSxcblxuXHRcdFx0c3BoZXJlSW5pdGlhbGl6ZWQ6IGJvdW5kLnNwaGVyZUluaXRpYWxpemVkLFxuXHRcdFx0c3BoZXJlOiBib3VuZC5zcGhlcmUuY2xvbmUoKVxuXHRcdH0gKSApO1xuXG5cdFx0dGhpcy5fbWF4R2VvbWV0cnlDb3VudCA9IHNvdXJjZS5fbWF4R2VvbWV0cnlDb3VudDtcblx0XHR0aGlzLl9tYXhWZXJ0ZXhDb3VudCA9IHNvdXJjZS5fbWF4VmVydGV4Q291bnQ7XG5cdFx0dGhpcy5fbWF4SW5kZXhDb3VudCA9IHNvdXJjZS5fbWF4SW5kZXhDb3VudDtcblxuXHRcdHRoaXMuX2dlb21ldHJ5SW5pdGlhbGl6ZWQgPSBzb3VyY2UuX2dlb21ldHJ5SW5pdGlhbGl6ZWQ7XG5cdFx0dGhpcy5fZ2VvbWV0cnlDb3VudCA9IHNvdXJjZS5fZ2VvbWV0cnlDb3VudDtcblx0XHR0aGlzLl9tdWx0aURyYXdDb3VudHMgPSBzb3VyY2UuX211bHRpRHJhd0NvdW50cy5zbGljZSgpO1xuXHRcdHRoaXMuX211bHRpRHJhd1N0YXJ0cyA9IHNvdXJjZS5fbXVsdGlEcmF3U3RhcnRzLnNsaWNlKCk7XG5cblx0XHR0aGlzLl9tYXRyaWNlc1RleHR1cmUgPSBzb3VyY2UuX21hdHJpY2VzVGV4dHVyZS5jbG9uZSgpO1xuXHRcdHRoaXMuX21hdHJpY2VzVGV4dHVyZS5pbWFnZS5kYXRhID0gdGhpcy5fbWF0cmljZXNUZXh0dXJlLmltYWdlLnNsaWNlKCk7XG5cblx0XHRpZiAoIHRoaXMuX2NvbG9yc1RleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2NvbG9yc1RleHR1cmUgPSBzb3VyY2UuX2NvbG9yc1RleHR1cmUuY2xvbmUoKTtcblx0XHRcdHRoaXMuX2NvbG9yc1RleHR1cmUuaW1hZ2UuZGF0YSA9IHRoaXMuX2NvbG9yc1RleHR1cmUuaW1hZ2Uuc2xpY2UoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0Ly8gQXNzdW1pbmcgdGhlIGdlb21ldHJ5IGlzIG5vdCBzaGFyZWQgd2l0aCBvdGhlciBtZXNoZXNcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblxuXHRcdHRoaXMuX21hdHJpY2VzVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5fbWF0cmljZXNUZXh0dXJlID0gbnVsbDtcblxuXHRcdGlmICggdGhpcy5fY29sb3JzVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fY29sb3JzVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLl9jb2xvcnNUZXh0dXJlID0gbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRvbkJlZm9yZVJlbmRlciggcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbC8qLCBfZ3JvdXAqLyApIHtcblxuXHRcdC8vIGlmIHZpc2liaWxpdHkgaGFzIG5vdCBjaGFuZ2VkIGFuZCBmcnVzdHVtIGN1bGxpbmcgYW5kIG9iamVjdCBzb3J0aW5nIGlzIG5vdCByZXF1aXJlZFxuXHRcdC8vIHRoZW4gc2tpcCBpdGVyYXRpbmcgb3ZlciBhbGwgaXRlbXNcblx0XHRpZiAoICEgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgJiYgISB0aGlzLnBlck9iamVjdEZydXN0dW1DdWxsZWQgJiYgISB0aGlzLnNvcnRPYmplY3RzICkge1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHQvLyB0aGUgaW5kZXhlZCB2ZXJzaW9uIG9mIHRoZSBtdWx0aSBkcmF3IGZ1bmN0aW9uIHJlcXVpcmVzIHNwZWNpZnlpbmcgdGhlIHN0YXJ0XG5cdFx0Ly8gb2Zmc2V0IGluIGJ5dGVzLlxuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblx0XHRjb25zdCBieXRlc1BlckVsZW1lbnQgPSBpbmRleCA9PT0gbnVsbCA/IDEgOiBpbmRleC5hcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcblx0XHRjb25zdCB2aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJpbGl0eTtcblx0XHRjb25zdCBtdWx0aURyYXdTdGFydHMgPSB0aGlzLl9tdWx0aURyYXdTdGFydHM7XG5cdFx0Y29uc3QgbXVsdGlEcmF3Q291bnRzID0gdGhpcy5fbXVsdGlEcmF3Q291bnRzO1xuXHRcdGNvbnN0IGRyYXdSYW5nZXMgPSB0aGlzLl9kcmF3UmFuZ2VzO1xuXHRcdGNvbnN0IHBlck9iamVjdEZydXN0dW1DdWxsZWQgPSB0aGlzLnBlck9iamVjdEZydXN0dW1DdWxsZWQ7XG5cblx0XHQvLyBwcmVwYXJlIHRoZSBmcnVzdHVtIGluIHRoZSBsb2NhbCBmcmFtZVxuXHRcdGlmICggcGVyT2JqZWN0RnJ1c3R1bUN1bGxlZCApIHtcblxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgkMlxuXHRcdFx0XHQubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKVxuXHRcdFx0XHQubXVsdGlwbHkoIHRoaXMubWF0cml4V29ybGQgKTtcblx0XHRcdF9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KFxuXHRcdFx0XHRfcHJvalNjcmVlbk1hdHJpeCQyLFxuXHRcdFx0XHRyZW5kZXJlci5jb29yZGluYXRlU3lzdGVtXG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGNvdW50ID0gMDtcblx0XHRpZiAoIHRoaXMuc29ydE9iamVjdHMgKSB7XG5cblx0XHRcdC8vIGdldCB0aGUgY2FtZXJhIHBvc2l0aW9uIGluIHRoZSBsb2NhbCBmcmFtZVxuXHRcdFx0X2ludk1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblx0XHRcdF92ZWN0b3IkNS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApLmFwcGx5TWF0cml4NCggX2ludk1hdHJpeFdvcmxkICk7XG5cdFx0XHRfZm9yd2FyZC5zZXQoIDAsIDAsIC0gMSApLnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICkudHJhbnNmb3JtRGlyZWN0aW9uKCBfaW52TWF0cml4V29ybGQgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdmlzaWJpbGl0eS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggdmlzaWJpbGl0eVsgaSBdICYmIGFjdGl2ZVsgaSBdICkge1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSBib3VuZHMgaW4gd29ybGQgc3BhY2Vcblx0XHRcdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfbWF0cml4JDEgKTtcblx0XHRcdFx0XHR0aGlzLmdldEJvdW5kaW5nU3BoZXJlQXQoIGksIF9zcGhlcmUkMiApLmFwcGx5TWF0cml4NCggX21hdHJpeCQxICk7XG5cblx0XHRcdFx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgYmF0Y2hlZCBnZW9tZXRyeSBpcyB3aXRoaW4gdGhlIGZydXN0dW1cblx0XHRcdFx0XHRsZXQgY3VsbGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKCBwZXJPYmplY3RGcnVzdHVtQ3VsbGVkICkge1xuXG5cdFx0XHRcdFx0XHRjdWxsZWQgPSAhIF9mcnVzdHVtLmludGVyc2VjdHNTcGhlcmUoIF9zcGhlcmUkMiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhIGN1bGxlZCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gZ2V0IHRoZSBkaXN0YW5jZSBmcm9tIGNhbWVyYSB1c2VkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0XHRjb25zdCB6ID0gX3RlbXAuc3ViVmVjdG9ycyggX3NwaGVyZSQyLmNlbnRlciwgX3ZlY3RvciQ1ICkuZG90KCBfZm9yd2FyZCApO1xuXHRcdFx0XHRcdFx0X3JlbmRlckxpc3QucHVzaCggZHJhd1Jhbmdlc1sgaSBdLCB6ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFNvcnQgdGhlIGRyYXcgcmFuZ2VzIGFuZCBwcmVwIGZvciByZW5kZXJpbmdcblx0XHRcdGNvbnN0IGxpc3QgPSBfcmVuZGVyTGlzdC5saXN0O1xuXHRcdFx0Y29uc3QgY3VzdG9tU29ydCA9IHRoaXMuY3VzdG9tU29ydDtcblx0XHRcdGlmICggY3VzdG9tU29ydCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRsaXN0LnNvcnQoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID8gc29ydFRyYW5zcGFyZW50IDogc29ydE9wYXF1ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGN1c3RvbVNvcnQuY2FsbCggdGhpcywgbGlzdCwgY2FtZXJhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGl0ZW0gPSBsaXN0WyBpIF07XG5cdFx0XHRcdG11bHRpRHJhd1N0YXJ0c1sgY291bnQgXSA9IGl0ZW0uc3RhcnQgKiBieXRlc1BlckVsZW1lbnQ7XG5cdFx0XHRcdG11bHRpRHJhd0NvdW50c1sgY291bnQgXSA9IGl0ZW0uY291bnQ7XG5cdFx0XHRcdGNvdW50ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9yZW5kZXJMaXN0LnJlc2V0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB2aXNpYmlsaXR5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCB2aXNpYmlsaXR5WyBpIF0gJiYgYWN0aXZlWyBpIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgYmF0Y2hlZCBnZW9tZXRyeSBpcyB3aXRoaW4gdGhlIGZydXN0dW1cblx0XHRcdFx0XHRsZXQgY3VsbGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKCBwZXJPYmplY3RGcnVzdHVtQ3VsbGVkICkge1xuXG5cdFx0XHRcdFx0XHQvLyBnZXQgdGhlIGJvdW5kcyBpbiB3b3JsZCBzcGFjZVxuXHRcdFx0XHRcdFx0dGhpcy5nZXRNYXRyaXhBdCggaSwgX21hdHJpeCQxICk7XG5cdFx0XHRcdFx0XHR0aGlzLmdldEJvdW5kaW5nU3BoZXJlQXQoIGksIF9zcGhlcmUkMiApLmFwcGx5TWF0cml4NCggX21hdHJpeCQxICk7XG5cdFx0XHRcdFx0XHRjdWxsZWQgPSAhIF9mcnVzdHVtLmludGVyc2VjdHNTcGhlcmUoIF9zcGhlcmUkMiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhIGN1bGxlZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgcmFuZ2UgPSBkcmF3UmFuZ2VzWyBpIF07XG5cdFx0XHRcdFx0XHRtdWx0aURyYXdTdGFydHNbIGNvdW50IF0gPSByYW5nZS5zdGFydCAqIGJ5dGVzUGVyRWxlbWVudDtcblx0XHRcdFx0XHRcdG11bHRpRHJhd0NvdW50c1sgY291bnQgXSA9IHJhbmdlLmNvdW50O1xuXHRcdFx0XHRcdFx0Y291bnQgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLl9tdWx0aURyYXdDb3VudCA9IGNvdW50O1xuXHRcdHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkID0gZmFsc2U7XG5cblx0fVxuXG5cdG9uQmVmb3JlU2hhZG93KCByZW5kZXJlciwgb2JqZWN0LCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwvKiAsIGdyb3VwICovICkge1xuXG5cdFx0dGhpcy5vbkJlZm9yZVJlbmRlciggcmVuZGVyZXIsIG51bGwsIHNoYWRvd0NhbWVyYSwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgTGluZUJhc2ljTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0xpbmVCYXNpY01hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5saW5ld2lkdGggPSAxO1xuXHRcdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0dGhpcy5saW5lam9pbiA9ICdyb3VuZCc7XG5cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcblx0XHR0aGlzLmxpbmVjYXAgPSBzb3VyY2UubGluZWNhcDtcblx0XHR0aGlzLmxpbmVqb2luID0gc291cmNlLmxpbmVqb2luO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNvbnN0IF92U3RhcnQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkVuZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2ludmVyc2VNYXRyaXgkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9yYXkkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFJheSgpO1xuY29uc3QgX3NwaGVyZSQxID0gLypAX19QVVJFX18qLyBuZXcgU3BoZXJlKCk7XG5cbmNvbnN0IF9pbnRlcnNlY3RQb2ludE9uUmF5ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2ludGVyc2VjdFBvaW50T25TZWdtZW50ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBMaW5lIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNMaW5lID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lJztcblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLm1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggc291cmNlLm1hdGVyaWFsICkgPyBzb3VyY2UubWF0ZXJpYWwuc2xpY2UoKSA6IHNvdXJjZS5tYXRlcmlhbDtcblx0XHR0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbXB1dGVMaW5lRGlzdGFuY2VzKCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0Ly8gd2UgYXNzdW1lIG5vbi1pbmRleGVkIGdlb21ldHJ5XG5cblx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBsaW5lRGlzdGFuY2VzID0gWyAwIF07XG5cblx0XHRcdGZvciAoIGxldCBpID0gMSwgbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRfdlN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpIC0gMSApO1xuXHRcdFx0XHRfdkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSApO1xuXG5cdFx0XHRcdGxpbmVEaXN0YW5jZXNbIGkgXSA9IGxpbmVEaXN0YW5jZXNbIGkgLSAxIF07XG5cdFx0XHRcdGxpbmVEaXN0YW5jZXNbIGkgXSArPSBfdlN0YXJ0LmRpc3RhbmNlVG8oIF92RW5kICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGxpbmVEaXN0YW5jZXMsIDEgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZS5jb21wdXRlTGluZURpc3RhbmNlcygpOiBDb21wdXRhdGlvbiBvbmx5IHBvc3NpYmxlIHdpdGggbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnkuJyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cdFx0Y29uc3QgdGhyZXNob2xkID0gcmF5Y2FzdGVyLnBhcmFtcy5MaW5lLnRocmVzaG9sZDtcblx0XHRjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG5cblx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdF9zcGhlcmUkMS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdF9zcGhlcmUkMS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cdFx0X3NwaGVyZSQxLnJhZGl1cyArPSB0aHJlc2hvbGQ7XG5cblx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSQxICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly9cblxuXHRcdF9pbnZlcnNlTWF0cml4JDEuY29weSggbWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblx0XHRfcmF5JDEuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggX2ludmVyc2VNYXRyaXgkMSApO1xuXG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoICggdGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56ICkgLyAzICk7XG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG5cblx0XHRjb25zdCBzdGVwID0gdGhpcy5pc0xpbmVTZWdtZW50cyA/IDIgOiAxO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBpbmRleC5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBsID0gZW5kIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcblxuXHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WCggaSApO1xuXHRcdFx0XHRjb25zdCBiID0gaW5kZXguZ2V0WCggaSArIDEgKTtcblxuXHRcdFx0XHRjb25zdCBpbnRlcnNlY3QgPSBjaGVja0ludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCBfcmF5JDEsIGxvY2FsVGhyZXNob2xkU3EsIGEsIGIgKTtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdCApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5pc0xpbmVMb29wICkge1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKCBlbmQgLSAxICk7XG5cdFx0XHRcdGNvbnN0IGIgPSBpbmRleC5nZXRYKCBzdGFydCApO1xuXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIF9yYXkkMSwgbG9jYWxUaHJlc2hvbGRTcSwgYSwgYiApO1xuXG5cdFx0XHRcdGlmICggaW50ZXJzZWN0ICkge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIDAsIGRyYXdSYW5nZS5zdGFydCApO1xuXHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gc3RhcnQsIGwgPSBlbmQgLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xuXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIF9yYXkkMSwgbG9jYWxUaHJlc2hvbGRTcSwgaSwgaSArIDEgKTtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdCApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5pc0xpbmVMb29wICkge1xuXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIF9yYXkkMSwgbG9jYWxUaHJlc2hvbGRTcSwgZW5kIC0gMSwgc3RhcnQgKTtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdCApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIG1vcnBoQXR0cmlidXRlcyApO1xuXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBrZXlzWyAwIF0gXTtcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdFx0Zm9yICggbGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IG1vcnBoQXR0cmlidXRlWyBtIF0ubmFtZSB8fCBTdHJpbmcoIG0gKTtcblxuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdID0gbTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHRocmVzaG9sZFNxLCBhLCBiICkge1xuXG5cdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gb2JqZWN0Lmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0X3ZTdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYSApO1xuXHRfdkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYiApO1xuXG5cdGNvbnN0IGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCBfdlN0YXJ0LCBfdkVuZCwgX2ludGVyc2VjdFBvaW50T25SYXksIF9pbnRlcnNlY3RQb2ludE9uU2VnbWVudCApO1xuXG5cdGlmICggZGlzdFNxID4gdGhyZXNob2xkU3EgKSByZXR1cm47XG5cblx0X2ludGVyc2VjdFBvaW50T25SYXkuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTsgLy8gTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG5cdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggX2ludGVyc2VjdFBvaW50T25SYXkgKTtcblxuXHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xuXG5cdHJldHVybiB7XG5cblx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG5cdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0cG9pbnQ6IF9pbnRlcnNlY3RQb2ludE9uU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICksXG5cdFx0aW5kZXg6IGEsXG5cdFx0ZmFjZTogbnVsbCxcblx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0b2JqZWN0OiBvYmplY3RcblxuXHR9O1xuXG59XG5cbmNvbnN0IF9zdGFydCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9lbmQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNsYXNzIExpbmVTZWdtZW50cyBleHRlbmRzIExpbmUge1xuXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR0aGlzLmlzTGluZVNlZ21lbnRzID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xuXG5cdH1cblxuXHRjb21wdXRlTGluZURpc3RhbmNlcygpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdC8vIHdlIGFzc3VtZSBub24taW5kZXhlZCBnZW9tZXRyeVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgbGluZURpc3RhbmNlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKz0gMiApIHtcblxuXHRcdFx0XHRfc3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKTtcblx0XHRcdFx0X2VuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDEgKTtcblxuXHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpIF0gPSAoIGkgPT09IDAgKSA/IDAgOiBsaW5lRGlzdGFuY2VzWyBpIC0gMSBdO1xuXHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpICsgMSBdID0gbGluZURpc3RhbmNlc1sgaSBdICsgX3N0YXJ0LmRpc3RhbmNlVG8oIF9lbmQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbGluZURpc3RhbmNlcywgMSApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lU2VnbWVudHMuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTogQ29tcHV0YXRpb24gb25seSBwb3NzaWJsZSB3aXRoIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5LicgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBMaW5lTG9vcCBleHRlbmRzIExpbmUge1xuXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR0aGlzLmlzTGluZUxvb3AgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVMb29wJztcblxuXHR9XG5cbn1cblxuY2xhc3MgUG9pbnRzTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1BvaW50c01hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdQb2ludHNNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLnNpemUgPSAxO1xuXHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblxuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLnNpemUgPSBzb3VyY2Uuc2l6ZTtcblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY29uc3QgX2ludmVyc2VNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfcmF5ID0gLypAX19QVVJFX18qLyBuZXcgUmF5KCk7XG5jb25zdCBfc3BoZXJlID0gLypAX19QVVJFX18qLyBuZXcgU3BoZXJlKCk7XG5jb25zdCBfcG9zaXRpb24kMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgUG9pbnRzIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBtYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCgpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNQb2ludHMgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvaW50cyc7XG5cblx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdFx0dGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5tYXRlcmlhbCA9IEFycmF5LmlzQXJyYXkoIHNvdXJjZS5tYXRlcmlhbCApID8gc291cmNlLm1hdGVyaWFsLnNsaWNlKCkgOiBzb3VyY2UubWF0ZXJpYWw7XG5cdFx0dGhpcy5nZW9tZXRyeSA9IHNvdXJjZS5nZW9tZXRyeTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXHRcdGNvbnN0IHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcblx0XHRjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG5cblx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdF9zcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcblx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblx0XHRfc3BoZXJlLnJhZGl1cyArPSB0aHJlc2hvbGQ7XG5cblx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdC8vXG5cblx0XHRfaW52ZXJzZU1hdHJpeC5jb3B5KCBtYXRyaXhXb3JsZCApLmludmVydCgpO1xuXHRcdF9yYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggX2ludmVyc2VNYXRyaXggKTtcblxuXHRcdGNvbnN0IGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCAoIHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueiApIC8gMyApO1xuXHRcdGNvbnN0IGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBpbmRleC5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKCBpICk7XG5cblx0XHRcdFx0X3Bvc2l0aW9uJDIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGEgKTtcblxuXHRcdFx0XHR0ZXN0UG9pbnQoIF9wb3NpdGlvbiQyLCBhLCBsb2NhbFRocmVzaG9sZFNxLCBtYXRyaXhXb3JsZCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0aGlzICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIDAsIGRyYXdSYW5nZS5zdGFydCApO1xuXHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gc3RhcnQsIGwgPSBlbmQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdF9wb3NpdGlvbiQyLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICk7XG5cblx0XHRcdFx0dGVzdFBvaW50KCBfcG9zaXRpb24kMiwgaSwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIG1vcnBoQXR0cmlidXRlcyApO1xuXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBrZXlzWyAwIF0gXTtcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdFx0Zm9yICggbGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IG1vcnBoQXR0cmlidXRlWyBtIF0ubmFtZSB8fCBTdHJpbmcoIG0gKTtcblxuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdID0gbTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gdGVzdFBvaW50KCBwb2ludCwgaW5kZXgsIGxvY2FsVGhyZXNob2xkU3EsIG1hdHJpeFdvcmxkLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIG9iamVjdCApIHtcblxuXHRjb25zdCByYXlQb2ludERpc3RhbmNlU3EgPSBfcmF5LmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApO1xuXG5cdGlmICggcmF5UG9pbnREaXN0YW5jZVNxIDwgbG9jYWxUaHJlc2hvbGRTcSApIHtcblxuXHRcdGNvbnN0IGludGVyc2VjdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdF9yYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIGludGVyc2VjdFBvaW50ICk7XG5cdFx0aW50ZXJzZWN0UG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG5cdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3RQb2ludCApO1xuXG5cdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcblxuXHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRkaXN0YW5jZVRvUmF5OiBNYXRoLnNxcnQoIHJheVBvaW50RGlzdGFuY2VTcSApLFxuXHRcdFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LFxuXHRcdFx0aW5kZXg6IGluZGV4LFxuXHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdG9iamVjdDogb2JqZWN0XG5cblx0XHR9ICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFZpZGVvVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFx0c3VwZXIoIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuXHRcdHRoaXMuaXNWaWRlb1RleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IExpbmVhckZpbHRlcjtcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZVZpZGVvKCkge1xuXG5cdFx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR2aWRlby5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKCB1cGRhdGVWaWRlbyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAncmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaycgaW4gdmlkZW8gKSB7XG5cblx0XHRcdHZpZGVvLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soIHVwZGF0ZVZpZGVvICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmltYWdlICkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cblx0XHRjb25zdCB2aWRlbyA9IHRoaXMuaW1hZ2U7XG5cdFx0Y29uc3QgaGFzVmlkZW9GcmFtZUNhbGxiYWNrID0gJ3JlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2snIGluIHZpZGVvO1xuXG5cdFx0aWYgKCBoYXNWaWRlb0ZyYW1lQ2FsbGJhY2sgPT09IGZhbHNlICYmIHZpZGVvLnJlYWR5U3RhdGUgPj0gdmlkZW8uSEFWRV9DVVJSRU5UX0RBVEEgKSB7XG5cblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5jbGFzcyBGcmFtZWJ1ZmZlclRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdHN1cGVyKCB7IHdpZHRoLCBoZWlnaHQgfSApO1xuXG5cdFx0dGhpcy5pc0ZyYW1lYnVmZmVyVGV4dHVyZSA9IHRydWU7XG5cblx0XHR0aGlzLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBDb21wcmVzc2VkVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCBtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGNvbG9yU3BhY2UgKSB7XG5cblx0XHRzdXBlciggbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBjb2xvclNwYWNlICk7XG5cblx0XHR0aGlzLmlzQ29tcHJlc3NlZFRleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuXHRcdHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XG5cblx0XHQvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xuXHRcdC8vIChhbHNvIGZsaXBwaW5nIGRvZXNuJ3Qgd29yayBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcyApXG5cblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cblx0XHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXG5cdFx0Ly8gbWlwcyBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlc1xuXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQ29tcHJlc3NlZEFycmF5VGV4dHVyZSBleHRlbmRzIENvbXByZXNzZWRUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvciggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGZvcm1hdCwgdHlwZSApIHtcblxuXHRcdHN1cGVyKCBtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUgKTtcblxuXHRcdHRoaXMuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlID0gdHJ1ZTtcblx0XHR0aGlzLmltYWdlLmRlcHRoID0gZGVwdGg7XG5cdFx0dGhpcy53cmFwUiA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cblx0XHR0aGlzLmxheWVyVXBkYXRlcyA9IG5ldyBTZXQoKTtcblxuXHR9XG5cblx0YWRkTGF5ZXJVcGRhdGVzKCBsYXllckluZGV4ICkge1xuXG5cdFx0dGhpcy5sYXllclVwZGF0ZXMuYWRkKCBsYXllckluZGV4ICk7XG5cblx0fVxuXG5cdGNsZWFyTGF5ZXJVcGRhdGVzKCkge1xuXG5cdFx0dGhpcy5sYXllclVwZGF0ZXMuY2xlYXIoKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQ29tcHJlc3NlZEN1YmVUZXh0dXJlIGV4dGVuZHMgQ29tcHJlc3NlZFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCBpbWFnZXMsIGZvcm1hdCwgdHlwZSApIHtcblxuXHRcdHN1cGVyKCB1bmRlZmluZWQsIGltYWdlc1sgMCBdLndpZHRoLCBpbWFnZXNbIDAgXS5oZWlnaHQsIGZvcm1hdCwgdHlwZSwgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nICk7XG5cblx0XHR0aGlzLmlzQ29tcHJlc3NlZEN1YmVUZXh0dXJlID0gdHJ1ZTtcblx0XHR0aGlzLmlzQ3ViZVRleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy5pbWFnZSA9IGltYWdlcztcblxuXHR9XG5cbn1cblxuY2xhc3MgQ2FudmFzVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuXHRcdHN1cGVyKCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdFx0dGhpcy5pc0NhbnZhc1RleHR1cmUgPSB0cnVlO1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG59XG5cbi8qKlxuICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3QuXG4gKlxuICogU29tZSBjb21tb24gb2YgY3VydmUgbWV0aG9kczpcbiAqIC5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0IClcbiAqIC5nZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudEF0KCB1LCBvcHRpb25hbFRhcmdldCApXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuICogLmdldExlbmd0aCgpXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXG4gKlxuICogVGhpcyBmb2xsb3dpbmcgY3VydmVzIGluaGVyaXQgZnJvbSBUSFJFRS5DdXJ2ZTpcbiAqXG4gKiAtLSAyRCBjdXJ2ZXMgLS1cbiAqIFRIUkVFLkFyY0N1cnZlXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcbiAqIFRIUkVFLkxpbmVDdXJ2ZVxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLlNwbGluZUN1cnZlXG4gKlxuICogLS0gM0QgY3VydmVzIC0tXG4gKiBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xuICogVEhSRUUuTGluZUN1cnZlM1xuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG4gKlxuICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aC5cbiAqXG4gKiovXG5cbmNsYXNzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMudHlwZSA9ICdDdXJ2ZSc7XG5cblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IDIwMDtcblxuXHR9XG5cblx0Ly8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXG5cdC8vXHQtIHQgWzAgLi4gMV1cblxuXHRnZXRQb2ludCggLyogdCwgb3B0aW9uYWxUYXJnZXQgKi8gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZTogLmdldFBvaW50KCkgbm90IGltcGxlbWVudGVkLicgKTtcblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0Ly8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXG5cdC8vIC0gdSBbMCAuLiAxXVxuXG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG5cblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXG5cblx0Z2V0UG9pbnRzKCBkaXZpc2lvbnMgPSA1ICkge1xuXG5cdFx0Y29uc3QgcG9pbnRzID0gW107XG5cblx0XHRmb3IgKCBsZXQgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG5cdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxuXG5cdGdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zID0gNSApIHtcblxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHQvLyBHZXQgdG90YWwgY3VydmUgYXJjIGxlbmd0aFxuXG5cdGdldExlbmd0aCgpIHtcblxuXHRcdGNvbnN0IGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblx0XHRyZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XG5cblx0fVxuXG5cdC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXG5cblx0Z2V0TGVuZ3RocyggZGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgKSB7XG5cblx0XHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzICYmXG5cdFx0XHQoIHRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aCA9PT0gZGl2aXNpb25zICsgMSApICYmXG5cdFx0XHQhIHRoaXMubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcblxuXHRcdH1cblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdGNvbnN0IGNhY2hlID0gW107XG5cdFx0bGV0IGN1cnJlbnQsIGxhc3QgPSB0aGlzLmdldFBvaW50KCAwICk7XG5cdFx0bGV0IHN1bSA9IDA7XG5cblx0XHRjYWNoZS5wdXNoKCAwICk7XG5cblx0XHRmb3IgKCBsZXQgcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xuXG5cdFx0XHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludCggcCAvIGRpdmlzaW9ucyApO1xuXHRcdFx0c3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xuXHRcdFx0Y2FjaGUucHVzaCggc3VtICk7XG5cdFx0XHRsYXN0ID0gY3VycmVudDtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2FjaGVBcmNMZW5ndGhzID0gY2FjaGU7XG5cblx0XHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTogc3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxuXG5cdH1cblxuXHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5nZXRMZW5ndGhzKCk7XG5cblx0fVxuXG5cdC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcblxuXHRnZXRVdG9UbWFwcGluZyggdSwgZGlzdGFuY2UgKSB7XG5cblx0XHRjb25zdCBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cblx0XHRsZXQgaSA9IDA7XG5cdFx0Y29uc3QgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcblxuXHRcdGxldCB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxuXG5cdFx0aWYgKCBkaXN0YW5jZSApIHtcblxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XG5cblx0XHR9XG5cblx0XHQvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxuXG5cdFx0bGV0IGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XG5cblx0XHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xuXG5cdFx0XHRpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcblxuXHRcdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuXHRcdFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcblxuXHRcdFx0XHRsb3cgPSBpICsgMTtcblxuXHRcdFx0fSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XG5cblx0XHRcdFx0aGlnaCA9IGkgLSAxO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGhpZ2ggPSBpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvLyBET05FXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGkgPSBoaWdoO1xuXG5cdFx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcblxuXHRcdFx0cmV0dXJuIGkgLyAoIGlsIC0gMSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuXHRcdGNvbnN0IGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcblx0XHRjb25zdCBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XG5cblx0XHRjb25zdCBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cblx0XHQvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xuXG5cdFx0Y29uc3Qgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XG5cblx0XHQvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XG5cblx0XHRjb25zdCB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0gMSApO1xuXG5cdFx0cmV0dXJuIHQ7XG5cblx0fVxuXG5cdC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcblx0Ly8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxuXHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuXHQvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXG5cblx0Z2V0VGFuZ2VudCggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRjb25zdCBkZWx0YSA9IDAuMDAwMTtcblx0XHRsZXQgdDEgPSB0IC0gZGVsdGE7XG5cdFx0bGV0IHQyID0gdCArIGRlbHRhO1xuXG5cdFx0Ly8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxuXG5cdFx0aWYgKCB0MSA8IDAgKSB0MSA9IDA7XG5cdFx0aWYgKCB0MiA+IDEgKSB0MiA9IDE7XG5cblx0XHRjb25zdCBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xuXHRcdGNvbnN0IHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cblx0XHRjb25zdCB0YW5nZW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgKCAoIHB0MS5pc1ZlY3RvcjIgKSA/IG5ldyBWZWN0b3IyKCkgOiBuZXcgVmVjdG9yMygpICk7XG5cblx0XHR0YW5nZW50LmNvcHkoIHB0MiApLnN1YiggcHQxICkubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdGFuZ2VudDtcblxuXHR9XG5cblx0Z2V0VGFuZ2VudEF0KCB1LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdGNvbnN0IHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG5cblx0Y29tcHV0ZUZyZW5ldEZyYW1lcyggc2VnbWVudHMsIGNsb3NlZCApIHtcblxuXHRcdC8vIHNlZSBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcblxuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRjb25zdCB0YW5nZW50cyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCBiaW5vcm1hbHMgPSBbXTtcblxuXHRcdGNvbnN0IHZlYyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB1ID0gaSAvIHNlZ21lbnRzO1xuXG5cdFx0XHR0YW5nZW50c1sgaSBdID0gdGhpcy5nZXRUYW5nZW50QXQoIHUsIG5ldyBWZWN0b3IzKCkgKTtcblxuXHRcdH1cblxuXHRcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXG5cdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1pbmltdW0gdGFuZ2VudCB4eXogY29tcG9uZW50XG5cblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRjb25zdCB0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcblx0XHRjb25zdCB0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcblx0XHRjb25zdCB0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcblxuXHRcdGlmICggdHggPD0gbWluICkge1xuXG5cdFx0XHRtaW4gPSB0eDtcblx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHkgPD0gbWluICkge1xuXG5cdFx0XHRtaW4gPSB0eTtcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHogPD0gbWluICkge1xuXG5cdFx0XHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XG5cblx0XHR9XG5cblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcblxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cblxuXHRcdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cblx0XHRcdGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cblx0XHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cblx0XHRcdGlmICggdmVjLmxlbmd0aCgpID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0dmVjLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKCBjbGFtcCggdGFuZ2VudHNbIGkgLSAxIF0uZG90KCB0YW5nZW50c1sgaSBdICksIC0gMSwgMSApICk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcblxuXHRcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcblxuXHRcdGlmICggY2xvc2VkID09PSB0cnVlICkge1xuXG5cdFx0XHRsZXQgdGhldGEgPSBNYXRoLmFjb3MoIGNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBzZWdtZW50cyBdICksIC0gMSwgMSApICk7XG5cdFx0XHR0aGV0YSAvPSBzZWdtZW50cztcblxuXHRcdFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBzZWdtZW50cyBdICkgKSA+IDAgKSB7XG5cblx0XHRcdFx0dGhldGEgPSAtIHRoZXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxuXHRcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcblx0XHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRhbmdlbnRzOiB0YW5nZW50cyxcblx0XHRcdG5vcm1hbHM6IG5vcm1hbHMsXG5cdFx0XHRiaW5vcm1hbHM6IGJpbm9ybWFsc1xuXHRcdH07XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IHNvdXJjZS5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ0N1cnZlJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnQ3VydmUudG9KU09OJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRkYXRhLmFyY0xlbmd0aERpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0ganNvbi5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgRWxsaXBzZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCBhWCA9IDAsIGFZID0gMCwgeFJhZGl1cyA9IDEsIHlSYWRpdXMgPSAxLCBhU3RhcnRBbmdsZSA9IDAsIGFFbmRBbmdsZSA9IE1hdGguUEkgKiAyLCBhQ2xvY2t3aXNlID0gZmFsc2UsIGFSb3RhdGlvbiA9IDAgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0VsbGlwc2VDdXJ2ZSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnRWxsaXBzZUN1cnZlJztcblxuXHRcdHRoaXMuYVggPSBhWDtcblx0XHR0aGlzLmFZID0gYVk7XG5cblx0XHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XG5cblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XG5cdFx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XG5cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXG5cdFx0dGhpcy5hUm90YXRpb24gPSBhUm90YXRpb247XG5cblx0fVxuXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IyKCkgKSB7XG5cblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG5cdFx0Y29uc3QgdHdvUGkgPSBNYXRoLlBJICogMjtcblx0XHRsZXQgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcblx0XHRjb25zdCBzYW1lUG9pbnRzID0gTWF0aC5hYnMoIGRlbHRhQW5nbGUgKSA8IE51bWJlci5FUFNJTE9OO1xuXG5cdFx0Ly8gZW5zdXJlcyB0aGF0IGRlbHRhQW5nbGUgaXMgMCAuLiAyIFBJXG5cdFx0d2hpbGUgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gdHdvUGk7XG5cdFx0d2hpbGUgKCBkZWx0YUFuZ2xlID4gdHdvUGkgKSBkZWx0YUFuZ2xlIC09IHR3b1BpO1xuXG5cdFx0aWYgKCBkZWx0YUFuZ2xlIDwgTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdGlmICggc2FtZVBvaW50cyApIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gMDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gdHdvUGk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICYmICEgc2FtZVBvaW50cyApIHtcblxuXHRcdFx0aWYgKCBkZWx0YUFuZ2xlID09PSB0d29QaSApIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gLSB0d29QaTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcblx0XHRsZXQgeCA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHRsZXQgeSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRcdGlmICggdGhpcy5hUm90YXRpb24gIT09IDAgKSB7XG5cblx0XHRcdGNvbnN0IGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xuXHRcdFx0Y29uc3Qgc2luID0gTWF0aC5zaW4oIHRoaXMuYVJvdGF0aW9uICk7XG5cblx0XHRcdGNvbnN0IHR4ID0geCAtIHRoaXMuYVg7XG5cdFx0XHRjb25zdCB0eSA9IHkgLSB0aGlzLmFZO1xuXG5cdFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG5cdFx0XHR4ID0gdHggKiBjb3MgLSB0eSAqIHNpbiArIHRoaXMuYVg7XG5cdFx0XHR5ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIHRoaXMuYVk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnQuc2V0KCB4LCB5ICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5hWCA9IHNvdXJjZS5hWDtcblx0XHR0aGlzLmFZID0gc291cmNlLmFZO1xuXG5cdFx0dGhpcy54UmFkaXVzID0gc291cmNlLnhSYWRpdXM7XG5cdFx0dGhpcy55UmFkaXVzID0gc291cmNlLnlSYWRpdXM7XG5cblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gc291cmNlLmFTdGFydEFuZ2xlO1xuXHRcdHRoaXMuYUVuZEFuZ2xlID0gc291cmNlLmFFbmRBbmdsZTtcblxuXHRcdHRoaXMuYUNsb2Nrd2lzZSA9IHNvdXJjZS5hQ2xvY2t3aXNlO1xuXG5cdFx0dGhpcy5hUm90YXRpb24gPSBzb3VyY2UuYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEuYVggPSB0aGlzLmFYO1xuXHRcdGRhdGEuYVkgPSB0aGlzLmFZO1xuXG5cdFx0ZGF0YS54UmFkaXVzID0gdGhpcy54UmFkaXVzO1xuXHRcdGRhdGEueVJhZGl1cyA9IHRoaXMueVJhZGl1cztcblxuXHRcdGRhdGEuYVN0YXJ0QW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlO1xuXHRcdGRhdGEuYUVuZEFuZ2xlID0gdGhpcy5hRW5kQW5nbGU7XG5cblx0XHRkYXRhLmFDbG9ja3dpc2UgPSB0aGlzLmFDbG9ja3dpc2U7XG5cblx0XHRkYXRhLmFSb3RhdGlvbiA9IHRoaXMuYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMuYVggPSBqc29uLmFYO1xuXHRcdHRoaXMuYVkgPSBqc29uLmFZO1xuXG5cdFx0dGhpcy54UmFkaXVzID0ganNvbi54UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IGpzb24ueVJhZGl1cztcblxuXHRcdHRoaXMuYVN0YXJ0QW5nbGUgPSBqc29uLmFTdGFydEFuZ2xlO1xuXHRcdHRoaXMuYUVuZEFuZ2xlID0ganNvbi5hRW5kQW5nbGU7XG5cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBqc29uLmFDbG9ja3dpc2U7XG5cblx0XHR0aGlzLmFSb3RhdGlvbiA9IGpzb24uYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIEFyY0N1cnZlIGV4dGVuZHMgRWxsaXBzZUN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFx0c3VwZXIoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdFx0dGhpcy5pc0FyY0N1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdBcmNDdXJ2ZSc7XG5cblx0fVxuXG59XG5cbi8qKlxuICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcbiAqIGN1c3BzIGFuZCBzZWxmLWludGVyc2VjdGlvbnMgaW4gbm9uLXVuaWZvcm0gY2F0bXVsbCByb20gY3VydmVzLlxuICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcbiAqXG4gKiBjdXJ2ZS50eXBlIGFjY2VwdHMgY2VudHJpcGV0YWwoZGVmYXVsdCksIGNob3JkYWwgYW5kIGNhdG11bGxyb21cbiAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcbiAqL1xuXG5cbi8qXG5CYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXG4gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuIC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXG5cblRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcbmJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxud2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxuKi9cblxuZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xuXG5cdGxldCBjMCA9IDAsIGMxID0gMCwgYzIgPSAwLCBjMyA9IDA7XG5cblx0Lypcblx0ICogQ29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIGEgY3ViaWMgcG9seW5vbWlhbFxuXHQgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcblx0ICogc3VjaCB0aGF0XG5cdCAqICAgcCgwKSA9IHgwLCBwKDEpID0geDFcblx0ICogIGFuZFxuXHQgKiAgIHAnKDApID0gdDAsIHAnKDEpID0gdDEuXG5cdCAqL1xuXHRmdW5jdGlvbiBpbml0KCB4MCwgeDEsIHQwLCB0MSApIHtcblxuXHRcdGMwID0geDA7XG5cdFx0YzEgPSB0MDtcblx0XHRjMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XG5cdFx0YzMgPSAyICogeDAgLSAyICogeDEgKyB0MCArIHQxO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0aW5pdENhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XG5cblx0XHRcdGluaXQoIHgxLCB4MiwgdGVuc2lvbiAqICggeDIgLSB4MCApLCB0ZW5zaW9uICogKCB4MyAtIHgxICkgKTtcblxuXHRcdH0sXG5cblx0XHRpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XG5cblx0XHRcdC8vIGNvbXB1dGUgdGFuZ2VudHMgd2hlbiBwYXJhbWV0ZXJpemVkIGluIFt0MSx0Ml1cblx0XHRcdGxldCB0MSA9ICggeDEgLSB4MCApIC8gZHQwIC0gKCB4MiAtIHgwICkgLyAoIGR0MCArIGR0MSApICsgKCB4MiAtIHgxICkgLyBkdDE7XG5cdFx0XHRsZXQgdDIgPSAoIHgyIC0geDEgKSAvIGR0MSAtICggeDMgLSB4MSApIC8gKCBkdDEgKyBkdDIgKSArICggeDMgLSB4MiApIC8gZHQyO1xuXG5cdFx0XHQvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cblx0XHRcdHQxICo9IGR0MTtcblx0XHRcdHQyICo9IGR0MTtcblxuXHRcdFx0aW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcblxuXHRcdH0sXG5cblx0XHRjYWxjOiBmdW5jdGlvbiAoIHQgKSB7XG5cblx0XHRcdGNvbnN0IHQyID0gdCAqIHQ7XG5cdFx0XHRjb25zdCB0MyA9IHQyICogdDtcblx0XHRcdHJldHVybiBjMCArIGMxICogdCArIGMyICogdDIgKyBjMyAqIHQzO1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuLy9cblxuY29uc3QgdG1wID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgcHggPSAvKkBfX1BVUkVfXyovIG5ldyBDdWJpY1BvbHkoKTtcbmNvbnN0IHB5ID0gLypAX19QVVJFX18qLyBuZXcgQ3ViaWNQb2x5KCk7XG5jb25zdCBweiA9IC8qQF9fUFVSRV9fKi8gbmV3IEN1YmljUG9seSgpO1xuXG5jbGFzcyBDYXRtdWxsUm9tQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgPSBbXSwgY2xvc2VkID0gZmFsc2UsIGN1cnZlVHlwZSA9ICdjZW50cmlwZXRhbCcsIHRlbnNpb24gPSAwLjUgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0NhdG11bGxSb21DdXJ2ZTMgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NhdG11bGxSb21DdXJ2ZTMnO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cdFx0dGhpcy5jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBjdXJ2ZVR5cGU7XG5cdFx0dGhpcy50ZW5zaW9uID0gdGVuc2lvbjtcblxuXHR9XG5cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRjb25zdCBsID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGNvbnN0IHAgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcblx0XHRsZXQgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XG5cdFx0bGV0IHdlaWdodCA9IHAgLSBpbnRQb2ludDtcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgKSB7XG5cblx0XHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gbCApICsgMSApICogbDtcblxuXHRcdH0gZWxzZSBpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XG5cblx0XHRcdGludFBvaW50ID0gbCAtIDI7XG5cdFx0XHR3ZWlnaHQgPSAxO1xuXG5cdFx0fVxuXG5cdFx0bGV0IHAwLCBwMzsgLy8gNCBwb2ludHMgKHAxICYgcDIgZGVmaW5lZCBiZWxvdylcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgPiAwICkge1xuXG5cdFx0XHRwMCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIGwgXTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGV4dHJhcG9sYXRlIGZpcnN0IHBvaW50XG5cdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuXHRcdFx0cDAgPSB0bXA7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwMSA9IHBvaW50c1sgaW50UG9pbnQgJSBsIF07XG5cdFx0Y29uc3QgcDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBsIF07XG5cblx0XHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ICsgMiA8IGwgKSB7XG5cblx0XHRcdHAzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgbCBdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxuXHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAxIF0gKTtcblx0XHRcdHAzID0gdG1wO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnICkge1xuXG5cdFx0XHQvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxuXHRcdFx0Y29uc3QgcG93ID0gdGhpcy5jdXJ2ZVR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XG5cdFx0XHRsZXQgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcblx0XHRcdGxldCBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xuXHRcdFx0bGV0IGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XG5cblx0XHRcdC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXG5cdFx0XHRpZiAoIGR0MSA8IDFlLTQgKSBkdDEgPSAxLjA7XG5cdFx0XHRpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XG5cdFx0XHRpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XG5cblx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xuXHRcdFx0cHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XG5cdFx0XHRwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2F0bXVsbHJvbScgKSB7XG5cblx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0aGlzLnRlbnNpb24gKTtcblx0XHRcdHB5LmluaXRDYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCB0aGlzLnRlbnNpb24gKTtcblx0XHRcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0aGlzLnRlbnNpb24gKTtcblxuXHRcdH1cblxuXHRcdHBvaW50LnNldChcblx0XHRcdHB4LmNhbGMoIHdlaWdodCApLFxuXHRcdFx0cHkuY2FsYyggd2VpZ2h0ICksXG5cdFx0XHRwei5jYWxjKCB3ZWlnaHQgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XG5cblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2xvc2VkID0gc291cmNlLmNsb3NlZDtcblx0XHR0aGlzLmN1cnZlVHlwZSA9IHNvdXJjZS5jdXJ2ZVR5cGU7XG5cdFx0dGhpcy50ZW5zaW9uID0gc291cmNlLnRlbnNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0gdGhpcy5wb2ludHNbIGkgXTtcblx0XHRcdGRhdGEucG9pbnRzLnB1c2goIHBvaW50LnRvQXJyYXkoKSApO1xuXG5cdFx0fVxuXG5cdFx0ZGF0YS5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcblx0XHRkYXRhLmN1cnZlVHlwZSA9IHRoaXMuY3VydmVUeXBlO1xuXHRcdGRhdGEudGVuc2lvbiA9IHRoaXMudGVuc2lvbjtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBqc29uLnBvaW50c1sgaSBdO1xuXHRcdFx0dGhpcy5wb2ludHMucHVzaCggbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoIHBvaW50ICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2xvc2VkID0ganNvbi5jbG9zZWQ7XG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBqc29uLmN1cnZlVHlwZTtcblx0XHR0aGlzLnRlbnNpb24gPSBqc29uLnRlbnNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG4gKi9cblxuZnVuY3Rpb24gQ2F0bXVsbFJvbSggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cblx0Y29uc3QgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcblx0Y29uc3QgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblx0Y29uc3QgdDIgPSB0ICogdDtcblx0Y29uc3QgdDMgPSB0ICogdDI7XG5cdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG59XG5cbi8vXG5cbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAwKCB0LCBwICkge1xuXG5cdGNvbnN0IGsgPSAxIC0gdDtcblx0cmV0dXJuIGsgKiBrICogcDtcblxufVxuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMSggdCwgcCApIHtcblxuXHRyZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAyKCB0LCBwICkge1xuXG5cdHJldHVybiB0ICogdCAqIHA7XG5cbn1cblxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyKCB0LCBwMCwgcDEsIHAyICkge1xuXG5cdHJldHVybiBRdWFkcmF0aWNCZXppZXJQMCggdCwgcDAgKSArIFF1YWRyYXRpY0JlemllclAxKCB0LCBwMSApICtcblx0XHRRdWFkcmF0aWNCZXppZXJQMiggdCwgcDIgKTtcblxufVxuXG4vL1xuXG5mdW5jdGlvbiBDdWJpY0JlemllclAwKCB0LCBwICkge1xuXG5cdGNvbnN0IGsgPSAxIC0gdDtcblx0cmV0dXJuIGsgKiBrICogayAqIHA7XG5cbn1cblxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMSggdCwgcCApIHtcblxuXHRjb25zdCBrID0gMSAtIHQ7XG5cdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcblxufVxuXG5mdW5jdGlvbiBDdWJpY0JlemllclAyKCB0LCBwICkge1xuXG5cdHJldHVybiAzICogKCAxIC0gdCApICogdCAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDMoIHQsIHAgKSB7XG5cblx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XG5cbn1cblxuZnVuY3Rpb24gQ3ViaWNCZXppZXIoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG5cdHJldHVybiBDdWJpY0JlemllclAwKCB0LCBwMCApICsgQ3ViaWNCZXppZXJQMSggdCwgcDEgKSArIEN1YmljQmV6aWVyUDIoIHQsIHAyICkgK1xuXHRcdEN1YmljQmV6aWVyUDMoIHQsIHAzICk7XG5cbn1cblxuY2xhc3MgQ3ViaWNCZXppZXJDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMigpLCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSwgdjMgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNDdWJpY0JlemllckN1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlJztcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXHRcdHRoaXMudjMgPSB2MztcblxuXHR9XG5cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRjb25zdCB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCwgdjMueCApLFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cdFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBDdWJpY0JlemllckN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMygpLCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSwgdjMgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNDdWJpY0JlemllckN1cnZlMyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZTMnO1xuXG5cdFx0dGhpcy52MCA9IHYwO1xuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cdFx0dGhpcy52MyA9IHYzO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjIsIHYzID0gdGhpcy52MztcblxuXHRcdHBvaW50LnNldChcblx0XHRcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSwgdjMueSApLFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnosIHYzLnogKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cdFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBMaW5lQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoIHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNMaW5lQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVDdXJ2ZSc7XG5cblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGlmICggdCA9PT0gMSApIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xuXHRcdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Ly8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdHJldHVybiBvcHRpb25hbFRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBMaW5lQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTGluZUN1cnZlMyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGluZUN1cnZlMyc7XG5cblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGlmICggdCA9PT0gMSApIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xuXHRcdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Ly8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdHJldHVybiBvcHRpb25hbFRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMigpLCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlJztcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjI7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApXG5cdFx0KTtcblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoIHYwID0gbmV3IFZlY3RvcjMoKSwgdjEgPSBuZXcgVmVjdG9yMygpLCB2MiA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1F1YWRyYXRpY0JlemllckN1cnZlMyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUzJztcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjI7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApLFxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56IClcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHBvaW50O1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcblx0XHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIFNwbGluZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgPSBbXSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzU3BsaW5lQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NwbGluZUN1cnZlJztcblxuXHRcdHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGNvbnN0IHAgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdFx0Y29uc3QgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XG5cdFx0Y29uc3Qgd2VpZ2h0ID0gcCAtIGludFBvaW50O1xuXG5cdFx0Y29uc3QgcDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcblx0XHRjb25zdCBwMSA9IHBvaW50c1sgaW50UG9pbnQgXTtcblx0XHRjb25zdCBwMiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG5cdFx0Y29uc3QgcDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG5cdFx0cG9pbnQuc2V0KFxuXHRcdFx0Q2F0bXVsbFJvbSggd2VpZ2h0LCBwMC54LCBwMS54LCBwMi54LCBwMy54ICksXG5cdFx0XHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XG5cblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xuXHRcdFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0ganNvbi5wb2ludHNbIGkgXTtcblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBwb2ludCApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxudmFyIEN1cnZlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRBcmNDdXJ2ZTogQXJjQ3VydmUsXG5cdENhdG11bGxSb21DdXJ2ZTM6IENhdG11bGxSb21DdXJ2ZTMsXG5cdEN1YmljQmV6aWVyQ3VydmU6IEN1YmljQmV6aWVyQ3VydmUsXG5cdEN1YmljQmV6aWVyQ3VydmUzOiBDdWJpY0JlemllckN1cnZlMyxcblx0RWxsaXBzZUN1cnZlOiBFbGxpcHNlQ3VydmUsXG5cdExpbmVDdXJ2ZTogTGluZUN1cnZlLFxuXHRMaW5lQ3VydmUzOiBMaW5lQ3VydmUzLFxuXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTogUXVhZHJhdGljQmV6aWVyQ3VydmUsXG5cdFF1YWRyYXRpY0JlemllckN1cnZlMzogUXVhZHJhdGljQmV6aWVyQ3VydmUzLFxuXHRTcGxpbmVDdXJ2ZTogU3BsaW5lQ3VydmVcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jbGFzcyBDdXJ2ZVBhdGggZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N1cnZlUGF0aCc7XG5cblx0XHR0aGlzLmN1cnZlcyA9IFtdO1xuXHRcdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXG5cblx0fVxuXG5cdGFkZCggY3VydmUgKSB7XG5cblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdH1cblxuXHRjbG9zZVBhdGgoKSB7XG5cblx0XHQvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcblx0XHRjb25zdCBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbIDAgXS5nZXRQb2ludCggMCApO1xuXHRcdGNvbnN0IGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xuXG5cdFx0aWYgKCAhIHN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xuXG5cdFx0XHRjb25zdCBsaW5lVHlwZSA9ICggc3RhcnRQb2ludC5pc1ZlY3RvcjIgPT09IHRydWUgKSA/ICdMaW5lQ3VydmUnIDogJ0xpbmVDdXJ2ZTMnO1xuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggbmV3IEN1cnZlc1sgbGluZVR5cGUgXSggZW5kUG9pbnQsIHN0YXJ0UG9pbnQgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xuXHQvLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXG5cdC8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcblxuXHQvLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXG5cdC8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxuXHQvLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXG5cdC8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxuXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdGNvbnN0IGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRjb25zdCBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdGxldCBpID0gMDtcblxuXHRcdC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxuXG5cdFx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcblxuXHRcdFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xuXG5cdFx0XHRcdGNvbnN0IGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XG5cdFx0XHRcdGNvbnN0IGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBzZWdtZW50TGVuZ3RoID0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdGNvbnN0IHUgPSBzZWdtZW50TGVuZ3RoID09PSAwID8gMCA6IDEgLSBkaWZmIC8gc2VnbWVudExlbmd0aDtcblxuXHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpICsrO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0XHQvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcblxuXHR9XG5cblx0Ly8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuXHQvLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcblx0Ly8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxuXG5cdGdldExlbmd0aCgpIHtcblxuXHRcdGNvbnN0IGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcblxuXHR9XG5cblx0Ly8gY2FjaGVMZW5ndGhzIG11c3QgYmUgcmVjYWxjdWxhdGVkLlxuXHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xuXHRcdHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cblx0fVxuXG5cdC8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuXHQvLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxuXG5cdGdldEN1cnZlTGVuZ3RocygpIHtcblxuXHRcdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcblxuXHRcdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuXHRcdH1cblxuXHRcdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXG5cdFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cblx0XHRjb25zdCBsZW5ndGhzID0gW107XG5cdFx0bGV0IHN1bXMgPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0c3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xuXHRcdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNhY2hlTGVuZ3RocyA9IGxlbmd0aHM7XG5cblx0XHRyZXR1cm4gbGVuZ3RocztcblxuXHR9XG5cblx0Z2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMgPSA0MCApIHtcblxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgaSArKyApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmF1dG9DbG9zZSApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHRnZXRQb2ludHMoIGRpdmlzaW9ucyA9IDEyICkge1xuXG5cdFx0Y29uc3QgcG9pbnRzID0gW107XG5cdFx0bGV0IGxhc3Q7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGN1cnZlcyA9IHRoaXMuY3VydmVzOyBpIDwgY3VydmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY3VydmUgPSBjdXJ2ZXNbIGkgXTtcblx0XHRcdGNvbnN0IHJlc29sdXRpb24gPSBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSA/IGRpdmlzaW9ucyAqIDJcblx0XHRcdFx0OiAoIGN1cnZlLmlzTGluZUN1cnZlIHx8IGN1cnZlLmlzTGluZUN1cnZlMyApID8gMVxuXHRcdFx0XHRcdDogY3VydmUuaXNTcGxpbmVDdXJ2ZSA/IGRpdmlzaW9ucyAqIGN1cnZlLnBvaW50cy5sZW5ndGhcblx0XHRcdFx0XHRcdDogZGl2aXNpb25zO1xuXG5cdFx0XHRjb25zdCBwdHMgPSBjdXJ2ZS5nZXRQb2ludHMoIHJlc29sdXRpb24gKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwb2ludCA9IHB0c1sgaiBdO1xuXG5cdFx0XHRcdGlmICggbGFzdCAmJiBsYXN0LmVxdWFscyggcG9pbnQgKSApIGNvbnRpbnVlOyAvLyBlbnN1cmVzIG5vIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgZHVwbGljYXRlc1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludCApO1xuXHRcdFx0XHRsYXN0ID0gcG9pbnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgJiYgcG9pbnRzLmxlbmd0aCA+IDEgJiYgISBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xuXG5cdFx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludHM7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY3VydmUgPSBzb3VyY2UuY3VydmVzWyBpIF07XG5cblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXV0b0Nsb3NlID0gc291cmNlLmF1dG9DbG9zZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlO1xuXHRcdGRhdGEuY3VydmVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XG5cdFx0XHRkYXRhLmN1cnZlcy5wdXNoKCBjdXJ2ZS50b0pTT04oKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24uY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGN1cnZlID0ganNvbi5jdXJ2ZXNbIGkgXTtcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBDdXJ2ZXNbIGN1cnZlLnR5cGUgXSgpLmZyb21KU09OKCBjdXJ2ZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgUGF0aCBleHRlbmRzIEN1cnZlUGF0aCB7XG5cblx0Y29uc3RydWN0b3IoIHBvaW50cyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGF0aCc7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRpZiAoIHBvaW50cyApIHtcblxuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xuXG5cdFx0dGhpcy5tb3ZlVG8oIHBvaW50c1sgMCBdLngsIHBvaW50c1sgMCBdLnkgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmxpbmVUbyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1vdmVUbyggeCwgeSApIHtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggeCwgeSApOyAvLyBUT0RPIGNvbnNpZGVyIHJlZmVyZW5jaW5nIHZlY3RvcnMgaW5zdGVhZCBvZiBjb3B5aW5nP1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxpbmVUbyggeCwgeSApIHtcblxuXHRcdGNvbnN0IGN1cnZlID0gbmV3IExpbmVDdXJ2ZSggdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoIHgsIHkgKSApO1xuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIHgsIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRxdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZShcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXG5cdFx0XHRuZXcgVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXG5cdFx0KTtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGJlemllckN1cnZlVG8oIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKSB7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBDdWJpY0JlemllckN1cnZlKFxuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBhQ1AxeCwgYUNQMXkgKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxuXHRcdCk7XG5cblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCBhWCwgYVkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzcGxpbmVUaHJ1KCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuXHRcdGNvbnN0IG5wdHMgPSBbIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCkgXS5jb25jYXQoIHB0cyApO1xuXG5cdFx0Y29uc3QgY3VydmUgPSBuZXcgU3BsaW5lQ3VydmUoIG5wdHMgKTtcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggcHRzWyBwdHMubGVuZ3RoIC0gMSBdICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXJjKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHRjb25zdCB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XG5cdFx0Y29uc3QgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xuXG5cdFx0dGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXG5cdFx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWJzYXJjKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHR0aGlzLmFic2VsbGlwc2UoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVsbGlwc2UoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG5cdFx0Y29uc3QgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xuXHRcdGNvbnN0IHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcblxuXHRcdHRoaXMuYWJzZWxsaXBzZSggYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWJzZWxsaXBzZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBFbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cblx0XHRpZiAoIHRoaXMuY3VydmVzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdC8vIGlmIGEgcHJldmlvdXMgY3VydmUgaXMgcHJlc2VudCwgYXR0ZW1wdCB0byBqb2luXG5cdFx0XHRjb25zdCBmaXJzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDAgKTtcblxuXHRcdFx0aWYgKCAhIGZpcnN0UG9pbnQuZXF1YWxzKCB0aGlzLmN1cnJlbnRQb2ludCApICkge1xuXG5cdFx0XHRcdHRoaXMubGluZVRvKCBmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0Y29uc3QgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDEgKTtcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBsYXN0UG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHNvdXJjZS5jdXJyZW50UG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmN1cnJlbnRQb2ludCA9IHRoaXMuY3VycmVudFBvaW50LnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5mcm9tQXJyYXkoIGpzb24uY3VycmVudFBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgTGF0aGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcG9pbnRzID0gWyBuZXcgVmVjdG9yMiggMCwgLSAwLjUgKSwgbmV3IFZlY3RvcjIoIDAuNSwgMCApLCBuZXcgVmVjdG9yMiggMCwgMC41ICkgXSwgc2VnbWVudHMgPSAxMiwgcGhpU3RhcnQgPSAwLCBwaGlMZW5ndGggPSBNYXRoLlBJICogMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRwb2ludHM6IHBvaW50cyxcblx0XHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcblx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHNlZ21lbnRzID0gTWF0aC5mbG9vciggc2VnbWVudHMgKTtcblxuXHRcdC8vIGNsYW1wIHBoaUxlbmd0aCBzbyBpdCdzIGluIHJhbmdlIG9mIFsgMCwgMlBJIF1cblxuXHRcdHBoaUxlbmd0aCA9IGNsYW1wKCBwaGlMZW5ndGgsIDAsIE1hdGguUEkgKiAyICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblx0XHRjb25zdCBpbml0Tm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgY3VyTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBwcmV2Tm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgZHggPSAwO1xuXHRcdGxldCBkeSA9IDA7XG5cblx0XHQvLyBwcmUtY29tcHV0ZSBub3JtYWxzIGZvciBpbml0aWFsIFwibWVyaWRpYW5cIlxuXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0c3dpdGNoICggaiApIHtcblxuXHRcdFx0XHRjYXNlIDA6XHRcdFx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciAxc3QgdmVydGV4IG9uIHBhdGhcblxuXHRcdFx0XHRcdGR4ID0gcG9pbnRzWyBqICsgMSBdLnggLSBwb2ludHNbIGogXS54O1xuXHRcdFx0XHRcdGR5ID0gcG9pbnRzWyBqICsgMSBdLnkgLSBwb2ludHNbIGogXS55O1xuXG5cdFx0XHRcdFx0bm9ybWFsLnggPSBkeSAqIDEuMDtcblx0XHRcdFx0XHRub3JtYWwueSA9IC0gZHg7XG5cdFx0XHRcdFx0bm9ybWFsLnogPSBkeSAqIDAuMDtcblxuXHRcdFx0XHRcdHByZXZOb3JtYWwuY29weSggbm9ybWFsICk7XG5cblx0XHRcdFx0XHRub3JtYWwubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0XHRpbml0Tm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICggcG9pbnRzLmxlbmd0aCAtIDEgKTpcdC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGxhc3QgVmVydGV4IG9uIHBhdGhcblxuXHRcdFx0XHRcdGluaXROb3JtYWxzLnB1c2goIHByZXZOb3JtYWwueCwgcHJldk5vcm1hbC55LCBwcmV2Tm9ybWFsLnogKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XHRcdFx0Ly8gZGVmYXVsdCBoYW5kbGluZyBmb3IgYWxsIHZlcnRpY2VzIGluIGJldHdlZW5cblxuXHRcdFx0XHRcdGR4ID0gcG9pbnRzWyBqICsgMSBdLnggLSBwb2ludHNbIGogXS54O1xuXHRcdFx0XHRcdGR5ID0gcG9pbnRzWyBqICsgMSBdLnkgLSBwb2ludHNbIGogXS55O1xuXG5cdFx0XHRcdFx0bm9ybWFsLnggPSBkeSAqIDEuMDtcblx0XHRcdFx0XHRub3JtYWwueSA9IC0gZHg7XG5cdFx0XHRcdFx0bm9ybWFsLnogPSBkeSAqIDAuMDtcblxuXHRcdFx0XHRcdGN1ck5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblxuXHRcdFx0XHRcdG5vcm1hbC54ICs9IHByZXZOb3JtYWwueDtcblx0XHRcdFx0XHRub3JtYWwueSArPSBwcmV2Tm9ybWFsLnk7XG5cdFx0XHRcdFx0bm9ybWFsLnogKz0gcHJldk5vcm1hbC56O1xuXG5cdFx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0aW5pdE5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdFx0cHJldk5vcm1hbC5jb3B5KCBjdXJOb3JtYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIHV2cyBhbmQgbm9ybWFsc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XG5cblx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKCBwaGkgKTtcblx0XHRcdGNvbnN0IGNvcyA9IE1hdGguY29zKCBwaGkgKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHBvaW50c1sgaiBdLnggKiBzaW47XG5cdFx0XHRcdHZlcnRleC55ID0gcG9pbnRzWyBqIF0ueTtcblx0XHRcdFx0dmVydGV4LnogPSBwb2ludHNbIGogXS54ICogY29zO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2LnggPSBpIC8gc2VnbWVudHM7XG5cdFx0XHRcdHV2LnkgPSBqIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0Y29uc3QgeCA9IGluaXROb3JtYWxzWyAzICogaiArIDAgXSAqIHNpbjtcblx0XHRcdFx0Y29uc3QgeSA9IGluaXROb3JtYWxzWyAzICogaiArIDEgXTtcblx0XHRcdFx0Y29uc3QgeiA9IGluaXROb3JtYWxzWyAzICogaiArIDAgXSAqIGNvcztcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBiYXNlID0gaiArIGkgKiBwb2ludHMubGVuZ3RoO1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBiYXNlO1xuXHRcdFx0XHRjb25zdCBiID0gYmFzZSArIHBvaW50cy5sZW5ndGg7XG5cdFx0XHRcdGNvbnN0IGMgPSBiYXNlICsgcG9pbnRzLmxlbmd0aCArIDE7XG5cdFx0XHRcdGNvbnN0IGQgPSBiYXNlICsgMTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGMsIGQsIGIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBMYXRoZUdlb21ldHJ5KCBkYXRhLnBvaW50cywgZGF0YS5zZWdtZW50cywgZGF0YS5waGlTdGFydCwgZGF0YS5waGlMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQ2Fwc3VsZUdlb21ldHJ5IGV4dGVuZHMgTGF0aGVHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGxlbmd0aCA9IDEsIGNhcFNlZ21lbnRzID0gNCwgcmFkaWFsU2VnbWVudHMgPSA4ICkge1xuXG5cdFx0Y29uc3QgcGF0aCA9IG5ldyBQYXRoKCk7XG5cdFx0cGF0aC5hYnNhcmMoIDAsIC0gbGVuZ3RoIC8gMiwgcmFkaXVzLCBNYXRoLlBJICogMS41LCAwICk7XG5cdFx0cGF0aC5hYnNhcmMoIDAsIGxlbmd0aCAvIDIsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDAuNSApO1xuXG5cdFx0c3VwZXIoIHBhdGguZ2V0UG9pbnRzKCBjYXBTZWdtZW50cyApLCByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NhcHN1bGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGxlbmd0aDogbGVuZ3RoLFxuXHRcdFx0Y2FwU2VnbWVudHM6IGNhcFNlZ21lbnRzLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdH07XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQ2Fwc3VsZUdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5sZW5ndGgsIGRhdGEuY2FwU2VnbWVudHMsIGRhdGEucmFkaWFsU2VnbWVudHMgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQ2lyY2xlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIHNlZ21lbnRzID0gMzIsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdFx0c2VnbWVudHMgPSBNYXRoLm1heCggMywgc2VnbWVudHMgKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Ly8gY2VudGVyIHBvaW50XG5cblx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XG5cdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cdFx0dXZzLnB1c2goIDAuNSwgMC41ICk7XG5cblx0XHRmb3IgKCBsZXQgcyA9IDAsIGkgPSAzOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMgKSB7XG5cblx0XHRcdGNvbnN0IHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgcyAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cblx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXG5cdFx0XHQvLyB1dnNcblxuXHRcdFx0dXYueCA9ICggdmVydGljZXNbIGkgXSAvIHJhZGl1cyArIDEgKSAvIDI7XG5cdFx0XHR1di55ID0gKCB2ZXJ0aWNlc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XG5cblx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHR9XG5cblx0XHQvLyBpbmRpY2VzXG5cblx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQ2lyY2xlR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLnNlZ21lbnRzLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQ3lsaW5kZXJHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzVG9wID0gMSwgcmFkaXVzQm90dG9tID0gMSwgaGVpZ2h0ID0gMSwgcmFkaWFsU2VnbWVudHMgPSAzMiwgaGVpZ2h0U2VnbWVudHMgPSAxLCBvcGVuRW5kZWQgPSBmYWxzZSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0XHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdGNvbnN0IGluZGV4QXJyYXkgPSBbXTtcblx0XHRjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblx0XHRsZXQgZ3JvdXBTdGFydCA9IDA7XG5cblx0XHQvLyBnZW5lcmF0ZSBnZW9tZXRyeVxuXG5cdFx0Z2VuZXJhdGVUb3JzbygpO1xuXG5cdFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRpZiAoIHJhZGl1c1RvcCA+IDAgKSBnZW5lcmF0ZUNhcCggdHJ1ZSApO1xuXHRcdFx0aWYgKCByYWRpdXNCb3R0b20gPiAwICkgZ2VuZXJhdGVDYXAoIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVG9yc28oKSB7XG5cblx0XHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRsZXQgZ3JvdXBDb3VudCA9IDA7XG5cblx0XHRcdC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsXG5cdFx0XHRjb25zdCBzbG9wZSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG5cblx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGluZGV4Um93ID0gW107XG5cblx0XHRcdFx0Y29uc3QgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcblxuXHRcdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHJhZGl1cyBvZiB0aGUgY3VycmVudCByb3dcblxuXHRcdFx0XHRjb25zdCByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcblxuXHRcdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuXG5cdFx0XHRcdFx0Y29uc3QgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcblx0XHRcdFx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gLSB2ICogaGVpZ2h0ICsgaGFsZkhlaWdodDtcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdFx0bm9ybWFsLnNldCggc2luVGhldGEsIHNsb3BlLCBjb3NUaGV0YSApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHRcdHV2cy5wdXNoKCB1LCAxIC0gdiApO1xuXG5cdFx0XHRcdFx0Ly8gc2F2ZSBpbmRleCBvZiB2ZXJ0ZXggaW4gcmVzcGVjdGl2ZSByb3dcblxuXHRcdFx0XHRcdGluZGV4Um93LnB1c2goIGluZGV4ICsrICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vdyBzYXZlIHZlcnRpY2VzIG9mIHRoZSByb3cgaW4gb3VyIGluZGV4IGFycmF5XG5cblx0XHRcdFx0aW5kZXhBcnJheS5wdXNoKCBpbmRleFJvdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cblx0XHRcdFx0XHQvLyB3ZSB1c2UgdGhlIGluZGV4IGFycmF5IHRvIGFjY2VzcyB0aGUgY29ycmVjdCBpbmRpY2VzXG5cblx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXhBcnJheVsgeSBdWyB4IF07XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggXTtcblx0XHRcdFx0XHRjb25zdCBjID0gaW5kZXhBcnJheVsgeSArIDEgXVsgeCArIDEgXTtcblx0XHRcdFx0XHRjb25zdCBkID0gaW5kZXhBcnJheVsgeSBdWyB4ICsgMSBdO1xuXG5cdFx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGdyb3VwIGNvdW50ZXJcblxuXHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gNjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIDAgKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlQ2FwKCB0b3AgKSB7XG5cblx0XHRcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjZW50ZXIgdmVydGV4XG5cdFx0XHRjb25zdCBjZW50ZXJJbmRleFN0YXJ0ID0gaW5kZXg7XG5cblx0XHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGxldCBncm91cENvdW50ID0gMDtcblxuXHRcdFx0Y29uc3QgcmFkaXVzID0gKCB0b3AgPT09IHRydWUgKSA/IHJhZGl1c1RvcCA6IHJhZGl1c0JvdHRvbTtcblx0XHRcdGNvbnN0IHNpZ24gPSAoIHRvcCA9PT0gdHJ1ZSApID8gMSA6IC0gMTtcblxuXHRcdFx0Ly8gZmlyc3Qgd2UgZ2VuZXJhdGUgdGhlIGNlbnRlciB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2FwLlxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXG5cdFx0XHQvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XG5cblx0XHRcdGZvciAoIGxldCB4ID0gMTsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCBoYWxmSGVpZ2h0ICogc2lnbiwgMCApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgc2lnbiwgMCApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIDAuNSwgMC41ICk7XG5cblx0XHRcdFx0Ly8gaW5jcmVhc2UgaW5kZXhcblxuXHRcdFx0XHRpbmRleCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjZW50ZXIgdmVydGV4XG5cdFx0XHRjb25zdCBjZW50ZXJJbmRleEVuZCA9IGluZGV4O1xuXG5cdFx0XHQvLyBub3cgd2UgZ2VuZXJhdGUgdGhlIHN1cnJvdW5kaW5nIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG5cdFx0XHRcdGNvbnN0IHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcblxuXHRcdFx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdFx0XHRjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG5cdFx0XHRcdHZlcnRleC55ID0gaGFsZkhlaWdodCAqIHNpZ247XG5cdFx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIDAsIHNpZ24sIDAgKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2LnggPSAoIGNvc1RoZXRhICogMC41ICkgKyAwLjU7XG5cdFx0XHRcdHV2LnkgPSAoIHNpblRoZXRhICogMC41ICogc2lnbiApICsgMC41O1xuXHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG5cblx0XHRcdFx0aW5kZXggKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjID0gY2VudGVySW5kZXhTdGFydCArIHg7XG5cdFx0XHRcdGNvbnN0IGkgPSBjZW50ZXJJbmRleEVuZCArIHg7XG5cblx0XHRcdFx0aWYgKCB0b3AgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBmYWNlIHRvcFxuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpLCBpICsgMSwgYyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBmYWNlIGJvdHRvbVxuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpICsgMSwgaSwgYyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRncm91cENvdW50ICs9IDM7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIHRvcCA9PT0gdHJ1ZSA/IDEgOiAyICk7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG5cdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBDeWxpbmRlckdlb21ldHJ5KCBkYXRhLnJhZGl1c1RvcCwgZGF0YS5yYWRpdXNCb3R0b20sIGRhdGEuaGVpZ2h0LCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLm9wZW5FbmRlZCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIENvbmVHZW9tZXRyeSBleHRlbmRzIEN5bGluZGVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBoZWlnaHQgPSAxLCByYWRpYWxTZWdtZW50cyA9IDMyLCBoZWlnaHRTZWdtZW50cyA9IDEsIG9wZW5FbmRlZCA9IGZhbHNlLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICogMiApIHtcblxuXHRcdHN1cGVyKCAwLCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ29uZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IENvbmVHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuaGVpZ2h0LCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLm9wZW5FbmRlZCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFBvbHloZWRyb25HZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggdmVydGljZXMgPSBbXSwgaW5kaWNlcyA9IFtdLCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0dmVydGljZXM6IHZlcnRpY2VzLFxuXHRcdFx0aW5kaWNlczogaW5kaWNlcyxcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdFx0Ly8gZGVmYXVsdCBidWZmZXIgZGF0YVxuXG5cdFx0Y29uc3QgdmVydGV4QnVmZmVyID0gW107XG5cdFx0Y29uc3QgdXZCdWZmZXIgPSBbXTtcblxuXHRcdC8vIHRoZSBzdWJkaXZpc2lvbiBjcmVhdGVzIHRoZSB2ZXJ0ZXggYnVmZmVyIGRhdGFcblxuXHRcdHN1YmRpdmlkZSggZGV0YWlsICk7XG5cblx0XHQvLyBhbGwgdmVydGljZXMgc2hvdWxkIGxpZSBvbiBhIGNvbmNlcHR1YWwgc3BoZXJlIHdpdGggYSBnaXZlbiByYWRpdXNcblxuXHRcdGFwcGx5UmFkaXVzKCByYWRpdXMgKTtcblxuXHRcdC8vIGZpbmFsbHksIGNyZWF0ZSB0aGUgdXYgZGF0YVxuXG5cdFx0Z2VuZXJhdGVVVnMoKTtcblxuXHRcdC8vIGJ1aWxkIG5vbi1pbmRleGVkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRleEJ1ZmZlciwgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGV4QnVmZmVyLnNsaWNlKCksIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZCdWZmZXIsIDIgKSApO1xuXG5cdFx0aWYgKCBkZXRhaWwgPT09IDAgKSB7XG5cblx0XHRcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTsgLy8gZmxhdCBub3JtYWxzXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTsgLy8gc21vb3RoIG5vcm1hbHNcblxuXHRcdH1cblxuXHRcdC8vIGhlbHBlciBmdW5jdGlvbnNcblxuXHRcdGZ1bmN0aW9uIHN1YmRpdmlkZSggZGV0YWlsICkge1xuXG5cdFx0XHRjb25zdCBhID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgYyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdC8vIGl0ZXJhdGUgb3ZlciBhbGwgZmFjZXMgYW5kIGFwcGx5IGEgc3ViZGl2aXNpb24gd2l0aCB0aGUgZ2l2ZW4gZGV0YWlsIHZhbHVlXG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0Ly8gZ2V0IHRoZSB2ZXJ0aWNlcyBvZiB0aGUgZmFjZVxuXG5cdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAwIF0sIGEgKTtcblx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDEgXSwgYiApO1xuXHRcdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMiBdLCBjICk7XG5cblx0XHRcdFx0Ly8gcGVyZm9ybSBzdWJkaXZpc2lvblxuXG5cdFx0XHRcdHN1YmRpdmlkZUZhY2UoIGEsIGIsIGMsIGRldGFpbCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdWJkaXZpZGVGYWNlKCBhLCBiLCBjLCBkZXRhaWwgKSB7XG5cblx0XHRcdGNvbnN0IGNvbHMgPSBkZXRhaWwgKyAxO1xuXG5cdFx0XHQvLyB3ZSB1c2UgdGhpcyBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IGFzIGEgZGF0YSBzdHJ1Y3R1cmUgZm9yIGNyZWF0aW5nIHRoZSBzdWJkaXZpc2lvblxuXG5cdFx0XHRjb25zdCB2ID0gW107XG5cblx0XHRcdC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIHZlcnRpY2VzIGZvciB0aGlzIHN1YmRpdmlzaW9uXG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSBjb2xzOyBpICsrICkge1xuXG5cdFx0XHRcdHZbIGkgXSA9IFtdO1xuXG5cdFx0XHRcdGNvbnN0IGFqID0gYS5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICk7XG5cdFx0XHRcdGNvbnN0IGJqID0gYi5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICk7XG5cblx0XHRcdFx0Y29uc3Qgcm93cyA9IGNvbHMgLSBpO1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByb3dzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGkgPT09IGNvbHMgKSB7XG5cblx0XHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWo7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGogXSA9IGFqLmNsb25lKCkubGVycCggYmosIGogLyByb3dzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIGZhY2VzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgMiAqICggY29scyAtIGkgKSAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBrID0gTWF0aC5mbG9vciggaiAvIDIgKTtcblxuXHRcdFx0XHRcdGlmICggaiAlIDIgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayArIDEgXSApO1xuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSArIDEgXVsgayBdICk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgXSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSBdWyBrICsgMSBdICk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrICsgMSBdICk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFwcGx5UmFkaXVzKCByYWRpdXMgKSB7XG5cblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdC8vIGl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGJ1ZmZlciBhbmQgYXBwbHkgdGhlIHJhZGl1cyB0byBlYWNoIHZlcnRleFxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF07XG5cdFx0XHRcdHZlcnRleC55ID0gdmVydGV4QnVmZmVyWyBpICsgMSBdO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHZlcnRleEJ1ZmZlclsgaSArIDIgXTtcblxuXHRcdFx0XHR2ZXJ0ZXgubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xuXG5cdFx0XHRcdHZlcnRleEJ1ZmZlclsgaSArIDAgXSA9IHZlcnRleC54O1xuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF0gPSB2ZXJ0ZXgueTtcblx0XHRcdFx0dmVydGV4QnVmZmVyWyBpICsgMiBdID0gdmVydGV4Lno7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVVZzKCkge1xuXG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF07XG5cdFx0XHRcdHZlcnRleC55ID0gdmVydGV4QnVmZmVyWyBpICsgMSBdO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHZlcnRleEJ1ZmZlclsgaSArIDIgXTtcblxuXHRcdFx0XHRjb25zdCB1ID0gYXppbXV0aCggdmVydGV4ICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcblx0XHRcdFx0Y29uc3QgdiA9IGluY2xpbmF0aW9uKCB2ZXJ0ZXggKSAvIE1hdGguUEkgKyAwLjU7XG5cdFx0XHRcdHV2QnVmZmVyLnB1c2goIHUsIDEgLSB2ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29ycmVjdFVWcygpO1xuXG5cdFx0XHRjb3JyZWN0U2VhbSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29ycmVjdFNlYW0oKSB7XG5cblx0XHRcdC8vIGhhbmRsZSBjYXNlIHdoZW4gZmFjZSBzdHJhZGRsZXMgdGhlIHNlYW0sIHNlZSAjMzI2OVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB1dkJ1ZmZlci5sZW5ndGg7IGkgKz0gNiApIHtcblxuXHRcdFx0XHQvLyB1diBkYXRhIG9mIGEgc2luZ2xlIGZhY2VcblxuXHRcdFx0XHRjb25zdCB4MCA9IHV2QnVmZmVyWyBpICsgMCBdO1xuXHRcdFx0XHRjb25zdCB4MSA9IHV2QnVmZmVyWyBpICsgMiBdO1xuXHRcdFx0XHRjb25zdCB4MiA9IHV2QnVmZmVyWyBpICsgNCBdO1xuXG5cdFx0XHRcdGNvbnN0IG1heCA9IE1hdGgubWF4KCB4MCwgeDEsIHgyICk7XG5cdFx0XHRcdGNvbnN0IG1pbiA9IE1hdGgubWluKCB4MCwgeDEsIHgyICk7XG5cblx0XHRcdFx0Ly8gMC45IGlzIHNvbWV3aGF0IGFyYml0cmFyeVxuXG5cdFx0XHRcdGlmICggbWF4ID4gMC45ICYmIG1pbiA8IDAuMSApIHtcblxuXHRcdFx0XHRcdGlmICggeDAgPCAwLjIgKSB1dkJ1ZmZlclsgaSArIDAgXSArPSAxO1xuXHRcdFx0XHRcdGlmICggeDEgPCAwLjIgKSB1dkJ1ZmZlclsgaSArIDIgXSArPSAxO1xuXHRcdFx0XHRcdGlmICggeDIgPCAwLjIgKSB1dkJ1ZmZlclsgaSArIDQgXSArPSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHVzaFZlcnRleCggdmVydGV4ICkge1xuXG5cdFx0XHR2ZXJ0ZXhCdWZmZXIucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VmVydGV4QnlJbmRleCggaW5kZXgsIHZlcnRleCApIHtcblxuXHRcdFx0Y29uc3Qgc3RyaWRlID0gaW5kZXggKiAzO1xuXG5cdFx0XHR2ZXJ0ZXgueCA9IHZlcnRpY2VzWyBzdHJpZGUgKyAwIF07XG5cdFx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBzdHJpZGUgKyAxIF07XG5cdFx0XHR2ZXJ0ZXgueiA9IHZlcnRpY2VzWyBzdHJpZGUgKyAyIF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb3JyZWN0VVZzKCkge1xuXG5cdFx0XHRjb25zdCBhID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgYyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGNvbnN0IGNlbnRyb2lkID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Y29uc3QgdXZBID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHV2QiA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHRjb25zdCB1dkMgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGogPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSA5LCBqICs9IDYgKSB7XG5cblx0XHRcdFx0YS5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDAgXSwgdmVydGV4QnVmZmVyWyBpICsgMSBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gKTtcblx0XHRcdFx0Yi5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDMgXSwgdmVydGV4QnVmZmVyWyBpICsgNCBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA1IF0gKTtcblx0XHRcdFx0Yy5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDYgXSwgdmVydGV4QnVmZmVyWyBpICsgNyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA4IF0gKTtcblxuXHRcdFx0XHR1dkEuc2V0KCB1dkJ1ZmZlclsgaiArIDAgXSwgdXZCdWZmZXJbIGogKyAxIF0gKTtcblx0XHRcdFx0dXZCLnNldCggdXZCdWZmZXJbIGogKyAyIF0sIHV2QnVmZmVyWyBqICsgMyBdICk7XG5cdFx0XHRcdHV2Qy5zZXQoIHV2QnVmZmVyWyBqICsgNCBdLCB1dkJ1ZmZlclsgaiArIDUgXSApO1xuXG5cdFx0XHRcdGNlbnRyb2lkLmNvcHkoIGEgKS5hZGQoIGIgKS5hZGQoIGMgKS5kaXZpZGVTY2FsYXIoIDMgKTtcblxuXHRcdFx0XHRjb25zdCBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xuXG5cdFx0XHRcdGNvcnJlY3RVViggdXZBLCBqICsgMCwgYSwgYXppICk7XG5cdFx0XHRcdGNvcnJlY3RVViggdXZCLCBqICsgMiwgYiwgYXppICk7XG5cdFx0XHRcdGNvcnJlY3RVViggdXZDLCBqICsgNCwgYywgYXppICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHN0cmlkZSwgdmVjdG9yLCBhemltdXRoICkge1xuXG5cdFx0XHRpZiAoICggYXppbXV0aCA8IDAgKSAmJiAoIHV2LnggPT09IDEgKSApIHtcblxuXHRcdFx0XHR1dkJ1ZmZlclsgc3RyaWRlIF0gPSB1di54IC0gMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB7XG5cblx0XHRcdFx0dXZCdWZmZXJbIHN0cmlkZSBdID0gYXppbXV0aCAvIDIgLyBNYXRoLlBJICsgMC41O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXG5cblx0XHRmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLmF0YW4yKCB2ZWN0b3IueiwgLSB2ZWN0b3IueCApO1xuXG5cdFx0fVxuXG5cblx0XHQvLyBBbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUuXG5cblx0XHRmdW5jdGlvbiBpbmNsaW5hdGlvbiggdmVjdG9yICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFBvbHloZWRyb25HZW9tZXRyeSggZGF0YS52ZXJ0aWNlcywgZGF0YS5pbmRpY2VzLCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWxzICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIERvZGVjYWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgZGV0YWlsID0gMCApIHtcblxuXHRcdGNvbnN0IHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcblx0XHRjb25zdCByID0gMSAvIHQ7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcblxuXHRcdFx0Ly8gKMKxMSwgwrExLCDCsTEpXG5cdFx0XHQtIDEsIC0gMSwgLSAxLFx0LSAxLCAtIDEsIDEsXG5cdFx0XHQtIDEsIDEsIC0gMSwgLSAxLCAxLCAxLFxuXHRcdFx0MSwgLSAxLCAtIDEsIDEsIC0gMSwgMSxcblx0XHRcdDEsIDEsIC0gMSwgMSwgMSwgMSxcblxuXHRcdFx0Ly8gKDAsIMKxMS/PhiwgwrHPhilcblx0XHRcdDAsIC0gciwgLSB0LCAwLCAtIHIsIHQsXG5cdFx0XHQwLCByLCAtIHQsIDAsIHIsIHQsXG5cblx0XHRcdC8vICjCsTEvz4YsIMKxz4YsIDApXG5cdFx0XHQtIHIsIC0gdCwgMCwgLSByLCB0LCAwLFxuXHRcdFx0ciwgLSB0LCAwLCByLCB0LCAwLFxuXG5cdFx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxuXHRcdFx0LSB0LCAwLCAtIHIsIHQsIDAsIC0gcixcblx0XHRcdC0gdCwgMCwgciwgdCwgMCwgclxuXHRcdF07XG5cblx0XHRjb25zdCBpbmRpY2VzID0gW1xuXHRcdFx0MywgMTEsIDcsIFx0MywgNywgMTUsIFx0MywgMTUsIDEzLFxuXHRcdFx0NywgMTksIDE3LCBcdDcsIDE3LCA2LCBcdDcsIDYsIDE1LFxuXHRcdFx0MTcsIDQsIDgsIFx0MTcsIDgsIDEwLCBcdDE3LCAxMCwgNixcblx0XHRcdDgsIDAsIDE2LCBcdDgsIDE2LCAyLCBcdDgsIDIsIDEwLFxuXHRcdFx0MCwgMTIsIDEsIFx0MCwgMSwgMTgsIFx0MCwgMTgsIDE2LFxuXHRcdFx0NiwgMTAsIDIsIFx0NiwgMiwgMTMsIFx0NiwgMTMsIDE1LFxuXHRcdFx0MiwgMTYsIDE4LCBcdDIsIDE4LCAzLCBcdDIsIDMsIDEzLFxuXHRcdFx0MTgsIDEsIDksIFx0MTgsIDksIDExLCBcdDE4LCAxMSwgMyxcblx0XHRcdDQsIDE0LCAxMiwgXHQ0LCAxMiwgMCwgXHQ0LCAwLCA4LFxuXHRcdFx0MTEsIDksIDUsIFx0MTEsIDUsIDE5LCBcdDExLCAxOSwgNyxcblx0XHRcdDE5LCA1LCAxNCwgXHQxOSwgMTQsIDQsIFx0MTksIDQsIDE3LFxuXHRcdFx0MSwgMTIsIDE0LCBcdDEsIDE0LCA1LCBcdDEsIDUsIDlcblx0XHRdO1xuXG5cdFx0c3VwZXIoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IERvZGVjYWhlZHJvbkdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YxJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbm9ybWFsID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3RyaWFuZ2xlID0gLypAX19QVVJFX18qLyBuZXcgVHJpYW5nbGUoKTtcblxuY2xhc3MgRWRnZXNHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnkgPSBudWxsLCB0aHJlc2hvbGRBbmdsZSA9IDEgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0VkZ2VzR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxuXHRcdFx0dGhyZXNob2xkQW5nbGU6IHRocmVzaG9sZEFuZ2xlXG5cdFx0fTtcblxuXHRcdGlmICggZ2VvbWV0cnkgIT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IHByZWNpc2lvblBvaW50cyA9IDQ7XG5cdFx0XHRjb25zdCBwcmVjaXNpb24gPSBNYXRoLnBvdyggMTAsIHByZWNpc2lvblBvaW50cyApO1xuXHRcdFx0Y29uc3QgdGhyZXNob2xkRG90ID0gTWF0aC5jb3MoIERFRzJSQUQgKiB0aHJlc2hvbGRBbmdsZSApO1xuXG5cdFx0XHRjb25zdCBpbmRleEF0dHIgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cdFx0XHRjb25zdCBpbmRleENvdW50ID0gaW5kZXhBdHRyID8gaW5kZXhBdHRyLmNvdW50IDogcG9zaXRpb25BdHRyLmNvdW50O1xuXG5cdFx0XHRjb25zdCBpbmRleEFyciA9IFsgMCwgMCwgMCBdO1xuXHRcdFx0Y29uc3QgdmVydEtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblx0XHRcdGNvbnN0IGhhc2hlcyA9IG5ldyBBcnJheSggMyApO1xuXG5cdFx0XHRjb25zdCBlZGdlRGF0YSA9IHt9O1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGluZGV4Q291bnQ7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRpZiAoIGluZGV4QXR0ciApIHtcblxuXHRcdFx0XHRcdGluZGV4QXJyWyAwIF0gPSBpbmRleEF0dHIuZ2V0WCggaSApO1xuXHRcdFx0XHRcdGluZGV4QXJyWyAxIF0gPSBpbmRleEF0dHIuZ2V0WCggaSArIDEgKTtcblx0XHRcdFx0XHRpbmRleEFyclsgMiBdID0gaW5kZXhBdHRyLmdldFgoIGkgKyAyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGluZGV4QXJyWyAwIF0gPSBpO1xuXHRcdFx0XHRcdGluZGV4QXJyWyAxIF0gPSBpICsgMTtcblx0XHRcdFx0XHRpbmRleEFyclsgMiBdID0gaSArIDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHsgYSwgYiwgYyB9ID0gX3RyaWFuZ2xlO1xuXHRcdFx0XHRhLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbIDAgXSApO1xuXHRcdFx0XHRiLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbIDEgXSApO1xuXHRcdFx0XHRjLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbIDIgXSApO1xuXHRcdFx0XHRfdHJpYW5nbGUuZ2V0Tm9ybWFsKCBfbm9ybWFsICk7XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGhhc2hlcyBmb3IgdGhlIGVkZ2UgZnJvbSB0aGUgdmVydGljZXNcblx0XHRcdFx0aGFzaGVzWyAwIF0gPSBgJHsgTWF0aC5yb3VuZCggYS54ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBhLnkgKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGEueiAqIHByZWNpc2lvbiApIH1gO1xuXHRcdFx0XHRoYXNoZXNbIDEgXSA9IGAkeyBNYXRoLnJvdW5kKCBiLnggKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGIueSAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYi56ICogcHJlY2lzaW9uICkgfWA7XG5cdFx0XHRcdGhhc2hlc1sgMiBdID0gYCR7IE1hdGgucm91bmQoIGMueCAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYy55ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBjLnogKiBwcmVjaXNpb24gKSB9YDtcblxuXHRcdFx0XHQvLyBza2lwIGRlZ2VuZXJhdGUgdHJpYW5nbGVzXG5cdFx0XHRcdGlmICggaGFzaGVzWyAwIF0gPT09IGhhc2hlc1sgMSBdIHx8IGhhc2hlc1sgMSBdID09PSBoYXNoZXNbIDIgXSB8fCBoYXNoZXNbIDIgXSA9PT0gaGFzaGVzWyAwIF0gKSB7XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGV2ZXJ5IGVkZ2Vcblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdC8vIGdldCB0aGUgZmlyc3QgYW5kIG5leHQgdmVydGV4IG1ha2luZyB1cCB0aGUgZWRnZVxuXHRcdFx0XHRcdGNvbnN0IGpOZXh0ID0gKCBqICsgMSApICUgMztcblx0XHRcdFx0XHRjb25zdCB2ZWNIYXNoMCA9IGhhc2hlc1sgaiBdO1xuXHRcdFx0XHRcdGNvbnN0IHZlY0hhc2gxID0gaGFzaGVzWyBqTmV4dCBdO1xuXHRcdFx0XHRcdGNvbnN0IHYwID0gX3RyaWFuZ2xlWyB2ZXJ0S2V5c1sgaiBdIF07XG5cdFx0XHRcdFx0Y29uc3QgdjEgPSBfdHJpYW5nbGVbIHZlcnRLZXlzWyBqTmV4dCBdIF07XG5cblx0XHRcdFx0XHRjb25zdCBoYXNoID0gYCR7IHZlY0hhc2gwIH1fJHsgdmVjSGFzaDEgfWA7XG5cdFx0XHRcdFx0Y29uc3QgcmV2ZXJzZUhhc2ggPSBgJHsgdmVjSGFzaDEgfV8keyB2ZWNIYXNoMCB9YDtcblxuXHRcdFx0XHRcdGlmICggcmV2ZXJzZUhhc2ggaW4gZWRnZURhdGEgJiYgZWRnZURhdGFbIHJldmVyc2VIYXNoIF0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHdlIGZvdW5kIGEgc2libGluZyBlZGdlIGFkZCBpdCBpbnRvIHRoZSB2ZXJ0ZXggYXJyYXkgaWZcblx0XHRcdFx0XHRcdC8vIGl0IG1lZXRzIHRoZSBhbmdsZSB0aHJlc2hvbGQgYW5kIGRlbGV0ZSB0aGUgZWRnZSBmcm9tIHRoZSBtYXAuXG5cdFx0XHRcdFx0XHRpZiAoIF9ub3JtYWwuZG90KCBlZGdlRGF0YVsgcmV2ZXJzZUhhc2ggXS5ub3JtYWwgKSA8PSB0aHJlc2hvbGREb3QgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggdjAueCwgdjAueSwgdjAueiApO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2MS54LCB2MS55LCB2MS56ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZWRnZURhdGFbIHJldmVyc2VIYXNoIF0gPSBudWxsO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISAoIGhhc2ggaW4gZWRnZURhdGEgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gZWRnZSBoZXJlIHRoZW4gc2tpcCBhZGRpbmcgYSBuZXcgb25lXG5cdFx0XHRcdFx0XHRlZGdlRGF0YVsgaGFzaCBdID0ge1xuXG5cdFx0XHRcdFx0XHRcdGluZGV4MDogaW5kZXhBcnJbIGogXSxcblx0XHRcdFx0XHRcdFx0aW5kZXgxOiBpbmRleEFyclsgak5leHQgXSxcblx0XHRcdFx0XHRcdFx0bm9ybWFsOiBfbm9ybWFsLmNsb25lKCksXG5cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGl0ZXJhdGUgb3ZlciBhbGwgcmVtYWluaW5nLCB1bm1hdGNoZWQgZWRnZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSB2ZXJ0ZXggYXJyYXlcblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBlZGdlRGF0YSApIHtcblxuXHRcdFx0XHRpZiAoIGVkZ2VEYXRhWyBrZXkgXSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHsgaW5kZXgwLCBpbmRleDEgfSA9IGVkZ2VEYXRhWyBrZXkgXTtcblx0XHRcdFx0XHRfdjAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleDAgKTtcblx0XHRcdFx0XHRfdjEkMS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHIsIGluZGV4MSApO1xuXG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggX3YwLngsIF92MC55LCBfdjAueiApO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIF92MSQxLngsIF92MSQxLnksIF92MSQxLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgU2hhcGUgZXh0ZW5kcyBQYXRoIHtcblxuXHRjb25zdHJ1Y3RvciggcG9pbnRzICkge1xuXG5cdFx0c3VwZXIoIHBvaW50cyApO1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhcGUnO1xuXG5cdFx0dGhpcy5ob2xlcyA9IFtdO1xuXG5cdH1cblxuXHRnZXRQb2ludHNIb2xlcyggZGl2aXNpb25zICkge1xuXG5cdFx0Y29uc3QgaG9sZXNQdHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRQb2ludHMoIGRpdmlzaW9ucyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhvbGVzUHRzO1xuXG5cdH1cblxuXHQvLyBnZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcblxuXHRleHRyYWN0UG9pbnRzKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRzaGFwZTogdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucyApLFxuXHRcdFx0aG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cblx0XHR9O1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuaG9sZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBob2xlID0gc291cmNlLmhvbGVzWyBpIF07XG5cblx0XHRcdHRoaXMuaG9sZXMucHVzaCggaG9sZS5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEuaG9sZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgaG9sZSA9IHRoaXMuaG9sZXNbIGkgXTtcblx0XHRcdGRhdGEuaG9sZXMucHVzaCggaG9sZS50b0pTT04oKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudXVpZCA9IGpzb24udXVpZDtcblx0XHR0aGlzLmhvbGVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGhvbGUgPSBqc29uLmhvbGVzWyBpIF07XG5cdFx0XHR0aGlzLmhvbGVzLnB1c2goIG5ldyBQYXRoKCkuZnJvbUpTT04oIGhvbGUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbi8qKlxuICogUG9ydCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0ICh2Mi4yLjQpXG4gKi9cblxuY29uc3QgRWFyY3V0ID0ge1xuXG5cdHRyaWFuZ3VsYXRlOiBmdW5jdGlvbiAoIGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0gPSAyICkge1xuXG5cdFx0Y29uc3QgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG5cdFx0Y29uc3Qgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWyAwIF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblx0XHRsZXQgb3V0ZXJOb2RlID0gbGlua2VkTGlzdCggZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSApO1xuXHRcdGNvbnN0IHRyaWFuZ2xlcyA9IFtdO1xuXG5cdFx0aWYgKCAhIG91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYgKSByZXR1cm4gdHJpYW5nbGVzO1xuXG5cdFx0bGV0IG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG5cblx0XHRpZiAoIGhhc0hvbGVzICkgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoIGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSApO1xuXG5cdFx0Ly8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG5cdFx0aWYgKCBkYXRhLmxlbmd0aCA+IDgwICogZGltICkge1xuXG5cdFx0XHRtaW5YID0gbWF4WCA9IGRhdGFbIDAgXTtcblx0XHRcdG1pblkgPSBtYXhZID0gZGF0YVsgMSBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSApIHtcblxuXHRcdFx0XHR4ID0gZGF0YVsgaSBdO1xuXHRcdFx0XHR5ID0gZGF0YVsgaSArIDEgXTtcblx0XHRcdFx0aWYgKCB4IDwgbWluWCApIG1pblggPSB4O1xuXHRcdFx0XHRpZiAoIHkgPCBtaW5ZICkgbWluWSA9IHk7XG5cdFx0XHRcdGlmICggeCA+IG1heFggKSBtYXhYID0geDtcblx0XHRcdFx0aWYgKCB5ID4gbWF4WSApIG1heFkgPSB5O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG5cdFx0XHRpbnZTaXplID0gTWF0aC5tYXgoIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSApO1xuXHRcdFx0aW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAzMjc2NyAvIGludlNpemUgOiAwO1xuXG5cdFx0fVxuXG5cdFx0ZWFyY3V0TGlua2VkKCBvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwICk7XG5cblx0XHRyZXR1cm4gdHJpYW5nbGVzO1xuXG5cdH1cblxufTtcblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KCBkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSApIHtcblxuXHRsZXQgaSwgbGFzdDtcblxuXHRpZiAoIGNsb2Nrd2lzZSA9PT0gKCBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSA+IDAgKSApIHtcblxuXHRcdGZvciAoIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0gKSBsYXN0ID0gaW5zZXJ0Tm9kZSggaSwgZGF0YVsgaSBdLCBkYXRhWyBpICsgMSBdLCBsYXN0ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGZvciAoIGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xuXG5cdH1cblxuXHRpZiAoIGxhc3QgJiYgZXF1YWxzKCBsYXN0LCBsYXN0Lm5leHQgKSApIHtcblxuXHRcdHJlbW92ZU5vZGUoIGxhc3QgKTtcblx0XHRsYXN0ID0gbGFzdC5uZXh0O1xuXG5cdH1cblxuXHRyZXR1cm4gbGFzdDtcblxufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKCBzdGFydCwgZW5kICkge1xuXG5cdGlmICggISBzdGFydCApIHJldHVybiBzdGFydDtcblx0aWYgKCAhIGVuZCApIGVuZCA9IHN0YXJ0O1xuXG5cdGxldCBwID0gc3RhcnQsXG5cdFx0YWdhaW47XG5cdGRvIHtcblxuXHRcdGFnYWluID0gZmFsc2U7XG5cblx0XHRpZiAoICEgcC5zdGVpbmVyICYmICggZXF1YWxzKCBwLCBwLm5leHQgKSB8fCBhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID09PSAwICkgKSB7XG5cblx0XHRcdHJlbW92ZU5vZGUoIHAgKTtcblx0XHRcdHAgPSBlbmQgPSBwLnByZXY7XG5cdFx0XHRpZiAoIHAgPT09IHAubmV4dCApIGJyZWFrO1xuXHRcdFx0YWdhaW4gPSB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cCA9IHAubmV4dDtcblxuXHRcdH1cblxuXHR9IHdoaWxlICggYWdhaW4gfHwgcCAhPT0gZW5kICk7XG5cblx0cmV0dXJuIGVuZDtcblxufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZCggZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcyApIHtcblxuXHRpZiAoICEgZWFyICkgcmV0dXJuO1xuXG5cdC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcblx0aWYgKCAhIHBhc3MgJiYgaW52U2l6ZSApIGluZGV4Q3VydmUoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xuXG5cdGxldCBzdG9wID0gZWFyLFxuXHRcdHByZXYsIG5leHQ7XG5cblx0Ly8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG5cdHdoaWxlICggZWFyLnByZXYgIT09IGVhci5uZXh0ICkge1xuXG5cdFx0cHJldiA9IGVhci5wcmV2O1xuXHRcdG5leHQgPSBlYXIubmV4dDtcblxuXHRcdGlmICggaW52U2l6ZSA/IGlzRWFySGFzaGVkKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKSA6IGlzRWFyKCBlYXIgKSApIHtcblxuXHRcdFx0Ly8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBwcmV2LmkgLyBkaW0gfCAwICk7XG5cdFx0XHR0cmlhbmdsZXMucHVzaCggZWFyLmkgLyBkaW0gfCAwICk7XG5cdFx0XHR0cmlhbmdsZXMucHVzaCggbmV4dC5pIC8gZGltIHwgMCApO1xuXG5cdFx0XHRyZW1vdmVOb2RlKCBlYXIgKTtcblxuXHRcdFx0Ly8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuXHRcdFx0ZWFyID0gbmV4dC5uZXh0O1xuXHRcdFx0c3RvcCA9IG5leHQubmV4dDtcblxuXHRcdFx0Y29udGludWU7XG5cblx0XHR9XG5cblx0XHRlYXIgPSBuZXh0O1xuXG5cdFx0Ly8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcblx0XHRpZiAoIGVhciA9PT0gc3RvcCApIHtcblxuXHRcdFx0Ly8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cblx0XHRcdGlmICggISBwYXNzICkge1xuXG5cdFx0XHRcdGVhcmN1dExpbmtlZCggZmlsdGVyUG9pbnRzKCBlYXIgKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEgKTtcblxuXHRcdFx0XHQvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXNzID09PSAxICkge1xuXG5cdFx0XHRcdGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoIGZpbHRlclBvaW50cyggZWFyICksIHRyaWFuZ2xlcywgZGltICk7XG5cdFx0XHRcdGVhcmN1dExpbmtlZCggZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMiApO1xuXG5cdFx0XHRcdC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG5cblx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDIgKSB7XG5cblx0XHRcdFx0c3BsaXRFYXJjdXQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhciggZWFyICkge1xuXG5cdGNvbnN0IGEgPSBlYXIucHJldixcblx0XHRiID0gZWFyLFxuXHRcdGMgPSBlYXIubmV4dDtcblxuXHRpZiAoIGFyZWEoIGEsIGIsIGMgKSA+PSAwICkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG5cdC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG5cdGNvbnN0IGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cblx0Ly8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcblx0Y29uc3QgeDAgPSBheCA8IGJ4ID8gKCBheCA8IGN4ID8gYXggOiBjeCApIDogKCBieCA8IGN4ID8gYnggOiBjeCApLFxuXHRcdHkwID0gYXkgPCBieSA/ICggYXkgPCBjeSA/IGF5IDogY3kgKSA6ICggYnkgPCBjeSA/IGJ5IDogY3kgKSxcblx0XHR4MSA9IGF4ID4gYnggPyAoIGF4ID4gY3ggPyBheCA6IGN4ICkgOiAoIGJ4ID4gY3ggPyBieCA6IGN4ICksXG5cdFx0eTEgPSBheSA+IGJ5ID8gKCBheSA+IGN5ID8gYXkgOiBjeSApIDogKCBieSA+IGN5ID8gYnkgOiBjeSApO1xuXG5cdGxldCBwID0gYy5uZXh0O1xuXHR3aGlsZSAoIHAgIT09IGEgKSB7XG5cblx0XHRpZiAoIHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJlxuXHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSApICYmXG5cdFx0XHRhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XG5cdFx0cCA9IHAubmV4dDtcblxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG5cbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcblxuXHRjb25zdCBhID0gZWFyLnByZXYsXG5cdFx0YiA9IGVhcixcblx0XHRjID0gZWFyLm5leHQ7XG5cblx0aWYgKCBhcmVhKCBhLCBiLCBjICkgPj0gMCApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuXHRjb25zdCBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG5cdC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG5cdGNvbnN0IHgwID0gYXggPCBieCA/ICggYXggPCBjeCA/IGF4IDogY3ggKSA6ICggYnggPCBjeCA/IGJ4IDogY3ggKSxcblx0XHR5MCA9IGF5IDwgYnkgPyAoIGF5IDwgY3kgPyBheSA6IGN5ICkgOiAoIGJ5IDwgY3kgPyBieSA6IGN5ICksXG5cdFx0eDEgPSBheCA+IGJ4ID8gKCBheCA+IGN4ID8gYXggOiBjeCApIDogKCBieCA+IGN4ID8gYnggOiBjeCApLFxuXHRcdHkxID0gYXkgPiBieSA/ICggYXkgPiBjeSA/IGF5IDogY3kgKSA6ICggYnkgPiBjeSA/IGJ5IDogY3kgKTtcblxuXHQvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuXHRjb25zdCBtaW5aID0gek9yZGVyKCB4MCwgeTAsIG1pblgsIG1pblksIGludlNpemUgKSxcblx0XHRtYXhaID0gek9yZGVyKCB4MSwgeTEsIG1pblgsIG1pblksIGludlNpemUgKTtcblxuXHRsZXQgcCA9IGVhci5wcmV2Wixcblx0XHRuID0gZWFyLm5leHRaO1xuXG5cdC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuXHR3aGlsZSAoIHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4WiApIHtcblxuXHRcdGlmICggcC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuXHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSApICYmIGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcblx0XHRwID0gcC5wcmV2WjtcblxuXHRcdGlmICggbi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuXHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSApICYmIGFyZWEoIG4ucHJldiwgbiwgbi5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcblx0XHRuID0gbi5uZXh0WjtcblxuXHR9XG5cblx0Ly8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcblx0d2hpbGUgKCBwICYmIHAueiA+PSBtaW5aICkge1xuXG5cdFx0aWYgKCBwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG5cdFx0XHRwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55ICkgJiYgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xuXHRcdHAgPSBwLnByZXZaO1xuXG5cdH1cblxuXHQvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuXHR3aGlsZSAoIG4gJiYgbi56IDw9IG1heFogKSB7XG5cblx0XHRpZiAoIG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcblx0XHRcdHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkgKSAmJiBhcmVhKCBuLnByZXYsIG4sIG4ubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XG5cdFx0biA9IG4ubmV4dFo7XG5cblx0fVxuXG5cdHJldHVybiB0cnVlO1xuXG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKCBzdGFydCwgdHJpYW5nbGVzLCBkaW0gKSB7XG5cblx0bGV0IHAgPSBzdGFydDtcblx0ZG8ge1xuXG5cdFx0Y29uc3QgYSA9IHAucHJldixcblx0XHRcdGIgPSBwLm5leHQubmV4dDtcblxuXHRcdGlmICggISBlcXVhbHMoIGEsIGIgKSAmJiBpbnRlcnNlY3RzKCBhLCBwLCBwLm5leHQsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBhLCBiICkgJiYgbG9jYWxseUluc2lkZSggYiwgYSApICkge1xuXG5cdFx0XHR0cmlhbmdsZXMucHVzaCggYS5pIC8gZGltIHwgMCApO1xuXHRcdFx0dHJpYW5nbGVzLnB1c2goIHAuaSAvIGRpbSB8IDAgKTtcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBiLmkgLyBkaW0gfCAwICk7XG5cblx0XHRcdC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcblx0XHRcdHJlbW92ZU5vZGUoIHAgKTtcblx0XHRcdHJlbW92ZU5vZGUoIHAubmV4dCApO1xuXG5cdFx0XHRwID0gc3RhcnQgPSBiO1xuXG5cdFx0fVxuXG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcblxuXHRyZXR1cm4gZmlsdGVyUG9pbnRzKCBwICk7XG5cbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KCBzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKSB7XG5cblx0Ly8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cblx0bGV0IGEgPSBzdGFydDtcblx0ZG8ge1xuXG5cdFx0bGV0IGIgPSBhLm5leHQubmV4dDtcblx0XHR3aGlsZSAoIGIgIT09IGEucHJldiApIHtcblxuXHRcdFx0aWYgKCBhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoIGEsIGIgKSApIHtcblxuXHRcdFx0XHQvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG5cdFx0XHRcdGxldCBjID0gc3BsaXRQb2x5Z29uKCBhLCBiICk7XG5cblx0XHRcdFx0Ly8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcblx0XHRcdFx0YSA9IGZpbHRlclBvaW50cyggYSwgYS5uZXh0ICk7XG5cdFx0XHRcdGMgPSBmaWx0ZXJQb2ludHMoIGMsIGMubmV4dCApO1xuXG5cdFx0XHRcdC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG5cdFx0XHRcdGVhcmN1dExpbmtlZCggYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDAgKTtcblx0XHRcdFx0ZWFyY3V0TGlua2VkKCBjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0YiA9IGIubmV4dDtcblxuXHRcdH1cblxuXHRcdGEgPSBhLm5leHQ7XG5cblx0fSB3aGlsZSAoIGEgIT09IHN0YXJ0ICk7XG5cbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoIGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSApIHtcblxuXHRjb25zdCBxdWV1ZSA9IFtdO1xuXHRsZXQgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG5cdGZvciAoIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKysgKSB7XG5cblx0XHRzdGFydCA9IGhvbGVJbmRpY2VzWyBpIF0gKiBkaW07XG5cdFx0ZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1sgaSArIDEgXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXHRcdGxpc3QgPSBsaW5rZWRMaXN0KCBkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlICk7XG5cdFx0aWYgKCBsaXN0ID09PSBsaXN0Lm5leHQgKSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuXHRcdHF1ZXVlLnB1c2goIGdldExlZnRtb3N0KCBsaXN0ICkgKTtcblxuXHR9XG5cblx0cXVldWUuc29ydCggY29tcGFyZVggKTtcblxuXHQvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuXHRmb3IgKCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGUoIHF1ZXVlWyBpIF0sIG91dGVyTm9kZSApO1xuXG5cdH1cblxuXHRyZXR1cm4gb3V0ZXJOb2RlO1xuXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKCBhLCBiICkge1xuXG5cdHJldHVybiBhLnggLSBiLng7XG5cbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoIGhvbGUsIG91dGVyTm9kZSApIHtcblxuXHRjb25zdCBicmlkZ2UgPSBmaW5kSG9sZUJyaWRnZSggaG9sZSwgb3V0ZXJOb2RlICk7XG5cdGlmICggISBicmlkZ2UgKSB7XG5cblx0XHRyZXR1cm4gb3V0ZXJOb2RlO1xuXG5cdH1cblxuXHRjb25zdCBicmlkZ2VSZXZlcnNlID0gc3BsaXRQb2x5Z29uKCBicmlkZ2UsIGhvbGUgKTtcblxuXHQvLyBmaWx0ZXIgY29sbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcblx0ZmlsdGVyUG9pbnRzKCBicmlkZ2VSZXZlcnNlLCBicmlkZ2VSZXZlcnNlLm5leHQgKTtcblx0cmV0dXJuIGZpbHRlclBvaW50cyggYnJpZGdlLCBicmlkZ2UubmV4dCApO1xuXG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKCBob2xlLCBvdXRlck5vZGUgKSB7XG5cblx0bGV0IHAgPSBvdXRlck5vZGUsXG5cdFx0cXggPSAtIEluZmluaXR5LFxuXHRcdG07XG5cblx0Y29uc3QgaHggPSBob2xlLngsIGh5ID0gaG9sZS55O1xuXG5cdC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcblx0Ly8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuXHRkbyB7XG5cblx0XHRpZiAoIGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55ICkge1xuXG5cdFx0XHRjb25zdCB4ID0gcC54ICsgKCBoeSAtIHAueSApICogKCBwLm5leHQueCAtIHAueCApIC8gKCBwLm5leHQueSAtIHAueSApO1xuXHRcdFx0aWYgKCB4IDw9IGh4ICYmIHggPiBxeCApIHtcblxuXHRcdFx0XHRxeCA9IHg7XG5cdFx0XHRcdG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG5cdFx0XHRcdGlmICggeCA9PT0gaHggKSByZXR1cm4gbTsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbGVmdG1vc3QgZW5kcG9pbnRcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gb3V0ZXJOb2RlICk7XG5cblx0aWYgKCAhIG0gKSByZXR1cm4gbnVsbDtcblxuXHQvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG5cdC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuXHQvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG5cdGNvbnN0IHN0b3AgPSBtLFxuXHRcdG14ID0gbS54LFxuXHRcdG15ID0gbS55O1xuXHRsZXQgdGFuTWluID0gSW5maW5pdHksIHRhbjtcblxuXHRwID0gbTtcblxuXHRkbyB7XG5cblx0XHRpZiAoIGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxuXHRcdFx0XHRwb2ludEluVHJpYW5nbGUoIGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55ICkgKSB7XG5cblx0XHRcdHRhbiA9IE1hdGguYWJzKCBoeSAtIHAueSApIC8gKCBoeCAtIHAueCApOyAvLyB0YW5nZW50aWFsXG5cblx0XHRcdGlmICggbG9jYWxseUluc2lkZSggcCwgaG9sZSApICYmICggdGFuIDwgdGFuTWluIHx8ICggdGFuID09PSB0YW5NaW4gJiYgKCBwLnggPiBtLnggfHwgKCBwLnggPT09IG0ueCAmJiBzZWN0b3JDb250YWluc1NlY3RvciggbSwgcCApICkgKSApICkgKSB7XG5cblx0XHRcdFx0bSA9IHA7XG5cdFx0XHRcdHRhbk1pbiA9IHRhbjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gc3RvcCApO1xuXG5cdHJldHVybiBtO1xuXG59XG5cbi8vIHdoZXRoZXIgc2VjdG9yIGluIHZlcnRleCBtIGNvbnRhaW5zIHNlY3RvciBpbiB2ZXJ0ZXggcCBpbiB0aGUgc2FtZSBjb29yZGluYXRlc1xuZnVuY3Rpb24gc2VjdG9yQ29udGFpbnNTZWN0b3IoIG0sIHAgKSB7XG5cblx0cmV0dXJuIGFyZWEoIG0ucHJldiwgbSwgcC5wcmV2ICkgPCAwICYmIGFyZWEoIHAubmV4dCwgbSwgbS5uZXh0ICkgPCAwO1xuXG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoIHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xuXG5cdGxldCBwID0gc3RhcnQ7XG5cdGRvIHtcblxuXHRcdGlmICggcC56ID09PSAwICkgcC56ID0gek9yZGVyKCBwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xuXHRcdHAucHJldlogPSBwLnByZXY7XG5cdFx0cC5uZXh0WiA9IHAubmV4dDtcblx0XHRwID0gcC5uZXh0O1xuXG5cdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xuXG5cdHAucHJldloubmV4dFogPSBudWxsO1xuXHRwLnByZXZaID0gbnVsbDtcblxuXHRzb3J0TGlua2VkKCBwICk7XG5cbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKCBsaXN0ICkge1xuXG5cdGxldCBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcblx0XHRpblNpemUgPSAxO1xuXG5cdGRvIHtcblxuXHRcdHAgPSBsaXN0O1xuXHRcdGxpc3QgPSBudWxsO1xuXHRcdHRhaWwgPSBudWxsO1xuXHRcdG51bU1lcmdlcyA9IDA7XG5cblx0XHR3aGlsZSAoIHAgKSB7XG5cblx0XHRcdG51bU1lcmdlcyArKztcblx0XHRcdHEgPSBwO1xuXHRcdFx0cFNpemUgPSAwO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBpblNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0cFNpemUgKys7XG5cdFx0XHRcdHEgPSBxLm5leHRaO1xuXHRcdFx0XHRpZiAoICEgcSApIGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHFTaXplID0gaW5TaXplO1xuXG5cdFx0XHR3aGlsZSAoIHBTaXplID4gMCB8fCAoIHFTaXplID4gMCAmJiBxICkgKSB7XG5cblx0XHRcdFx0aWYgKCBwU2l6ZSAhPT0gMCAmJiAoIHFTaXplID09PSAwIHx8ICEgcSB8fCBwLnogPD0gcS56ICkgKSB7XG5cblx0XHRcdFx0XHRlID0gcDtcblx0XHRcdFx0XHRwID0gcC5uZXh0Wjtcblx0XHRcdFx0XHRwU2l6ZSAtLTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZSA9IHE7XG5cdFx0XHRcdFx0cSA9IHEubmV4dFo7XG5cdFx0XHRcdFx0cVNpemUgLS07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGFpbCApIHRhaWwubmV4dFogPSBlO1xuXHRcdFx0XHRlbHNlIGxpc3QgPSBlO1xuXG5cdFx0XHRcdGUucHJldlogPSB0YWlsO1xuXHRcdFx0XHR0YWlsID0gZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwID0gcTtcblxuXHRcdH1cblxuXHRcdHRhaWwubmV4dFogPSBudWxsO1xuXHRcdGluU2l6ZSAqPSAyO1xuXG5cdH0gd2hpbGUgKCBudW1NZXJnZXMgPiAxICk7XG5cblx0cmV0dXJuIGxpc3Q7XG5cbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5mdW5jdGlvbiB6T3JkZXIoIHgsIHksIG1pblgsIG1pblksIGludlNpemUgKSB7XG5cblx0Ly8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuXHR4ID0gKCB4IC0gbWluWCApICogaW52U2l6ZSB8IDA7XG5cdHkgPSAoIHkgLSBtaW5ZICkgKiBpbnZTaXplIHwgMDtcblxuXHR4ID0gKCB4IHwgKCB4IDw8IDggKSApICYgMHgwMEZGMDBGRjtcblx0eCA9ICggeCB8ICggeCA8PCA0ICkgKSAmIDB4MEYwRjBGMEY7XG5cdHggPSAoIHggfCAoIHggPDwgMiApICkgJiAweDMzMzMzMzMzO1xuXHR4ID0gKCB4IHwgKCB4IDw8IDEgKSApICYgMHg1NTU1NTU1NTtcblxuXHR5ID0gKCB5IHwgKCB5IDw8IDggKSApICYgMHgwMEZGMDBGRjtcblx0eSA9ICggeSB8ICggeSA8PCA0ICkgKSAmIDB4MEYwRjBGMEY7XG5cdHkgPSAoIHkgfCAoIHkgPDwgMiApICkgJiAweDMzMzMzMzMzO1xuXHR5ID0gKCB5IHwgKCB5IDw8IDEgKSApICYgMHg1NTU1NTU1NTtcblxuXHRyZXR1cm4geCB8ICggeSA8PCAxICk7XG5cbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3QoIHN0YXJ0ICkge1xuXG5cdGxldCBwID0gc3RhcnQsXG5cdFx0bGVmdG1vc3QgPSBzdGFydDtcblx0ZG8ge1xuXG5cdFx0aWYgKCBwLnggPCBsZWZ0bW9zdC54IHx8ICggcC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkgKSApIGxlZnRtb3N0ID0gcDtcblx0XHRwID0gcC5uZXh0O1xuXG5cdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xuXG5cdHJldHVybiBsZWZ0bW9zdDtcblxufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSApIHtcblxuXHRyZXR1cm4gKCBjeCAtIHB4ICkgKiAoIGF5IC0gcHkgKSA+PSAoIGF4IC0gcHggKSAqICggY3kgLSBweSApICYmXG4gICAgICAgICAgICggYXggLSBweCApICogKCBieSAtIHB5ICkgPj0gKCBieCAtIHB4ICkgKiAoIGF5IC0gcHkgKSAmJlxuICAgICAgICAgICAoIGJ4IC0gcHggKSAqICggY3kgLSBweSApID49ICggY3ggLSBweCApICogKCBieSAtIHB5ICk7XG5cbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoIGEsIGIgKSB7XG5cblx0cmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhIGludGVyc2VjdHNQb2x5Z29uKCBhLCBiICkgJiYgLy8gZG9uZXMndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcbiAgICAgICAgICAgKCBsb2NhbGx5SW5zaWRlKCBhLCBiICkgJiYgbG9jYWxseUluc2lkZSggYiwgYSApICYmIG1pZGRsZUluc2lkZSggYSwgYiApICYmIC8vIGxvY2FsbHkgdmlzaWJsZVxuICAgICAgICAgICAgKCBhcmVhKCBhLnByZXYsIGEsIGIucHJldiApIHx8IGFyZWEoIGEsIGIucHJldiwgYiApICkgfHwgLy8gZG9lcyBub3QgY3JlYXRlIG9wcG9zaXRlLWZhY2luZyBzZWN0b3JzXG4gICAgICAgICAgICBlcXVhbHMoIGEsIGIgKSAmJiBhcmVhKCBhLnByZXYsIGEsIGEubmV4dCApID4gMCAmJiBhcmVhKCBiLnByZXYsIGIsIGIubmV4dCApID4gMCApOyAvLyBzcGVjaWFsIHplcm8tbGVuZ3RoIGNhc2VcblxufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKCBwLCBxLCByICkge1xuXG5cdHJldHVybiAoIHEueSAtIHAueSApICogKCByLnggLSBxLnggKSAtICggcS54IC0gcC54ICkgKiAoIHIueSAtIHEueSApO1xuXG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMoIHAxLCBwMiApIHtcblxuXHRyZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xuXG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMoIHAxLCBxMSwgcDIsIHEyICkge1xuXG5cdGNvbnN0IG8xID0gc2lnbiggYXJlYSggcDEsIHExLCBwMiApICk7XG5cdGNvbnN0IG8yID0gc2lnbiggYXJlYSggcDEsIHExLCBxMiApICk7XG5cdGNvbnN0IG8zID0gc2lnbiggYXJlYSggcDIsIHEyLCBwMSApICk7XG5cdGNvbnN0IG80ID0gc2lnbiggYXJlYSggcDIsIHEyLCBxMSApICk7XG5cblx0aWYgKCBvMSAhPT0gbzIgJiYgbzMgIT09IG80ICkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG5cdGlmICggbzEgPT09IDAgJiYgb25TZWdtZW50KCBwMSwgcDIsIHExICkgKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBwMiBhcmUgY29sbGluZWFyIGFuZCBwMiBsaWVzIG9uIHAxcTFcblx0aWYgKCBvMiA9PT0gMCAmJiBvblNlZ21lbnQoIHAxLCBxMiwgcTEgKSApIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHEyIGFyZSBjb2xsaW5lYXIgYW5kIHEyIGxpZXMgb24gcDFxMVxuXHRpZiAoIG8zID09PSAwICYmIG9uU2VnbWVudCggcDIsIHAxLCBxMiApICkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG5cdGlmICggbzQgPT09IDAgJiYgb25TZWdtZW50KCBwMiwgcTEsIHEyICkgKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBxMSBhcmUgY29sbGluZWFyIGFuZCBxMSBsaWVzIG9uIHAycTJcblxuXHRyZXR1cm4gZmFsc2U7XG5cbn1cblxuLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcbmZ1bmN0aW9uIG9uU2VnbWVudCggcCwgcSwgciApIHtcblxuXHRyZXR1cm4gcS54IDw9IE1hdGgubWF4KCBwLngsIHIueCApICYmIHEueCA+PSBNYXRoLm1pbiggcC54LCByLnggKSAmJiBxLnkgPD0gTWF0aC5tYXgoIHAueSwgci55ICkgJiYgcS55ID49IE1hdGgubWluKCBwLnksIHIueSApO1xuXG59XG5cbmZ1bmN0aW9uIHNpZ24oIG51bSApIHtcblxuXHRyZXR1cm4gbnVtID4gMCA/IDEgOiBudW0gPCAwID8gLSAxIDogMDtcblxufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oIGEsIGIgKSB7XG5cblx0bGV0IHAgPSBhO1xuXHRkbyB7XG5cblx0XHRpZiAoIHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuXHRcdFx0aW50ZXJzZWN0cyggcCwgcC5uZXh0LCBhLCBiICkgKSByZXR1cm4gdHJ1ZTtcblx0XHRwID0gcC5uZXh0O1xuXG5cdH0gd2hpbGUgKCBwICE9PSBhICk7XG5cblx0cmV0dXJuIGZhbHNlO1xuXG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZSggYSwgYiApIHtcblxuXHRyZXR1cm4gYXJlYSggYS5wcmV2LCBhLCBhLm5leHQgKSA8IDAgP1xuXHRcdGFyZWEoIGEsIGIsIGEubmV4dCApID49IDAgJiYgYXJlYSggYSwgYS5wcmV2LCBiICkgPj0gMCA6XG5cdFx0YXJlYSggYSwgYiwgYS5wcmV2ICkgPCAwIHx8IGFyZWEoIGEsIGEubmV4dCwgYiApIDwgMDtcblxufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZSggYSwgYiApIHtcblxuXHRsZXQgcCA9IGEsXG5cdFx0aW5zaWRlID0gZmFsc2U7XG5cdGNvbnN0IHB4ID0gKCBhLnggKyBiLnggKSAvIDIsXG5cdFx0cHkgPSAoIGEueSArIGIueSApIC8gMjtcblx0ZG8ge1xuXG5cdFx0aWYgKCAoICggcC55ID4gcHkgKSAhPT0gKCBwLm5leHQueSA+IHB5ICkgKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXG5cdFx0XHQoIHB4IDwgKCBwLm5leHQueCAtIHAueCApICogKCBweSAtIHAueSApIC8gKCBwLm5leHQueSAtIHAueSApICsgcC54ICkgKVxuXHRcdFx0aW5zaWRlID0gISBpbnNpZGU7XG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gYSApO1xuXG5cdHJldHVybiBpbnNpZGU7XG5cbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oIGEsIGIgKSB7XG5cblx0Y29uc3QgYTIgPSBuZXcgTm9kZSggYS5pLCBhLngsIGEueSApLFxuXHRcdGIyID0gbmV3IE5vZGUoIGIuaSwgYi54LCBiLnkgKSxcblx0XHRhbiA9IGEubmV4dCxcblx0XHRicCA9IGIucHJldjtcblxuXHRhLm5leHQgPSBiO1xuXHRiLnByZXYgPSBhO1xuXG5cdGEyLm5leHQgPSBhbjtcblx0YW4ucHJldiA9IGEyO1xuXG5cdGIyLm5leHQgPSBhMjtcblx0YTIucHJldiA9IGIyO1xuXG5cdGJwLm5leHQgPSBiMjtcblx0YjIucHJldiA9IGJwO1xuXG5cdHJldHVybiBiMjtcblxufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZSggaSwgeCwgeSwgbGFzdCApIHtcblxuXHRjb25zdCBwID0gbmV3IE5vZGUoIGksIHgsIHkgKTtcblxuXHRpZiAoICEgbGFzdCApIHtcblxuXHRcdHAucHJldiA9IHA7XG5cdFx0cC5uZXh0ID0gcDtcblxuXHR9IGVsc2Uge1xuXG5cdFx0cC5uZXh0ID0gbGFzdC5uZXh0O1xuXHRcdHAucHJldiA9IGxhc3Q7XG5cdFx0bGFzdC5uZXh0LnByZXYgPSBwO1xuXHRcdGxhc3QubmV4dCA9IHA7XG5cblx0fVxuXG5cdHJldHVybiBwO1xuXG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUoIHAgKSB7XG5cblx0cC5uZXh0LnByZXYgPSBwLnByZXY7XG5cdHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG5cdGlmICggcC5wcmV2WiApIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuXHRpZiAoIHAubmV4dFogKSBwLm5leHRaLnByZXZaID0gcC5wcmV2WjtcblxufVxuXG5mdW5jdGlvbiBOb2RlKCBpLCB4LCB5ICkge1xuXG5cdC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuXHR0aGlzLmkgPSBpO1xuXG5cdC8vIHZlcnRleCBjb29yZGluYXRlc1xuXHR0aGlzLnggPSB4O1xuXHR0aGlzLnkgPSB5O1xuXG5cdC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuXHR0aGlzLnByZXYgPSBudWxsO1xuXHR0aGlzLm5leHQgPSBudWxsO1xuXG5cdC8vIHotb3JkZXIgY3VydmUgdmFsdWVcblx0dGhpcy56ID0gMDtcblxuXHQvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG5cdHRoaXMucHJldlogPSBudWxsO1xuXHR0aGlzLm5leHRaID0gbnVsbDtcblxuXHQvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuXHR0aGlzLnN0ZWluZXIgPSBmYWxzZTtcblxufVxuXG5mdW5jdGlvbiBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSB7XG5cblx0bGV0IHN1bSA9IDA7XG5cdGZvciAoIGxldCBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltICkge1xuXG5cdFx0c3VtICs9ICggZGF0YVsgaiBdIC0gZGF0YVsgaSBdICkgKiAoIGRhdGFbIGkgKyAxIF0gKyBkYXRhWyBqICsgMSBdICk7XG5cdFx0aiA9IGk7XG5cblx0fVxuXG5cdHJldHVybiBzdW07XG5cbn1cblxuY2xhc3MgU2hhcGVVdGlscyB7XG5cblx0Ly8gY2FsY3VsYXRlIGFyZWEgb2YgdGhlIGNvbnRvdXIgcG9seWdvblxuXG5cdHN0YXRpYyBhcmVhKCBjb250b3VyICkge1xuXG5cdFx0Y29uc3QgbiA9IGNvbnRvdXIubGVuZ3RoO1xuXHRcdGxldCBhID0gMC4wO1xuXG5cdFx0Zm9yICggbGV0IHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSArKyApIHtcblxuXHRcdFx0YSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhICogMC41O1xuXG5cdH1cblxuXHRzdGF0aWMgaXNDbG9ja1dpc2UoIHB0cyApIHtcblxuXHRcdHJldHVybiBTaGFwZVV0aWxzLmFyZWEoIHB0cyApIDwgMDtcblxuXHR9XG5cblx0c3RhdGljIHRyaWFuZ3VsYXRlU2hhcGUoIGNvbnRvdXIsIGhvbGVzICkge1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTsgLy8gZmxhdCBhcnJheSBvZiB2ZXJ0aWNlcyBsaWtlIFsgeDAseTAsIHgxLHkxLCB4Mix5MiwgLi4uIF1cblx0XHRjb25zdCBob2xlSW5kaWNlcyA9IFtdOyAvLyBhcnJheSBvZiBob2xlIGluZGljZXNcblx0XHRjb25zdCBmYWNlcyA9IFtdOyAvLyBmaW5hbCBhcnJheSBvZiB2ZXJ0ZXggaW5kaWNlcyBsaWtlIFsgWyBhLGIsZCBdLCBbIGIsYyxkIF0gXVxuXG5cdFx0cmVtb3ZlRHVwRW5kUHRzKCBjb250b3VyICk7XG5cdFx0YWRkQ29udG91ciggdmVydGljZXMsIGNvbnRvdXIgKTtcblxuXHRcdC8vXG5cblx0XHRsZXQgaG9sZUluZGV4ID0gY29udG91ci5sZW5ndGg7XG5cblx0XHRob2xlcy5mb3JFYWNoKCByZW1vdmVEdXBFbmRQdHMgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0aG9sZUluZGljZXMucHVzaCggaG9sZUluZGV4ICk7XG5cdFx0XHRob2xlSW5kZXggKz0gaG9sZXNbIGkgXS5sZW5ndGg7XG5cdFx0XHRhZGRDb250b3VyKCB2ZXJ0aWNlcywgaG9sZXNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHRyaWFuZ2xlcyA9IEVhcmN1dC50cmlhbmd1bGF0ZSggdmVydGljZXMsIGhvbGVJbmRpY2VzICk7XG5cblx0XHQvL1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzICkge1xuXG5cdFx0XHRmYWNlcy5wdXNoKCB0cmlhbmdsZXMuc2xpY2UoIGksIGkgKyAzICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWNlcztcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRHVwRW5kUHRzKCBwb2ludHMgKSB7XG5cblx0Y29uc3QgbCA9IHBvaW50cy5sZW5ndGg7XG5cblx0aWYgKCBsID4gMiAmJiBwb2ludHNbIGwgLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xuXG5cdFx0cG9pbnRzLnBvcCgpO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApIHtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb250b3VyLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdHZlcnRpY2VzLnB1c2goIGNvbnRvdXJbIGkgXS54ICk7XG5cdFx0dmVydGljZXMucHVzaCggY29udG91clsgaSBdLnkgKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnbWVudHMgb2YgZXh0cnVkZSBzcGxpbmUgdG9vXG4gKiAgZGVwdGg6IDxmbG9hdD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXG4gKlxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIChpbmNsdWRpbmcgYmV2ZWxPZmZzZXQpIGlzIGJldmVsXG4gKiAgYmV2ZWxPZmZzZXQ6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGRvZXMgYmV2ZWwgc3RhcnRcbiAqICBiZXZlbFNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIGJldmVsIGxheWVyc1xuICpcbiAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlPiAvLyBjdXJ2ZSB0byBleHRydWRlIHNoYXBlIGFsb25nXG4gKlxuICogIFVWR2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG4gKlxuICogfVxuICovXG5cblxuY2xhc3MgRXh0cnVkZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCBzaGFwZXMgPSBuZXcgU2hhcGUoIFsgbmV3IFZlY3RvcjIoIDAuNSwgMC41ICksIG5ldyBWZWN0b3IyKCAtIDAuNSwgMC41ICksIG5ldyBWZWN0b3IyKCAtIDAuNSwgLSAwLjUgKSwgbmV3IFZlY3RvcjIoIDAuNSwgLSAwLjUgKSBdICksIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHNoYXBlczogc2hhcGVzLFxuXHRcdFx0b3B0aW9uczogb3B0aW9uc1xuXHRcdH07XG5cblx0XHRzaGFwZXMgPSBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCB2ZXJ0aWNlc0FycmF5ID0gW107XG5cdFx0Y29uc3QgdXZBcnJheSA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzWyBpIF07XG5cdFx0XHRhZGRTaGFwZSggc2hhcGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzQXJyYXksIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZBcnJheSwgMiApICk7XG5cblx0XHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0XHQvLyBmdW5jdGlvbnNcblxuXHRcdGZ1bmN0aW9uIGFkZFNoYXBlKCBzaGFwZSApIHtcblxuXHRcdFx0Y29uc3QgcGxhY2Vob2xkZXIgPSBbXTtcblxuXHRcdFx0Ly8gb3B0aW9uc1xuXG5cdFx0XHRjb25zdCBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblx0XHRcdGNvbnN0IHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XG5cdFx0XHRjb25zdCBkZXB0aCA9IG9wdGlvbnMuZGVwdGggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGggOiAxO1xuXG5cdFx0XHRsZXQgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTtcblx0XHRcdGxldCBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiAwLjI7XG5cdFx0XHRsZXQgYmV2ZWxTaXplID0gb3B0aW9ucy5iZXZlbFNpemUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTaXplIDogYmV2ZWxUaGlja25lc3MgLSAwLjE7XG5cdFx0XHRsZXQgYmV2ZWxPZmZzZXQgPSBvcHRpb25zLmJldmVsT2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsT2Zmc2V0IDogMDtcblx0XHRcdGxldCBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xuXG5cdFx0XHRjb25zdCBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XG5cblx0XHRcdGNvbnN0IHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IFdvcmxkVVZHZW5lcmF0b3I7XG5cblx0XHRcdC8vXG5cblx0XHRcdGxldCBleHRydWRlUHRzLCBleHRydWRlQnlQYXRoID0gZmFsc2U7XG5cdFx0XHRsZXQgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xuXG5cdFx0XHRpZiAoIGV4dHJ1ZGVQYXRoICkge1xuXG5cdFx0XHRcdGV4dHJ1ZGVQdHMgPSBleHRydWRlUGF0aC5nZXRTcGFjZWRQb2ludHMoIHN0ZXBzICk7XG5cblx0XHRcdFx0ZXh0cnVkZUJ5UGF0aCA9IHRydWU7XG5cdFx0XHRcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cblxuXHRcdFx0XHQvLyBTRVRVUCBUTkIgdmFyaWFibGVzXG5cblx0XHRcdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cblxuXHRcdFx0XHRzcGxpbmVUdWJlID0gZXh0cnVkZVBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyggc3RlcHMsIGZhbHNlICk7XG5cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XG5cblx0XHRcdFx0Ymlub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRwb3NpdGlvbjIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxuXG5cdFx0XHRpZiAoICEgYmV2ZWxFbmFibGVkICkge1xuXG5cdFx0XHRcdGJldmVsU2VnbWVudHMgPSAwO1xuXHRcdFx0XHRiZXZlbFRoaWNrbmVzcyA9IDA7XG5cdFx0XHRcdGJldmVsU2l6ZSA9IDA7XG5cdFx0XHRcdGJldmVsT2Zmc2V0ID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBWYXJpYWJsZXMgaW5pdGlhbGl6YXRpb25cblxuXHRcdFx0Y29uc3Qgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cblx0XHRcdGxldCB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xuXHRcdFx0Y29uc3QgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcblxuXHRcdFx0Y29uc3QgcmV2ZXJzZSA9ICEgU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcblxuXHRcdFx0aWYgKCByZXZlcnNlICkge1xuXG5cdFx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG5cdFx0XHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXG5cblx0XHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xuXG5cdFx0XHRcdFx0XHRob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cblx0XHRcdGNvbnN0IGZhY2VzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcblxuXHRcdFx0LyogVmVydGljZXMgKi9cblxuXHRcdFx0Y29uc3QgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxuXG5cdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0ZnVuY3Rpb24gc2NhbGVQdDIoIHB0LCB2ZWMsIHNpemUgKSB7XG5cblx0XHRcdFx0aWYgKCAhIHZlYyApIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdCcgKTtcblxuXHRcdFx0XHRyZXR1cm4gcHQuY2xvbmUoKS5hZGRTY2FsZWRWZWN0b3IoIHZlYywgc2l6ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsIGZsZW4gPSBmYWNlcy5sZW5ndGg7XG5cblxuXHRcdFx0Ly8gRmluZCBkaXJlY3Rpb25zIGZvciBwb2ludCBtb3ZlbWVudFxuXG5cblx0XHRcdGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcblxuXHRcdFx0XHQvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXG5cdFx0XHRcdC8vICAgc2hpZnRlZCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcblx0XHRcdFx0Ly8gaWYgd2Ugd2FsayBhbG9uZyBjb250b3VyIGNsb2Nrd2lzZSwgdGhpcyBuZXcgY29udG91ciBpcyBvdXRzaWRlIHRoZSBvbGQgb25lXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXG5cdFx0XHRcdC8vICBhZGphY2VudCBlZGdlcyBvZiBpblB0IGF0IGEgZGlzdGFuY2Ugb2YgMSB1bml0IG9uIHRoZSBsZWZ0IHNpZGUuXG5cblx0XHRcdFx0bGV0IHZfdHJhbnNfeCwgdl90cmFuc195LCBzaHJpbmtfYnk7IC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcblxuXHRcdFx0XHQvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXG5cdFx0XHRcdC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXG5cblx0XHRcdFx0Y29uc3Qgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCxcblx0XHRcdFx0XHR2X3ByZXZfeSA9IGluUHQueSAtIGluUHJldi55O1xuXHRcdFx0XHRjb25zdCB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LFxuXHRcdFx0XHRcdHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XG5cblx0XHRcdFx0Y29uc3Qgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGZvciBjb2xsaW5lYXIgZWRnZXNcblx0XHRcdFx0Y29uc3QgY29sbGluZWFyMCA9ICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBjb2xsaW5lYXIwICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdC8vIG5vdCBjb2xsaW5lYXJcblxuXHRcdFx0XHRcdC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xuXG5cdFx0XHRcdFx0Y29uc3Qgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG5cdFx0XHRcdFx0Y29uc3Qgdl9uZXh0X2xlbiA9IE1hdGguc3FydCggdl9uZXh0X3ggKiB2X25leHRfeCArIHZfbmV4dF95ICogdl9uZXh0X3kgKTtcblxuXHRcdFx0XHRcdC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcblxuXHRcdFx0XHRcdGNvbnN0IHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XG5cdFx0XHRcdFx0Y29uc3QgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcblxuXHRcdFx0XHRcdGNvbnN0IHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XG5cdFx0XHRcdFx0Y29uc3QgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcblxuXHRcdFx0XHRcdC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cblx0XHRcdFx0XHRjb25zdCBzZiA9ICggKCBwdE5leHRTaGlmdF94IC0gcHRQcmV2U2hpZnRfeCApICogdl9uZXh0X3kgLVxuXHRcdFx0XHRcdFx0XHQoIHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95ICkgKiB2X25leHRfeCApIC9cblx0XHRcdFx0XHRcdCggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcblxuXHRcdFx0XHRcdC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cblx0XHRcdFx0XHR2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XG5cdFx0XHRcdFx0dl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qgbm9ybWFsaXplISwgb3RoZXJ3aXNlIHNoYXJwIGNvcm5lcnMgYmVjb21lIHVnbHlcblx0XHRcdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG5cdFx0XHRcdFx0Y29uc3Qgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195ICk7XG5cdFx0XHRcdFx0aWYgKCB2X3RyYW5zX2xlbnNxIDw9IDIgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMiggdl90cmFuc194LCB2X3RyYW5zX3kgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcblxuXHRcdFx0XHRcdGxldCBkaXJlY3Rpb25fZXEgPSBmYWxzZTsgLy8gYXNzdW1lczogb3Bwb3NpdGVcblxuXHRcdFx0XHRcdGlmICggdl9wcmV2X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCB2X25leHRfeCA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggdl9wcmV2X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdl9uZXh0X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBNYXRoLnNpZ24oIHZfcHJldl95ICkgPT09IE1hdGguc2lnbiggdl9uZXh0X3kgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGRpcmVjdGlvbl9lcSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzZXF1ZW5jZVwiKTtcblx0XHRcdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XG5cdFx0XHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeDtcblx0XHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xuXHRcdFx0XHRcdFx0dl90cmFuc194ID0gdl9wcmV2X3g7XG5cdFx0XHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeTtcblx0XHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRjb25zdCBjb250b3VyTW92ZW1lbnRzID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xuXHRcdFx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnaSxqLGsnLCBpLCBqICwgaylcblxuXHRcdFx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGhvbGVzTW92ZW1lbnRzID0gW107XG5cdFx0XHRsZXQgb25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xuXG5cdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuXHRcdFx0XHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcblx0XHRcdFx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHRcdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0XHRcdFx0b25lSG9sZU1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGFob2xlWyBpIF0sIGFob2xlWyBqIF0sIGFob2xlWyBrIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xuXHRcdFx0XHR2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdCggb25lSG9sZU1vdmVtZW50cyApO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXG5cblx0XHRcdGZvciAoIGxldCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG5cblx0XHRcdFx0Ly9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XG5cblx0XHRcdFx0Y29uc3QgdCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuXHRcdFx0XHRjb25zdCB6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XG5cdFx0XHRcdGNvbnN0IGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApICsgYmV2ZWxPZmZzZXQ7XG5cblx0XHRcdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgLSB6ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGV4cGFuZCBob2xlc1xuXG5cdFx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbIGggXTtcblx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAtIHogKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKyBiZXZlbE9mZnNldDtcblxuXHRcdFx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcblxuXHRcdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcblx0XHRcdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG5cdFx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIDAgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xuXG5cdFx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxuXHRcdFx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGRlcHRoIC8gc3RlcHMgKiBzICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cblx0XHRcdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcblx0XHRcdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XG5cblx0XHRcdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuXHRcdFx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cblx0XHRcdC8vIEFkZCBiZXZlbCBzZWdtZW50cyBwbGFuZXNcblxuXHRcdFx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXHRcdFx0Zm9yICggbGV0IGIgPSBiZXZlbFNlZ21lbnRzIC0gMTsgYiA+PSAwOyBiIC0tICkge1xuXG5cdFx0XHRcdGNvbnN0IHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHRcdFx0Y29uc3QgeiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoIHQgKiBNYXRoLlBJIC8gMiApO1xuXHRcdFx0XHRjb25zdCBicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKSArIGJldmVsT2Zmc2V0O1xuXG5cdFx0XHRcdC8vIGNvbnRyYWN0IHNoYXBlXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBkZXB0aCArIHogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZXhwYW5kIGhvbGVzXG5cblx0XHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGRlcHRoICsgeiApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueCArIHogKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvKiBGYWNlcyAqL1xuXG5cdFx0XHQvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xuXG5cdFx0XHRidWlsZExpZEZhY2VzKCk7XG5cblx0XHRcdC8vIFNpZGVzIGZhY2VzXG5cblx0XHRcdGJ1aWxkU2lkZUZhY2VzKCk7XG5cblxuXHRcdFx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xuXG5cdFx0XHRmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXG5cdFx0XHRcdGlmICggYmV2ZWxFbmFibGVkICkge1xuXG5cdFx0XHRcdFx0bGV0IGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXG5cdFx0XHRcdFx0bGV0IG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuXHRcdFx0XHRcdC8vIEJvdHRvbSBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0XHRmMyggZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xuXHRcdFx0XHRcdG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuXHRcdFx0XHRcdC8vIFRvcCBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0XHRmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBCb3R0b20gZmFjZXNcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFRvcCBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0XHRmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5hZGRHcm91cCggc3RhcnQsIHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMyAtIHN0YXJ0LCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XG5cblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cdFx0XHRcdGxldCBsYXllcm9mZnNldCA9IDA7XG5cdFx0XHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcblx0XHRcdFx0bGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0XHRcdHNpZGV3YWxscyggYWhvbGUsIGxheWVyb2Zmc2V0ICk7XG5cblx0XHRcdFx0XHQvLywgdHJ1ZVxuXHRcdFx0XHRcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRzY29wZS5hZGRHcm91cCggc3RhcnQsIHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMyAtIHN0YXJ0LCAxICk7XG5cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xuXG5cdFx0XHRcdGxldCBpID0gY29udG91ci5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCAtLSBpID49IDAgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBqID0gaTtcblx0XHRcdFx0XHRsZXQgayA9IGkgLSAxO1xuXHRcdFx0XHRcdGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgcyA9IDAsIHNsID0gKCBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyICk7IHMgPCBzbDsgcyArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgc2xlbjEgPSB2bGVuICogcztcblx0XHRcdFx0XHRcdGNvbnN0IHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxuXHRcdFx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG5cdFx0XHRcdFx0XHRcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcblx0XHRcdFx0XHRcdFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xuXG5cdFx0XHRcdFx0XHRmNCggYSwgYiwgYywgZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG5cdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goIHggKTtcblx0XHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeSApO1xuXHRcdFx0XHRwbGFjZWhvbGRlci5wdXNoKCB6ICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGEgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBiICk7XG5cdFx0XHRcdGFkZFZlcnRleCggYyApO1xuXG5cdFx0XHRcdGNvbnN0IG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0Y29uc3QgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIHZlcnRpY2VzQXJyYXksIG5leHRJbmRleCAtIDMsIG5leHRJbmRleCAtIDIsIG5leHRJbmRleCAtIDEgKTtcblxuXHRcdFx0XHRhZGRVViggdXZzWyAwIF0gKTtcblx0XHRcdFx0YWRkVVYoIHV2c1sgMSBdICk7XG5cdFx0XHRcdGFkZFVWKCB1dnNbIDIgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkICkge1xuXG5cdFx0XHRcdGFkZFZlcnRleCggYSApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBkICk7XG5cblx0XHRcdFx0YWRkVmVydGV4KCBiICk7XG5cdFx0XHRcdGFkZFZlcnRleCggYyApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGQgKTtcblxuXG5cdFx0XHRcdGNvbnN0IG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0Y29uc3QgdXZzID0gdXZnZW4uZ2VuZXJhdGVTaWRlV2FsbFVWKCBzY29wZSwgdmVydGljZXNBcnJheSwgbmV4dEluZGV4IC0gNiwgbmV4dEluZGV4IC0gMywgbmV4dEluZGV4IC0gMiwgbmV4dEluZGV4IC0gMSApO1xuXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xuXHRcdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcblx0XHRcdFx0YWRkVVYoIHV2c1sgMyBdICk7XG5cblx0XHRcdFx0YWRkVVYoIHV2c1sgMSBdICk7XG5cdFx0XHRcdGFkZFVWKCB1dnNbIDIgXSApO1xuXHRcdFx0XHRhZGRVViggdXZzWyAzIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhZGRWZXJ0ZXgoIGluZGV4ICkge1xuXG5cdFx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDAgXSApO1xuXHRcdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAxIF0gKTtcblx0XHRcdFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMiBdICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRmdW5jdGlvbiBhZGRVViggdmVjdG9yMiApIHtcblxuXHRcdFx0XHR1dkFycmF5LnB1c2goIHZlY3RvcjIueCApO1xuXHRcdFx0XHR1dkFycmF5LnB1c2goIHZlY3RvcjIueSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0Y29uc3Qgc2hhcGVzID0gdGhpcy5wYXJhbWV0ZXJzLnNoYXBlcztcblx0XHRjb25zdCBvcHRpb25zID0gdGhpcy5wYXJhbWV0ZXJzLm9wdGlvbnM7XG5cblx0XHRyZXR1cm4gdG9KU09OJDEoIHNoYXBlcywgb3B0aW9ucywgZGF0YSApO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEsIHNoYXBlcyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5U2hhcGVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gZGF0YS5zaGFwZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzWyBkYXRhLnNoYXBlc1sgaiBdIF07XG5cblx0XHRcdGdlb21ldHJ5U2hhcGVzLnB1c2goIHNoYXBlICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBleHRydWRlUGF0aCA9IGRhdGEub3B0aW9ucy5leHRydWRlUGF0aDtcblxuXHRcdGlmICggZXh0cnVkZVBhdGggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoID0gbmV3IEN1cnZlc1sgZXh0cnVkZVBhdGgudHlwZSBdKCkuZnJvbUpTT04oIGV4dHJ1ZGVQYXRoICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEV4dHJ1ZGVHZW9tZXRyeSggZ2VvbWV0cnlTaGFwZXMsIGRhdGEub3B0aW9ucyApO1xuXG5cdH1cblxufVxuXG5jb25zdCBXb3JsZFVWR2VuZXJhdG9yID0ge1xuXG5cdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xuXG5cdFx0Y29uc3QgYV94ID0gdmVydGljZXNbIGluZGV4QSAqIDMgXTtcblx0XHRjb25zdCBhX3kgPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDEgXTtcblx0XHRjb25zdCBiX3ggPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyBdO1xuXHRcdGNvbnN0IGJfeSA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMSBdO1xuXHRcdGNvbnN0IGNfeCA9IHZlcnRpY2VzWyBpbmRleEMgKiAzIF07XG5cdFx0Y29uc3QgY195ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAxIF07XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0bmV3IFZlY3RvcjIoIGFfeCwgYV95ICksXG5cdFx0XHRuZXcgVmVjdG9yMiggYl94LCBiX3kgKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBjX3gsIGNfeSApXG5cdFx0XTtcblxuXHR9LFxuXG5cdGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgdmVydGljZXMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCApIHtcblxuXHRcdGNvbnN0IGFfeCA9IHZlcnRpY2VzWyBpbmRleEEgKiAzIF07XG5cdFx0Y29uc3QgYV95ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAxIF07XG5cdFx0Y29uc3QgYV96ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAyIF07XG5cdFx0Y29uc3QgYl94ID0gdmVydGljZXNbIGluZGV4QiAqIDMgXTtcblx0XHRjb25zdCBiX3kgPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDEgXTtcblx0XHRjb25zdCBiX3ogPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDIgXTtcblx0XHRjb25zdCBjX3ggPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyBdO1xuXHRcdGNvbnN0IGNfeSA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMSBdO1xuXHRcdGNvbnN0IGNfeiA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMiBdO1xuXHRcdGNvbnN0IGRfeCA9IHZlcnRpY2VzWyBpbmRleEQgKiAzIF07XG5cdFx0Y29uc3QgZF95ID0gdmVydGljZXNbIGluZGV4RCAqIDMgKyAxIF07XG5cdFx0Y29uc3QgZF96ID0gdmVydGljZXNbIGluZGV4RCAqIDMgKyAyIF07XG5cblx0XHRpZiAoIE1hdGguYWJzKCBhX3kgLSBiX3kgKSA8IE1hdGguYWJzKCBhX3ggLSBiX3ggKSApIHtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFfeCwgMSAtIGFfeiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYl94LCAxIC0gYl96ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBjX3gsIDEgLSBjX3ogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGRfeCwgMSAtIGRfeiApXG5cdFx0XHRdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFfeSwgMSAtIGFfeiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYl95LCAxIC0gYl96ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBjX3ksIDEgLSBjX3ogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGRfeSwgMSAtIGRfeiApXG5cdFx0XHRdO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuZnVuY3Rpb24gdG9KU09OJDEoIHNoYXBlcywgb3B0aW9ucywgZGF0YSApIHtcblxuXHRkYXRhLnNoYXBlcyA9IFtdO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGkgXTtcblxuXHRcdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGUudXVpZCApO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZXMudXVpZCApO1xuXG5cdH1cblxuXHRkYXRhLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKCB7fSwgb3B0aW9ucyApO1xuXG5cdGlmICggb3B0aW9ucy5leHRydWRlUGF0aCAhPT0gdW5kZWZpbmVkICkgZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aC50b0pTT04oKTtcblxuXHRyZXR1cm4gZGF0YTtcblxufVxuXG5jbGFzcyBJY29zYWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgZGV0YWlsID0gMCApIHtcblxuXHRcdGNvbnN0IHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW1xuXHRcdFx0LSAxLCB0LCAwLCBcdDEsIHQsIDAsIFx0LSAxLCAtIHQsIDAsIFx0MSwgLSB0LCAwLFxuXHRcdFx0MCwgLSAxLCB0LCBcdDAsIDEsIHQsXHQwLCAtIDEsIC0gdCwgXHQwLCAxLCAtIHQsXG5cdFx0XHR0LCAwLCAtIDEsIFx0dCwgMCwgMSwgXHQtIHQsIDAsIC0gMSwgXHQtIHQsIDAsIDFcblx0XHRdO1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtcblx0XHRcdDAsIDExLCA1LCBcdDAsIDUsIDEsIFx0MCwgMSwgNywgXHQwLCA3LCAxMCwgXHQwLCAxMCwgMTEsXG5cdFx0XHQxLCA1LCA5LCBcdDUsIDExLCA0LFx0MTEsIDEwLCAyLFx0MTAsIDcsIDYsXHQ3LCAxLCA4LFxuXHRcdFx0MywgOSwgNCwgXHQzLCA0LCAyLFx0MywgMiwgNixcdDMsIDYsIDgsXHQzLCA4LCA5LFxuXHRcdFx0NCwgOSwgNSwgXHQyLCA0LCAxMSxcdDYsIDIsIDEwLFx0OCwgNiwgNyxcdDksIDgsIDFcblx0XHRdO1xuXG5cdFx0c3VwZXIoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgSWNvc2FoZWRyb25HZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIE9jdGFoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcblx0XHRcdDEsIDAsIDAsIFx0LSAxLCAwLCAwLFx0MCwgMSwgMCxcblx0XHRcdDAsIC0gMSwgMCwgXHQwLCAwLCAxLFx0MCwgMCwgLSAxXG5cdFx0XTtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXG5cdFx0XHQwLCAyLCA0LFx0MCwgNCwgMyxcdDAsIDMsIDUsXG5cdFx0XHQwLCA1LCAyLFx0MSwgMiwgNSxcdDEsIDUsIDMsXG5cdFx0XHQxLCAzLCA0LFx0MSwgNCwgMlxuXHRcdF07XG5cblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IE9jdGFoZWRyb25HZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFJpbmdHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggaW5uZXJSYWRpdXMgPSAwLjUsIG91dGVyUmFkaXVzID0gMSwgdGhldGFTZWdtZW50cyA9IDMyLCBwaGlTZWdtZW50cyA9IDEsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdSaW5nR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuXHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuXHRcdFx0dGhldGFTZWdtZW50czogdGhldGFTZWdtZW50cyxcblx0XHRcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdFx0dGhldGFTZWdtZW50cyA9IE1hdGgubWF4KCAzLCB0aGV0YVNlZ21lbnRzICk7XG5cdFx0cGhpU2VnbWVudHMgPSBNYXRoLm1heCggMSwgcGhpU2VnbWVudHMgKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIHNvbWUgaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IHJhZGl1cyA9IGlubmVyUmFkaXVzO1xuXHRcdGNvbnN0IHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSBwaGlTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly8gdmFsdWVzIGFyZSBnZW5lcmF0ZSBmcm9tIHRoZSBpbnNpZGUgb2YgdGhlIHJpbmcgdG8gdGhlIG91dHNpZGVcblxuXHRcdFx0XHRjb25zdCBzZWdtZW50ID0gdGhldGFTdGFydCArIGkgLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXYueCA9ICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDI7XG5cdFx0XHRcdHV2LnkgPSAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5jcmVhc2UgdGhlIHJhZGl1cyBmb3IgbmV4dCByb3cgb2YgdmVydGljZXNcblxuXHRcdFx0cmFkaXVzICs9IHJhZGl1c1N0ZXA7XG5cblx0XHR9XG5cblx0XHQvLyBpbmRpY2VzXG5cblx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBwaGlTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Y29uc3QgdGhldGFTZWdtZW50TGV2ZWwgPSBqICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGV0YVNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNlZ21lbnQgPSBpICsgdGhldGFTZWdtZW50TGV2ZWw7XG5cblx0XHRcdFx0Y29uc3QgYSA9IHNlZ21lbnQ7XG5cdFx0XHRcdGNvbnN0IGIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDE7XG5cdFx0XHRcdGNvbnN0IGMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG5cdFx0XHRcdGNvbnN0IGQgPSBzZWdtZW50ICsgMTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBSaW5nR2VvbWV0cnkoIGRhdGEuaW5uZXJSYWRpdXMsIGRhdGEub3V0ZXJSYWRpdXMsIGRhdGEudGhldGFTZWdtZW50cywgZGF0YS5waGlTZWdtZW50cywgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFNoYXBlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHNoYXBlcyA9IG5ldyBTaGFwZSggWyBuZXcgVmVjdG9yMiggMCwgMC41ICksIG5ldyBWZWN0b3IyKCAtIDAuNSwgLSAwLjUgKSwgbmV3IFZlY3RvcjIoIDAuNSwgLSAwLjUgKSBdICksIGN1cnZlU2VnbWVudHMgPSAxMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRzaGFwZXM6IHNoYXBlcyxcblx0XHRcdGN1cnZlU2VnbWVudHM6IGN1cnZlU2VnbWVudHNcblx0XHR9O1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IGdyb3VwU3RhcnQgPSAwO1xuXHRcdGxldCBncm91cENvdW50ID0gMDtcblxuXHRcdC8vIGFsbG93IHNpbmdsZSBhbmQgYXJyYXkgdmFsdWVzIGZvciBcInNoYXBlc1wiIHBhcmFtZXRlclxuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGFkZFNoYXBlKCBzaGFwZXMgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNoYXBlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0YWRkU2hhcGUoIHNoYXBlc1sgaSBdICk7XG5cblx0XHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgaSApOyAvLyBlbmFibGVzIE11bHRpTWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblx0XHRcdFx0Z3JvdXBDb3VudCA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb25zXG5cblx0XHRmdW5jdGlvbiBhZGRTaGFwZSggc2hhcGUgKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMztcblx0XHRcdGNvbnN0IHBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHRcdFx0bGV0IHNoYXBlVmVydGljZXMgPSBwb2ludHMuc2hhcGU7XG5cdFx0XHRjb25zdCBzaGFwZUhvbGVzID0gcG9pbnRzLmhvbGVzO1xuXG5cdFx0XHQvLyBjaGVjayBkaXJlY3Rpb24gb2YgdmVydGljZXNcblxuXHRcdFx0aWYgKCBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBzaGFwZVZlcnRpY2VzICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLnJldmVyc2UoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZUhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlID0gc2hhcGVIb2xlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggc2hhcGVIb2xlICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRzaGFwZUhvbGVzWyBpIF0gPSBzaGFwZUhvbGUucmV2ZXJzZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggc2hhcGVWZXJ0aWNlcywgc2hhcGVIb2xlcyApO1xuXG5cdFx0XHQvLyBqb2luIHZlcnRpY2VzIG9mIGlubmVyIGFuZCBvdXRlciBwYXRocyB0byBhIHNpbmdsZSBhcnJheVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZUhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlID0gc2hhcGVIb2xlc1sgaSBdO1xuXHRcdFx0XHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5jb25jYXQoIHNoYXBlSG9sZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHZlcnRpY2VzLCBub3JtYWxzLCB1dnNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVWZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHZlcnRleCA9IHNoYXBlVmVydGljZXNbIGkgXTtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIDAgKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cdFx0XHRcdHV2cy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnkgKTsgLy8gd29ybGQgdXZzXG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBmYWNlWyAwIF0gKyBpbmRleE9mZnNldDtcblx0XHRcdFx0Y29uc3QgYiA9IGZhY2VbIDEgXSArIGluZGV4T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCBjID0gZmFjZVsgMiBdICsgaW5kZXhPZmZzZXQ7XG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBjICk7XG5cdFx0XHRcdGdyb3VwQ291bnQgKz0gMztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRyZXR1cm4gdG9KU09OKCBzaGFwZXMsIGRhdGEgKTtcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhLCBzaGFwZXMgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeVNoYXBlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IGRhdGEuc2hhcGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgZGF0YS5zaGFwZXNbIGogXSBdO1xuXG5cdFx0XHRnZW9tZXRyeVNoYXBlcy5wdXNoKCBzaGFwZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBTaGFwZUdlb21ldHJ5KCBnZW9tZXRyeVNoYXBlcywgZGF0YS5jdXJ2ZVNlZ21lbnRzICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHRvSlNPTiggc2hhcGVzLCBkYXRhICkge1xuXG5cdGRhdGEuc2hhcGVzID0gW107XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZS51dWlkICk7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGRhdGEuc2hhcGVzLnB1c2goIHNoYXBlcy51dWlkICk7XG5cblx0fVxuXG5cdHJldHVybiBkYXRhO1xuXG59XG5cbmNsYXNzIFNwaGVyZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCB3aWR0aFNlZ21lbnRzID0gMzIsIGhlaWdodFNlZ21lbnRzID0gMTYsIHBoaVN0YXJ0ID0gMCwgcGhpTGVuZ3RoID0gTWF0aC5QSSAqIDIsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcblx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHR3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSApO1xuXHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgKTtcblxuXHRcdGNvbnN0IHRoZXRhRW5kID0gTWF0aC5taW4oIHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aCwgTWF0aC5QSSApO1xuXG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRjb25zdCBncmlkID0gW107XG5cblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8PSBoZWlnaHRTZWdtZW50czsgaXkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHZlcnRpY2VzUm93ID0gW107XG5cblx0XHRcdGNvbnN0IHYgPSBpeSAvIGhlaWdodFNlZ21lbnRzO1xuXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIHRoZSBwb2xlc1xuXG5cdFx0XHRsZXQgdU9mZnNldCA9IDA7XG5cblx0XHRcdGlmICggaXkgPT09IDAgJiYgdGhldGFTdGFydCA9PT0gMCApIHtcblxuXHRcdFx0XHR1T2Zmc2V0ID0gMC41IC8gd2lkdGhTZWdtZW50cztcblxuXHRcdFx0fSBlbHNlIGlmICggaXkgPT09IGhlaWdodFNlZ21lbnRzICYmIHRoZXRhRW5kID09PSBNYXRoLlBJICkge1xuXG5cdFx0XHRcdHVPZmZzZXQgPSAtIDAuNSAvIHdpZHRoU2VnbWVudHM7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPD0gd2lkdGhTZWdtZW50czsgaXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdSA9IGl4IC8gd2lkdGhTZWdtZW50cztcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblx0XHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbC5jb3B5KCB2ZXJ0ZXggKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1dnMucHVzaCggdSArIHVPZmZzZXQsIDEgLSB2ICk7XG5cblx0XHRcdFx0dmVydGljZXNSb3cucHVzaCggaW5kZXggKysgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRncmlkLnB1c2goIHZlcnRpY2VzUm93ICk7XG5cblx0XHR9XG5cblx0XHQvLyBpbmRpY2VzXG5cblx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGhlaWdodFNlZ21lbnRzOyBpeSArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCB3aWR0aFNlZ21lbnRzOyBpeCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhID0gZ3JpZFsgaXkgXVsgaXggKyAxIF07XG5cdFx0XHRcdGNvbnN0IGIgPSBncmlkWyBpeSBdWyBpeCBdO1xuXHRcdFx0XHRjb25zdCBjID0gZ3JpZFsgaXkgKyAxIF1bIGl4IF07XG5cdFx0XHRcdGNvbnN0IGQgPSBncmlkWyBpeSArIDEgXVsgaXggKyAxIF07XG5cblx0XHRcdFx0aWYgKCBpeSAhPT0gMCB8fCB0aGV0YVN0YXJ0ID4gMCApIGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpZiAoIGl5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgfHwgdGhldGFFbmQgPCBNYXRoLlBJICkgaW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgU3BoZXJlR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEucGhpU3RhcnQsIGRhdGEucGhpTGVuZ3RoLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVGV0cmFoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcblx0XHRcdDEsIDEsIDEsIFx0LSAxLCAtIDEsIDEsIFx0LSAxLCAxLCAtIDEsIFx0MSwgLSAxLCAtIDFcblx0XHRdO1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtcblx0XHRcdDIsIDEsIDAsIFx0MCwgMywgMixcdDEsIDMsIDAsXHQyLCAzLCAxXG5cdFx0XTtcblxuXHRcdHN1cGVyKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRldHJhaGVkcm9uR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBUb3J1c0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCB0dWJlID0gMC40LCByYWRpYWxTZWdtZW50cyA9IDEyLCB0dWJ1bGFyU2VnbWVudHMgPSA0OCwgYXJjID0gTWF0aC5QSSAqIDIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1RvcnVzR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHR0dWJlOiB0dWJlLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRhcmM6IGFyY1xuXHRcdH07XG5cblx0XHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0dHVidWxhclNlZ21lbnRzID0gTWF0aC5mbG9vciggdHVidWxhclNlZ21lbnRzICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRjb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIGFyYztcblx0XHRcdFx0Y29uc3QgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRleC54ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcblx0XHRcdFx0dmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRjZW50ZXIueCA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICk7XG5cdFx0XHRcdGNlbnRlci55ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKTtcblx0XHRcdFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgY2VudGVyICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1dnMucHVzaCggaSAvIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdFx0XHR1dnMucHVzaCggaiAvIHJhZGlhbFNlZ21lbnRzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRcdGZvciAoIGxldCBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdFx0Y29uc3QgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xuXHRcdFx0XHRjb25zdCBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcblx0XHRcdFx0Y29uc3QgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblx0XHRcdFx0Y29uc3QgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XG5cblx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgVG9ydXNHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEudHViZSwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS50dWJ1bGFyU2VnbWVudHMsIGRhdGEuYXJjICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFRvcnVzS25vdEdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCB0dWJlID0gMC40LCB0dWJ1bGFyU2VnbWVudHMgPSA2NCwgcmFkaWFsU2VnbWVudHMgPSA4LCBwID0gMiwgcSA9IDMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0dHViZTogdHViZSxcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0cDogcCxcblx0XHRcdHE6IHFcblx0XHR9O1xuXG5cdFx0dHVidWxhclNlZ21lbnRzID0gTWF0aC5mbG9vciggdHVidWxhclNlZ21lbnRzICk7XG5cdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Y29uc3QgUDEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IFAyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGNvbnN0IEIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IFQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IE4gPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgKysgaSApIHtcblxuXHRcdFx0Ly8gdGhlIHJhZGlhbiBcInVcIiBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlIG9mIHRoZSBjdXJyZW50IHR1YnVsYXIgc2VnbWVudFxuXG5cdFx0XHRjb25zdCB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIHAgKiBNYXRoLlBJICogMjtcblxuXHRcdFx0Ly8gbm93IHdlIGNhbGN1bGF0ZSB0d28gcG9pbnRzLiBQMSBpcyBvdXIgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmUsIFAyIGlzIGEgbGl0dGxlIGZhcnRoZXIgYWhlYWQuXG5cdFx0XHQvLyB0aGVzZSBwb2ludHMgYXJlIHVzZWQgdG8gY3JlYXRlIGEgc3BlY2lhbCBcImNvb3JkaW5hdGUgc3BhY2VcIiwgd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCB2ZXJ0ZXggcG9zaXRpb25zXG5cblx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSwgcCwgcSwgcmFkaXVzLCBQMSApO1xuXHRcdFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1ICsgMC4wMSwgcCwgcSwgcmFkaXVzLCBQMiApO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgb3J0aG9ub3JtYWwgYmFzaXNcblxuXHRcdFx0VC5zdWJWZWN0b3JzKCBQMiwgUDEgKTtcblx0XHRcdE4uYWRkVmVjdG9ycyggUDIsIFAxICk7XG5cdFx0XHRCLmNyb3NzVmVjdG9ycyggVCwgTiApO1xuXHRcdFx0Ti5jcm9zc1ZlY3RvcnMoIEIsIFQgKTtcblxuXHRcdFx0Ly8gbm9ybWFsaXplIEIsIE4uIFQgY2FuIGJlIGlnbm9yZWQsIHdlIGRvbid0IHVzZSBpdFxuXG5cdFx0XHRCLm5vcm1hbGl6ZSgpO1xuXHRcdFx0Ti5ub3JtYWxpemUoKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyArKyBqICkge1xuXG5cdFx0XHRcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIHZlcnRpY2VzLiB0aGV5IGFyZSBub3RoaW5nIG1vcmUgdGhhbiBhbiBleHRydXNpb24gb2YgdGhlIHRvcnVzIGN1cnZlLlxuXHRcdFx0XHQvLyBiZWNhdXNlIHdlIGV4dHJ1ZGUgYSBzaGFwZSBpbiB0aGUgeHktcGxhbmUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGEgei12YWx1ZS5cblxuXHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0XHRcdGNvbnN0IGN4ID0gLSB0dWJlICogTWF0aC5jb3MoIHYgKTtcblx0XHRcdFx0Y29uc3QgY3kgPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0XHQvLyBub3cgY2FsY3VsYXRlIHRoZSBmaW5hbCB2ZXJ0ZXggcG9zaXRpb24uXG5cdFx0XHRcdC8vIGZpcnN0IHdlIG9yaWVudCB0aGUgZXh0cnVzaW9uIHdpdGggb3VyIGJhc2lzIHZlY3RvcnMsIHRoZW4gd2UgYWRkIGl0IHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZVxuXG5cdFx0XHRcdHZlcnRleC54ID0gUDEueCArICggY3ggKiBOLnggKyBjeSAqIEIueCApO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IFAxLnkgKyAoIGN4ICogTi55ICsgY3kgKiBCLnkgKTtcblx0XHRcdFx0dmVydGV4LnogPSBQMS56ICsgKCBjeCAqIE4ueiArIGN5ICogQi56ICk7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbCAoUDEgaXMgYWx3YXlzIHRoZSBjZW50ZXIvb3JpZ2luIG9mIHRoZSBleHRydXNpb24sIHRodXMgd2UgY2FuIHVzZSBpdCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbClcblxuXHRcdFx0XHRub3JtYWwuc3ViVmVjdG9ycyggdmVydGV4LCBQMSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIGkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcblx0XHRcdFx0dXZzLnB1c2goIGogLyByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblx0XHRmb3IgKCBsZXQgaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gcmFkaWFsU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRcdGNvbnN0IGEgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgKCBpIC0gMSApO1xuXHRcdFx0XHRjb25zdCBiID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyAoIGkgLSAxICk7XG5cdFx0XHRcdGNvbnN0IGMgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArIGk7XG5cdFx0XHRcdGNvbnN0IGQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0XHQvLyB0aGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlXG5cblx0XHRmdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUsIHAsIHEsIHJhZGl1cywgcG9zaXRpb24gKSB7XG5cblx0XHRcdGNvbnN0IGN1ID0gTWF0aC5jb3MoIHUgKTtcblx0XHRcdGNvbnN0IHN1ID0gTWF0aC5zaW4oIHUgKTtcblx0XHRcdGNvbnN0IHF1T3ZlclAgPSBxIC8gcCAqIHU7XG5cdFx0XHRjb25zdCBjcyA9IE1hdGguY29zKCBxdU92ZXJQICk7XG5cblx0XHRcdHBvc2l0aW9uLnggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XG5cdFx0XHRwb3NpdGlvbi55ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIHN1ICogMC41O1xuXHRcdFx0cG9zaXRpb24ueiA9IHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUb3J1c0tub3RHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEudHViZSwgZGF0YS50dWJ1bGFyU2VnbWVudHMsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEucCwgZGF0YS5xICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFR1YmVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcGF0aCA9IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMoIG5ldyBWZWN0b3IzKCAtIDEsIC0gMSwgMCApLCBuZXcgVmVjdG9yMyggLSAxLCAxLCAwICksIG5ldyBWZWN0b3IzKCAxLCAxLCAwICkgKSwgdHVidWxhclNlZ21lbnRzID0gNjQsIHJhZGl1cyA9IDEsIHJhZGlhbFNlZ21lbnRzID0gOCwgY2xvc2VkID0gZmFsc2UgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1R1YmVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRwYXRoOiBwYXRoLFxuXHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdGNsb3NlZDogY2xvc2VkXG5cdFx0fTtcblxuXHRcdGNvbnN0IGZyYW1lcyA9IHBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyggdHVidWxhclNlZ21lbnRzLCBjbG9zZWQgKTtcblxuXHRcdC8vIGV4cG9zZSBpbnRlcm5hbHNcblxuXHRcdHRoaXMudGFuZ2VudHMgPSBmcmFtZXMudGFuZ2VudHM7XG5cdFx0dGhpcy5ub3JtYWxzID0gZnJhbWVzLm5vcm1hbHM7XG5cdFx0dGhpcy5iaW5vcm1hbHMgPSBmcmFtZXMuYmlub3JtYWxzO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRsZXQgUCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBidWZmZXJcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblxuXHRcdC8vIGNyZWF0ZSBidWZmZXIgZGF0YVxuXG5cdFx0Z2VuZXJhdGVCdWZmZXJEYXRhKCk7XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdC8vIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVCdWZmZXJEYXRhKCkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Z2VuZXJhdGVTZWdtZW50KCBpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGlzIG5vdCBjbG9zZWQsIGdlbmVyYXRlIHRoZSBsYXN0IHJvdyBvZiB2ZXJ0aWNlcyBhbmQgbm9ybWFsc1xuXHRcdFx0Ly8gYXQgdGhlIHJlZ3VsYXIgcG9zaXRpb24gb24gdGhlIGdpdmVuIHBhdGhcblx0XHRcdC8vXG5cdFx0XHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgY2xvc2VkLCBkdXBsaWNhdGUgdGhlIGZpcnN0IHJvdyBvZiB2ZXJ0aWNlcyBhbmQgbm9ybWFscyAodXZzIHdpbGwgZGlmZmVyKVxuXG5cdFx0XHRnZW5lcmF0ZVNlZ21lbnQoICggY2xvc2VkID09PSBmYWxzZSApID8gdHVidWxhclNlZ21lbnRzIDogMCApO1xuXG5cdFx0XHQvLyB1dnMgYXJlIGdlbmVyYXRlZCBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uLlxuXHRcdFx0Ly8gdGhpcyBtYWtlcyBpdCBlYXN5IGNvbXB1dGUgY29ycmVjdCB2YWx1ZXMgZm9yIGNsb3NlZCBnZW9tZXRyaWVzXG5cblx0XHRcdGdlbmVyYXRlVVZzKCk7XG5cblx0XHRcdC8vIGZpbmFsbHkgY3JlYXRlIGZhY2VzXG5cblx0XHRcdGdlbmVyYXRlSW5kaWNlcygpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVTZWdtZW50KCBpICkge1xuXG5cdFx0XHQvLyB3ZSB1c2UgZ2V0UG9pbnRBdCB0byBzYW1wbGUgZXZlbmx5IGRpc3RyaWJ1dGVkIHBvaW50cyBmcm9tIHRoZSBnaXZlbiBwYXRoXG5cblx0XHRcdFAgPSBwYXRoLmdldFBvaW50QXQoIGkgLyB0dWJ1bGFyU2VnbWVudHMsIFAgKTtcblxuXHRcdFx0Ly8gcmV0cmlldmUgY29ycmVzcG9uZGluZyBub3JtYWwgYW5kIGJpbm9ybWFsXG5cblx0XHRcdGNvbnN0IE4gPSBmcmFtZXMubm9ybWFsc1sgaSBdO1xuXHRcdFx0Y29uc3QgQiA9IGZyYW1lcy5iaW5vcm1hbHNbIGkgXTtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgbm9ybWFscyBhbmQgdmVydGljZXMgZm9yIHRoZSBjdXJyZW50IHNlZ21lbnRcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblxuXHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbiggdiApO1xuXHRcdFx0XHRjb25zdCBjb3MgPSAtIE1hdGguY29zKCB2ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFsLnggPSAoIGNvcyAqIE4ueCArIHNpbiAqIEIueCApO1xuXHRcdFx0XHRub3JtYWwueSA9ICggY29zICogTi55ICsgc2luICogQi55ICk7XG5cdFx0XHRcdG5vcm1hbC56ID0gKCBjb3MgKiBOLnogKyBzaW4gKiBCLnogKTtcblx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRleC54ID0gUC54ICsgcmFkaXVzICogbm9ybWFsLng7XG5cdFx0XHRcdHZlcnRleC55ID0gUC55ICsgcmFkaXVzICogbm9ybWFsLnk7XG5cdFx0XHRcdHZlcnRleC56ID0gUC56ICsgcmFkaXVzICogbm9ybWFsLno7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZUluZGljZXMoKSB7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMTsgaiA8PSB0dWJ1bGFyU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyAoIGkgLSAxICk7XG5cdFx0XHRcdFx0Y29uc3QgYiA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgKCBpIC0gMSApO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArIGk7XG5cdFx0XHRcdFx0Y29uc3QgZCA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuXG5cdFx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dXYueCA9IGkgLyB0dWJ1bGFyU2VnbWVudHM7XG5cdFx0XHRcdFx0dXYueSA9IGogLyByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS5wYXRoID0gdGhpcy5wYXJhbWV0ZXJzLnBhdGgudG9KU09OKCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0Ly8gVGhpcyBvbmx5IHdvcmtzIGZvciBidWlsdC1pbiBjdXJ2ZXMgKGUuZy4gQ2F0bXVsbFJvbUN1cnZlMykuXG5cdFx0Ly8gVXNlciBkZWZpbmVkIGN1cnZlcyBvciBpbnN0YW5jZXMgb2YgQ3VydmVQYXRoIHdpbGwgbm90IGJlIGRlc2VyaWFsaXplZC5cblx0XHRyZXR1cm4gbmV3IFR1YmVHZW9tZXRyeShcblx0XHRcdG5ldyBDdXJ2ZXNbIGRhdGEucGF0aC50eXBlIF0oKS5mcm9tSlNPTiggZGF0YS5wYXRoICksXG5cdFx0XHRkYXRhLnR1YnVsYXJTZWdtZW50cyxcblx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcblx0XHRcdGRhdGEuY2xvc2VkXG5cdFx0KTtcblxuXHR9XG5cbn1cblxuY2xhc3MgV2lyZWZyYW1lR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5ID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnV2lyZWZyYW1lR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5XG5cdFx0fTtcblxuXHRcdGlmICggZ2VvbWV0cnkgIT09IG51bGwgKSB7XG5cblx0XHRcdC8vIGJ1ZmZlclxuXG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgZWRnZXMgPSBuZXcgU2V0KCk7XG5cblx0XHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgZW5kID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHQvLyBpbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdGxldCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cblx0XHRcdFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0Z3JvdXBzID0gWyB7IHN0YXJ0OiAwLCBjb3VudDogaW5kaWNlcy5jb3VudCwgbWF0ZXJpYWxJbmRleDogMCB9IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNyZWF0ZSBhIGRhdGEgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgYWxsIGVkZ2VzIHdpdGhvdXQgZHVwbGljYXRlc1xuXG5cdFx0XHRcdGZvciAoIGxldCBvID0gMCwgb2wgPSBncm91cHMubGVuZ3RoOyBvIDwgb2w7ICsrIG8gKSB7XG5cblx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgbyBdO1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBTdGFydCA9IGdyb3VwLnN0YXJ0O1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwQ291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gZ3JvdXBTdGFydCwgbCA9ICggZ3JvdXBTdGFydCArIGdyb3VwQ291bnQgKTsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbmRleDEgPSBpbmRpY2VzLmdldFgoIGkgKyBqICk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MiA9IGluZGljZXMuZ2V0WCggaSArICggaiArIDEgKSAlIDMgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXgxICk7XG5cdFx0XHRcdFx0XHRcdGVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXgyICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpc1VuaXF1ZUVkZ2UoIHN0YXJ0LCBlbmQsIGVkZ2VzICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBzdGFydC54LCBzdGFydC55LCBzdGFydC56ICk7XG5cdFx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggZW5kLngsIGVuZC55LCBlbmQueiApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSAoIHBvc2l0aW9uLmNvdW50IC8gMyApOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHRocmVlIGVkZ2VzIHBlciB0cmlhbmdsZSwgYW4gZWRnZSBpcyByZXByZXNlbnRlZCBhcyAoaW5kZXgxLCBpbmRleDIpXG5cdFx0XHRcdFx0XHQvLyBlLmcuIHRoZSBmaXJzdCB0cmlhbmdsZSBoYXMgdGhlIGZvbGxvd2luZyBlZGdlczogKDAsMSksKDEsMiksKDIsMClcblxuXHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgxID0gMyAqIGkgKyBqO1xuXHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgyID0gMyAqIGkgKyAoICggaiArIDEgKSAlIDMgKTtcblxuXHRcdFx0XHRcdFx0c3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MSApO1xuXHRcdFx0XHRcdFx0ZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDIgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc1VuaXF1ZUVkZ2UoIHN0YXJ0LCBlbmQsIGVkZ2VzICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggc3RhcnQueCwgc3RhcnQueSwgc3RhcnQueiApO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBlbmQueCwgZW5kLnksIGVuZC56ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gaXNVbmlxdWVFZGdlKCBzdGFydCwgZW5kLCBlZGdlcyApIHtcblxuXHRjb25zdCBoYXNoMSA9IGAke3N0YXJ0Lnh9LCR7c3RhcnQueX0sJHtzdGFydC56fS0ke2VuZC54fSwke2VuZC55fSwke2VuZC56fWA7XG5cdGNvbnN0IGhhc2gyID0gYCR7ZW5kLnh9LCR7ZW5kLnl9LCR7ZW5kLnp9LSR7c3RhcnQueH0sJHtzdGFydC55fSwke3N0YXJ0Lnp9YDsgLy8gY29pbmNpZGVudCBlZGdlXG5cblx0aWYgKCBlZGdlcy5oYXMoIGhhc2gxICkgPT09IHRydWUgfHwgZWRnZXMuaGFzKCBoYXNoMiApID09PSB0cnVlICkge1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRlZGdlcy5hZGQoIGhhc2gxICk7XG5cdFx0ZWRnZXMuYWRkKCBoYXNoMiApO1xuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxufVxuXG52YXIgR2VvbWV0cmllcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRCb3hHZW9tZXRyeTogQm94R2VvbWV0cnksXG5cdENhcHN1bGVHZW9tZXRyeTogQ2Fwc3VsZUdlb21ldHJ5LFxuXHRDaXJjbGVHZW9tZXRyeTogQ2lyY2xlR2VvbWV0cnksXG5cdENvbmVHZW9tZXRyeTogQ29uZUdlb21ldHJ5LFxuXHRDeWxpbmRlckdlb21ldHJ5OiBDeWxpbmRlckdlb21ldHJ5LFxuXHREb2RlY2FoZWRyb25HZW9tZXRyeTogRG9kZWNhaGVkcm9uR2VvbWV0cnksXG5cdEVkZ2VzR2VvbWV0cnk6IEVkZ2VzR2VvbWV0cnksXG5cdEV4dHJ1ZGVHZW9tZXRyeTogRXh0cnVkZUdlb21ldHJ5LFxuXHRJY29zYWhlZHJvbkdlb21ldHJ5OiBJY29zYWhlZHJvbkdlb21ldHJ5LFxuXHRMYXRoZUdlb21ldHJ5OiBMYXRoZUdlb21ldHJ5LFxuXHRPY3RhaGVkcm9uR2VvbWV0cnk6IE9jdGFoZWRyb25HZW9tZXRyeSxcblx0UGxhbmVHZW9tZXRyeTogUGxhbmVHZW9tZXRyeSxcblx0UG9seWhlZHJvbkdlb21ldHJ5OiBQb2x5aGVkcm9uR2VvbWV0cnksXG5cdFJpbmdHZW9tZXRyeTogUmluZ0dlb21ldHJ5LFxuXHRTaGFwZUdlb21ldHJ5OiBTaGFwZUdlb21ldHJ5LFxuXHRTcGhlcmVHZW9tZXRyeTogU3BoZXJlR2VvbWV0cnksXG5cdFRldHJhaGVkcm9uR2VvbWV0cnk6IFRldHJhaGVkcm9uR2VvbWV0cnksXG5cdFRvcnVzR2VvbWV0cnk6IFRvcnVzR2VvbWV0cnksXG5cdFRvcnVzS25vdEdlb21ldHJ5OiBUb3J1c0tub3RHZW9tZXRyeSxcblx0VHViZUdlb21ldHJ5OiBUdWJlR2VvbWV0cnksXG5cdFdpcmVmcmFtZUdlb21ldHJ5OiBXaXJlZnJhbWVHZW9tZXRyeVxufSk7XG5cbmNsYXNzIFNoYWRvd01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNTaGFkb3dNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhZG93TWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBSYXdTaGFkZXJNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCBwYXJhbWV0ZXJzICk7XG5cblx0XHR0aGlzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcblxuXHR9XG5cbn1cblxuY2xhc3MgTWVzaFN0YW5kYXJkTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHsgJ1NUQU5EQVJEJzogJycgfTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoU3RhbmRhcmRNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG5cdFx0dGhpcy5yb3VnaG5lc3MgPSAxLjA7XG5cdFx0dGhpcy5tZXRhbG5lc3MgPSAwLjA7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuXHRcdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnU1RBTkRBUkQnOiAnJyB9O1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLnJvdWdobmVzcyA9IHNvdXJjZS5yb3VnaG5lc3M7XG5cdFx0dGhpcy5tZXRhbG5lc3MgPSBzb3VyY2UubWV0YWxuZXNzO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBzb3VyY2Uucm91Z2huZXNzTWFwO1xuXG5cdFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBzb3VyY2UubWV0YWxuZXNzTWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0XHR0aGlzLmVudk1hcFJvdGF0aW9uLmNvcHkoIHNvdXJjZS5lbnZNYXBSb3RhdGlvbiApO1xuXHRcdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gc291cmNlLmVudk1hcEludGVuc2l0eTtcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgTWVzaFBoeXNpY2FsTWF0ZXJpYWwgZXh0ZW5kcyBNZXNoU3RhbmRhcmRNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01lc2hQaHlzaWNhbE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHtcblxuXHRcdFx0J1NUQU5EQVJEJzogJycsXG5cdFx0XHQnUEhZU0lDQUwnOiAnJ1xuXG5cdFx0fTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoUGh5c2ljYWxNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmFuaXNvdHJvcHlSb3RhdGlvbiA9IDA7XG5cdFx0dGhpcy5hbmlzb3Ryb3B5TWFwID0gbnVsbDtcblxuXHRcdHRoaXMuY2xlYXJjb2F0TWFwID0gbnVsbDtcblx0XHR0aGlzLmNsZWFyY29hdFJvdWdobmVzcyA9IDAuMDtcblx0XHR0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcCA9IG51bGw7XG5cdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5pb3IgPSAxLjU7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdyZWZsZWN0aXZpdHknLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRyZXR1cm4gKCBjbGFtcCggMi41ICogKCB0aGlzLmlvciAtIDEgKSAvICggdGhpcy5pb3IgKyAxICksIDAsIDEgKSApO1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHJlZmxlY3Rpdml0eSApIHtcblxuXHRcdFx0XHR0aGlzLmlvciA9ICggMSArIDAuNCAqIHJlZmxlY3Rpdml0eSApIC8gKCAxIC0gMC40ICogcmVmbGVjdGl2aXR5ICk7XG5cblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLmlyaWRlc2NlbmNlTWFwID0gbnVsbDtcblx0XHR0aGlzLmlyaWRlc2NlbmNlSU9SID0gMS4zO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsgMTAwLCA0MDAgXTtcblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuc2hlZW5Db2xvciA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcblx0XHR0aGlzLnNoZWVuQ29sb3JNYXAgPSBudWxsO1xuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3MgPSAxLjA7XG5cdFx0dGhpcy5zaGVlblJvdWdobmVzc01hcCA9IG51bGw7XG5cblx0XHR0aGlzLnRyYW5zbWlzc2lvbk1hcCA9IG51bGw7XG5cblx0XHR0aGlzLnRoaWNrbmVzcyA9IDA7XG5cdFx0dGhpcy50aGlja25lc3NNYXAgPSBudWxsO1xuXHRcdHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IEluZmluaXR5O1xuXHRcdHRoaXMuYXR0ZW51YXRpb25Db2xvciA9IG5ldyBDb2xvciggMSwgMSwgMSApO1xuXG5cdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwID0gbnVsbDtcblx0XHR0aGlzLnNwZWN1bGFyQ29sb3IgPSBuZXcgQ29sb3IoIDEsIDEsIDEgKTtcblx0XHR0aGlzLnNwZWN1bGFyQ29sb3JNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5fYW5pc290cm9weSA9IDA7XG5cdFx0dGhpcy5fY2xlYXJjb2F0ID0gMDtcblx0XHR0aGlzLl9kaXNwZXJzaW9uID0gMDtcblx0XHR0aGlzLl9pcmlkZXNjZW5jZSA9IDA7XG5cdFx0dGhpcy5fc2hlZW4gPSAwLjA7XG5cdFx0dGhpcy5fdHJhbnNtaXNzaW9uID0gMDtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGdldCBhbmlzb3Ryb3B5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2FuaXNvdHJvcHk7XG5cblx0fVxuXG5cdHNldCBhbmlzb3Ryb3B5KCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5fYW5pc290cm9weSA+IDAgIT09IHZhbHVlID4gMCApIHtcblxuXHRcdFx0dGhpcy52ZXJzaW9uICsrO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fYW5pc290cm9weSA9IHZhbHVlO1xuXG5cdH1cblxuXHRnZXQgY2xlYXJjb2F0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2NsZWFyY29hdDtcblxuXHR9XG5cblx0c2V0IGNsZWFyY29hdCggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2NsZWFyY29hdCA+IDAgIT09IHZhbHVlID4gMCApIHtcblxuXHRcdFx0dGhpcy52ZXJzaW9uICsrO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fY2xlYXJjb2F0ID0gdmFsdWU7XG5cblx0fVxuXG5cdGdldCBpcmlkZXNjZW5jZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9pcmlkZXNjZW5jZTtcblxuXHR9XG5cblx0c2V0IGlyaWRlc2NlbmNlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5faXJpZGVzY2VuY2UgPiAwICE9PSB2YWx1ZSA+IDAgKSB7XG5cblx0XHRcdHRoaXMudmVyc2lvbiArKztcblxuXHRcdH1cblxuXHRcdHRoaXMuX2lyaWRlc2NlbmNlID0gdmFsdWU7XG5cblx0fVxuXG5cdGdldCBkaXNwZXJzaW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2Rpc3BlcnNpb247XG5cblx0fVxuXG5cdHNldCBkaXNwZXJzaW9uKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5fZGlzcGVyc2lvbiA+IDAgIT09IHZhbHVlID4gMCApIHtcblxuXHRcdFx0dGhpcy52ZXJzaW9uICsrO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fZGlzcGVyc2lvbiA9IHZhbHVlO1xuXG5cdH1cblxuXHRnZXQgc2hlZW4oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fc2hlZW47XG5cblx0fVxuXG5cdHNldCBzaGVlbiggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX3NoZWVuID4gMCAhPT0gdmFsdWUgPiAwICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9zaGVlbiA9IHZhbHVlO1xuXG5cdH1cblxuXHRnZXQgdHJhbnNtaXNzaW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zbWlzc2lvbjtcblxuXHR9XG5cblx0c2V0IHRyYW5zbWlzc2lvbiggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX3RyYW5zbWlzc2lvbiA+IDAgIT09IHZhbHVlID4gMCApIHtcblxuXHRcdFx0dGhpcy52ZXJzaW9uICsrO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJhbnNtaXNzaW9uID0gdmFsdWU7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5kZWZpbmVzID0ge1xuXG5cdFx0XHQnU1RBTkRBUkQnOiAnJyxcblx0XHRcdCdQSFlTSUNBTCc6ICcnXG5cblx0XHR9O1xuXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XG5cdFx0dGhpcy5hbmlzb3Ryb3B5Um90YXRpb24gPSBzb3VyY2UuYW5pc290cm9weVJvdGF0aW9uO1xuXHRcdHRoaXMuYW5pc290cm9weU1hcCA9IHNvdXJjZS5hbmlzb3Ryb3B5TWFwO1xuXG5cdFx0dGhpcy5jbGVhcmNvYXQgPSBzb3VyY2UuY2xlYXJjb2F0O1xuXHRcdHRoaXMuY2xlYXJjb2F0TWFwID0gc291cmNlLmNsZWFyY29hdE1hcDtcblx0XHR0aGlzLmNsZWFyY29hdFJvdWdobmVzcyA9IHNvdXJjZS5jbGVhcmNvYXRSb3VnaG5lc3M7XG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSBzb3VyY2UuY2xlYXJjb2F0Um91Z2huZXNzTWFwO1xuXHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwID0gc291cmNlLmNsZWFyY29hdE5vcm1hbE1hcDtcblx0XHR0aGlzLmNsZWFyY29hdE5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5jbGVhcmNvYXROb3JtYWxTY2FsZSApO1xuXG5cdFx0dGhpcy5kaXNwZXJzaW9uID0gc291cmNlLmRpc3BlcnNpb247XG5cdFx0dGhpcy5pb3IgPSBzb3VyY2UuaW9yO1xuXG5cdFx0dGhpcy5pcmlkZXNjZW5jZSA9IHNvdXJjZS5pcmlkZXNjZW5jZTtcblx0XHR0aGlzLmlyaWRlc2NlbmNlTWFwID0gc291cmNlLmlyaWRlc2NlbmNlTWFwO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VJT1IgPSBzb3VyY2UuaXJpZGVzY2VuY2VJT1I7XG5cdFx0dGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0gWyAuLi5zb3VyY2UuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSBdO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPSBzb3VyY2UuaXJpZGVzY2VuY2VUaGlja25lc3NNYXA7XG5cblx0XHR0aGlzLnNoZWVuID0gc291cmNlLnNoZWVuO1xuXHRcdHRoaXMuc2hlZW5Db2xvci5jb3B5KCBzb3VyY2Uuc2hlZW5Db2xvciApO1xuXHRcdHRoaXMuc2hlZW5Db2xvck1hcCA9IHNvdXJjZS5zaGVlbkNvbG9yTWFwO1xuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3MgPSBzb3VyY2Uuc2hlZW5Sb3VnaG5lc3M7XG5cdFx0dGhpcy5zaGVlblJvdWdobmVzc01hcCA9IHNvdXJjZS5zaGVlblJvdWdobmVzc01hcDtcblxuXHRcdHRoaXMudHJhbnNtaXNzaW9uID0gc291cmNlLnRyYW5zbWlzc2lvbjtcblx0XHR0aGlzLnRyYW5zbWlzc2lvbk1hcCA9IHNvdXJjZS50cmFuc21pc3Npb25NYXA7XG5cblx0XHR0aGlzLnRoaWNrbmVzcyA9IHNvdXJjZS50aGlja25lc3M7XG5cdFx0dGhpcy50aGlja25lc3NNYXAgPSBzb3VyY2UudGhpY2tuZXNzTWFwO1xuXHRcdHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IHNvdXJjZS5hdHRlbnVhdGlvbkRpc3RhbmNlO1xuXHRcdHRoaXMuYXR0ZW51YXRpb25Db2xvci5jb3B5KCBzb3VyY2UuYXR0ZW51YXRpb25Db2xvciApO1xuXG5cdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eSA9IHNvdXJjZS5zcGVjdWxhckludGVuc2l0eTtcblx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwID0gc291cmNlLnNwZWN1bGFySW50ZW5zaXR5TWFwO1xuXHRcdHRoaXMuc3BlY3VsYXJDb2xvci5jb3B5KCBzb3VyY2Uuc3BlY3VsYXJDb2xvciApO1xuXHRcdHRoaXMuc3BlY3VsYXJDb2xvck1hcCA9IHNvdXJjZS5zcGVjdWxhckNvbG9yTWFwO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1lc2hQaG9uZ01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNNZXNoUGhvbmdNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXHRcdHRoaXMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoIDB4MTExMTExICk7XG5cdFx0dGhpcy5zaGluaW5lc3MgPSAzMDtcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHR0aGlzLmFvTWFwID0gbnVsbDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHRcdHRoaXMuZW52TWFwUm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblx0XHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xuXHRcdHRoaXMuc2hpbmluZXNzID0gc291cmNlLnNoaW5pbmVzcztcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHRcdHRoaXMuZW52TWFwUm90YXRpb24uY29weSggc291cmNlLmVudk1hcFJvdGF0aW9uICk7XG5cdFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuXHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgTWVzaFRvb25NYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTWVzaFRvb25NYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmRlZmluZXMgPSB7ICdUT09OJzogJycgfTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoVG9vbk1hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cdFx0dGhpcy5ncmFkaWVudE1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdHRoaXMuZ3JhZGllbnRNYXAgPSBzb3VyY2UuZ3JhZGllbnRNYXA7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1lc2hOb3JtYWxNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTWVzaE5vcm1hbE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1lc2hMYW1iZXJ0TWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuXHRcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbi5jb3B5KCBzb3VyY2UuZW52TWFwUm90YXRpb24gKTtcblx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBNZXNoTWF0Y2FwTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01lc2hNYXRjYXBNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmRlZmluZXMgPSB7ICdNQVRDQVAnOiAnJyB9O1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hNYXRjYXBNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG5cblx0XHR0aGlzLm1hdGNhcCA9IG51bGw7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHsgJ01BVENBUCc6ICcnIH07XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXRjYXAgPSBzb3VyY2UubWF0Y2FwO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIExpbmVEYXNoZWRNYXRlcmlhbCBleHRlbmRzIExpbmVCYXNpY01hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTGluZURhc2hlZE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lRGFzaGVkTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5zY2FsZSA9IDE7XG5cdFx0dGhpcy5kYXNoU2l6ZSA9IDM7XG5cdFx0dGhpcy5nYXBTaXplID0gMTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5zY2FsZSA9IHNvdXJjZS5zY2FsZTtcblx0XHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xuXHRcdHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbi8vIGNvbnZlcnRzIGFuIGFycmF5IHRvIGEgc3BlY2lmaWMgdHlwZVxuZnVuY3Rpb24gY29udmVydEFycmF5KCBhcnJheSwgdHlwZSwgZm9yY2VDbG9uZSApIHtcblxuXHRpZiAoICEgYXJyYXkgfHwgLy8gbGV0ICd1bmRlZmluZWQnIGFuZCAnbnVsbCcgcGFzc1xuXHRcdCEgZm9yY2VDbG9uZSAmJiBhcnJheS5jb25zdHJ1Y3RvciA9PT0gdHlwZSApIHJldHVybiBhcnJheTtcblxuXHRpZiAoIHR5cGVvZiB0eXBlLkJZVEVTX1BFUl9FTEVNRU5UID09PSAnbnVtYmVyJyApIHtcblxuXHRcdHJldHVybiBuZXcgdHlwZSggYXJyYXkgKTsgLy8gY3JlYXRlIHR5cGVkIGFycmF5XG5cblx0fVxuXG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJyYXkgKTsgLy8gY3JlYXRlIEFycmF5XG5cbn1cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KCBvYmplY3QgKSB7XG5cblx0cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyggb2JqZWN0ICkgJiZcblx0XHQhICggb2JqZWN0IGluc3RhbmNlb2YgRGF0YVZpZXcgKTtcblxufVxuXG4vLyByZXR1cm5zIGFuIGFycmF5IGJ5IHdoaWNoIHRpbWVzIGFuZCB2YWx1ZXMgY2FuIGJlIHNvcnRlZFxuZnVuY3Rpb24gZ2V0S2V5ZnJhbWVPcmRlciggdGltZXMgKSB7XG5cblx0ZnVuY3Rpb24gY29tcGFyZVRpbWUoIGksIGogKSB7XG5cblx0XHRyZXR1cm4gdGltZXNbIGkgXSAtIHRpbWVzWyBqIF07XG5cblx0fVxuXG5cdGNvbnN0IG4gPSB0aW1lcy5sZW5ndGg7XG5cdGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSggbiApO1xuXHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG47ICsrIGkgKSByZXN1bHRbIGkgXSA9IGk7XG5cblx0cmVzdWx0LnNvcnQoIGNvbXBhcmVUaW1lICk7XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufVxuXG4vLyB1c2VzIHRoZSBhcnJheSBwcmV2aW91c2x5IHJldHVybmVkIGJ5ICdnZXRLZXlmcmFtZU9yZGVyJyB0byBzb3J0IGRhdGFcbmZ1bmN0aW9uIHNvcnRlZEFycmF5KCB2YWx1ZXMsIHN0cmlkZSwgb3JkZXIgKSB7XG5cblx0Y29uc3QgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG5cdGNvbnN0IHJlc3VsdCA9IG5ldyB2YWx1ZXMuY29uc3RydWN0b3IoIG5WYWx1ZXMgKTtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGRzdE9mZnNldCA9IDA7IGRzdE9mZnNldCAhPT0gblZhbHVlczsgKysgaSApIHtcblxuXHRcdGNvbnN0IHNyY09mZnNldCA9IG9yZGVyWyBpIF0gKiBzdHJpZGU7XG5cblx0XHRmb3IgKCBsZXQgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcblxuXHRcdFx0cmVzdWx0WyBkc3RPZmZzZXQgKysgXSA9IHZhbHVlc1sgc3JjT2Zmc2V0ICsgaiBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xuXG59XG5cbi8vIGZ1bmN0aW9uIGZvciBwYXJzaW5nIEFPUyBrZXlmcmFtZSBmb3JtYXRzXG5mdW5jdGlvbiBmbGF0dGVuSlNPTigganNvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHZhbHVlUHJvcGVydHlOYW1lICkge1xuXG5cdGxldCBpID0gMSwga2V5ID0ganNvbktleXNbIDAgXTtcblxuXHR3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuXHR9XG5cblx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxuXG5cdGxldCB2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuOyAvLyBubyBkYXRhXG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XG5cdFx0XHRcdHZhbHVlcy5wdXNoLmFwcGx5KCB2YWx1ZXMsIHZhbHVlICk7IC8vIHB1c2ggYWxsIGVsZW1lbnRzXG5cblx0XHRcdH1cblxuXHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuXHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xuXG5cdH0gZWxzZSBpZiAoIHZhbHVlLnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdC8vIC4uLmFzc3VtZSBUSFJFRS5NYXRoLWlzaFxuXG5cdFx0ZG8ge1xuXG5cdFx0XHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XG5cdFx0XHRcdHZhbHVlLnRvQXJyYXkoIHZhbHVlcywgdmFsdWVzLmxlbmd0aCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cblx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gb3RoZXJ3aXNlIHB1c2ggYXMtaXNcblxuXHRcdGRvIHtcblxuXHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG5cblx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xuXHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xuXG5cdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHN1YmNsaXAoIHNvdXJjZUNsaXAsIG5hbWUsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBmcHMgPSAzMCApIHtcblxuXHRjb25zdCBjbGlwID0gc291cmNlQ2xpcC5jbG9uZSgpO1xuXG5cdGNsaXAubmFtZSA9IG5hbWU7XG5cblx0Y29uc3QgdHJhY2tzID0gW107XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY2xpcC50cmFja3MubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0Y29uc3QgdHJhY2sgPSBjbGlwLnRyYWNrc1sgaSBdO1xuXHRcdGNvbnN0IHZhbHVlU2l6ZSA9IHRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuXG5cdFx0Y29uc3QgdGltZXMgPSBbXTtcblx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHRyYWNrLnRpbWVzLmxlbmd0aDsgKysgaiApIHtcblxuXHRcdFx0Y29uc3QgZnJhbWUgPSB0cmFjay50aW1lc1sgaiBdICogZnBzO1xuXG5cdFx0XHRpZiAoIGZyYW1lIDwgc3RhcnRGcmFtZSB8fCBmcmFtZSA+PSBlbmRGcmFtZSApIGNvbnRpbnVlO1xuXG5cdFx0XHR0aW1lcy5wdXNoKCB0cmFjay50aW1lc1sgaiBdICk7XG5cblx0XHRcdGZvciAoIGxldCBrID0gMDsgayA8IHZhbHVlU2l6ZTsgKysgayApIHtcblxuXHRcdFx0XHR2YWx1ZXMucHVzaCggdHJhY2sudmFsdWVzWyBqICogdmFsdWVTaXplICsgayBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGltZXMubGVuZ3RoID09PSAwICkgY29udGludWU7XG5cblx0XHR0cmFjay50aW1lcyA9IGNvbnZlcnRBcnJheSggdGltZXMsIHRyYWNrLnRpbWVzLmNvbnN0cnVjdG9yICk7XG5cdFx0dHJhY2sudmFsdWVzID0gY29udmVydEFycmF5KCB2YWx1ZXMsIHRyYWNrLnZhbHVlcy5jb25zdHJ1Y3RvciApO1xuXG5cdFx0dHJhY2tzLnB1c2goIHRyYWNrICk7XG5cblx0fVxuXG5cdGNsaXAudHJhY2tzID0gdHJhY2tzO1xuXG5cdC8vIGZpbmQgbWluaW11bSAudGltZXMgdmFsdWUgYWNyb3NzIGFsbCB0cmFja3MgaW4gdGhlIHRyaW1tZWQgY2xpcFxuXG5cdGxldCBtaW5TdGFydFRpbWUgPSBJbmZpbml0eTtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjbGlwLnRyYWNrcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRpZiAoIG1pblN0YXJ0VGltZSA+IGNsaXAudHJhY2tzWyBpIF0udGltZXNbIDAgXSApIHtcblxuXHRcdFx0bWluU3RhcnRUaW1lID0gY2xpcC50cmFja3NbIGkgXS50aW1lc1sgMCBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBzaGlmdCBhbGwgdHJhY2tzIHN1Y2ggdGhhdCBjbGlwIGJlZ2lucyBhdCB0PTBcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjbGlwLnRyYWNrcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRjbGlwLnRyYWNrc1sgaSBdLnNoaWZ0KCAtIDEgKiBtaW5TdGFydFRpbWUgKTtcblxuXHR9XG5cblx0Y2xpcC5yZXNldER1cmF0aW9uKCk7XG5cblx0cmV0dXJuIGNsaXA7XG5cbn1cblxuZnVuY3Rpb24gbWFrZUNsaXBBZGRpdGl2ZSggdGFyZ2V0Q2xpcCwgcmVmZXJlbmNlRnJhbWUgPSAwLCByZWZlcmVuY2VDbGlwID0gdGFyZ2V0Q2xpcCwgZnBzID0gMzAgKSB7XG5cblx0aWYgKCBmcHMgPD0gMCApIGZwcyA9IDMwO1xuXG5cdGNvbnN0IG51bVRyYWNrcyA9IHJlZmVyZW5jZUNsaXAudHJhY2tzLmxlbmd0aDtcblx0Y29uc3QgcmVmZXJlbmNlVGltZSA9IHJlZmVyZW5jZUZyYW1lIC8gZnBzO1xuXG5cdC8vIE1ha2UgZWFjaCB0cmFjaydzIHZhbHVlcyByZWxhdGl2ZSB0byB0aGUgdmFsdWVzIGF0IHRoZSByZWZlcmVuY2UgZnJhbWVcblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbnVtVHJhY2tzOyArKyBpICkge1xuXG5cdFx0Y29uc3QgcmVmZXJlbmNlVHJhY2sgPSByZWZlcmVuY2VDbGlwLnRyYWNrc1sgaSBdO1xuXHRcdGNvbnN0IHJlZmVyZW5jZVRyYWNrVHlwZSA9IHJlZmVyZW5jZVRyYWNrLlZhbHVlVHlwZU5hbWU7XG5cblx0XHQvLyBTa2lwIHRoaXMgdHJhY2sgaWYgaXQncyBub24tbnVtZXJpY1xuXHRcdGlmICggcmVmZXJlbmNlVHJhY2tUeXBlID09PSAnYm9vbCcgfHwgcmVmZXJlbmNlVHJhY2tUeXBlID09PSAnc3RyaW5nJyApIGNvbnRpbnVlO1xuXG5cdFx0Ly8gRmluZCB0aGUgdHJhY2sgaW4gdGhlIHRhcmdldCBjbGlwIHdob3NlIG5hbWUgYW5kIHR5cGUgbWF0Y2hlcyB0aGUgcmVmZXJlbmNlIHRyYWNrXG5cdFx0Y29uc3QgdGFyZ2V0VHJhY2sgPSB0YXJnZXRDbGlwLnRyYWNrcy5maW5kKCBmdW5jdGlvbiAoIHRyYWNrICkge1xuXG5cdFx0XHRyZXR1cm4gdHJhY2submFtZSA9PT0gcmVmZXJlbmNlVHJhY2submFtZVxuXHRcdFx0XHQmJiB0cmFjay5WYWx1ZVR5cGVOYW1lID09PSByZWZlcmVuY2VUcmFja1R5cGU7XG5cblx0XHR9ICk7XG5cblx0XHRpZiAoIHRhcmdldFRyYWNrID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdGxldCByZWZlcmVuY2VPZmZzZXQgPSAwO1xuXHRcdGNvbnN0IHJlZmVyZW5jZVZhbHVlU2l6ZSA9IHJlZmVyZW5jZVRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuXG5cdFx0aWYgKCByZWZlcmVuY2VUcmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSApIHtcblxuXHRcdFx0cmVmZXJlbmNlT2Zmc2V0ID0gcmVmZXJlbmNlVmFsdWVTaXplIC8gMztcblxuXHRcdH1cblxuXHRcdGxldCB0YXJnZXRPZmZzZXQgPSAwO1xuXHRcdGNvbnN0IHRhcmdldFZhbHVlU2l6ZSA9IHRhcmdldFRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuXG5cdFx0aWYgKCB0YXJnZXRUcmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSApIHtcblxuXHRcdFx0dGFyZ2V0T2Zmc2V0ID0gdGFyZ2V0VmFsdWVTaXplIC8gMztcblxuXHRcdH1cblxuXHRcdGNvbnN0IGxhc3RJbmRleCA9IHJlZmVyZW5jZVRyYWNrLnRpbWVzLmxlbmd0aCAtIDE7XG5cdFx0bGV0IHJlZmVyZW5jZVZhbHVlO1xuXG5cdFx0Ly8gRmluZCB0aGUgdmFsdWUgdG8gc3VidHJhY3Qgb3V0IG9mIHRoZSB0cmFja1xuXHRcdGlmICggcmVmZXJlbmNlVGltZSA8PSByZWZlcmVuY2VUcmFjay50aW1lc1sgMCBdICkge1xuXG5cdFx0XHQvLyBSZWZlcmVuY2UgZnJhbWUgaXMgZWFybGllciB0aGFuIHRoZSBmaXJzdCBrZXlmcmFtZSwgc28ganVzdCB1c2UgdGhlIGZpcnN0IGtleWZyYW1lXG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0Y29uc3QgZW5kSW5kZXggPSByZWZlcmVuY2VWYWx1ZVNpemUgLSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRyZWZlcmVuY2VWYWx1ZSA9IHJlZmVyZW5jZVRyYWNrLnZhbHVlcy5zbGljZSggc3RhcnRJbmRleCwgZW5kSW5kZXggKTtcblxuXHRcdH0gZWxzZSBpZiAoIHJlZmVyZW5jZVRpbWUgPj0gcmVmZXJlbmNlVHJhY2sudGltZXNbIGxhc3RJbmRleCBdICkge1xuXG5cdFx0XHQvLyBSZWZlcmVuY2UgZnJhbWUgaXMgYWZ0ZXIgdGhlIGxhc3Qga2V5ZnJhbWUsIHNvIGp1c3QgdXNlIHRoZSBsYXN0IGtleWZyYW1lXG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gbGFzdEluZGV4ICogcmVmZXJlbmNlVmFsdWVTaXplICsgcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0Y29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgcmVmZXJlbmNlVmFsdWVTaXplIC0gcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0cmVmZXJlbmNlVmFsdWUgPSByZWZlcmVuY2VUcmFjay52YWx1ZXMuc2xpY2UoIHN0YXJ0SW5kZXgsIGVuZEluZGV4ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJbnRlcnBvbGF0ZSB0byB0aGUgcmVmZXJlbmNlIHZhbHVlXG5cdFx0XHRjb25zdCBpbnRlcnBvbGFudCA9IHJlZmVyZW5jZVRyYWNrLmNyZWF0ZUludGVycG9sYW50KCk7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0Y29uc3QgZW5kSW5kZXggPSByZWZlcmVuY2VWYWx1ZVNpemUgLSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRpbnRlcnBvbGFudC5ldmFsdWF0ZSggcmVmZXJlbmNlVGltZSApO1xuXHRcdFx0cmVmZXJlbmNlVmFsdWUgPSBpbnRlcnBvbGFudC5yZXN1bHRCdWZmZXIuc2xpY2UoIHN0YXJ0SW5kZXgsIGVuZEluZGV4ICk7XG5cblx0XHR9XG5cblx0XHQvLyBDb25qdWdhdGUgdGhlIHF1YXRlcm5pb25cblx0XHRpZiAoIHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ3F1YXRlcm5pb24nICkge1xuXG5cdFx0XHRjb25zdCByZWZlcmVuY2VRdWF0ID0gbmV3IFF1YXRlcm5pb24oKS5mcm9tQXJyYXkoIHJlZmVyZW5jZVZhbHVlICkubm9ybWFsaXplKCkuY29uanVnYXRlKCk7XG5cdFx0XHRyZWZlcmVuY2VRdWF0LnRvQXJyYXkoIHJlZmVyZW5jZVZhbHVlICk7XG5cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCB0aGUgcmVmZXJlbmNlIHZhbHVlIGZyb20gYWxsIG9mIHRoZSB0cmFjayB2YWx1ZXNcblxuXHRcdGNvbnN0IG51bVRpbWVzID0gdGFyZ2V0VHJhY2sudGltZXMubGVuZ3RoO1xuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8IG51bVRpbWVzOyArKyBqICkge1xuXG5cdFx0XHRjb25zdCB2YWx1ZVN0YXJ0ID0gaiAqIHRhcmdldFZhbHVlU2l6ZSArIHRhcmdldE9mZnNldDtcblxuXHRcdFx0aWYgKCByZWZlcmVuY2VUcmFja1R5cGUgPT09ICdxdWF0ZXJuaW9uJyApIHtcblxuXHRcdFx0XHQvLyBNdWx0aXBseSB0aGUgY29uanVnYXRlIGZvciBxdWF0ZXJuaW9uIHRyYWNrIHR5cGVzXG5cdFx0XHRcdFF1YXRlcm5pb24ubXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoXG5cdFx0XHRcdFx0dGFyZ2V0VHJhY2sudmFsdWVzLFxuXHRcdFx0XHRcdHZhbHVlU3RhcnQsXG5cdFx0XHRcdFx0cmVmZXJlbmNlVmFsdWUsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHR0YXJnZXRUcmFjay52YWx1ZXMsXG5cdFx0XHRcdFx0dmFsdWVTdGFydFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHZhbHVlRW5kID0gdGFyZ2V0VmFsdWVTaXplIC0gdGFyZ2V0T2Zmc2V0ICogMjtcblxuXHRcdFx0XHQvLyBTdWJ0cmFjdCBlYWNoIHZhbHVlIGZvciBhbGwgb3RoZXIgbnVtZXJpYyB0cmFjayB0eXBlc1xuXHRcdFx0XHRmb3IgKCBsZXQgayA9IDA7IGsgPCB2YWx1ZUVuZDsgKysgayApIHtcblxuXHRcdFx0XHRcdHRhcmdldFRyYWNrLnZhbHVlc1sgdmFsdWVTdGFydCArIGsgXSAtPSByZWZlcmVuY2VWYWx1ZVsgayBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0YXJnZXRDbGlwLmJsZW5kTW9kZSA9IEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlO1xuXG5cdHJldHVybiB0YXJnZXRDbGlwO1xuXG59XG5cbmNvbnN0IEFuaW1hdGlvblV0aWxzID0ge1xuXHRjb252ZXJ0QXJyYXk6IGNvbnZlcnRBcnJheSxcblx0aXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXksXG5cdGdldEtleWZyYW1lT3JkZXI6IGdldEtleWZyYW1lT3JkZXIsXG5cdHNvcnRlZEFycmF5OiBzb3J0ZWRBcnJheSxcblx0ZmxhdHRlbkpTT046IGZsYXR0ZW5KU09OLFxuXHRzdWJjbGlwOiBzdWJjbGlwLFxuXHRtYWtlQ2xpcEFkZGl0aXZlOiBtYWtlQ2xpcEFkZGl0aXZlXG59O1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3Mgb2YgaW50ZXJwb2xhbnRzIG92ZXIgcGFyYW1ldHJpYyBzYW1wbGVzLlxuICpcbiAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxuICogYWxvbmcgYSBjdXJ2ZSBkZWZpbmVkIGJ5IHRoZSBkYXRhLlxuICpcbiAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxuICogYXBwbHkgc3BlY2lhbCBpbnRlcnByZXRhdGlvbnMgdG8gdGhlIGRhdGEuXG4gKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXG4gKiB0aGUgYWN0dWFsIGludGVycG9sYXRpb24gdG8gZGVyaXZlZCBjbGFzc2VzLlxuICpcbiAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xuICogYW5kIE8obG9nIE4pIGZvciByYW5kb20gYWNjZXNzLCB3aGVyZSBOIGlzIHRoZSBudW1iZXIgb2YgcG9zaXRpb25zLlxuICpcbiAqIFJlZmVyZW5jZXM6XG4gKlxuICogXHRcdGh0dHA6Ly93d3cub29kZXNpZ24uY29tL3RlbXBsYXRlLW1ldGhvZC1wYXR0ZXJuLmh0bWxcbiAqXG4gKi9cblxuY2xhc3MgSW50ZXJwb2xhbnQge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMgPSBwYXJhbWV0ZXJQb3NpdGlvbnM7XG5cdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xuXG5cdFx0dGhpcy5yZXN1bHRCdWZmZXIgPSByZXN1bHRCdWZmZXIgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRyZXN1bHRCdWZmZXIgOiBuZXcgc2FtcGxlVmFsdWVzLmNvbnN0cnVjdG9yKCBzYW1wbGVTaXplICk7XG5cdFx0dGhpcy5zYW1wbGVWYWx1ZXMgPSBzYW1wbGVWYWx1ZXM7XG5cdFx0dGhpcy52YWx1ZVNpemUgPSBzYW1wbGVTaXplO1xuXG5cdFx0dGhpcy5zZXR0aW5ncyA9IG51bGw7XG5cdFx0dGhpcy5EZWZhdWx0U2V0dGluZ3NfID0ge307XG5cblx0fVxuXG5cdGV2YWx1YXRlKCB0ICkge1xuXG5cdFx0Y29uc3QgcHAgPSB0aGlzLnBhcmFtZXRlclBvc2l0aW9ucztcblx0XHRsZXQgaTEgPSB0aGlzLl9jYWNoZWRJbmRleCxcblx0XHRcdHQxID0gcHBbIGkxIF0sXG5cdFx0XHR0MCA9IHBwWyBpMSAtIDEgXTtcblxuXHRcdHZhbGlkYXRlX2ludGVydmFsOiB7XG5cblx0XHRcdHNlZWs6IHtcblxuXHRcdFx0XHRsZXQgcmlnaHQ7XG5cblx0XHRcdFx0bGluZWFyX3NjYW46IHtcblxuXHRcdFx0XHRcdC8vLSBTZWUgaHR0cDovL2pzcGVyZi5jb20vY29tcGFyaXNvbi10by11bmRlZmluZWQvM1xuXHRcdFx0XHRcdC8vLSBzbG93ZXIgY29kZTpcblx0XHRcdFx0XHQvLy1cblx0XHRcdFx0XHQvLy0gXHRcdFx0XHRpZiAoIHQgPj0gdDEgfHwgdDEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRmb3J3YXJkX3NjYW46IGlmICggISAoIHQgPCB0MSApICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgZ2l2ZVVwQXQgPSBpMSArIDI7IDsgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0MSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDAgKSBicmVhayBmb3J3YXJkX3NjYW47XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBhZnRlciBlbmRcblxuXHRcdFx0XHRcdFx0XHRcdGkxID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxuXG5cdFx0XHRcdFx0XHRcdHQwID0gdDE7XG5cdFx0XHRcdFx0XHRcdHQxID0gcHBbICsrIGkxIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgaW5kZXhcblx0XHRcdFx0XHRcdHJpZ2h0ID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLy0gc2xvd2VyIGNvZGU6XG5cdFx0XHRcdFx0Ly8tXHRcdFx0XHRcdGlmICggdCA8IHQwIHx8IHQwID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhICggdCA+PSB0MCApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBsb29waW5nP1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0MWdsb2JhbCA9IHBwWyAxIF07XG5cblx0XHRcdFx0XHRcdGlmICggdCA8IHQxZ2xvYmFsICkge1xuXG5cdFx0XHRcdFx0XHRcdGkxID0gMjsgLy8gKyAxLCB1c2luZyB0aGUgc2NhbiBmb3IgdGhlIGRldGFpbHNcblx0XHRcdFx0XHRcdFx0dDAgPSB0MWdsb2JhbDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBsaW5lYXIgcmV2ZXJzZSBzY2FuXG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBnaXZlVXBBdCA9IGkxIC0gMjsgOyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBiZWZvcmUgc3RhcnRcblxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCAwICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxuXG5cdFx0XHRcdFx0XHRcdHQxID0gdDA7XG5cdFx0XHRcdFx0XHRcdHQwID0gcHBbIC0tIGkxIC0gMSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdCA+PSB0MCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2VlaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGluZGV4XG5cdFx0XHRcdFx0XHRyaWdodCA9IGkxO1xuXHRcdFx0XHRcdFx0aTEgPSAwO1xuXHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0aGUgaW50ZXJ2YWwgaXMgdmFsaWRcblxuXHRcdFx0XHRcdGJyZWFrIHZhbGlkYXRlX2ludGVydmFsO1xuXG5cdFx0XHRcdH0gLy8gbGluZWFyIHNjYW5cblxuXHRcdFx0XHQvLyBiaW5hcnkgc2VhcmNoXG5cblx0XHRcdFx0d2hpbGUgKCBpMSA8IHJpZ2h0ICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbWlkID0gKCBpMSArIHJpZ2h0ICkgPj4+IDE7XG5cblx0XHRcdFx0XHRpZiAoIHQgPCBwcFsgbWlkIF0gKSB7XG5cblx0XHRcdFx0XHRcdHJpZ2h0ID0gbWlkO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aTEgPSBtaWQgKyAxO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0MSA9IHBwWyBpMSBdO1xuXHRcdFx0XHR0MCA9IHBwWyBpMSAtIDEgXTtcblxuXHRcdFx0XHQvLyBjaGVjayBib3VuZGFyeSBjYXNlcywgYWdhaW5cblxuXHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcblx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oIGkxIC0gMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSAvLyBzZWVrXG5cblx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XG5cblx0XHRcdHRoaXMuaW50ZXJ2YWxDaGFuZ2VkXyggaTEsIHQwLCB0MSApO1xuXG5cdFx0fSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxuXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICk7XG5cblx0fVxuXG5cdGdldFNldHRpbmdzXygpIHtcblxuXHRcdHJldHVybiB0aGlzLnNldHRpbmdzIHx8IHRoaXMuRGVmYXVsdFNldHRpbmdzXztcblxuXHR9XG5cblx0Y29weVNhbXBsZVZhbHVlXyggaW5kZXggKSB7XG5cblx0XHQvLyBjb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXJcblxuXHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdG9mZnNldCA9IGluZGV4ICogc3RyaWRlO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdHJlc3VsdFsgaSBdID0gdmFsdWVzWyBvZmZzZXQgKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHQvLyBUZW1wbGF0ZSBtZXRob2RzIGZvciBkZXJpdmVkIGNsYXNzZXM6XG5cblx0aW50ZXJwb2xhdGVfKCAvKiBpMSwgdDAsIHQsIHQxICovICkge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnY2FsbCB0byBhYnN0cmFjdCBtZXRob2QnICk7XG5cdFx0Ly8gaW1wbGVtZW50YXRpb25zIHNoYWxsIHJldHVybiB0aGlzLnJlc3VsdEJ1ZmZlclxuXG5cdH1cblxuXHRpbnRlcnZhbENoYW5nZWRfKCAvKiBpMSwgdDAsIHQxICovICkge1xuXG5cdFx0Ly8gZW1wdHlcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBGYXN0IGFuZCBzaW1wbGUgY3ViaWMgc3BsaW5lIGludGVycG9sYW50LlxuICpcbiAqIEl0IHdhcyBkZXJpdmVkIGZyb20gYSBIZXJtaXRpYW4gY29uc3RydWN0aW9uIHNldHRpbmcgdGhlIGZpcnN0IGRlcml2YXRpdmVcbiAqIGF0IGVhY2ggc2FtcGxlIHBvc2l0aW9uIHRvIHRoZSBsaW5lYXIgc2xvcGUgYmV0d2VlbiBuZWlnaGJvcmluZyBwb3NpdGlvbnNcbiAqIG92ZXIgdGhlaXIgcGFyYW1ldGVyIGludGVydmFsLlxuICovXG5cbmNsYXNzIEN1YmljSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0XHRzdXBlciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xuXG5cdFx0dGhpcy5fd2VpZ2h0UHJldiA9IC0gMDtcblx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gLSAwO1xuXHRcdHRoaXMuX3dlaWdodE5leHQgPSAtIDA7XG5cdFx0dGhpcy5fb2Zmc2V0TmV4dCA9IC0gMDtcblxuXHRcdHRoaXMuRGVmYXVsdFNldHRpbmdzXyA9IHtcblxuXHRcdFx0ZW5kaW5nU3RhcnQ6IFplcm9DdXJ2YXR1cmVFbmRpbmcsXG5cdFx0XHRlbmRpbmdFbmQ6IFplcm9DdXJ2YXR1cmVFbmRpbmdcblxuXHRcdH07XG5cblx0fVxuXG5cdGludGVydmFsQ2hhbmdlZF8oIGkxLCB0MCwgdDEgKSB7XG5cblx0XHRjb25zdCBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zO1xuXHRcdGxldCBpUHJldiA9IGkxIC0gMixcblx0XHRcdGlOZXh0ID0gaTEgKyAxLFxuXG5cdFx0XHR0UHJldiA9IHBwWyBpUHJldiBdLFxuXHRcdFx0dE5leHQgPSBwcFsgaU5leHQgXTtcblxuXHRcdGlmICggdFByZXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdTdGFydCApIHtcblxuXHRcdFx0XHRjYXNlIFplcm9TbG9wZUVuZGluZzpcblxuXHRcdFx0XHRcdC8vIGYnKHQwKSA9IDBcblx0XHRcdFx0XHRpUHJldiA9IGkxO1xuXHRcdFx0XHRcdHRQcmV2ID0gMiAqIHQwIC0gdDE7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XG5cblx0XHRcdFx0XHQvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcblx0XHRcdFx0XHRpUHJldiA9IHBwLmxlbmd0aCAtIDI7XG5cdFx0XHRcdFx0dFByZXYgPSB0MCArIHBwWyBpUHJldiBdIC0gcHBbIGlQcmV2ICsgMSBdO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDogLy8gWmVyb0N1cnZhdHVyZUVuZGluZ1xuXG5cdFx0XHRcdFx0Ly8gZicnKHQwKSA9IDAgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0aVByZXYgPSBpMTtcblx0XHRcdFx0XHR0UHJldiA9IHQxO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHROZXh0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nRW5kICkge1xuXG5cdFx0XHRcdGNhc2UgWmVyb1Nsb3BlRW5kaW5nOlxuXG5cdFx0XHRcdFx0Ly8gZicodE4pID0gMFxuXHRcdFx0XHRcdGlOZXh0ID0gaTE7XG5cdFx0XHRcdFx0dE5leHQgPSAyICogdDEgLSB0MDtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgV3JhcEFyb3VuZEVuZGluZzpcblxuXHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxuXHRcdFx0XHRcdGlOZXh0ID0gMTtcblx0XHRcdFx0XHR0TmV4dCA9IHQxICsgcHBbIDEgXSAtIHBwWyAwIF07XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXG5cblx0XHRcdFx0XHQvLyBmJycodE4pID0gMCwgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0aU5leHQgPSBpMSAtIDE7XG5cdFx0XHRcdFx0dE5leHQgPSB0MDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaGFsZkR0ID0gKCB0MSAtIHQwICkgKiAwLjUsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcblxuXHRcdHRoaXMuX3dlaWdodFByZXYgPSBoYWxmRHQgLyAoIHQwIC0gdFByZXYgKTtcblx0XHR0aGlzLl93ZWlnaHROZXh0ID0gaGFsZkR0IC8gKCB0TmV4dCAtIHQxICk7XG5cdFx0dGhpcy5fb2Zmc2V0UHJldiA9IGlQcmV2ICogc3RyaWRlO1xuXHRcdHRoaXMuX29mZnNldE5leHQgPSBpTmV4dCAqIHN0cmlkZTtcblxuXHR9XG5cblx0aW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG5cdFx0XHRvMSA9IGkxICogc3RyaWRlLFx0XHRvMCA9IG8xIC0gc3RyaWRlLFxuXHRcdFx0b1AgPSB0aGlzLl9vZmZzZXRQcmV2LCBcdG9OID0gdGhpcy5fb2Zmc2V0TmV4dCxcblx0XHRcdHdQID0gdGhpcy5fd2VpZ2h0UHJldixcdHdOID0gdGhpcy5fd2VpZ2h0TmV4dCxcblxuXHRcdFx0cCA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKSxcblx0XHRcdHBwID0gcCAqIHAsXG5cdFx0XHRwcHAgPSBwcCAqIHA7XG5cblx0XHQvLyBldmFsdWF0ZSBwb2x5bm9taWFsc1xuXG5cdFx0Y29uc3Qgc1AgPSAtIHdQICogcHBwICsgMiAqIHdQICogcHAgLSB3UCAqIHA7XG5cdFx0Y29uc3QgczAgPSAoIDEgKyB3UCApICogcHBwICsgKCAtIDEuNSAtIDIgKiB3UCApICogcHAgKyAoIC0gMC41ICsgd1AgKSAqIHAgKyAxO1xuXHRcdGNvbnN0IHMxID0gKCAtIDEgLSB3TiApICogcHBwICsgKCAxLjUgKyB3TiApICogcHAgKyAwLjUgKiBwO1xuXHRcdGNvbnN0IHNOID0gd04gKiBwcHAgLSB3TiAqIHBwO1xuXG5cdFx0Ly8gY29tYmluZSBkYXRhIGxpbmVhcmx5XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuXHRcdFx0cmVzdWx0WyBpIF0gPVxuXHRcdFx0XHRcdHNQICogdmFsdWVzWyBvUCArIGkgXSArXG5cdFx0XHRcdFx0czAgKiB2YWx1ZXNbIG8wICsgaSBdICtcblx0XHRcdFx0XHRzMSAqIHZhbHVlc1sgbzEgKyBpIF0gK1xuXHRcdFx0XHRcdHNOICogdmFsdWVzWyBvTiArIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG59XG5cbmNsYXNzIExpbmVhckludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFx0c3VwZXIoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0aW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG5cdFx0XHRvZmZzZXQxID0gaTEgKiBzdHJpZGUsXG5cdFx0XHRvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZSxcblxuXHRcdFx0d2VpZ2h0MSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKSxcblx0XHRcdHdlaWdodDAgPSAxIC0gd2VpZ2h0MTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRyZXN1bHRbIGkgXSA9XG5cdFx0XHRcdFx0dmFsdWVzWyBvZmZzZXQwICsgaSBdICogd2VpZ2h0MCArXG5cdFx0XHRcdFx0dmFsdWVzWyBvZmZzZXQxICsgaSBdICogd2VpZ2h0MTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG59XG5cbi8qKlxuICpcbiAqIEludGVycG9sYW50IHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBzYW1wbGUgdmFsdWUgYXQgdGhlIHBvc2l0aW9uIHByZWNlZGluZ1xuICogdGhlIHBhcmFtZXRlci5cbiAqL1xuXG5jbGFzcyBEaXNjcmV0ZUludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFx0c3VwZXIoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0aW50ZXJwb2xhdGVfKCBpMSAvKiwgdDAsIHQsIHQxICovICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEtleWZyYW1lVHJhY2sge1xuXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0aWYgKCBuYW1lID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiB0cmFjayBuYW1lIGlzIHVuZGVmaW5lZCcgKTtcblx0XHRpZiAoIHRpbWVzID09PSB1bmRlZmluZWQgfHwgdGltZXMubGVuZ3RoID09PSAwICkgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogbm8ga2V5ZnJhbWVzIGluIHRyYWNrIG5hbWVkICcgKyBuYW1lICk7XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXG5cdFx0dGhpcy50aW1lcyA9IGNvbnZlcnRBcnJheSggdGltZXMsIHRoaXMuVGltZUJ1ZmZlclR5cGUgKTtcblx0XHR0aGlzLnZhbHVlcyA9IGNvbnZlcnRBcnJheSggdmFsdWVzLCB0aGlzLlZhbHVlQnVmZmVyVHlwZSApO1xuXG5cdFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCBpbnRlcnBvbGF0aW9uIHx8IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcblxuXHR9XG5cblx0Ly8gU2VyaWFsaXphdGlvbiAoaW4gc3RhdGljIGNvbnRleHQsIGJlY2F1c2Ugb2YgY29uc3RydWN0b3IgaW52b2NhdGlvblxuXHQvLyBhbmQgYXV0b21hdGljIGludm9jYXRpb24gb2YgLnRvSlNPTik6XG5cblx0c3RhdGljIHRvSlNPTiggdHJhY2sgKSB7XG5cblx0XHRjb25zdCB0cmFja1R5cGUgPSB0cmFjay5jb25zdHJ1Y3RvcjtcblxuXHRcdGxldCBqc29uO1xuXG5cdFx0Ly8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgdG9KU09OIG1ldGhvZFxuXHRcdGlmICggdHJhY2tUeXBlLnRvSlNPTiAhPT0gdGhpcy50b0pTT04gKSB7XG5cblx0XHRcdGpzb24gPSB0cmFja1R5cGUudG9KU09OKCB0cmFjayApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzdW1lIHRoZSBkYXRhIGNhbiBiZSBzZXJpYWxpemVkIGFzLWlzXG5cdFx0XHRqc29uID0ge1xuXG5cdFx0XHRcdCduYW1lJzogdHJhY2submFtZSxcblx0XHRcdFx0J3RpbWVzJzogY29udmVydEFycmF5KCB0cmFjay50aW1lcywgQXJyYXkgKSxcblx0XHRcdFx0J3ZhbHVlcyc6IGNvbnZlcnRBcnJheSggdHJhY2sudmFsdWVzLCBBcnJheSApXG5cblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGludGVycG9sYXRpb24gPSB0cmFjay5nZXRJbnRlcnBvbGF0aW9uKCk7XG5cblx0XHRcdGlmICggaW50ZXJwb2xhdGlvbiAhPT0gdHJhY2suRGVmYXVsdEludGVycG9sYXRpb24gKSB7XG5cblx0XHRcdFx0anNvbi5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0anNvbi50eXBlID0gdHJhY2suVmFsdWVUeXBlTmFtZTsgLy8gbWFuZGF0b3J5XG5cblx0XHRyZXR1cm4ganNvbjtcblxuXHR9XG5cblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGUoIHJlc3VsdCApIHtcblxuXHRcdHJldHVybiBuZXcgRGlzY3JldGVJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdH1cblxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIoIHJlc3VsdCApIHtcblxuXHRcdHJldHVybiBuZXcgTGluZWFySW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcblxuXHR9XG5cblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoKCByZXN1bHQgKSB7XG5cblx0XHRyZXR1cm4gbmV3IEN1YmljSW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcblxuXHR9XG5cblx0c2V0SW50ZXJwb2xhdGlvbiggaW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdGxldCBmYWN0b3J5TWV0aG9kO1xuXG5cdFx0c3dpdGNoICggaW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZURpc2NyZXRlOlxuXG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIEludGVycG9sYXRlTGluZWFyOlxuXG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZVNtb290aDpcblxuXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0XHRpZiAoIGZhY3RvcnlNZXRob2QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgbWVzc2FnZSA9ICd1bnN1cHBvcnRlZCBpbnRlcnBvbGF0aW9uIGZvciAnICtcblx0XHRcdFx0dGhpcy5WYWx1ZVR5cGVOYW1lICsgJyBrZXlmcmFtZSB0cmFjayBuYW1lZCAnICsgdGhpcy5uYW1lO1xuXG5cdFx0XHRpZiAoIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCwgdW5sZXNzIHRoZSBkZWZhdWx0IGl0c2VsZiBpcyBtZXNzZWQgdXBcblx0XHRcdFx0aWYgKCBpbnRlcnBvbGF0aW9uICE9PSB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0XHRcdFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggbWVzc2FnZSApOyAvLyBmYXRhbCwgaW4gdGhpcyBjYXNlXG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLktleWZyYW1lVHJhY2s6JywgbWVzc2FnZSApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNyZWF0ZUludGVycG9sYW50ID0gZmFjdG9yeU1ldGhvZDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRJbnRlcnBvbGF0aW9uKCkge1xuXG5cdFx0c3dpdGNoICggdGhpcy5jcmVhdGVJbnRlcnBvbGFudCApIHtcblxuXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOlxuXG5cdFx0XHRcdHJldHVybiBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuXG5cdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOlxuXG5cdFx0XHRcdHJldHVybiBJbnRlcnBvbGF0ZUxpbmVhcjtcblxuXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDpcblxuXHRcdFx0XHRyZXR1cm4gSW50ZXJwb2xhdGVTbW9vdGg7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldFZhbHVlU2l6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggLyB0aGlzLnRpbWVzLmxlbmd0aDtcblxuXHR9XG5cblx0Ly8gbW92ZSBhbGwga2V5ZnJhbWVzIGVpdGhlciBmb3J3YXJkcyBvciBiYWNrd2FyZHMgaW4gdGltZVxuXHRzaGlmdCggdGltZU9mZnNldCApIHtcblxuXHRcdGlmICggdGltZU9mZnNldCAhPT0gMC4wICkge1xuXG5cdFx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHR0aW1lc1sgaSBdICs9IHRpbWVPZmZzZXQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvLyBzY2FsZSBhbGwga2V5ZnJhbWUgdGltZXMgYnkgYSBmYWN0b3IgKHVzZWZ1bCBmb3IgZnJhbWUgPC0+IHNlY29uZHMgY29udmVyc2lvbnMpXG5cdHNjYWxlKCB0aW1lU2NhbGUgKSB7XG5cblx0XHRpZiAoIHRpbWVTY2FsZSAhPT0gMS4wICkge1xuXG5cdFx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHR0aW1lc1sgaSBdICo9IHRpbWVTY2FsZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIHJlbW92ZXMga2V5ZnJhbWVzIGJlZm9yZSBhbmQgYWZ0ZXIgYW5pbWF0aW9uIHdpdGhvdXQgY2hhbmdpbmcgYW55IHZhbHVlcyB3aXRoaW4gdGhlIHJhbmdlIFtzdGFydFRpbWUsIGVuZFRpbWVdLlxuXHQvLyBJTVBPUlRBTlQ6IFdlIGRvIG5vdCBzaGlmdCBhcm91bmQga2V5cyB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYWNrIHRpbWUsIGJlY2F1c2UgZm9yIGludGVycG9sYXRlZCBrZXlzIHRoaXMgd2lsbCBjaGFuZ2UgdGhlaXIgdmFsdWVzXG5cdHRyaW0oIHN0YXJ0VGltZSwgZW5kVGltZSApIHtcblxuXHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcyxcblx0XHRcdG5LZXlzID0gdGltZXMubGVuZ3RoO1xuXG5cdFx0bGV0IGZyb20gPSAwLFxuXHRcdFx0dG8gPSBuS2V5cyAtIDE7XG5cblx0XHR3aGlsZSAoIGZyb20gIT09IG5LZXlzICYmIHRpbWVzWyBmcm9tIF0gPCBzdGFydFRpbWUgKSB7XG5cblx0XHRcdCsrIGZyb207XG5cblx0XHR9XG5cblx0XHR3aGlsZSAoIHRvICE9PSAtIDEgJiYgdGltZXNbIHRvIF0gPiBlbmRUaW1lICkge1xuXG5cdFx0XHQtLSB0bztcblxuXHRcdH1cblxuXHRcdCsrIHRvOyAvLyBpbmNsdXNpdmUgLT4gZXhjbHVzaXZlIGJvdW5kXG5cblx0XHRpZiAoIGZyb20gIT09IDAgfHwgdG8gIT09IG5LZXlzICkge1xuXG5cdFx0XHQvLyBlbXB0eSB0cmFja3MgYXJlIGZvcmJpZGRlbiwgc28ga2VlcCBhdCBsZWFzdCBvbmUga2V5ZnJhbWVcblx0XHRcdGlmICggZnJvbSA+PSB0byApIHtcblxuXHRcdFx0XHR0byA9IE1hdGgubWF4KCB0bywgMSApO1xuXHRcdFx0XHRmcm9tID0gdG8gLSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHN0cmlkZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XG5cdFx0XHR0aGlzLnRpbWVzID0gdGltZXMuc2xpY2UoIGZyb20sIHRvICk7XG5cdFx0XHR0aGlzLnZhbHVlcyA9IHRoaXMudmFsdWVzLnNsaWNlKCBmcm9tICogc3RyaWRlLCB0byAqIHN0cmlkZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIGVuc3VyZSB3ZSBkbyBub3QgZ2V0IGEgR2FyYmFnZUluR2FyYmFnZU91dCBzaXR1YXRpb24sIG1ha2Ugc3VyZSB0cmFja3MgYXJlIGF0IGxlYXN0IG1pbmltYWxseSB2aWFibGVcblx0dmFsaWRhdGUoKSB7XG5cblx0XHRsZXQgdmFsaWQgPSB0cnVlO1xuXG5cdFx0Y29uc3QgdmFsdWVTaXplID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcblx0XHRpZiAoIHZhbHVlU2l6ZSAtIE1hdGguZmxvb3IoIHZhbHVlU2l6ZSApICE9PSAwICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogSW52YWxpZCB2YWx1ZSBzaXplIGluIHRyYWNrLicsIHRoaXMgKTtcblx0XHRcdHZhbGlkID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXMsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnZhbHVlcyxcblxuXHRcdFx0bktleXMgPSB0aW1lcy5sZW5ndGg7XG5cblx0XHRpZiAoIG5LZXlzID09PSAwICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVHJhY2sgaXMgZW1wdHkuJywgdGhpcyApO1xuXHRcdFx0dmFsaWQgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGxldCBwcmV2VGltZSA9IG51bGw7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG5LZXlzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjdXJyVGltZSA9IHRpbWVzWyBpIF07XG5cblx0XHRcdGlmICggdHlwZW9mIGN1cnJUaW1lID09PSAnbnVtYmVyJyAmJiBpc05hTiggY3VyclRpbWUgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVGltZSBpcyBub3QgYSB2YWxpZCBudW1iZXIuJywgdGhpcywgaSwgY3VyclRpbWUgKTtcblx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwcmV2VGltZSAhPT0gbnVsbCAmJiBwcmV2VGltZSA+IGN1cnJUaW1lICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBPdXQgb2Ygb3JkZXIga2V5cy4nLCB0aGlzLCBpLCBjdXJyVGltZSwgcHJldlRpbWUgKTtcblx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0cHJldlRpbWUgPSBjdXJyVGltZTtcblxuXHRcdH1cblxuXHRcdGlmICggdmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggaXNUeXBlZEFycmF5KCB2YWx1ZXMgKSApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2YWx1ZXNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggaXNOYU4oIHZhbHVlICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBWYWx1ZSBpcyBub3QgYSB2YWxpZCBudW1iZXIuJywgdGhpcywgaSwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB2YWxpZDtcblxuXHR9XG5cblx0Ly8gcmVtb3ZlcyBlcXVpdmFsZW50IHNlcXVlbnRpYWwga2V5cyBhcyBjb21tb24gaW4gbW9ycGggdGFyZ2V0IHNlcXVlbmNlc1xuXHQvLyAoMCwwLDAsMCwxLDEsMSwwLDAsMCwwLDAsMCwwKSAtLT4gKDAsMCwxLDEsMCwwKVxuXHRvcHRpbWl6ZSgpIHtcblxuXHRcdC8vIHRpbWVzIG9yIHZhbHVlcyBtYXkgYmUgc2hhcmVkIHdpdGggb3RoZXIgdHJhY2tzLCBzbyBvdmVyd3JpdGluZyBpcyB1bnNhZmVcblx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXMuc2xpY2UoKSxcblx0XHRcdHZhbHVlcyA9IHRoaXMudmFsdWVzLnNsaWNlKCksXG5cdFx0XHRzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpLFxuXG5cdFx0XHRzbW9vdGhJbnRlcnBvbGF0aW9uID0gdGhpcy5nZXRJbnRlcnBvbGF0aW9uKCkgPT09IEludGVycG9sYXRlU21vb3RoLFxuXG5cdFx0XHRsYXN0SW5kZXggPSB0aW1lcy5sZW5ndGggLSAxO1xuXG5cdFx0bGV0IHdyaXRlSW5kZXggPSAxO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDwgbGFzdEluZGV4OyArKyBpICkge1xuXG5cdFx0XHRsZXQga2VlcCA9IGZhbHNlO1xuXG5cdFx0XHRjb25zdCB0aW1lID0gdGltZXNbIGkgXTtcblx0XHRcdGNvbnN0IHRpbWVOZXh0ID0gdGltZXNbIGkgKyAxIF07XG5cblx0XHRcdC8vIHJlbW92ZSBhZGphY2VudCBrZXlmcmFtZXMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWVcblxuXHRcdFx0aWYgKCB0aW1lICE9PSB0aW1lTmV4dCAmJiAoIGkgIT09IDEgfHwgdGltZSAhPT0gdGltZXNbIDAgXSApICkge1xuXG5cdFx0XHRcdGlmICggISBzbW9vdGhJbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IGtleWZyYW1lcyBzYW1lIGFzIHRoZWlyIG5laWdoYm9yc1xuXG5cdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gaSAqIHN0cmlkZSxcblx0XHRcdFx0XHRcdG9mZnNldFAgPSBvZmZzZXQgLSBzdHJpZGUsXG5cdFx0XHRcdFx0XHRvZmZzZXROID0gb2Zmc2V0ICsgc3RyaWRlO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gdmFsdWVzWyBvZmZzZXQgKyBqIF07XG5cblx0XHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0UCArIGogXSB8fFxuXHRcdFx0XHRcdFx0XHR2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXROICsgaiBdICkge1xuXG5cdFx0XHRcdFx0XHRcdGtlZXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRrZWVwID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW4tcGxhY2UgY29tcGFjdGlvblxuXG5cdFx0XHRpZiAoIGtlZXAgKSB7XG5cblx0XHRcdFx0aWYgKCBpICE9PSB3cml0ZUluZGV4ICkge1xuXG5cdFx0XHRcdFx0dGltZXNbIHdyaXRlSW5kZXggXSA9IHRpbWVzWyBpIF07XG5cblx0XHRcdFx0XHRjb25zdCByZWFkT2Zmc2V0ID0gaSAqIHN0cmlkZSxcblx0XHRcdFx0XHRcdHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHR2YWx1ZXNbIHdyaXRlT2Zmc2V0ICsgaiBdID0gdmFsdWVzWyByZWFkT2Zmc2V0ICsgaiBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQrKyB3cml0ZUluZGV4O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBmbHVzaCBsYXN0IGtleWZyYW1lIChjb21wYWN0aW9uIGxvb2tzIGFoZWFkKVxuXG5cdFx0aWYgKCBsYXN0SW5kZXggPiAwICkge1xuXG5cdFx0XHR0aW1lc1sgd3JpdGVJbmRleCBdID0gdGltZXNbIGxhc3RJbmRleCBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgcmVhZE9mZnNldCA9IGxhc3RJbmRleCAqIHN0cmlkZSwgd3JpdGVPZmZzZXQgPSB3cml0ZUluZGV4ICogc3RyaWRlLCBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xuXG5cdFx0XHRcdHZhbHVlc1sgd3JpdGVPZmZzZXQgKyBqIF0gPSB2YWx1ZXNbIHJlYWRPZmZzZXQgKyBqIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Kysgd3JpdGVJbmRleDtcblxuXHRcdH1cblxuXHRcdGlmICggd3JpdGVJbmRleCAhPT0gdGltZXMubGVuZ3RoICkge1xuXG5cdFx0XHR0aGlzLnRpbWVzID0gdGltZXMuc2xpY2UoIDAsIHdyaXRlSW5kZXggKTtcblx0XHRcdHRoaXMudmFsdWVzID0gdmFsdWVzLnNsaWNlKCAwLCB3cml0ZUluZGV4ICogc3RyaWRlICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnRpbWVzID0gdGltZXM7XG5cdFx0XHR0aGlzLnZhbHVlcyA9IHZhbHVlcztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcy5zbGljZSgpO1xuXHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzLnNsaWNlKCk7XG5cblx0XHRjb25zdCBUeXBlZEtleWZyYW1lVHJhY2sgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHRcdGNvbnN0IHRyYWNrID0gbmV3IFR5cGVkS2V5ZnJhbWVUcmFjayggdGhpcy5uYW1lLCB0aW1lcywgdmFsdWVzICk7XG5cblx0XHQvLyBJbnRlcnBvbGFudCBhcmd1bWVudCB0byBjb25zdHJ1Y3RvciBpcyBub3Qgc2F2ZWQsIHNvIGNvcHkgdGhlIGZhY3RvcnkgbWV0aG9kIGRpcmVjdGx5LlxuXHRcdHRyYWNrLmNyZWF0ZUludGVycG9sYW50ID0gdGhpcy5jcmVhdGVJbnRlcnBvbGFudDtcblxuXHRcdHJldHVybiB0cmFjaztcblxuXHR9XG5cbn1cblxuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVGltZUJ1ZmZlclR5cGUgPSBGbG9hdDMyQXJyYXk7XG5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZUJ1ZmZlclR5cGUgPSBGbG9hdDMyQXJyYXk7XG5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRlTGluZWFyO1xuXG4vKipcbiAqIEEgVHJhY2sgb2YgQm9vbGVhbiBrZXlmcmFtZSB2YWx1ZXMuXG4gKi9cbmNsYXNzIEJvb2xlYW5LZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7XG5cblx0Ly8gTm8gaW50ZXJwb2xhdGlvbiBwYXJhbWV0ZXIgYmVjYXVzZSBvbmx5IEludGVycG9sYXRlRGlzY3JldGUgaXMgdmFsaWQuXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0aW1lcywgdmFsdWVzICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKTtcblxuXHR9XG5cbn1cblxuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnYm9vbCc7XG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlID0gQXJyYXk7XG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhciA9IHVuZGVmaW5lZDtcbkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGggPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBUcmFjayBvZiBrZXlmcmFtZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgY29sb3IuXG4gKi9cbmNsYXNzIENvbG9yS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge31cblxuQ29sb3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ2NvbG9yJztcblxuLyoqXG4gKiBBIFRyYWNrIG9mIG51bWVyaWMga2V5ZnJhbWUgdmFsdWVzLlxuICovXG5jbGFzcyBOdW1iZXJLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7fVxuXG5OdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ251bWJlcic7XG5cbi8qKlxuICogU3BoZXJpY2FsIGxpbmVhciB1bml0IHF1YXRlcm5pb24gaW50ZXJwb2xhbnQuXG4gKi9cblxuY2xhc3MgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFx0c3VwZXIoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0aW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG5cdFx0XHRhbHBoYSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKTtcblxuXHRcdGxldCBvZmZzZXQgPSBpMSAqIHN0cmlkZTtcblxuXHRcdGZvciAoIGxldCBlbmQgPSBvZmZzZXQgKyBzdHJpZGU7IG9mZnNldCAhPT0gZW5kOyBvZmZzZXQgKz0gNCApIHtcblxuXHRcdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIHJlc3VsdCwgMCwgdmFsdWVzLCBvZmZzZXQgLSBzdHJpZGUsIHZhbHVlcywgb2Zmc2V0LCBhbHBoYSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBBIFRyYWNrIG9mIHF1YXRlcm5pb24ga2V5ZnJhbWUgdmFsdWVzLlxuICovXG5jbGFzcyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge1xuXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhciggcmVzdWx0ICkge1xuXG5cdFx0cmV0dXJuIG5ldyBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcblxuXHR9XG5cbn1cblxuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAncXVhdGVybmlvbic7XG4vLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG4vLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWQ7XG5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgVHJhY2sgdGhhdCBpbnRlcnBvbGF0ZXMgU3RyaW5nc1xuICovXG5jbGFzcyBTdHJpbmdLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7XG5cblx0Ly8gTm8gaW50ZXJwb2xhdGlvbiBwYXJhbWV0ZXIgYmVjYXVzZSBvbmx5IEludGVycG9sYXRlRGlzY3JldGUgaXMgdmFsaWQuXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0aW1lcywgdmFsdWVzICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKTtcblxuXHR9XG5cbn1cblxuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdzdHJpbmcnO1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlID0gQXJyYXk7XG5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRlRGlzY3JldGU7XG5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIgPSB1bmRlZmluZWQ7XG5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGggPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBUcmFjayBvZiB2ZWN0b3JlZCBrZXlmcmFtZSB2YWx1ZXMuXG4gKi9cbmNsYXNzIFZlY3RvcktleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHt9XG5cblZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAndmVjdG9yJztcblxuY2xhc3MgQW5pbWF0aW9uQ2xpcCB7XG5cblx0Y29uc3RydWN0b3IoIG5hbWUgPSAnJywgZHVyYXRpb24gPSAtIDEsIHRyYWNrcyA9IFtdLCBibGVuZE1vZGUgPSBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMudHJhY2tzID0gdHJhY2tzO1xuXHRcdHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0XHR0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcblxuXHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0Ly8gdGhpcyBtZWFucyBpdCBzaG91bGQgZmlndXJlIG91dCBpdHMgZHVyYXRpb24gYnkgc2Nhbm5pbmcgdGhlIHRyYWNrc1xuXHRcdGlmICggdGhpcy5kdXJhdGlvbiA8IDAgKSB7XG5cblx0XHRcdHRoaXMucmVzZXREdXJhdGlvbigpO1xuXG5cdFx0fVxuXG5cdH1cblxuXG5cdHN0YXRpYyBwYXJzZSgganNvbiApIHtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdLFxuXHRcdFx0anNvblRyYWNrcyA9IGpzb24udHJhY2tzLFxuXHRcdFx0ZnJhbWVUaW1lID0gMS4wIC8gKCBqc29uLmZwcyB8fCAxLjAgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGpzb25UcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHR0cmFja3MucHVzaCggcGFyc2VLZXlmcmFtZVRyYWNrKCBqc29uVHJhY2tzWyBpIF0gKS5zY2FsZSggZnJhbWVUaW1lICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGNsaXAgPSBuZXcgdGhpcygganNvbi5uYW1lLCBqc29uLmR1cmF0aW9uLCB0cmFja3MsIGpzb24uYmxlbmRNb2RlICk7XG5cdFx0Y2xpcC51dWlkID0ganNvbi51dWlkO1xuXG5cdFx0cmV0dXJuIGNsaXA7XG5cblx0fVxuXG5cdHN0YXRpYyB0b0pTT04oIGNsaXAgKSB7XG5cblx0XHRjb25zdCB0cmFja3MgPSBbXSxcblx0XHRcdGNsaXBUcmFja3MgPSBjbGlwLnRyYWNrcztcblxuXHRcdGNvbnN0IGpzb24gPSB7XG5cblx0XHRcdCduYW1lJzogY2xpcC5uYW1lLFxuXHRcdFx0J2R1cmF0aW9uJzogY2xpcC5kdXJhdGlvbixcblx0XHRcdCd0cmFja3MnOiB0cmFja3MsXG5cdFx0XHQndXVpZCc6IGNsaXAudXVpZCxcblx0XHRcdCdibGVuZE1vZGUnOiBjbGlwLmJsZW5kTW9kZVxuXG5cdFx0fTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGNsaXBUcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHR0cmFja3MucHVzaCggS2V5ZnJhbWVUcmFjay50b0pTT04oIGNsaXBUcmFja3NbIGkgXSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ganNvbjtcblxuXHR9XG5cblx0c3RhdGljIENyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKCBuYW1lLCBtb3JwaFRhcmdldFNlcXVlbmNlLCBmcHMsIG5vTG9vcCApIHtcblxuXHRcdGNvbnN0IG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoVGFyZ2V0U2VxdWVuY2UubGVuZ3RoO1xuXHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG5cdFx0XHRsZXQgdGltZXMgPSBbXTtcblx0XHRcdGxldCB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0dGltZXMucHVzaChcblx0XHRcdFx0KCBpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSApICUgbnVtTW9ycGhUYXJnZXRzLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHQoIGkgKyAxICkgJSBudW1Nb3JwaFRhcmdldHMgKTtcblxuXHRcdFx0dmFsdWVzLnB1c2goIDAsIDEsIDAgKTtcblxuXHRcdFx0Y29uc3Qgb3JkZXIgPSBnZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApO1xuXHRcdFx0dGltZXMgPSBzb3J0ZWRBcnJheSggdGltZXMsIDEsIG9yZGVyICk7XG5cdFx0XHR2YWx1ZXMgPSBzb3J0ZWRBcnJheSggdmFsdWVzLCAxLCBvcmRlciApO1xuXG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBhIGtleSBhdCB0aGUgZmlyc3QgZnJhbWUsIGR1cGxpY2F0ZSBpdCBhcyB0aGVcblx0XHRcdC8vIGxhc3QgZnJhbWUgYXMgd2VsbCBmb3IgcGVyZmVjdCBsb29wLlxuXHRcdFx0aWYgKCAhIG5vTG9vcCAmJiB0aW1lc1sgMCBdID09PSAwICkge1xuXG5cdFx0XHRcdHRpbWVzLnB1c2goIG51bU1vcnBoVGFyZ2V0cyApO1xuXHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWVzWyAwIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0cmFja3MucHVzaChcblx0XHRcdFx0bmV3IE51bWJlcktleWZyYW1lVHJhY2soXG5cdFx0XHRcdFx0Jy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbJyArIG1vcnBoVGFyZ2V0U2VxdWVuY2VbIGkgXS5uYW1lICsgJ10nLFxuXHRcdFx0XHRcdHRpbWVzLCB2YWx1ZXNcblx0XHRcdFx0KS5zY2FsZSggMS4wIC8gZnBzICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgdGhpcyggbmFtZSwgLSAxLCB0cmFja3MgKTtcblxuXHR9XG5cblx0c3RhdGljIGZpbmRCeU5hbWUoIG9iamVjdE9yQ2xpcEFycmF5LCBuYW1lICkge1xuXG5cdFx0bGV0IGNsaXBBcnJheSA9IG9iamVjdE9yQ2xpcEFycmF5O1xuXG5cdFx0aWYgKCAhIEFycmF5LmlzQXJyYXkoIG9iamVjdE9yQ2xpcEFycmF5ICkgKSB7XG5cblx0XHRcdGNvbnN0IG8gPSBvYmplY3RPckNsaXBBcnJheTtcblx0XHRcdGNsaXBBcnJheSA9IG8uZ2VvbWV0cnkgJiYgby5nZW9tZXRyeS5hbmltYXRpb25zIHx8IG8uYW5pbWF0aW9ucztcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNsaXBBcnJheS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGlmICggY2xpcEFycmF5WyBpIF0ubmFtZSA9PT0gbmFtZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gY2xpcEFycmF5WyBpIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHRzdGF0aWMgQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMoIG1vcnBoVGFyZ2V0cywgZnBzLCBub0xvb3AgKSB7XG5cblx0XHRjb25zdCBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyA9IHt9O1xuXG5cdFx0Ly8gdGVzdGVkIHdpdGggaHR0cHM6Ly9yZWdleDEwMS5jb20vIG9uIHRyaWNrIHNlcXVlbmNlc1xuXHRcdC8vIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxuXHRcdGNvbnN0IHBhdHRlcm4gPSAvXihbXFx3LV0qPykoW1xcZF0rKSQvO1xuXG5cdFx0Ly8gc29ydCBtb3JwaCB0YXJnZXQgbmFtZXMgaW50byBhbmltYXRpb24gZ3JvdXBzIGJhc2VkXG5cdFx0Ly8gcGF0dGVybnMgbGlrZSBXYWxrXzAwMSwgV2Fsa18wMDIsIFJ1bl8wMDEsIFJ1bl8wMDJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xuXHRcdFx0Y29uc3QgcGFydHMgPSBtb3JwaFRhcmdldC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XG5cblx0XHRcdGlmICggcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRjb25zdCBuYW1lID0gcGFydHNbIDEgXTtcblxuXHRcdFx0XHRsZXQgYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoICEgYW5pbWF0aW9uTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdFx0YW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSA9IGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhbmltYXRpb25Nb3JwaFRhcmdldHMucHVzaCggbW9ycGhUYXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2xpcHMgPSBbXTtcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdGNsaXBzLnB1c2goIHRoaXMuQ3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2UoIG5hbWUsIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF0sIGZwcywgbm9Mb29wICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBjbGlwcztcblxuXHR9XG5cblx0Ly8gcGFyc2UgdGhlIGFuaW1hdGlvbi5oaWVyYXJjaHkgZm9ybWF0XG5cdHN0YXRpYyBwYXJzZUFuaW1hdGlvbiggYW5pbWF0aW9uLCBib25lcyApIHtcblxuXHRcdGlmICggISBhbmltYXRpb24gKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5BbmltYXRpb25DbGlwOiBObyBhbmltYXRpb24gaW4gSlNPTkxvYWRlciBkYXRhLicgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYWRkTm9uZW1wdHlUcmFjayA9IGZ1bmN0aW9uICggdHJhY2tUeXBlLCB0cmFja05hbWUsIGFuaW1hdGlvbktleXMsIHByb3BlcnR5TmFtZSwgZGVzdFRyYWNrcyApIHtcblxuXHRcdFx0Ly8gb25seSByZXR1cm4gdHJhY2sgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGtleXMuXG5cdFx0XHRpZiAoIGFuaW1hdGlvbktleXMubGVuZ3RoICE9PSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IHRpbWVzID0gW107XG5cdFx0XHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRcdGZsYXR0ZW5KU09OKCBhbmltYXRpb25LZXlzLCB0aW1lcywgdmFsdWVzLCBwcm9wZXJ0eU5hbWUgKTtcblxuXHRcdFx0XHQvLyBlbXB0eSBrZXlzIGFyZSBmaWx0ZXJlZCBvdXQsIHNvIGNoZWNrIGFnYWluXG5cdFx0XHRcdGlmICggdGltZXMubGVuZ3RoICE9PSAwICkge1xuXG5cdFx0XHRcdFx0ZGVzdFRyYWNrcy5wdXNoKCBuZXcgdHJhY2tUeXBlKCB0cmFja05hbWUsIHRpbWVzLCB2YWx1ZXMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXG5cdFx0Y29uc3QgY2xpcE5hbWUgPSBhbmltYXRpb24ubmFtZSB8fCAnZGVmYXVsdCc7XG5cdFx0Y29uc3QgZnBzID0gYW5pbWF0aW9uLmZwcyB8fCAzMDtcblx0XHRjb25zdCBibGVuZE1vZGUgPSBhbmltYXRpb24uYmxlbmRNb2RlO1xuXG5cdFx0Ly8gYXV0b21hdGljIGxlbmd0aCBkZXRlcm1pbmF0aW9uIGluIEFuaW1hdGlvbkNsaXAuXG5cdFx0bGV0IGR1cmF0aW9uID0gYW5pbWF0aW9uLmxlbmd0aCB8fCAtIDE7XG5cblx0XHRjb25zdCBoaWVyYXJjaHlUcmFja3MgPSBhbmltYXRpb24uaGllcmFyY2h5IHx8IFtdO1xuXG5cdFx0Zm9yICggbGV0IGggPSAwOyBoIDwgaGllcmFyY2h5VHJhY2tzLmxlbmd0aDsgaCArKyApIHtcblxuXHRcdFx0Y29uc3QgYW5pbWF0aW9uS2V5cyA9IGhpZXJhcmNoeVRyYWNrc1sgaCBdLmtleXM7XG5cblx0XHRcdC8vIHNraXAgZW1wdHkgdHJhY2tzXG5cdFx0XHRpZiAoICEgYW5pbWF0aW9uS2V5cyB8fCBhbmltYXRpb25LZXlzLmxlbmd0aCA9PT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIHRhcmdldHNcblx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHQvLyBmaWd1cmUgb3V0IGFsbCBtb3JwaCB0YXJnZXRzIHVzZWQgaW4gdGhpcyB0cmFja1xuXHRcdFx0XHRjb25zdCBtb3JwaFRhcmdldE5hbWVzID0ge307XG5cblx0XHRcdFx0bGV0IGs7XG5cblx0XHRcdFx0Zm9yICggayA9IDA7IGsgPCBhbmltYXRpb25LZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IG0gPSAwOyBtIDwgYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0bW9ycGhUYXJnZXROYW1lc1sgYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdIF0gPSAtIDE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm9cblx0XHRcdFx0Ly8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGV4Y2VwdCBmb3IgdGhlIGtleXMgaW4gd2hpY2hcblx0XHRcdFx0Ly8gdGhlIG1vcnBoVGFyZ2V0IGlzIG5hbWVkLlxuXHRcdFx0XHRmb3IgKCBjb25zdCBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHRpbWVzID0gW107XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgbSA9IDA7IG0gIT09IGFuaW1hdGlvbktleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyArKyBtICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhbmltYXRpb25LZXkgPSBhbmltYXRpb25LZXlzWyBrIF07XG5cblx0XHRcdFx0XHRcdHRpbWVzLnB1c2goIGFuaW1hdGlvbktleS50aW1lICk7XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggKCBhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSApID8gMSA6IDAgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyYWNrcy5wdXNoKCBuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjayggJy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZHVyYXRpb24gPSBtb3JwaFRhcmdldE5hbWVzLmxlbmd0aCAqIGZwcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyAuLi5hc3N1bWUgc2tlbGV0YWwgYW5pbWF0aW9uXG5cblx0XHRcdFx0Y29uc3QgYm9uZU5hbWUgPSAnLmJvbmVzWycgKyBib25lc1sgaCBdLm5hbWUgKyAnXSc7XG5cblx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhcblx0XHRcdFx0XHRWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucG9zaXRpb24nLFxuXHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdwb3MnLCB0cmFja3MgKTtcblxuXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxuXHRcdFx0XHRcdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucXVhdGVybmlvbicsXG5cdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3JvdCcsIHRyYWNrcyApO1xuXG5cdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXG5cdFx0XHRcdFx0VmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnNjYWxlJyxcblx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAnc2NsJywgdHJhY2tzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdHJhY2tzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBjbGlwID0gbmV3IHRoaXMoIGNsaXBOYW1lLCBkdXJhdGlvbiwgdHJhY2tzLCBibGVuZE1vZGUgKTtcblxuXHRcdHJldHVybiBjbGlwO1xuXG5cdH1cblxuXHRyZXNldER1cmF0aW9uKCkge1xuXG5cdFx0Y29uc3QgdHJhY2tzID0gdGhpcy50cmFja3M7XG5cdFx0bGV0IGR1cmF0aW9uID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbIGkgXTtcblxuXHRcdFx0ZHVyYXRpb24gPSBNYXRoLm1heCggZHVyYXRpb24sIHRyYWNrLnRpbWVzWyB0cmFjay50aW1lcy5sZW5ndGggLSAxIF0gKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmltKCkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLnRyYWNrc1sgaSBdLnRyaW0oIDAsIHRoaXMuZHVyYXRpb24gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR2YWxpZGF0ZSgpIHtcblxuXHRcdGxldCB2YWxpZCA9IHRydWU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhbGlkID0gdmFsaWQgJiYgdGhpcy50cmFja3NbIGkgXS52YWxpZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbGlkO1xuXG5cdH1cblxuXHRvcHRpbWl6ZSgpIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy50cmFja3NbIGkgXS5vcHRpbWl6ZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0Y29uc3QgdHJhY2tzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHRyYWNrcy5wdXNoKCB0aGlzLnRyYWNrc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5uYW1lLCB0aGlzLmR1cmF0aW9uLCB0cmFja3MsIHRoaXMuYmxlbmRNb2RlICk7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvSlNPTiggdGhpcyApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBnZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lKCB0eXBlTmFtZSApIHtcblxuXHRzd2l0Y2ggKCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXG5cdFx0Y2FzZSAnc2NhbGFyJzpcblx0XHRjYXNlICdkb3VibGUnOlxuXHRcdGNhc2UgJ2Zsb2F0Jzpcblx0XHRjYXNlICdudW1iZXInOlxuXHRcdGNhc2UgJ2ludGVnZXInOlxuXG5cdFx0XHRyZXR1cm4gTnVtYmVyS2V5ZnJhbWVUcmFjaztcblxuXHRcdGNhc2UgJ3ZlY3Rvcic6XG5cdFx0Y2FzZSAndmVjdG9yMic6XG5cdFx0Y2FzZSAndmVjdG9yMyc6XG5cdFx0Y2FzZSAndmVjdG9yNCc6XG5cblx0XHRcdHJldHVybiBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuXG5cdFx0Y2FzZSAnY29sb3InOlxuXG5cdFx0XHRyZXR1cm4gQ29sb3JLZXlmcmFtZVRyYWNrO1xuXG5cdFx0Y2FzZSAncXVhdGVybmlvbic6XG5cblx0XHRcdHJldHVybiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcblxuXHRcdGNhc2UgJ2Jvb2wnOlxuXHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXG5cdFx0XHRyZXR1cm4gQm9vbGVhbktleWZyYW1lVHJhY2s7XG5cblx0XHRjYXNlICdzdHJpbmcnOlxuXG5cdFx0XHRyZXR1cm4gU3RyaW5nS2V5ZnJhbWVUcmFjaztcblxuXHR9XG5cblx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVW5zdXBwb3J0ZWQgdHlwZU5hbWU6ICcgKyB0eXBlTmFtZSApO1xuXG59XG5cbmZ1bmN0aW9uIHBhcnNlS2V5ZnJhbWVUcmFjaygganNvbiApIHtcblxuXHRpZiAoIGpzb24udHlwZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogdHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2UnICk7XG5cblx0fVxuXG5cdGNvbnN0IHRyYWNrVHlwZSA9IGdldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoIGpzb24udHlwZSApO1xuXG5cdGlmICgganNvbi50aW1lcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Y29uc3QgdGltZXMgPSBbXSwgdmFsdWVzID0gW107XG5cblx0XHRmbGF0dGVuSlNPTigganNvbi5rZXlzLCB0aW1lcywgdmFsdWVzLCAndmFsdWUnICk7XG5cblx0XHRqc29uLnRpbWVzID0gdGltZXM7XG5cdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XG5cblx0fVxuXG5cdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHBhcnNlIG1ldGhvZFxuXHRpZiAoIHRyYWNrVHlwZS5wYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0cmV0dXJuIHRyYWNrVHlwZS5wYXJzZSgganNvbiApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgYSBjb25zdHJ1Y3RvciBjb21wYXRpYmxlIHdpdGggdGhlIGJhc2Vcblx0XHRyZXR1cm4gbmV3IHRyYWNrVHlwZSgganNvbi5uYW1lLCBqc29uLnRpbWVzLCBqc29uLnZhbHVlcywganNvbi5pbnRlcnBvbGF0aW9uICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IENhY2hlID0ge1xuXG5cdGVuYWJsZWQ6IGZhbHNlLFxuXG5cdGZpbGVzOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBmaWxlICkge1xuXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xuXG5cdFx0dGhpcy5maWxlc1sga2V5IF0gPSBmaWxlO1xuXG5cdH0sXG5cblx0Z2V0OiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsZXNbIGtleSBdO1xuXG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcblxuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmZpbGVzID0ge307XG5cblx0fVxuXG59O1xuXG5jbGFzcyBMb2FkaW5nTWFuYWdlciB7XG5cblx0Y29uc3RydWN0b3IoIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGxldCBpc0xvYWRpbmcgPSBmYWxzZTtcblx0XHRsZXQgaXRlbXNMb2FkZWQgPSAwO1xuXHRcdGxldCBpdGVtc1RvdGFsID0gMDtcblx0XHRsZXQgdXJsTW9kaWZpZXIgPSB1bmRlZmluZWQ7XG5cdFx0Y29uc3QgaGFuZGxlcnMgPSBbXTtcblxuXHRcdC8vIFJlZmVyIHRvICM1Njg5IGZvciB0aGUgcmVhc29uIHdoeSB3ZSBkb24ndCBzZXQgLm9uU3RhcnRcblx0XHQvLyBpbiB0aGUgY29uc3RydWN0b3JcblxuXHRcdHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLm9uTG9hZCA9IG9uTG9hZDtcblx0XHR0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xuXHRcdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG5cblx0XHR0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0XHRpdGVtc1RvdGFsICsrO1xuXG5cdFx0XHRpZiAoIGlzTG9hZGluZyA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5vblN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5vblN0YXJ0KCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlzTG9hZGluZyA9IHRydWU7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRcdGl0ZW1zTG9hZGVkICsrO1xuXG5cdFx0XHRpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzY29wZS5vblByb2dyZXNzKCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCApIHtcblxuXHRcdFx0XHRpc0xvYWRpbmcgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0c2NvcGUub25Mb2FkKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5pdGVtRXJyb3IgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5vbkVycm9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2NvcGUub25FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLnJlc29sdmVVUkwgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdFx0aWYgKCB1cmxNb2RpZmllciApIHtcblxuXHRcdFx0XHRyZXR1cm4gdXJsTW9kaWZpZXIoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1cmw7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRVUkxNb2RpZmllciA9IGZ1bmN0aW9uICggdHJhbnNmb3JtICkge1xuXG5cdFx0XHR1cmxNb2RpZmllciA9IHRyYW5zZm9ybTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5hZGRIYW5kbGVyID0gZnVuY3Rpb24gKCByZWdleCwgbG9hZGVyICkge1xuXG5cdFx0XHRoYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMucmVtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uICggcmVnZXggKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZiggcmVnZXggKTtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaW5kZXgsIDIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEhhbmRsZXIgPSBmdW5jdGlvbiAoIGZpbGUgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuXHRcdFx0XHRjb25zdCByZWdleCA9IGhhbmRsZXJzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGxvYWRlciA9IGhhbmRsZXJzWyBpICsgMSBdO1xuXG5cdFx0XHRcdGlmICggcmVnZXguZ2xvYmFsICkgcmVnZXgubGFzdEluZGV4ID0gMDsgLy8gc2VlICMxNzkyMFxuXG5cdFx0XHRcdGlmICggcmVnZXgudGVzdCggZmlsZSApICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGxvYWRlcjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9O1xuXG5cdH1cblxufVxuXG5jb25zdCBEZWZhdWx0TG9hZGluZ01hbmFnZXIgPSAvKkBfX1BVUkVfXyovIG5ldyBMb2FkaW5nTWFuYWdlcigpO1xuXG5jbGFzcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblx0XHR0aGlzLnBhdGggPSAnJztcblx0XHR0aGlzLnJlc291cmNlUGF0aCA9ICcnO1xuXHRcdHRoaXMucmVxdWVzdEhlYWRlciA9IHt9O1xuXG5cdH1cblxuXHRsb2FkKCAvKiB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciAqLyApIHt9XG5cblx0bG9hZEFzeW5jKCB1cmwsIG9uUHJvZ3Jlc3MgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSwgcmVqZWN0ICkge1xuXG5cdFx0XHRzY29wZS5sb2FkKCB1cmwsIHJlc29sdmUsIG9uUHJvZ3Jlc3MsIHJlamVjdCApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRwYXJzZSggLyogZGF0YSAqLyApIHt9XG5cblx0c2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICkge1xuXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRXaXRoQ3JlZGVudGlhbHMoIHZhbHVlICkge1xuXG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0UGF0aCggcGF0aCApIHtcblxuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFJlc291cmNlUGF0aCggcmVzb3VyY2VQYXRoICkge1xuXG5cdFx0dGhpcy5yZXNvdXJjZVBhdGggPSByZXNvdXJjZVBhdGg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFJlcXVlc3RIZWFkZXIoIHJlcXVlc3RIZWFkZXIgKSB7XG5cblx0XHR0aGlzLnJlcXVlc3RIZWFkZXIgPSByZXF1ZXN0SGVhZGVyO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5Mb2FkZXIuREVGQVVMVF9NQVRFUklBTF9OQU1FID0gJ19fREVGQVVMVCc7XG5cbmNvbnN0IGxvYWRpbmcgPSB7fTtcblxuY2xhc3MgSHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXG5cdGNvbnN0cnVjdG9yKCBtZXNzYWdlLCByZXNwb25zZSApIHtcblxuXHRcdHN1cGVyKCBtZXNzYWdlICk7XG5cdFx0dGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBGaWxlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHVybCA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcblxuXHRcdHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKCB1cmwgKTtcblxuXHRcdGNvbnN0IGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XG5cblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdFx0c2V0VGltZW91dCggKCkgPT4ge1xuXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcblxuXHRcdFx0XHR0aGlzLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdH0sIDAgKTtcblxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcblxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHJlcXVlc3QgaXMgZHVwbGljYXRlXG5cblx0XHRpZiAoIGxvYWRpbmdbIHVybCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxvYWRpbmdbIHVybCBdLnB1c2goIHtcblxuXHRcdFx0XHRvbkxvYWQ6IG9uTG9hZCxcblx0XHRcdFx0b25Qcm9ncmVzczogb25Qcm9ncmVzcyxcblx0XHRcdFx0b25FcnJvcjogb25FcnJvclxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdC8vIEluaXRpYWxpc2UgYXJyYXkgZm9yIGR1cGxpY2F0ZSByZXF1ZXN0c1xuXHRcdGxvYWRpbmdbIHVybCBdID0gW107XG5cblx0XHRsb2FkaW5nWyB1cmwgXS5wdXNoKCB7XG5cdFx0XHRvbkxvYWQ6IG9uTG9hZCxcblx0XHRcdG9uUHJvZ3Jlc3M6IG9uUHJvZ3Jlc3MsXG5cdFx0XHRvbkVycm9yOiBvbkVycm9yLFxuXHRcdH0gKTtcblxuXHRcdC8vIGNyZWF0ZSByZXF1ZXN0XG5cdFx0Y29uc3QgcmVxID0gbmV3IFJlcXVlc3QoIHVybCwge1xuXHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnMoIHRoaXMucmVxdWVzdEhlYWRlciApLFxuXHRcdFx0Y3JlZGVudGlhbHM6IHRoaXMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJyxcblx0XHRcdC8vIEFuIGFib3J0IGNvbnRyb2xsZXIgY291bGQgYmUgYWRkZWQgd2l0aGluIGEgZnV0dXJlIFBSXG5cdFx0fSApO1xuXG5cdFx0Ly8gcmVjb3JkIHN0YXRlcyAoIGF2b2lkIGRhdGEgcmFjZSApXG5cdFx0Y29uc3QgbWltZVR5cGUgPSB0aGlzLm1pbWVUeXBlO1xuXHRcdGNvbnN0IHJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuXG5cdFx0Ly8gc3RhcnQgdGhlIGZldGNoXG5cdFx0ZmV0Y2goIHJlcSApXG5cdFx0XHQudGhlbiggcmVzcG9uc2UgPT4ge1xuXG5cdFx0XHRcdGlmICggcmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAwICkge1xuXG5cdFx0XHRcdFx0Ly8gU29tZSBicm93c2VycyByZXR1cm4gSFRUUCBTdGF0dXMgMCB3aGVuIHVzaW5nIG5vbi1odHRwIHByb3RvY29sXG5cdFx0XHRcdFx0Ly8gZS5nLiAnZmlsZTovLycgb3IgJ2RhdGE6Ly8nLiBIYW5kbGUgYXMgc3VjY2Vzcy5cblxuXHRcdFx0XHRcdGlmICggcmVzcG9uc2Uuc3RhdHVzID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GaWxlTG9hZGVyOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFdvcmthcm91bmQ6IENoZWNraW5nIGlmIHJlc3BvbnNlLmJvZHkgPT09IHVuZGVmaW5lZCBmb3IgQWxpcGF5IGJyb3dzZXIgIzIzNTQ4XG5cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzcG9uc2UuYm9keSA9PT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xuXHRcdFx0XHRcdGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG5cblx0XHRcdFx0XHQvLyBOZ2lueCBuZWVkcyBYLUZpbGUtU2l6ZSBjaGVja1xuXHRcdFx0XHRcdC8vIGh0dHBzOi8vc2VydmVyZmF1bHQuY29tL3F1ZXN0aW9ucy80ODI4NzUvd2h5LWRvZXMtbmdpbngtcmVtb3ZlLWNvbnRlbnQtbGVuZ3RoLWhlYWRlci1mb3ItY2h1bmtlZC1jb250ZW50XG5cdFx0XHRcdFx0Y29uc3QgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCAnWC1GaWxlLVNpemUnICkgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoICdDb250ZW50LUxlbmd0aCcgKTtcblx0XHRcdFx0XHRjb25zdCB0b3RhbCA9IGNvbnRlbnRMZW5ndGggPyBwYXJzZUludCggY29udGVudExlbmd0aCApIDogMDtcblx0XHRcdFx0XHRjb25zdCBsZW5ndGhDb21wdXRhYmxlID0gdG90YWwgIT09IDA7XG5cdFx0XHRcdFx0bGV0IGxvYWRlZCA9IDA7XG5cblx0XHRcdFx0XHQvLyBwZXJpb2RpY2FsbHkgcmVhZCBkYXRhIGludG8gdGhlIG5ldyBzdHJlYW0gdHJhY2tpbmcgd2hpbGUgZG93bmxvYWQgcHJvZ3Jlc3Ncblx0XHRcdFx0XHRjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oIHtcblx0XHRcdFx0XHRcdHN0YXJ0KCBjb250cm9sbGVyICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlYWREYXRhKCk7XG5cblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gcmVhZERhdGEoKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZWFkZXIucmVhZCgpLnRoZW4oICggeyBkb25lLCB2YWx1ZSB9ICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRvbmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udHJvbGxlci5jbG9zZSgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGV2ZW50ID0gbmV3IFByb2dyZXNzRXZlbnQoICdwcm9ncmVzcycsIHsgbGVuZ3RoQ29tcHV0YWJsZSwgbG9hZGVkLCB0b3RhbCB9ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sub25Qcm9ncmVzcyApIGNhbGxiYWNrLm9uUHJvZ3Jlc3MoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuZW5xdWV1ZSggdmFsdWUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVhZERhdGEoKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fSwgKCBlICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb250cm9sbGVyLmVycm9yKCBlICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKCBzdHJlYW0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEh0dHBFcnJvciggYGZldGNoIGZvciBcIiR7cmVzcG9uc2UudXJsfVwiIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsIHJlc3BvbnNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IClcblx0XHRcdC50aGVuKCByZXNwb25zZSA9PiB7XG5cblx0XHRcdFx0c3dpdGNoICggcmVzcG9uc2VUeXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnYXJyYXlidWZmZXInOlxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcblxuXHRcdFx0XHRcdGNhc2UgJ2Jsb2InOlxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZG9jdW1lbnQnOlxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UudGV4dCgpXG5cdFx0XHRcdFx0XHRcdC50aGVuKCB0ZXh0ID0+IHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyggdGV4dCwgbWltZVR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRjYXNlICdqc29uJzpcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdGlmICggbWltZVR5cGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHNuaWZmIGVuY29kaW5nXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlID0gL2NoYXJzZXQ9XCI/KFteO1wiXFxzXSopXCI/L2k7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGV4ZWMgPSByZS5leGVjKCBtaW1lVHlwZSApO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBsYWJlbCA9IGV4ZWMgJiYgZXhlY1sgMSBdID8gZXhlY1sgMSBdLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoIGxhYmVsICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpLnRoZW4oIGFiID0+IGRlY29kZXIuZGVjb2RlKCBhYiApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKVxuXHRcdFx0LnRoZW4oIGRhdGEgPT4ge1xuXG5cdFx0XHRcdC8vIEFkZCB0byBjYWNoZSBvbmx5IG9uIEhUVFAgc3VjY2Vzcywgc28gdGhhdCB3ZSBkbyBub3QgY2FjaGVcblx0XHRcdFx0Ly8gZXJyb3IgcmVzcG9uc2UgYm9kaWVzIGFzIHByb3BlciByZXNwb25zZXMgdG8gcmVxdWVzdHMuXG5cdFx0XHRcdENhY2hlLmFkZCggdXJsLCBkYXRhICk7XG5cblx0XHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gbG9hZGluZ1sgdXJsIF07XG5cdFx0XHRcdGRlbGV0ZSBsb2FkaW5nWyB1cmwgXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrLm9uTG9hZCApIGNhbGxiYWNrLm9uTG9hZCggZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApXG5cdFx0XHQuY2F0Y2goIGVyciA9PiB7XG5cblx0XHRcdFx0Ly8gQWJvcnQgZXJyb3JzIGFuZCBvdGhlciBlcnJvcnMgYXJlIGhhbmRsZWQgdGhlIHNhbWVcblxuXHRcdFx0XHRjb25zdCBjYWxsYmFja3MgPSBsb2FkaW5nWyB1cmwgXTtcblxuXHRcdFx0XHRpZiAoIGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2hlbiBvbkxvYWQgd2FzIGNhbGxlZCBhbmQgdXJsIHdhcyBkZWxldGVkIGluIGBsb2FkaW5nYFxuXHRcdFx0XHRcdHRoaXMubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXHRcdFx0XHRcdHRocm93IGVycjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGxvYWRpbmdbIHVybCBdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sub25FcnJvciApIGNhbGxiYWNrLm9uRXJyb3IoIGVyciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fSApXG5cdFx0XHQuZmluYWxseSggKCkgPT4ge1xuXG5cdFx0XHRcdHRoaXMubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0dGhpcy5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0fVxuXG5cdHNldFJlc3BvbnNlVHlwZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRNaW1lVHlwZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLm1pbWVUeXBlID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIEFuaW1hdGlvbkxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0cGFyc2UoIGpzb24gKSB7XG5cblx0XHRjb25zdCBhbmltYXRpb25zID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2UoIGpzb25bIGkgXSApO1xuXG5cdFx0XHRhbmltYXRpb25zLnB1c2goIGNsaXAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhbmltYXRpb25zO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxuICpcbiAqIFN1YiBjbGFzc2VzIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBwYXJzZSgpIG1ldGhvZCB3aGljaCB3aWxsIGJlIHVzZWQgaW4gbG9hZCgpLlxuICovXG5cbmNsYXNzIENvbXByZXNzZWRUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgaW1hZ2VzID0gW107XG5cblx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IENvbXByZXNzZWRUZXh0dXJlKCk7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cblx0XHRsZXQgbG9hZGVkID0gMDtcblxuXHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBpICkge1xuXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdGNvbnN0IHRleERhdGFzID0gc2NvcGUucGFyc2UoIGJ1ZmZlciwgdHJ1ZSApO1xuXG5cdFx0XHRcdGltYWdlc1sgaSBdID0ge1xuXHRcdFx0XHRcdHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcblx0XHRcdFx0XHRmb3JtYXQ6IHRleERhdGFzLmZvcm1hdCxcblx0XHRcdFx0XHRtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0bG9hZGVkICs9IDE7XG5cblx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuXHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdH1cblxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XG5cblx0XHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdGNvbnN0IHRleERhdGFzID0gc2NvcGUucGFyc2UoIGJ1ZmZlciwgdHJ1ZSApO1xuXG5cdFx0XHRcdGlmICggdGV4RGF0YXMuaXNDdWJlbWFwICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGYgPSAwOyBmIDwgZmFjZXM7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdGltYWdlc1sgZiBdID0geyBtaXBtYXBzOiBbXSB9O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIHRleERhdGFzLm1pcG1hcHNbIGYgKiB0ZXhEYXRhcy5taXBtYXBDb3VudCArIGkgXSApO1xuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlcztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXHRcdFx0XHRcdHRleHR1cmUubWlwbWFwcyA9IHRleERhdGFzLm1pcG1hcHM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBJbWFnZUxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG5cblx0XHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCggdXJsICk7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBjYWNoZWQgPSBDYWNoZS5nZXQoIHVybCApO1xuXG5cdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdH0sIDAgKTtcblxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGltYWdlID0gY3JlYXRlRWxlbWVudE5TKCAnaW1nJyApO1xuXG5cdFx0ZnVuY3Rpb24gb25JbWFnZUxvYWQoKSB7XG5cblx0XHRcdHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG5cblx0XHRcdENhY2hlLmFkZCggdXJsLCB0aGlzICk7XG5cblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzICk7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkltYWdlRXJyb3IoIGV2ZW50ICkge1xuXG5cdFx0XHRyZW1vdmVFdmVudExpc3RlbmVycygpO1xuXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG5cblx0XHRcdGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgb25JbWFnZUxvYWQsIGZhbHNlICk7XG5cdFx0XHRpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZXJyb3InLCBvbkltYWdlRXJyb3IsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIG9uSW1hZ2VMb2FkLCBmYWxzZSApO1xuXHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIG9uSW1hZ2VFcnJvciwgZmFsc2UgKTtcblxuXHRcdGlmICggdXJsLnNsaWNlKCAwLCA1ICkgIT09ICdkYXRhOicgKSB7XG5cblx0XHRcdGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG5cdFx0fVxuXG5cdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0aW1hZ2Uuc3JjID0gdXJsO1xuXG5cdFx0cmV0dXJuIGltYWdlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBDdWJlVGV4dHVyZUxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHRsb2FkKCB1cmxzLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XG5cdFx0dGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblxuXHRcdGxldCBsb2FkZWQgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmxzWyBpIF0sIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5pbWFnZXNbIGkgXSA9IGltYWdlO1xuXG5cdFx0XHRcdGxvYWRlZCArKztcblxuXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdGxvYWRUZXh0dXJlKCBpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGxvYWQgZ2VuZXJpYyBiaW5hcnkgdGV4dHVyZXMgZm9ybWF0cyAocmdiZSwgaGRyLCAuLi4pXG4gKlxuICogU3ViIGNsYXNzZXMgaGF2ZSB0byBpbXBsZW1lbnQgdGhlIHBhcnNlKCkgbWV0aG9kIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiBsb2FkKCkuXG4gKi9cblxuY2xhc3MgRGF0YVRleHR1cmVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCk7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdGxldCB0ZXhEYXRhO1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdHRleERhdGEgPSBzY29wZS5wYXJzZSggYnVmZmVyICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGVycm9yICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleERhdGEuaW1hZ2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gdGV4RGF0YS5pbWFnZTtcblxuXHRcdFx0fSBlbHNlIGlmICggdGV4RGF0YS5kYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XG5cdFx0XHRcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YS5oZWlnaHQ7XG5cdFx0XHRcdHRleHR1cmUuaW1hZ2UuZGF0YSA9IHRleERhdGEuZGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gdGV4RGF0YS53cmFwUyAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS53cmFwUyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHR0ZXh0dXJlLndyYXBUID0gdGV4RGF0YS53cmFwVCAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gdGV4RGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IHRleERhdGEubWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSB0ZXhEYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS5taW5GaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cblx0XHRcdHRleHR1cmUuYW5pc290cm9weSA9IHRleERhdGEuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS5hbmlzb3Ryb3B5IDogMTtcblxuXHRcdFx0aWYgKCB0ZXhEYXRhLmNvbG9yU3BhY2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmNvbG9yU3BhY2UgPSB0ZXhEYXRhLmNvbG9yU3BhY2U7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXhEYXRhLmZsaXBZICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5mbGlwWSA9IHRleERhdGEuZmxpcFk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXhEYXRhLmZvcm1hdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YS5mb3JtYXQ7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXhEYXRhLnR5cGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSB0ZXhEYXRhLnR5cGU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXhEYXRhLm1pcG1hcHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyOyAvLyBwcmVzdW1hYmx5Li4uXG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXhEYXRhLm1pcG1hcENvdW50ID09PSAxICkge1xuXG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGV4RGF0YS5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRleERhdGEuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSwgdGV4RGF0YSApO1xuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVGV4dHVyZUxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG59XG5cbmNsYXNzIExpZ2h0IGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBjb2xvciwgaW50ZW5zaXR5ID0gMSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpZ2h0JztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHk7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHQvLyBFbXB0eSBoZXJlIGluIGJhc2UgY2xhc3M7IHNvbWUgc3ViY2xhc3NlcyBvdmVycmlkZS5cblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXHRcdGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXG5cdFx0aWYgKCB0aGlzLmdyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XG5cblx0XHRpZiAoIHRoaXMuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcblx0XHRpZiAoIHRoaXMuYW5nbGUgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZTtcblx0XHRpZiAoIHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblx0XHRpZiAoIHRoaXMucGVudW1icmEgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LnBlbnVtYnJhID0gdGhpcy5wZW51bWJyYTtcblxuXHRcdGlmICggdGhpcy5zaGFkb3cgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LnNoYWRvdyA9IHRoaXMuc2hhZG93LnRvSlNPTigpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmNsYXNzIEhlbWlzcGhlcmVMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuXHRjb25zdHJ1Y3Rvciggc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0XHRzdXBlciggc2t5Q29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0dGhpcy5pc0hlbWlzcGhlcmVMaWdodCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0JztcblxuXHRcdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuREVGQVVMVF9VUCApO1xuXHRcdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLmdyb3VuZENvbG9yID0gbmV3IENvbG9yKCBncm91bmRDb2xvciApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLmdyb3VuZENvbG9yLmNvcHkoIHNvdXJjZS5ncm91bmRDb2xvciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9wcm9qU2NyZWVuTWF0cml4JDEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfbGlnaHRQb3NpdGlvbldvcmxkJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbG9va1RhcmdldCQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBMaWdodFNoYWRvdyB7XG5cblx0Y29uc3RydWN0b3IoIGNhbWVyYSApIHtcblxuXHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG5cdFx0dGhpcy5iaWFzID0gMDtcblx0XHR0aGlzLm5vcm1hbEJpYXMgPSAwO1xuXHRcdHRoaXMucmFkaXVzID0gMTtcblx0XHR0aGlzLmJsdXJTYW1wbGVzID0gODtcblxuXHRcdHRoaXMubWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCA1MTIsIDUxMiApO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdHRoaXMubWFwUGFzcyA9IG51bGw7XG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLl9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcblx0XHR0aGlzLl9mcmFtZUV4dGVudHMgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG5cdFx0dGhpcy5fdmlld3BvcnRDb3VudCA9IDE7XG5cblx0XHR0aGlzLl92aWV3cG9ydHMgPSBbXG5cblx0XHRcdG5ldyBWZWN0b3I0KCAwLCAwLCAxLCAxIClcblxuXHRcdF07XG5cblx0fVxuXG5cdGdldFZpZXdwb3J0Q291bnQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdmlld3BvcnRDb3VudDtcblxuXHR9XG5cblx0Z2V0RnJ1c3R1bSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9mcnVzdHVtO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaWNlcyggbGlnaHQgKSB7XG5cblx0XHRjb25zdCBzaGFkb3dDYW1lcmEgPSB0aGlzLmNhbWVyYTtcblx0XHRjb25zdCBzaGFkb3dNYXRyaXggPSB0aGlzLm1hdHJpeDtcblxuXHRcdF9saWdodFBvc2l0aW9uV29ybGQkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoIF9saWdodFBvc2l0aW9uV29ybGQkMSApO1xuXG5cdFx0X2xvb2tUYXJnZXQkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0JDEgKTtcblx0XHRzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdF9wcm9qU2NyZWVuTWF0cml4JDEubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblx0XHR0aGlzLl9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCQxICk7XG5cblx0XHRzaGFkb3dNYXRyaXguc2V0KFxuXHRcdFx0MC41LCAwLjAsIDAuMCwgMC41LFxuXHRcdFx0MC4wLCAwLjUsIDAuMCwgMC41LFxuXHRcdFx0MC4wLCAwLjAsIDAuNSwgMC41LFxuXHRcdFx0MC4wLCAwLjAsIDAuMCwgMS4wXG5cdFx0KTtcblxuXHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggX3Byb2pTY3JlZW5NYXRyaXgkMSApO1xuXG5cdH1cblxuXHRnZXRWaWV3cG9ydCggdmlld3BvcnRJbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLl92aWV3cG9ydHNbIHZpZXdwb3J0SW5kZXggXTtcblxuXHR9XG5cblx0Z2V0RnJhbWVFeHRlbnRzKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2ZyYW1lRXh0ZW50cztcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdGlmICggdGhpcy5tYXAgKSB7XG5cblx0XHRcdHRoaXMubWFwLmRpc3Bvc2UoKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tYXBQYXNzICkge1xuXG5cdFx0XHR0aGlzLm1hcFBhc3MuZGlzcG9zZSgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLmNhbWVyYSA9IHNvdXJjZS5jYW1lcmEuY2xvbmUoKTtcblxuXHRcdHRoaXMuYmlhcyA9IHNvdXJjZS5iaWFzO1xuXHRcdHRoaXMucmFkaXVzID0gc291cmNlLnJhZGl1cztcblxuXHRcdHRoaXMubWFwU2l6ZS5jb3B5KCBzb3VyY2UubWFwU2l6ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBvYmplY3QgPSB7fTtcblxuXHRcdGlmICggdGhpcy5iaWFzICE9PSAwICkgb2JqZWN0LmJpYXMgPSB0aGlzLmJpYXM7XG5cdFx0aWYgKCB0aGlzLm5vcm1hbEJpYXMgIT09IDAgKSBvYmplY3Qubm9ybWFsQmlhcyA9IHRoaXMubm9ybWFsQmlhcztcblx0XHRpZiAoIHRoaXMucmFkaXVzICE9PSAxICkgb2JqZWN0LnJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXHRcdGlmICggdGhpcy5tYXBTaXplLnggIT09IDUxMiB8fCB0aGlzLm1hcFNpemUueSAhPT0gNTEyICkgb2JqZWN0Lm1hcFNpemUgPSB0aGlzLm1hcFNpemUudG9BcnJheSgpO1xuXG5cdFx0b2JqZWN0LmNhbWVyYSA9IHRoaXMuY2FtZXJhLnRvSlNPTiggZmFsc2UgKS5vYmplY3Q7XG5cdFx0ZGVsZXRlIG9iamVjdC5jYW1lcmEubWF0cml4O1xuXG5cdFx0cmV0dXJuIG9iamVjdDtcblxuXHR9XG5cbn1cblxuY2xhc3MgU3BvdExpZ2h0U2hhZG93IGV4dGVuZHMgTGlnaHRTaGFkb3cge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggNTAsIDEsIDAuNSwgNTAwICkgKTtcblxuXHRcdHRoaXMuaXNTcG90TGlnaHRTaGFkb3cgPSB0cnVlO1xuXG5cdFx0dGhpcy5mb2N1cyA9IDE7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpY2VzKCBsaWdodCApIHtcblxuXHRcdGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuXG5cdFx0Y29uc3QgZm92ID0gUkFEMkRFRyAqIDIgKiBsaWdodC5hbmdsZSAqIHRoaXMuZm9jdXM7XG5cdFx0Y29uc3QgYXNwZWN0ID0gdGhpcy5tYXBTaXplLndpZHRoIC8gdGhpcy5tYXBTaXplLmhlaWdodDtcblx0XHRjb25zdCBmYXIgPSBsaWdodC5kaXN0YW5jZSB8fCBjYW1lcmEuZmFyO1xuXG5cdFx0aWYgKCBmb3YgIT09IGNhbWVyYS5mb3YgfHwgYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0IHx8IGZhciAhPT0gY2FtZXJhLmZhciApIHtcblxuXHRcdFx0Y2FtZXJhLmZvdiA9IGZvdjtcblx0XHRcdGNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XG5cdFx0XHRjYW1lcmEuZmFyID0gZmFyO1xuXHRcdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHRcdH1cblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpY2VzKCBsaWdodCApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY2xhc3MgU3BvdExpZ2h0IGV4dGVuZHMgTGlnaHQge1xuXG5cdGNvbnN0cnVjdG9yKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSA9IDAsIGFuZ2xlID0gTWF0aC5QSSAvIDMsIHBlbnVtYnJhID0gMCwgZGVjYXkgPSAyICkge1xuXG5cdFx0c3VwZXIoIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdHRoaXMuaXNTcG90TGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1Nwb3RMaWdodCc7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRFRkFVTFRfVVAgKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR0aGlzLmFuZ2xlID0gYW5nbGU7XG5cdFx0dGhpcy5wZW51bWJyYSA9IHBlbnVtYnJhO1xuXHRcdHRoaXMuZGVjYXkgPSBkZWNheTtcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdHRoaXMuc2hhZG93ID0gbmV3IFNwb3RMaWdodFNoYWRvdygpO1xuXG5cdH1cblxuXHRnZXQgcG93ZXIoKSB7XG5cblx0XHQvLyBjb21wdXRlIHRoZSBsaWdodCdzIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpIGZyb20gaXRzIGludGVuc2l0eSAoaW4gY2FuZGVsYSlcblx0XHQvLyBieSBjb252ZW50aW9uIGZvciBhIHNwb3RsaWdodCwgbHVtaW5vdXMgcG93ZXIgKGxtKSA9IM+AICogbHVtaW5vdXMgaW50ZW5zaXR5IChjZClcblx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiBNYXRoLlBJO1xuXG5cdH1cblxuXHRzZXQgcG93ZXIoIHBvd2VyICkge1xuXG5cdFx0Ly8gc2V0IHRoZSBsaWdodCdzIGludGVuc2l0eSAoaW4gY2FuZGVsYSkgZnJvbSB0aGUgZGVzaXJlZCBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKVxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyBNYXRoLlBJO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5zaGFkb3cuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xuXHRcdHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XG5cdFx0dGhpcy5wZW51bWJyYSA9IHNvdXJjZS5wZW51bWJyYTtcblx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXG5cdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cblx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jb25zdCBfcHJvalNjcmVlbk1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9saWdodFBvc2l0aW9uV29ybGQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbG9va1RhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgUG9pbnRMaWdodFNoYWRvdyBleHRlbmRzIExpZ2h0U2hhZG93IHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAwLjUsIDUwMCApICk7XG5cblx0XHR0aGlzLmlzUG9pbnRMaWdodFNoYWRvdyA9IHRydWU7XG5cblx0XHR0aGlzLl9mcmFtZUV4dGVudHMgPSBuZXcgVmVjdG9yMiggNCwgMiApO1xuXG5cdFx0dGhpcy5fdmlld3BvcnRDb3VudCA9IDY7XG5cblx0XHR0aGlzLl92aWV3cG9ydHMgPSBbXG5cdFx0XHQvLyBUaGVzZSB2aWV3cG9ydHMgbWFwIGEgY3ViZS1tYXAgb250byBhIDJEIHRleHR1cmUgd2l0aCB0aGVcblx0XHRcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcblx0XHRcdC8vXG5cdFx0XHQvLyAgeHpYWlxuXHRcdFx0Ly8gICB5IFlcblx0XHRcdC8vXG5cdFx0XHQvLyBYIC0gUG9zaXRpdmUgeCBkaXJlY3Rpb25cblx0XHRcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxuXHRcdFx0Ly8gWSAtIFBvc2l0aXZlIHkgZGlyZWN0aW9uXG5cdFx0XHQvLyB5IC0gTmVnYXRpdmUgeSBkaXJlY3Rpb25cblx0XHRcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxuXHRcdFx0Ly8geiAtIE5lZ2F0aXZlIHogZGlyZWN0aW9uXG5cblx0XHRcdC8vIHBvc2l0aXZlIFhcblx0XHRcdG5ldyBWZWN0b3I0KCAyLCAxLCAxLCAxICksXG5cdFx0XHQvLyBuZWdhdGl2ZSBYXG5cdFx0XHRuZXcgVmVjdG9yNCggMCwgMSwgMSwgMSApLFxuXHRcdFx0Ly8gcG9zaXRpdmUgWlxuXHRcdFx0bmV3IFZlY3RvcjQoIDMsIDEsIDEsIDEgKSxcblx0XHRcdC8vIG5lZ2F0aXZlIFpcblx0XHRcdG5ldyBWZWN0b3I0KCAxLCAxLCAxLCAxICksXG5cdFx0XHQvLyBwb3NpdGl2ZSBZXG5cdFx0XHRuZXcgVmVjdG9yNCggMywgMCwgMSwgMSApLFxuXHRcdFx0Ly8gbmVnYXRpdmUgWVxuXHRcdFx0bmV3IFZlY3RvcjQoIDEsIDAsIDEsIDEgKVxuXHRcdF07XG5cblx0XHR0aGlzLl9jdWJlRGlyZWN0aW9ucyA9IFtcblx0XHRcdG5ldyBWZWN0b3IzKCAxLCAwLCAwICksIG5ldyBWZWN0b3IzKCAtIDEsIDAsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSxcblx0XHRcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIC0gMSwgMCApXG5cdFx0XTtcblxuXHRcdHRoaXMuX2N1YmVVcHMgPSBbXG5cdFx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLFxuXHRcdFx0bmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSxcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKVxuXHRcdF07XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpY2VzKCBsaWdodCwgdmlld3BvcnRJbmRleCA9IDAgKSB7XG5cblx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcblx0XHRjb25zdCBzaGFkb3dNYXRyaXggPSB0aGlzLm1hdHJpeDtcblxuXHRcdGNvbnN0IGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IGNhbWVyYS5mYXI7XG5cblx0XHRpZiAoIGZhciAhPT0gY2FtZXJhLmZhciApIHtcblxuXHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcblx0XHRcdGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHR9XG5cblx0XHRfbGlnaHRQb3NpdGlvbldvcmxkLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRjYW1lcmEucG9zaXRpb24uY29weSggX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xuXG5cdFx0X2xvb2tUYXJnZXQuY29weSggY2FtZXJhLnBvc2l0aW9uICk7XG5cdFx0X2xvb2tUYXJnZXQuYWRkKCB0aGlzLl9jdWJlRGlyZWN0aW9uc1sgdmlld3BvcnRJbmRleCBdICk7XG5cdFx0Y2FtZXJhLnVwLmNvcHkoIHRoaXMuX2N1YmVVcHNbIHZpZXdwb3J0SW5kZXggXSApO1xuXHRcdGNhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XG5cdFx0Y2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRzaGFkb3dNYXRyaXgubWFrZVRyYW5zbGF0aW9uKCAtIF9saWdodFBvc2l0aW9uV29ybGQueCwgLSBfbGlnaHRQb3NpdGlvbldvcmxkLnksIC0gX2xpZ2h0UG9zaXRpb25Xb3JsZC56ICk7XG5cblx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdHRoaXMuX2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFBvaW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlID0gMCwgZGVjYXkgPSAyICkge1xuXG5cdFx0c3VwZXIoIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdHRoaXMuaXNQb2ludExpZ2h0ID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdQb2ludExpZ2h0JztcblxuXHRcdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR0aGlzLmRlY2F5ID0gZGVjYXk7XG5cblx0XHR0aGlzLnNoYWRvdyA9IG5ldyBQb2ludExpZ2h0U2hhZG93KCk7XG5cblx0fVxuXG5cdGdldCBwb3dlcigpIHtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIGxpZ2h0J3MgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucykgZnJvbSBpdHMgaW50ZW5zaXR5IChpbiBjYW5kZWxhKVxuXHRcdC8vIGZvciBhbiBpc290cm9waWMgbGlnaHQgc291cmNlLCBsdW1pbm91cyBwb3dlciAobG0pID0gNCDPgCBsdW1pbm91cyBpbnRlbnNpdHkgKGNkKVxuXHRcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIDQgKiBNYXRoLlBJO1xuXG5cdH1cblxuXHRzZXQgcG93ZXIoIHBvd2VyICkge1xuXG5cdFx0Ly8gc2V0IHRoZSBsaWdodCdzIGludGVuc2l0eSAoaW4gY2FuZGVsYSkgZnJvbSB0aGUgZGVzaXJlZCBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKVxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoIDQgKiBNYXRoLlBJICk7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLnNoYWRvdy5kaXNwb3NlKCk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG5cdFx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcblxuXHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZXh0ZW5kcyBMaWdodFNoYWRvdyB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlciggbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSA1LCA1LCA1LCAtIDUsIDAuNSwgNTAwICkgKTtcblxuXHRcdHRoaXMuaXNEaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRGlyZWN0aW9uYWxMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuXHRjb25zdHJ1Y3RvciggY29sb3IsIGludGVuc2l0eSApIHtcblxuXHRcdHN1cGVyKCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0XHR0aGlzLmlzRGlyZWN0aW9uYWxMaWdodCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRFRkFVTFRfVVAgKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdHRoaXMuc2hhZG93ID0gbmV3IERpcmVjdGlvbmFsTGlnaHRTaGFkb3coKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5jbGFzcyBBbWJpZW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0XHRzdXBlciggY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0dGhpcy5pc0FtYmllbnRMaWdodCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcblxuXHR9XG5cbn1cblxuY2xhc3MgUmVjdEFyZWFMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuXHRjb25zdHJ1Y3RvciggY29sb3IsIGludGVuc2l0eSwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gMTAgKSB7XG5cblx0XHRzdXBlciggY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0dGhpcy5pc1JlY3RBcmVhTGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1JlY3RBcmVhTGlnaHQnO1xuXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdH1cblxuXHRnZXQgcG93ZXIoKSB7XG5cblx0XHQvLyBjb21wdXRlIHRoZSBsaWdodCdzIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpIGZyb20gaXRzIGludGVuc2l0eSAoaW4gbml0cylcblx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiBNYXRoLlBJO1xuXG5cdH1cblxuXHRzZXQgcG93ZXIoIHBvd2VyICkge1xuXG5cdFx0Ly8gc2V0IHRoZSBsaWdodCdzIGludGVuc2l0eSAoaW4gbml0cykgZnJvbSB0aGUgZGVzaXJlZCBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKVxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIE1hdGguUEkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCBtZXRhICk7XG5cblx0XHRkYXRhLm9iamVjdC53aWR0aCA9IHRoaXMud2lkdGg7XG5cdFx0ZGF0YS5vYmplY3QuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBQcmltYXJ5IHJlZmVyZW5jZTpcbiAqICAgaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvcGFwZXJzL2Vudm1hcC9lbnZtYXAucGRmXG4gKlxuICogU2Vjb25kYXJ5IHJlZmVyZW5jZTpcbiAqICAgaHR0cHM6Ly93d3cucHBzbG9hbi5vcmcvcHVibGljYXRpb25zL1N0dXBpZFNIMzYucGRmXG4gKi9cblxuLy8gMy1iYW5kIFNIIGRlZmluZWQgYnkgOSBjb2VmZmljaWVudHNcblxuY2xhc3MgU3BoZXJpY2FsSGFybW9uaWNzMyB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLmlzU3BoZXJpY2FsSGFybW9uaWNzMyA9IHRydWU7XG5cblx0XHR0aGlzLmNvZWZmaWNpZW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHMucHVzaCggbmV3IFZlY3RvcjMoKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIGNvZWZmaWNpZW50cyApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY29lZmZpY2llbnRzWyBpIF0uY29weSggY29lZmZpY2llbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR6ZXJvKCkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHNbIGkgXS5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvLyBnZXQgdGhlIHJhZGlhbmNlIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG5vcm1hbFxuXHQvLyB0YXJnZXQgaXMgYSBWZWN0b3IzXG5cdGdldEF0KCBub3JtYWwsIHRhcmdldCApIHtcblxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoXG5cblx0XHRjb25zdCB4ID0gbm9ybWFsLngsIHkgPSBub3JtYWwueSwgeiA9IG5vcm1hbC56O1xuXG5cdFx0Y29uc3QgY29lZmYgPSB0aGlzLmNvZWZmaWNpZW50cztcblxuXHRcdC8vIGJhbmQgMFxuXHRcdHRhcmdldC5jb3B5KCBjb2VmZlsgMCBdICkubXVsdGlwbHlTY2FsYXIoIDAuMjgyMDk1ICk7XG5cblx0XHQvLyBiYW5kIDFcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMSBdLCAwLjQ4ODYwMyAqIHkgKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMiBdLCAwLjQ4ODYwMyAqIHogKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMyBdLCAwLjQ4ODYwMyAqIHggKTtcblxuXHRcdC8vIGJhbmQgMlxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA0IF0sIDEuMDkyNTQ4ICogKCB4ICogeSApICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDUgXSwgMS4wOTI1NDggKiAoIHkgKiB6ICkgKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgNiBdLCAwLjMxNTM5MiAqICggMy4wICogeiAqIHogLSAxLjAgKSApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA3IF0sIDEuMDkyNTQ4ICogKCB4ICogeiApICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDggXSwgMC41NDYyNzQgKiAoIHggKiB4IC0geSAqIHkgKSApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Ly8gZ2V0IHRoZSBpcnJhZGlhbmNlIChyYWRpYW5jZSBjb252b2x2ZWQgd2l0aCBjb3NpbmUgbG9iZSkgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbm9ybWFsXG5cdC8vIHRhcmdldCBpcyBhIFZlY3RvcjNcblx0Ly8gaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvcGFwZXJzL2Vudm1hcC9lbnZtYXAucGRmXG5cdGdldElycmFkaWFuY2VBdCggbm9ybWFsLCB0YXJnZXQgKSB7XG5cblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxuXG5cdFx0Y29uc3QgeCA9IG5vcm1hbC54LCB5ID0gbm9ybWFsLnksIHogPSBub3JtYWwuejtcblxuXHRcdGNvbnN0IGNvZWZmID0gdGhpcy5jb2VmZmljaWVudHM7XG5cblx0XHQvLyBiYW5kIDBcblx0XHR0YXJnZXQuY29weSggY29lZmZbIDAgXSApLm11bHRpcGx5U2NhbGFyKCAwLjg4NjIyNyApOyAvLyDPgCAqIDAuMjgyMDk1XG5cblx0XHQvLyBiYW5kIDFcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMSBdLCAyLjAgKiAwLjUxMTY2NCAqIHkgKTsgLy8gKCAyICogz4AgLyAzICkgKiAwLjQ4ODYwM1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyAyIF0sIDIuMCAqIDAuNTExNjY0ICogeiApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyAzIF0sIDIuMCAqIDAuNTExNjY0ICogeCApO1xuXG5cdFx0Ly8gYmFuZCAyXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDQgXSwgMi4wICogMC40MjkwNDMgKiB4ICogeSApOyAvLyAoIM+AIC8gNCApICogMS4wOTI1NDhcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgNSBdLCAyLjAgKiAwLjQyOTA0MyAqIHkgKiB6ICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDYgXSwgMC43NDMxMjUgKiB6ICogeiAtIDAuMjQ3NzA4ICk7IC8vICggz4AgLyA0ICkgKiAwLjMxNTM5MiAqIDNcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgNyBdLCAyLjAgKiAwLjQyOTA0MyAqIHggKiB6ICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDggXSwgMC40MjkwNDMgKiAoIHggKiB4IC0geSAqIHkgKSApOyAvLyAoIM+AIC8gNCApICogMC41NDYyNzRcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGFkZCggc2ggKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1sgaSBdLmFkZCggc2guY29lZmZpY2llbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsZWRTSCggc2gsIHMgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1sgaSBdLmFkZFNjYWxlZFZlY3Rvciggc2guY29lZmZpY2llbnRzWyBpIF0sIHMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzY2FsZSggcyApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY29lZmZpY2llbnRzWyBpIF0ubXVsdGlwbHlTY2FsYXIoIHMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwKCBzaCwgYWxwaGEgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1sgaSBdLmxlcnAoIHNoLmNvZWZmaWNpZW50c1sgaSBdLCBhbHBoYSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggc2ggKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHRpZiAoICEgdGhpcy5jb2VmZmljaWVudHNbIGkgXS5lcXVhbHMoIHNoLmNvZWZmaWNpZW50c1sgaSBdICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0Y29weSggc2ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHNoLmNvZWZmaWNpZW50cyApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0Y29lZmZpY2llbnRzWyBpIF0uZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ICsgKCBpICogMyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0Y29lZmZpY2llbnRzWyBpIF0udG9BcnJheSggYXJyYXksIG9mZnNldCArICggaSAqIDMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHQvLyBldmFsdWF0ZSB0aGUgYmFzaXMgZnVuY3Rpb25zXG5cdC8vIHNoQmFzaXMgaXMgYW4gQXJyYXlbIDkgXVxuXHRzdGF0aWMgZ2V0QmFzaXNBdCggbm9ybWFsLCBzaEJhc2lzICkge1xuXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGhcblxuXHRcdGNvbnN0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XG5cblx0XHQvLyBiYW5kIDBcblx0XHRzaEJhc2lzWyAwIF0gPSAwLjI4MjA5NTtcblxuXHRcdC8vIGJhbmQgMVxuXHRcdHNoQmFzaXNbIDEgXSA9IDAuNDg4NjAzICogeTtcblx0XHRzaEJhc2lzWyAyIF0gPSAwLjQ4ODYwMyAqIHo7XG5cdFx0c2hCYXNpc1sgMyBdID0gMC40ODg2MDMgKiB4O1xuXG5cdFx0Ly8gYmFuZCAyXG5cdFx0c2hCYXNpc1sgNCBdID0gMS4wOTI1NDggKiB4ICogeTtcblx0XHRzaEJhc2lzWyA1IF0gPSAxLjA5MjU0OCAqIHkgKiB6O1xuXHRcdHNoQmFzaXNbIDYgXSA9IDAuMzE1MzkyICogKCAzICogeiAqIHogLSAxICk7XG5cdFx0c2hCYXNpc1sgNyBdID0gMS4wOTI1NDggKiB4ICogejtcblx0XHRzaEJhc2lzWyA4IF0gPSAwLjU0NjI3NCAqICggeCAqIHggLSB5ICogeSApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBMaWdodFByb2JlIGV4dGVuZHMgTGlnaHQge1xuXG5cdGNvbnN0cnVjdG9yKCBzaCA9IG5ldyBTcGhlcmljYWxIYXJtb25pY3MzKCksIGludGVuc2l0eSA9IDEgKSB7XG5cblx0XHRzdXBlciggdW5kZWZpbmVkLCBpbnRlbnNpdHkgKTtcblxuXHRcdHRoaXMuaXNMaWdodFByb2JlID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2ggPSBzaDtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnNoLmNvcHkoIHNvdXJjZS5zaCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBqc29uLmludGVuc2l0eTsgLy8gVE9ETzogTW92ZSB0aGlzIGJpdCB0byBMaWdodC5mcm9tSlNPTigpO1xuXHRcdHRoaXMuc2guZnJvbUFycmF5KCBqc29uLnNoICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3Quc2ggPSB0aGlzLnNoLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5jbGFzcyBNYXRlcmlhbExvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXHRcdHRoaXMudGV4dHVyZXMgPSB7fTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHRwYXJzZSgganNvbiApIHtcblxuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcblxuXHRcdGZ1bmN0aW9uIGdldFRleHR1cmUoIG5hbWUgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZXNbIG5hbWUgXTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gTWF0ZXJpYWxMb2FkZXIuY3JlYXRlTWF0ZXJpYWxGcm9tVHlwZSgganNvbi50eXBlICk7XG5cblx0XHRpZiAoIGpzb24udXVpZCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudXVpZCA9IGpzb24udXVpZDtcblx0XHRpZiAoIGpzb24ubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGpzb24ubmFtZTtcblx0XHRpZiAoIGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5jb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBqc29uLmNvbG9yICk7XG5cdFx0aWYgKCBqc29uLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm91Z2huZXNzID0ganNvbi5yb3VnaG5lc3M7XG5cdFx0aWYgKCBqc29uLm1ldGFsbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWV0YWxuZXNzID0ganNvbi5tZXRhbG5lc3M7XG5cdFx0aWYgKCBqc29uLnNoZWVuICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGVlbiA9IGpzb24uc2hlZW47XG5cdFx0aWYgKCBqc29uLnNoZWVuQ29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoZWVuQ29sb3IgPSBuZXcgQ29sb3IoKS5zZXRIZXgoIGpzb24uc2hlZW5Db2xvciApO1xuXHRcdGlmICgganNvbi5zaGVlblJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgPSBqc29uLnNoZWVuUm91Z2huZXNzO1xuXHRcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLmVtaXNzaXZlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZS5zZXRIZXgoIGpzb24uZW1pc3NpdmUgKTtcblx0XHRpZiAoIGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXIuc2V0SGV4KCBqc29uLnNwZWN1bGFyICk7XG5cdFx0aWYgKCBqc29uLnNwZWN1bGFySW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eSA9IGpzb24uc3BlY3VsYXJJbnRlbnNpdHk7XG5cdFx0aWYgKCBqc29uLnNwZWN1bGFyQ29sb3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLnNldEhleCgganNvbi5zcGVjdWxhckNvbG9yICk7XG5cdFx0aWYgKCBqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XG5cdFx0aWYgKCBqc29uLmNsZWFyY29hdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJjb2F0ID0ganNvbi5jbGVhcmNvYXQ7XG5cdFx0aWYgKCBqc29uLmNsZWFyY29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0ganNvbi5jbGVhcmNvYXRSb3VnaG5lc3M7XG5cdFx0aWYgKCBqc29uLmRpc3BlcnNpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BlcnNpb24gPSBqc29uLmRpc3BlcnNpb247XG5cdFx0aWYgKCBqc29uLmlyaWRlc2NlbmNlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5pcmlkZXNjZW5jZSA9IGpzb24uaXJpZGVzY2VuY2U7XG5cdFx0aWYgKCBqc29uLmlyaWRlc2NlbmNlSU9SICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5pcmlkZXNjZW5jZUlPUiA9IGpzb24uaXJpZGVzY2VuY2VJT1I7XG5cdFx0aWYgKCBqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSBqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2U7XG5cdFx0aWYgKCBqc29uLnRyYW5zbWlzc2lvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNtaXNzaW9uID0ganNvbi50cmFuc21pc3Npb247XG5cdFx0aWYgKCBqc29uLnRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudGhpY2tuZXNzID0ganNvbi50aGlja25lc3M7XG5cdFx0aWYgKCBqc29uLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBqc29uLmF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0aWYgKCBqc29uLmF0dGVudWF0aW9uQ29sb3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yLnNldEhleCgganNvbi5hdHRlbnVhdGlvbkNvbG9yICk7XG5cdFx0aWYgKCBqc29uLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFuaXNvdHJvcHkgPSBqc29uLmFuaXNvdHJvcHk7XG5cdFx0aWYgKCBqc29uLmFuaXNvdHJvcHlSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uID0ganNvbi5hbmlzb3Ryb3B5Um90YXRpb247XG5cdFx0aWYgKCBqc29uLmZvZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZm9nID0ganNvbi5mb2c7XG5cdFx0aWYgKCBqc29uLmZsYXRTaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mbGF0U2hhZGluZyA9IGpzb24uZmxhdFNoYWRpbmc7XG5cdFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XG5cdFx0aWYgKCBqc29uLmNvbWJpbmUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbWJpbmUgPSBqc29uLmNvbWJpbmU7XG5cdFx0aWYgKCBqc29uLnNpZGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpZGUgPSBqc29uLnNpZGU7XG5cdFx0aWYgKCBqc29uLnNoYWRvd1NpZGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoYWRvd1NpZGUgPSBqc29uLnNoYWRvd1NpZGU7XG5cdFx0aWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XG5cdFx0aWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG5cdFx0aWYgKCBqc29uLmFscGhhVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYWxwaGFUZXN0ID0ganNvbi5hbHBoYVRlc3Q7XG5cdFx0aWYgKCBqc29uLmFscGhhSGFzaCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYWxwaGFIYXNoID0ganNvbi5hbHBoYUhhc2g7XG5cdFx0aWYgKCBqc29uLmRlcHRoRnVuYyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhGdW5jID0ganNvbi5kZXB0aEZ1bmM7XG5cdFx0aWYgKCBqc29uLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0ganNvbi5kZXB0aFRlc3Q7XG5cdFx0aWYgKCBqc29uLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XG5cdFx0aWYgKCBqc29uLmNvbG9yV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yV3JpdGUgPSBqc29uLmNvbG9yV3JpdGU7XG5cdFx0aWYgKCBqc29uLmJsZW5kU3JjICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZFNyYyA9IGpzb24uYmxlbmRTcmM7XG5cdFx0aWYgKCBqc29uLmJsZW5kRHN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZERzdCA9IGpzb24uYmxlbmREc3Q7XG5cdFx0aWYgKCBqc29uLmJsZW5kRXF1YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24gPSBqc29uLmJsZW5kRXF1YXRpb247XG5cdFx0aWYgKCBqc29uLmJsZW5kU3JjQWxwaGEgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEgPSBqc29uLmJsZW5kU3JjQWxwaGE7XG5cdFx0aWYgKCBqc29uLmJsZW5kRHN0QWxwaGEgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEgPSBqc29uLmJsZW5kRHN0QWxwaGE7XG5cdFx0aWYgKCBqc29uLmJsZW5kRXF1YXRpb25BbHBoYSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhID0ganNvbi5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cdFx0aWYgKCBqc29uLmJsZW5kQ29sb3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5ibGVuZENvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZENvbG9yLnNldEhleCgganNvbi5ibGVuZENvbG9yICk7XG5cdFx0aWYgKCBqc29uLmJsZW5kQWxwaGEgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kQWxwaGEgPSBqc29uLmJsZW5kQWxwaGE7XG5cdFx0aWYgKCBqc29uLnN0ZW5jaWxXcml0ZU1hc2sgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2sgPSBqc29uLnN0ZW5jaWxXcml0ZU1hc2s7XG5cdFx0aWYgKCBqc29uLnN0ZW5jaWxGdW5jICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsRnVuYyA9IGpzb24uc3RlbmNpbEZ1bmM7XG5cdFx0aWYgKCBqc29uLnN0ZW5jaWxSZWYgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnN0ZW5jaWxSZWYgPSBqc29uLnN0ZW5jaWxSZWY7XG5cdFx0aWYgKCBqc29uLnN0ZW5jaWxGdW5jTWFzayAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3RlbmNpbEZ1bmNNYXNrID0ganNvbi5zdGVuY2lsRnVuY01hc2s7XG5cdFx0aWYgKCBqc29uLnN0ZW5jaWxGYWlsICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsRmFpbCA9IGpzb24uc3RlbmNpbEZhaWw7XG5cdFx0aWYgKCBqc29uLnN0ZW5jaWxaRmFpbCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3RlbmNpbFpGYWlsID0ganNvbi5zdGVuY2lsWkZhaWw7XG5cdFx0aWYgKCBqc29uLnN0ZW5jaWxaUGFzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3RlbmNpbFpQYXNzID0ganNvbi5zdGVuY2lsWlBhc3M7XG5cdFx0aWYgKCBqc29uLnN0ZW5jaWxXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3RlbmNpbFdyaXRlID0ganNvbi5zdGVuY2lsV3JpdGU7XG5cblx0XHRpZiAoIGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWUgPSBqc29uLndpcmVmcmFtZTtcblx0XHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSBqc29uLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZWNhcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IGpzb24ud2lyZWZyYW1lTGluZWNhcDtcblx0XHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZWpvaW4gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0ganNvbi53aXJlZnJhbWVMaW5lam9pbjtcblxuXHRcdGlmICgganNvbi5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm90YXRpb24gPSBqc29uLnJvdGF0aW9uO1xuXG5cdFx0aWYgKCBqc29uLmxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGluZXdpZHRoID0ganNvbi5saW5ld2lkdGg7XG5cdFx0aWYgKCBqc29uLmRhc2hTaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kYXNoU2l6ZSA9IGpzb24uZGFzaFNpemU7XG5cdFx0aWYgKCBqc29uLmdhcFNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmdhcFNpemUgPSBqc29uLmdhcFNpemU7XG5cdFx0aWYgKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zY2FsZSA9IGpzb24uc2NhbGU7XG5cblx0XHRpZiAoIGpzb24ucG9seWdvbk9mZnNldCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucG9seWdvbk9mZnNldCA9IGpzb24ucG9seWdvbk9mZnNldDtcblx0XHRpZiAoIGpzb24ucG9seWdvbk9mZnNldEZhY3RvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciA9IGpzb24ucG9seWdvbk9mZnNldEZhY3Rvcjtcblx0XHRpZiAoIGpzb24ucG9seWdvbk9mZnNldFVuaXRzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBqc29uLnBvbHlnb25PZmZzZXRVbml0cztcblxuXHRcdGlmICgganNvbi5kaXRoZXJpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpdGhlcmluZyA9IGpzb24uZGl0aGVyaW5nO1xuXG5cdFx0aWYgKCBqc29uLmFscGhhVG9Db3ZlcmFnZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYWxwaGFUb0NvdmVyYWdlID0ganNvbi5hbHBoYVRvQ292ZXJhZ2U7XG5cdFx0aWYgKCBqc29uLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhID0ganNvbi5wcmVtdWx0aXBsaWVkQWxwaGE7XG5cdFx0aWYgKCBqc29uLmZvcmNlU2luZ2xlUGFzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZm9yY2VTaW5nbGVQYXNzID0ganNvbi5mb3JjZVNpbmdsZVBhc3M7XG5cblx0XHRpZiAoIGpzb24udmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmlzaWJsZSA9IGpzb24udmlzaWJsZTtcblxuXHRcdGlmICgganNvbi50b25lTWFwcGVkICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50b25lTWFwcGVkID0ganNvbi50b25lTWFwcGVkO1xuXG5cdFx0aWYgKCBqc29uLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51c2VyRGF0YSA9IGpzb24udXNlckRhdGE7XG5cblx0XHRpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIGpzb24udmVydGV4Q29sb3JzID09PSAnbnVtYmVyJyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSAoIGpzb24udmVydGV4Q29sb3JzID4gMCApID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGpzb24udmVydGV4Q29sb3JzO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBTaGFkZXIgTWF0ZXJpYWxcblxuXHRcdGlmICgganNvbi51bmlmb3JtcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGpzb24udW5pZm9ybXMgKSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybSA9IGpzb24udW5pZm9ybXNbIG5hbWUgXTtcblxuXHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1sgbmFtZSBdID0ge307XG5cblx0XHRcdFx0c3dpdGNoICggdW5pZm9ybS50eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1sgbmFtZSBdLnZhbHVlID0gZ2V0VGV4dHVyZSggdW5pZm9ybS52YWx1ZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0udmFsdWUgPSBuZXcgQ29sb3IoKS5zZXRIZXgoIHVuaWZvcm0udmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndjInOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCB1bmlmb3JtLnZhbHVlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3YzJzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0udmFsdWUgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSggdW5pZm9ybS52YWx1ZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2NCc6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1sgbmFtZSBdLnZhbHVlID0gbmV3IFZlY3RvcjQoKS5mcm9tQXJyYXkoIHVuaWZvcm0udmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbTMnOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBNYXRyaXgzKCkuZnJvbUFycmF5KCB1bmlmb3JtLnZhbHVlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ200Jzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0udmFsdWUgPSBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggdW5pZm9ybS52YWx1ZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IHVuaWZvcm0udmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24uZGVmaW5lcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVmaW5lcyA9IGpzb24uZGVmaW5lcztcblx0XHRpZiAoIGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcblx0XHRpZiAoIGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcblx0XHRpZiAoIGpzb24uZ2xzbFZlcnNpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmdsc2xWZXJzaW9uID0ganNvbi5nbHNsVmVyc2lvbjtcblxuXHRcdGlmICgganNvbi5leHRlbnNpb25zICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBqc29uLmV4dGVuc2lvbnMgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwuZXh0ZW5zaW9uc1sga2V5IF0gPSBqc29uLmV4dGVuc2lvbnNbIGtleSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24ubGlnaHRzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodHMgPSBqc29uLmxpZ2h0cztcblx0XHRpZiAoIGpzb24uY2xpcHBpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsaXBwaW5nID0ganNvbi5jbGlwcGluZztcblxuXHRcdC8vIGZvciBQb2ludHNNYXRlcmlhbFxuXG5cdFx0aWYgKCBqc29uLnNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemUgPSBqc29uLnNpemU7XG5cdFx0aWYgKCBqc29uLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0ganNvbi5zaXplQXR0ZW51YXRpb247XG5cblx0XHQvLyBtYXBzXG5cblx0XHRpZiAoIGpzb24ubWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tYXAgPSBnZXRUZXh0dXJlKCBqc29uLm1hcCApO1xuXHRcdGlmICgganNvbi5tYXRjYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1hdGNhcCA9IGdldFRleHR1cmUoIGpzb24ubWF0Y2FwICk7XG5cblx0XHRpZiAoIGpzb24uYWxwaGFNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFscGhhTWFwID0gZ2V0VGV4dHVyZSgganNvbi5hbHBoYU1hcCApO1xuXG5cdFx0aWYgKCBqc29uLmJ1bXBNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmJ1bXBNYXAgKTtcblx0XHRpZiAoIGpzb24uYnVtcFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wU2NhbGUgPSBqc29uLmJ1bXBTY2FsZTtcblxuXHRcdGlmICgganNvbi5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IGdldFRleHR1cmUoIGpzb24ubm9ybWFsTWFwICk7XG5cdFx0aWYgKCBqc29uLm5vcm1hbE1hcFR5cGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcFR5cGUgPSBqc29uLm5vcm1hbE1hcFR5cGU7XG5cdFx0aWYgKCBqc29uLm5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxldCBub3JtYWxTY2FsZSA9IGpzb24ubm9ybWFsU2NhbGU7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbm9ybWFsU2NhbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gQmxlbmRlciBleHBvcnRlciB1c2VkIHRvIGV4cG9ydCBhIHNjYWxhci4gU2VlICM3NDU5XG5cblx0XHRcdFx0bm9ybWFsU2NhbGUgPSBbIG5vcm1hbFNjYWxlLCBub3JtYWxTY2FsZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIG5vcm1hbFNjYWxlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmRpc3BsYWNlbWVudE1hcCApO1xuXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSBqc29uLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRCaWFzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzID0ganNvbi5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0aWYgKCBqc29uLnJvdWdobmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm91Z2huZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5yb3VnaG5lc3NNYXAgKTtcblx0XHRpZiAoIGpzb24ubWV0YWxuZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLm1ldGFsbmVzc01hcCApO1xuXG5cdFx0aWYgKCBqc29uLmVtaXNzaXZlTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZU1hcCA9IGdldFRleHR1cmUoIGpzb24uZW1pc3NpdmVNYXAgKTtcblx0XHRpZiAoIGpzb24uZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ID0ganNvbi5lbWlzc2l2ZUludGVuc2l0eTtcblxuXHRcdGlmICgganNvbi5zcGVjdWxhck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNwZWN1bGFyTWFwICk7XG5cdFx0aWYgKCBqc29uLnNwZWN1bGFySW50ZW5zaXR5TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcCA9IGdldFRleHR1cmUoIGpzb24uc3BlY3VsYXJJbnRlbnNpdHlNYXAgKTtcblx0XHRpZiAoIGpzb24uc3BlY3VsYXJDb2xvck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcCA9IGdldFRleHR1cmUoIGpzb24uc3BlY3VsYXJDb2xvck1hcCApO1xuXG5cdFx0aWYgKCBqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW52TWFwID0gZ2V0VGV4dHVyZSgganNvbi5lbnZNYXAgKTtcblx0XHRpZiAoIGpzb24uZW52TWFwUm90YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVudk1hcFJvdGF0aW9uLmZyb21BcnJheSgganNvbi5lbnZNYXBSb3RhdGlvbiApO1xuXHRcdGlmICgganNvbi5lbnZNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVudk1hcEludGVuc2l0eSA9IGpzb24uZW52TWFwSW50ZW5zaXR5O1xuXG5cdFx0aWYgKCBqc29uLnJlZmxlY3Rpdml0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0ganNvbi5yZWZsZWN0aXZpdHk7XG5cdFx0aWYgKCBqc29uLnJlZnJhY3Rpb25SYXRpbyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0ganNvbi5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHRpZiAoIGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwID0gZ2V0VGV4dHVyZSgganNvbi5saWdodE1hcCApO1xuXHRcdGlmICgganNvbi5saWdodE1hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgPSBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0aWYgKCBqc29uLmFvTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcCA9IGdldFRleHR1cmUoIGpzb24uYW9NYXAgKTtcblx0XHRpZiAoIGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0ganNvbi5hb01hcEludGVuc2l0eTtcblxuXHRcdGlmICgganNvbi5ncmFkaWVudE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZ3JhZGllbnRNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmdyYWRpZW50TWFwICk7XG5cblx0XHRpZiAoIGpzb24uY2xlYXJjb2F0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhcmNvYXRNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmNsZWFyY29hdE1hcCApO1xuXHRcdGlmICgganNvbi5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24uY2xlYXJjb2F0Um91Z2huZXNzTWFwICk7XG5cdFx0aWYgKCBqc29uLmNsZWFyY29hdE5vcm1hbE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwID0gZ2V0VGV4dHVyZSgganNvbi5jbGVhcmNvYXROb3JtYWxNYXAgKTtcblx0XHRpZiAoIGpzb24uY2xlYXJjb2F0Tm9ybWFsU2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIGpzb24uY2xlYXJjb2F0Tm9ybWFsU2NhbGUgKTtcblxuXHRcdGlmICgganNvbi5pcmlkZXNjZW5jZU1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmlyaWRlc2NlbmNlTWFwICk7XG5cdFx0aWYgKCBqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgKTtcblxuXHRcdGlmICgganNvbi50cmFuc21pc3Npb25NYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCA9IGdldFRleHR1cmUoIGpzb24udHJhbnNtaXNzaW9uTWFwICk7XG5cdFx0aWYgKCBqc29uLnRoaWNrbmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudGhpY2tuZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi50aGlja25lc3NNYXAgKTtcblxuXHRcdGlmICgganNvbi5hbmlzb3Ryb3B5TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwID0gZ2V0VGV4dHVyZSgganNvbi5hbmlzb3Ryb3B5TWFwICk7XG5cblx0XHRpZiAoIGpzb24uc2hlZW5Db2xvck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hlZW5Db2xvck1hcCA9IGdldFRleHR1cmUoIGpzb24uc2hlZW5Db2xvck1hcCApO1xuXHRcdGlmICgganNvbi5zaGVlblJvdWdobmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNoZWVuUm91Z2huZXNzTWFwICk7XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0fVxuXG5cdHNldFRleHR1cmVzKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudGV4dHVyZXMgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUoIHR5cGUgKSB7XG5cblx0XHRjb25zdCBtYXRlcmlhbExpYiA9IHtcblx0XHRcdFNoYWRvd01hdGVyaWFsLFxuXHRcdFx0U3ByaXRlTWF0ZXJpYWwsXG5cdFx0XHRSYXdTaGFkZXJNYXRlcmlhbCxcblx0XHRcdFNoYWRlck1hdGVyaWFsLFxuXHRcdFx0UG9pbnRzTWF0ZXJpYWwsXG5cdFx0XHRNZXNoUGh5c2ljYWxNYXRlcmlhbCxcblx0XHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLFxuXHRcdFx0TWVzaFBob25nTWF0ZXJpYWwsXG5cdFx0XHRNZXNoVG9vbk1hdGVyaWFsLFxuXHRcdFx0TWVzaE5vcm1hbE1hdGVyaWFsLFxuXHRcdFx0TWVzaExhbWJlcnRNYXRlcmlhbCxcblx0XHRcdE1lc2hEZXB0aE1hdGVyaWFsLFxuXHRcdFx0TWVzaERpc3RhbmNlTWF0ZXJpYWwsXG5cdFx0XHRNZXNoQmFzaWNNYXRlcmlhbCxcblx0XHRcdE1lc2hNYXRjYXBNYXRlcmlhbCxcblx0XHRcdExpbmVEYXNoZWRNYXRlcmlhbCxcblx0XHRcdExpbmVCYXNpY01hdGVyaWFsLFxuXHRcdFx0TWF0ZXJpYWxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIG5ldyBtYXRlcmlhbExpYlsgdHlwZSBdKCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIExvYWRlclV0aWxzIHtcblxuXHRzdGF0aWMgZGVjb2RlVGV4dCggYXJyYXkgKSB7IC8vIEBkZXByZWNhdGVkLCByMTY1XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXJVdGlsczogZGVjb2RlVGV4dCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgd2l0aCByMTY1IGFuZCB3aWxsIGJlIHJlbW92ZWQgd2l0aCByMTc1LiBVc2UgVGV4dERlY29kZXIgaW5zdGVhZC4nICk7XG5cblx0XHRpZiAoIHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoIGFycmF5ICk7XG5cblx0XHR9XG5cblx0XHQvLyBBdm9pZCB0aGUgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSkgc2hvcnRjdXQsIHdoaWNoXG5cdFx0Ly8gdGhyb3dzIGEgXCJtYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiIGVycm9yIGZvciBsYXJnZSBhcnJheXMuXG5cblx0XHRsZXQgcyA9ICcnO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHQvLyBJbXBsaWNpdGx5IGFzc3VtZXMgbGl0dGxlLWVuZGlhbi5cblx0XHRcdHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSggYXJyYXlbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Ly8gbWVyZ2VzIG11bHRpLWJ5dGUgdXRmLTggY2hhcmFjdGVycy5cblxuXHRcdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCggZXNjYXBlKCBzICkgKTtcblxuXHRcdH0gY2F0Y2ggKCBlICkgeyAvLyBzZWUgIzE2MzU4XG5cblx0XHRcdHJldHVybiBzO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzdGF0aWMgZXh0cmFjdFVybEJhc2UoIHVybCApIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdXJsLmxhc3RJbmRleE9mKCAnLycgKTtcblxuXHRcdGlmICggaW5kZXggPT09IC0gMSApIHJldHVybiAnLi8nO1xuXG5cdFx0cmV0dXJuIHVybC5zbGljZSggMCwgaW5kZXggKyAxICk7XG5cblx0fVxuXG5cdHN0YXRpYyByZXNvbHZlVVJMKCB1cmwsIHBhdGggKSB7XG5cblx0XHQvLyBJbnZhbGlkIFVSTFxuXHRcdGlmICggdHlwZW9mIHVybCAhPT0gJ3N0cmluZycgfHwgdXJsID09PSAnJyApIHJldHVybiAnJztcblxuXHRcdC8vIEhvc3QgUmVsYXRpdmUgVVJMXG5cdFx0aWYgKCAvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KCBwYXRoICkgJiYgL15cXC8vLnRlc3QoIHVybCApICkge1xuXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKCAvKF5odHRwcz86XFwvXFwvW15cXC9dKykuKi9pLCAnJDEnICk7XG5cblx0XHR9XG5cblx0XHQvLyBBYnNvbHV0ZSBVUkwgaHR0cDovLyxodHRwczovLywvL1xuXHRcdGlmICggL14oaHR0cHM/Oik/XFwvXFwvL2kudGVzdCggdXJsICkgKSByZXR1cm4gdXJsO1xuXG5cdFx0Ly8gRGF0YSBVUklcblx0XHRpZiAoIC9eZGF0YTouKiwuKiQvaS50ZXN0KCB1cmwgKSApIHJldHVybiB1cmw7XG5cblx0XHQvLyBCbG9iIFVSTFxuXHRcdGlmICggL15ibG9iOi4qJC9pLnRlc3QoIHVybCApICkgcmV0dXJuIHVybDtcblxuXHRcdC8vIFJlbGF0aXZlIFVSTFxuXHRcdHJldHVybiBwYXRoICsgdXJsO1xuXG5cdH1cblxufVxuXG5jbGFzcyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5Jztcblx0XHR0aGlzLmluc3RhbmNlQ291bnQgPSBJbmZpbml0eTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmluc3RhbmNlQ291bnQgPSBzb3VyY2UuaW5zdGFuY2VDb3VudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmluc3RhbmNlQ291bnQgPSB0aGlzLmluc3RhbmNlQ291bnQ7XG5cblx0XHRkYXRhLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmNsYXNzIEJ1ZmZlckdlb21ldHJ5TG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0cGFyc2UoIGpzb24gKSB7XG5cblx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlck1hcCA9IHt9O1xuXHRcdGNvbnN0IGFycmF5QnVmZmVyTWFwID0ge307XG5cblx0XHRmdW5jdGlvbiBnZXRJbnRlcmxlYXZlZEJ1ZmZlcigganNvbiwgdXVpZCApIHtcblxuXHRcdFx0aWYgKCBpbnRlcmxlYXZlZEJ1ZmZlck1hcFsgdXVpZCBdICE9PSB1bmRlZmluZWQgKSByZXR1cm4gaW50ZXJsZWF2ZWRCdWZmZXJNYXBbIHV1aWQgXTtcblxuXHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXJzID0ganNvbi5pbnRlcmxlYXZlZEJ1ZmZlcnM7XG5cdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IGludGVybGVhdmVkQnVmZmVyc1sgdXVpZCBdO1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSBnZXRBcnJheUJ1ZmZlcigganNvbiwgaW50ZXJsZWF2ZWRCdWZmZXIuYnVmZmVyICk7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gZ2V0VHlwZWRBcnJheSggaW50ZXJsZWF2ZWRCdWZmZXIudHlwZSwgYnVmZmVyICk7XG5cdFx0XHRjb25zdCBpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIGludGVybGVhdmVkQnVmZmVyLnN0cmlkZSApO1xuXHRcdFx0aWIudXVpZCA9IGludGVybGVhdmVkQnVmZmVyLnV1aWQ7XG5cblx0XHRcdGludGVybGVhdmVkQnVmZmVyTWFwWyB1dWlkIF0gPSBpYjtcblxuXHRcdFx0cmV0dXJuIGliO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIoIGpzb24sIHV1aWQgKSB7XG5cblx0XHRcdGlmICggYXJyYXlCdWZmZXJNYXBbIHV1aWQgXSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGFycmF5QnVmZmVyTWFwWyB1dWlkIF07XG5cblx0XHRcdGNvbnN0IGFycmF5QnVmZmVycyA9IGpzb24uYXJyYXlCdWZmZXJzO1xuXHRcdFx0Y29uc3QgYXJyYXlCdWZmZXIgPSBhcnJheUJ1ZmZlcnNbIHV1aWQgXTtcblxuXHRcdFx0Y29uc3QgYWIgPSBuZXcgVWludDMyQXJyYXkoIGFycmF5QnVmZmVyICkuYnVmZmVyO1xuXG5cdFx0XHRhcnJheUJ1ZmZlck1hcFsgdXVpZCBdID0gYWI7XG5cblx0XHRcdHJldHVybiBhYjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0ganNvbi5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID8gbmV3IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KCkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdGNvbnN0IGluZGV4ID0ganNvbi5kYXRhLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCB0eXBlZEFycmF5ID0gZ2V0VHlwZWRBcnJheSggaW5kZXgudHlwZSwgaW5kZXguYXJyYXkgKTtcblx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCAxICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBqc29uLmRhdGEuYXR0cmlidXRlcztcblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblx0XHRcdGxldCBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBnZXRJbnRlcmxlYXZlZEJ1ZmZlcigganNvbi5kYXRhLCBhdHRyaWJ1dGUuZGF0YSApO1xuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGludGVybGVhdmVkQnVmZmVyLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5vZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgdHlwZWRBcnJheSA9IGdldFR5cGVkQXJyYXkoIGF0dHJpYnV0ZS50eXBlLCBhdHRyaWJ1dGUuYXJyYXkgKTtcblx0XHRcdFx0Y29uc3QgYnVmZmVyQXR0cmlidXRlQ29uc3RyID0gYXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID8gSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIDogQnVmZmVyQXR0cmlidXRlO1xuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgYnVmZmVyQXR0cmlidXRlQ29uc3RyKCB0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5ub3JtYWxpemVkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUubmFtZSAhPT0gdW5kZWZpbmVkICkgYnVmZmVyQXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcblx0XHRcdGlmICggYXR0cmlidXRlLnVzYWdlICE9PSB1bmRlZmluZWQgKSBidWZmZXJBdHRyaWJ1dGUuc2V0VXNhZ2UoIGF0dHJpYnV0ZS51c2FnZSApO1xuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIGtleSwgYnVmZmVyQXR0cmlidXRlICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBqc29uLmRhdGEubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZUFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlQXJyYXlbIGkgXTtcblx0XHRcdFx0XHRsZXQgYnVmZmVyQXR0cmlidXRlO1xuXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBnZXRJbnRlcmxlYXZlZEJ1ZmZlcigganNvbi5kYXRhLCBhdHRyaWJ1dGUuZGF0YSApO1xuXHRcdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBpbnRlcmxlYXZlZEJ1ZmZlciwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUub2Zmc2V0LCBhdHRyaWJ1dGUubm9ybWFsaXplZCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdHlwZWRBcnJheSA9IGdldFR5cGVkQXJyYXkoIGF0dHJpYnV0ZS50eXBlLCBhdHRyaWJ1dGUuYXJyYXkgKTtcblx0XHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlLm5hbWUgIT09IHVuZGVmaW5lZCApIGJ1ZmZlckF0dHJpYnV0ZS5uYW1lID0gYXR0cmlidXRlLm5hbWU7XG5cdFx0XHRcdFx0YXJyYXkucHVzaCggYnVmZmVyQXR0cmlidXRlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1sga2V5IF0gPSBhcnJheTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBqc29uLmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHRpZiAoIG1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XG5cblx0XHRpZiAoIGdyb3VwcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0aWYgKCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjZW50ZXIuZnJvbUFycmF5KCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoIGNlbnRlciwgYm91bmRpbmdTcGhlcmUucmFkaXVzICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24ubmFtZSApIGdlb21ldHJ5Lm5hbWUgPSBqc29uLm5hbWU7XG5cdFx0aWYgKCBqc29uLnVzZXJEYXRhICkgZ2VvbWV0cnkudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH1cblxufVxuXG5jbGFzcyBPYmplY3RMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBwYXRoID0gKCB0aGlzLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiB0aGlzLnBhdGg7XG5cdFx0dGhpcy5yZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdGxldCBqc29uID0gbnVsbDtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xuXG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICE9PSB1bmRlZmluZWQgKSBvbkVycm9yKCBlcnJvciApO1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRTpPYmplY3RMb2FkZXI6IENhblxcJ3QgcGFyc2UgJyArIHVybCArICcuJywgZXJyb3IubWVzc2FnZSApO1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cblx0XHRcdGlmICggbWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnZ2VvbWV0cnknICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkgb25FcnJvciggbmV3IEVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCApICk7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk9iamVjdExvYWRlcjogQ2FuXFwndCBsb2FkICcgKyB1cmwgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNjb3BlLnBhcnNlKCBqc29uLCBvbkxvYWQgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0YXN5bmMgbG9hZEFzeW5jKCB1cmwsIG9uUHJvZ3Jlc3MgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBwYXRoID0gKCB0aGlzLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiB0aGlzLnBhdGg7XG5cdFx0dGhpcy5yZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdGNvbnN0IHRleHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCB1cmwsIG9uUHJvZ3Jlc3MgKTtcblxuXHRcdGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XG5cblx0XHRjb25zdCBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cblx0XHRpZiAoIG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5JyApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF3YWl0IHNjb3BlLnBhcnNlQXN5bmMoIGpzb24gKTtcblxuXHR9XG5cblx0cGFyc2UoIGpzb24sIG9uTG9hZCApIHtcblxuXHRcdGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XG5cdFx0Y29uc3Qgc2hhcGVzID0gdGhpcy5wYXJzZVNoYXBlcygganNvbi5zaGFwZXMgKTtcblx0XHRjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcywgc2hhcGVzICk7XG5cblx0XHRjb25zdCBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcblx0XHRjb25zdCBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcblxuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zICk7XG5cdFx0Y29uc3Qgc2tlbGV0b25zID0gdGhpcy5wYXJzZVNrZWxldG9ucygganNvbi5za2VsZXRvbnMsIG9iamVjdCApO1xuXG5cdFx0dGhpcy5iaW5kU2tlbGV0b25zKCBvYmplY3QsIHNrZWxldG9ucyApO1xuXG5cdFx0Ly9cblxuXHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxldCBoYXNJbWFnZXMgPSBmYWxzZTtcblxuXHRcdFx0Zm9yICggY29uc3QgdXVpZCBpbiBpbWFnZXMgKSB7XG5cblx0XHRcdFx0aWYgKCBpbWFnZXNbIHV1aWQgXS5kYXRhIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHtcblxuXHRcdFx0XHRcdGhhc0ltYWdlcyA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzSW1hZ2VzID09PSBmYWxzZSApIG9uTG9hZCggb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdH1cblxuXHRhc3luYyBwYXJzZUFzeW5jKCBqc29uICkge1xuXG5cdFx0Y29uc3QgYW5pbWF0aW9ucyA9IHRoaXMucGFyc2VBbmltYXRpb25zKCBqc29uLmFuaW1hdGlvbnMgKTtcblx0XHRjb25zdCBzaGFwZXMgPSB0aGlzLnBhcnNlU2hhcGVzKCBqc29uLnNoYXBlcyApO1xuXHRcdGNvbnN0IGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcygganNvbi5nZW9tZXRyaWVzLCBzaGFwZXMgKTtcblxuXHRcdGNvbnN0IGltYWdlcyA9IGF3YWl0IHRoaXMucGFyc2VJbWFnZXNBc3luYygganNvbi5pbWFnZXMgKTtcblxuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcblx0XHRjb25zdCBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcblxuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zICk7XG5cdFx0Y29uc3Qgc2tlbGV0b25zID0gdGhpcy5wYXJzZVNrZWxldG9ucygganNvbi5za2VsZXRvbnMsIG9iamVjdCApO1xuXG5cdFx0dGhpcy5iaW5kU2tlbGV0b25zKCBvYmplY3QsIHNrZWxldG9ucyApO1xuXG5cdFx0cmV0dXJuIG9iamVjdDtcblxuXHR9XG5cblx0cGFyc2VTaGFwZXMoIGpzb24gKSB7XG5cblx0XHRjb25zdCBzaGFwZXMgPSB7fTtcblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBuZXcgU2hhcGUoKS5mcm9tSlNPTigganNvblsgaSBdICk7XG5cblx0XHRcdFx0c2hhcGVzWyBzaGFwZS51dWlkIF0gPSBzaGFwZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNoYXBlcztcblxuXHR9XG5cblx0cGFyc2VTa2VsZXRvbnMoIGpzb24sIG9iamVjdCApIHtcblxuXHRcdGNvbnN0IHNrZWxldG9ucyA9IHt9O1xuXHRcdGNvbnN0IGJvbmVzID0ge307XG5cblx0XHQvLyBnZW5lcmF0ZSBib25lIGxvb2t1cCB0YWJsZVxuXG5cdFx0b2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRpZiAoIGNoaWxkLmlzQm9uZSApIGJvbmVzWyBjaGlsZC51dWlkIF0gPSBjaGlsZDtcblxuXHRcdH0gKTtcblxuXHRcdC8vIGNyZWF0ZSBza2VsZXRvbnNcblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBuZXcgU2tlbGV0b24oKS5mcm9tSlNPTigganNvblsgaSBdLCBib25lcyApO1xuXG5cdFx0XHRcdHNrZWxldG9uc1sgc2tlbGV0b24udXVpZCBdID0gc2tlbGV0b247XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBza2VsZXRvbnM7XG5cblx0fVxuXG5cdHBhcnNlR2VvbWV0cmllcygganNvbiwgc2hhcGVzICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cmllcyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gbmV3IEJ1ZmZlckdlb21ldHJ5TG9hZGVyKCk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgZ2VvbWV0cnk7XG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggZGF0YS50eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnQnVmZmVyR2VvbWV0cnknOlxuXHRcdFx0XHRcdGNhc2UgJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRpZiAoIGRhdGEudHlwZSBpbiBHZW9tZXRyaWVzICkge1xuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gR2VvbWV0cmllc1sgZGF0YS50eXBlIF0uZnJvbUpTT04oIGRhdGEsIHNoYXBlcyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggYFRIUkVFLk9iamVjdExvYWRlcjogVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSBcIiR7IGRhdGEudHlwZSB9XCJgICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgZ2VvbWV0cnkubmFtZSA9IGRhdGEubmFtZTtcblx0XHRcdFx0aWYgKCBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XG5cblx0XHRcdFx0Z2VvbWV0cmllc1sgZGF0YS51dWlkIF0gPSBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJpZXM7XG5cblx0fVxuXG5cdHBhcnNlTWF0ZXJpYWxzKCBqc29uLCB0ZXh0dXJlcyApIHtcblxuXHRcdGNvbnN0IGNhY2hlID0ge307IC8vIE11bHRpTWF0ZXJpYWxcblx0XHRjb25zdCBtYXRlcmlhbHMgPSB7fTtcblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcblx0XHRcdGxvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjYWNoZVsgZGF0YS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNhY2hlWyBkYXRhLnV1aWQgXSA9IGxvYWRlci5wYXJzZSggZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXRlcmlhbHNbIGRhdGEudXVpZCBdID0gY2FjaGVbIGRhdGEudXVpZCBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXG5cdH1cblxuXHRwYXJzZUFuaW1hdGlvbnMoIGpzb24gKSB7XG5cblx0XHRjb25zdCBhbmltYXRpb25zID0ge307XG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRjb25zdCBjbGlwID0gQW5pbWF0aW9uQ2xpcC5wYXJzZSggZGF0YSApO1xuXG5cdFx0XHRcdGFuaW1hdGlvbnNbIGNsaXAudXVpZCBdID0gY2xpcDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFuaW1hdGlvbnM7XG5cblx0fVxuXG5cdHBhcnNlSW1hZ2VzKCBqc29uLCBvbkxvYWQgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0Y29uc3QgaW1hZ2VzID0ge307XG5cblx0XHRsZXQgbG9hZGVyO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZEltYWdlKCB1cmwgKSB7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdFx0cmV0dXJuIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlc2VyaWFsaXplSW1hZ2UoIGltYWdlICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXJsID0gaW1hZ2U7XG5cblx0XHRcdFx0Y29uc3QgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCggdXJsICkgPyB1cmwgOiBzY29wZS5yZXNvdXJjZVBhdGggKyB1cmw7XG5cblx0XHRcdFx0cmV0dXJuIGxvYWRJbWFnZSggcGF0aCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggaW1hZ2UuZGF0YSApIHtcblxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkYXRhOiBnZXRUeXBlZEFycmF5KCBpbWFnZS50eXBlLCBpbWFnZS5kYXRhICksXG5cdFx0XHRcdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRjb25zdCBtYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKCBvbkxvYWQgKTtcblxuXHRcdFx0bG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCBtYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGpzb24ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW1hZ2UgPSBqc29uWyBpIF07XG5cdFx0XHRcdGNvbnN0IHVybCA9IGltYWdlLnVybDtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHVybCApICkge1xuXG5cdFx0XHRcdFx0Ly8gbG9hZCBhcnJheSBvZiBpbWFnZXMgZS5nIEN1YmVUZXh0dXJlXG5cblx0XHRcdFx0XHRjb25zdCBpbWFnZUFycmF5ID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gdXJsLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50VXJsID0gdXJsWyBqIF07XG5cblx0XHRcdFx0XHRcdGNvbnN0IGRlc2VyaWFsaXplZEltYWdlID0gZGVzZXJpYWxpemVJbWFnZSggY3VycmVudFVybCApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGRlc2VyaWFsaXplZEltYWdlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZGVzZXJpYWxpemVkSW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VBcnJheS5wdXNoKCBkZXNlcmlhbGl6ZWRJbWFnZSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBhcnJheSBvZiBkYXRhIHRleHR1cmVzIGZvciBjdWJlIHRleHR1cmVzXG5cblx0XHRcdFx0XHRcdFx0XHRpbWFnZUFycmF5LnB1c2goIG5ldyBEYXRhVGV4dHVyZSggZGVzZXJpYWxpemVkSW1hZ2UuZGF0YSwgZGVzZXJpYWxpemVkSW1hZ2Uud2lkdGgsIGRlc2VyaWFsaXplZEltYWdlLmhlaWdodCApICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IG5ldyBTb3VyY2UoIGltYWdlQXJyYXkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gbG9hZCBzaW5nbGUgaW1hZ2VcblxuXHRcdFx0XHRcdGNvbnN0IGRlc2VyaWFsaXplZEltYWdlID0gZGVzZXJpYWxpemVJbWFnZSggaW1hZ2UudXJsICk7XG5cdFx0XHRcdFx0aW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBuZXcgU291cmNlKCBkZXNlcmlhbGl6ZWRJbWFnZSApO1xuXG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW1hZ2VzO1xuXG5cdH1cblxuXHRhc3luYyBwYXJzZUltYWdlc0FzeW5jKCBqc29uICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdGNvbnN0IGltYWdlcyA9IHt9O1xuXG5cdFx0bGV0IGxvYWRlcjtcblxuXHRcdGFzeW5jIGZ1bmN0aW9uIGRlc2VyaWFsaXplSW1hZ2UoIGltYWdlICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXJsID0gaW1hZ2U7XG5cblx0XHRcdFx0Y29uc3QgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCggdXJsICkgPyB1cmwgOiBzY29wZS5yZXNvdXJjZVBhdGggKyB1cmw7XG5cblx0XHRcdFx0cmV0dXJuIGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoIHBhdGggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGltYWdlLmRhdGEgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZGF0YTogZ2V0VHlwZWRBcnJheSggaW1hZ2UudHlwZSwgaW1hZ2UuZGF0YSApLFxuXHRcdFx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBpbWFnZS5oZWlnaHRcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0bG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0ganNvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbWFnZSA9IGpzb25bIGkgXTtcblx0XHRcdFx0Y29uc3QgdXJsID0gaW1hZ2UudXJsO1xuXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XG5cblx0XHRcdFx0XHQvLyBsb2FkIGFycmF5IG9mIGltYWdlcyBlLmcgQ3ViZVRleHR1cmVcblxuXHRcdFx0XHRcdGNvbnN0IGltYWdlQXJyYXkgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSB1cmwubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRVcmwgPSB1cmxbIGogXTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZGVzZXJpYWxpemVkSW1hZ2UgPSBhd2FpdCBkZXNlcmlhbGl6ZUltYWdlKCBjdXJyZW50VXJsICk7XG5cblx0XHRcdFx0XHRcdGlmICggZGVzZXJpYWxpemVkSW1hZ2UgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBkZXNlcmlhbGl6ZWRJbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbWFnZUFycmF5LnB1c2goIGRlc2VyaWFsaXplZEltYWdlICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIGFycmF5IG9mIGRhdGEgdGV4dHVyZXMgZm9yIGN1YmUgdGV4dHVyZXNcblxuXHRcdFx0XHRcdFx0XHRcdGltYWdlQXJyYXkucHVzaCggbmV3IERhdGFUZXh0dXJlKCBkZXNlcmlhbGl6ZWRJbWFnZS5kYXRhLCBkZXNlcmlhbGl6ZWRJbWFnZS53aWR0aCwgZGVzZXJpYWxpemVkSW1hZ2UuaGVpZ2h0ICkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGltYWdlc1sgaW1hZ2UudXVpZCBdID0gbmV3IFNvdXJjZSggaW1hZ2VBcnJheSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBsb2FkIHNpbmdsZSBpbWFnZVxuXG5cdFx0XHRcdFx0Y29uc3QgZGVzZXJpYWxpemVkSW1hZ2UgPSBhd2FpdCBkZXNlcmlhbGl6ZUltYWdlKCBpbWFnZS51cmwgKTtcblx0XHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IG5ldyBTb3VyY2UoIGRlc2VyaWFsaXplZEltYWdlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW1hZ2VzO1xuXG5cdH1cblxuXHRwYXJzZVRleHR1cmVzKCBqc29uLCBpbWFnZXMgKSB7XG5cblx0XHRmdW5jdGlvbiBwYXJzZUNvbnN0YW50KCB2YWx1ZSwgdHlwZSApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkgcmV0dXJuIHZhbHVlO1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLicsIHZhbHVlICk7XG5cblx0XHRcdHJldHVybiB0eXBlWyB2YWx1ZSBdO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdGV4dHVyZXMgPSB7fTtcblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRpZiAoIGRhdGEuaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHNvdXJjZSA9IGltYWdlc1sgZGF0YS5pbWFnZSBdO1xuXHRcdFx0XHRjb25zdCBpbWFnZSA9IHNvdXJjZS5kYXRhO1xuXG5cdFx0XHRcdGxldCB0ZXh0dXJlO1xuXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggaW1hZ2UgKSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcblxuXHRcdFx0XHRcdGlmICggaW1hZ2UubGVuZ3RoID09PSA2ICkgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggaW1hZ2UgJiYgaW1hZ2UuZGF0YSApIHtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSgpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGltYWdlICkgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7IC8vIHRleHR1cmVzIGNhbiBoYXZlIHVuZGVmaW5lZCBpbWFnZSBkYXRhXG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUuc291cmNlID0gc291cmNlO1xuXG5cdFx0XHRcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5uYW1lID0gZGF0YS5uYW1lO1xuXG5cdFx0XHRcdGlmICggZGF0YS5tYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hcHBpbmcsIFRFWFRVUkVfTUFQUElORyApO1xuXHRcdFx0XHRpZiAoIGRhdGEuY2hhbm5lbCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5jaGFubmVsID0gZGF0YS5jaGFubmVsO1xuXG5cdFx0XHRcdGlmICggZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSggZGF0YS5vZmZzZXQgKTtcblx0XHRcdFx0aWYgKCBkYXRhLnJlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCBkYXRhLnJlcGVhdCApO1xuXHRcdFx0XHRpZiAoIGRhdGEuY2VudGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmNlbnRlci5mcm9tQXJyYXkoIGRhdGEuY2VudGVyICk7XG5cdFx0XHRcdGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yb3RhdGlvbiA9IGRhdGEucm90YXRpb247XG5cblx0XHRcdFx0aWYgKCBkYXRhLndyYXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDAgXSwgVEVYVFVSRV9XUkFQUElORyApO1xuXHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSwgVEVYVFVSRV9XUkFQUElORyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRhdGEuZm9ybWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmZvcm1hdCA9IGRhdGEuZm9ybWF0O1xuXHRcdFx0XHRpZiAoIGRhdGEuaW50ZXJuYWxGb3JtYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuaW50ZXJuYWxGb3JtYXQgPSBkYXRhLmludGVybmFsRm9ybWF0O1xuXHRcdFx0XHRpZiAoIGRhdGEudHlwZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS50eXBlID0gZGF0YS50eXBlO1xuXHRcdFx0XHRpZiAoIGRhdGEuY29sb3JTcGFjZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5jb2xvclNwYWNlID0gZGF0YS5jb2xvclNwYWNlO1xuXG5cdFx0XHRcdGlmICggZGF0YS5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWluRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5taW5GaWx0ZXIsIFRFWFRVUkVfRklMVEVSICk7XG5cdFx0XHRcdGlmICggZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFnRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5tYWdGaWx0ZXIsIFRFWFRVUkVfRklMVEVSICk7XG5cdFx0XHRcdGlmICggZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XG5cblx0XHRcdFx0aWYgKCBkYXRhLmZsaXBZICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmZsaXBZID0gZGF0YS5mbGlwWTtcblxuXHRcdFx0XHRpZiAoIGRhdGEuZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGRhdGEuZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdFx0XHRpZiAoIGRhdGEucHJlbXVsdGlwbHlBbHBoYSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhID0gZGF0YS5wcmVtdWx0aXBseUFscGhhO1xuXHRcdFx0XHRpZiAoIGRhdGEudW5wYWNrQWxpZ25tZW50ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnVucGFja0FsaWdubWVudCA9IGRhdGEudW5wYWNrQWxpZ25tZW50O1xuXHRcdFx0XHRpZiAoIGRhdGEuY29tcGFyZUZ1bmN0aW9uICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiA9IGRhdGEuY29tcGFyZUZ1bmN0aW9uO1xuXG5cdFx0XHRcdGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XG5cblx0XHRcdFx0dGV4dHVyZXNbIGRhdGEudXVpZCBdID0gdGV4dHVyZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmVzO1xuXG5cdH1cblxuXHRwYXJzZU9iamVjdCggZGF0YSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLCB0ZXh0dXJlcywgYW5pbWF0aW9ucyApIHtcblxuXHRcdGxldCBvYmplY3Q7XG5cblx0XHRmdW5jdGlvbiBnZXRHZW9tZXRyeSggbmFtZSApIHtcblxuXHRcdFx0aWYgKCBnZW9tZXRyaWVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBnZW9tZXRyeScsIG5hbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cmllc1sgbmFtZSBdO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TWF0ZXJpYWwoIG5hbWUgKSB7XG5cblx0XHRcdGlmICggbmFtZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB1dWlkID0gbmFtZVsgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbHNbIHV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIHV1aWQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIG1hdGVyaWFsc1sgdXVpZCBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsc1sgbmFtZSBdO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZSggdXVpZCApIHtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlc1sgdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIHV1aWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZXNbIHV1aWQgXTtcblxuXHRcdH1cblxuXHRcdGxldCBnZW9tZXRyeSwgbWF0ZXJpYWw7XG5cblx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cblx0XHRcdGNhc2UgJ1NjZW5lJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgU2NlbmUoKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBOdW1iZXIuaXNJbnRlZ2VyKCBkYXRhLmJhY2tncm91bmQgKSApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSBuZXcgQ29sb3IoIGRhdGEuYmFja2dyb3VuZCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSBnZXRUZXh0dXJlKCBkYXRhLmJhY2tncm91bmQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBkYXRhLmVudmlyb25tZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuZW52aXJvbm1lbnQgPSBnZXRUZXh0dXJlKCBkYXRhLmVudmlyb25tZW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGF0YS5mb2cgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggZGF0YS5mb2cudHlwZSA9PT0gJ0ZvZycgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5mb2cgPSBuZXcgRm9nKCBkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cubmVhciwgZGF0YS5mb2cuZmFyICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBkYXRhLmZvZy50eXBlID09PSAnRm9nRXhwMicgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5mb2cgPSBuZXcgRm9nRXhwMiggZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLmRlbnNpdHkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZGF0YS5mb2cubmFtZSAhPT0gJycgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5mb2cubmFtZSA9IGRhdGEuZm9nLm5hbWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGF0YS5iYWNrZ3JvdW5kQmx1cnJpbmVzcyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmJhY2tncm91bmRCbHVycmluZXNzID0gZGF0YS5iYWNrZ3JvdW5kQmx1cnJpbmVzcztcblx0XHRcdFx0aWYgKCBkYXRhLmJhY2tncm91bmRJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG9iamVjdC5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gZGF0YS5iYWNrZ3JvdW5kSW50ZW5zaXR5O1xuXHRcdFx0XHRpZiAoIGRhdGEuYmFja2dyb3VuZFJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QuYmFja2dyb3VuZFJvdGF0aW9uLmZyb21BcnJheSggZGF0YS5iYWNrZ3JvdW5kUm90YXRpb24gKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEuZW52aXJvbm1lbnRJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG9iamVjdC5lbnZpcm9ubWVudEludGVuc2l0eSA9IGRhdGEuZW52aXJvbm1lbnRJbnRlbnNpdHk7XG5cdFx0XHRcdGlmICggZGF0YS5lbnZpcm9ubWVudFJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZW52aXJvbm1lbnRSb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEuZW52aXJvbm1lbnRSb3RhdGlvbiApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdQZXJzcGVjdGl2ZUNhbWVyYSc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBkYXRhLmZvdiwgZGF0YS5hc3BlY3QsIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEuZm9jdXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5mb2N1cyA9IGRhdGEuZm9jdXM7XG5cdFx0XHRcdGlmICggZGF0YS56b29tICE9PSB1bmRlZmluZWQgKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcblx0XHRcdFx0aWYgKCBkYXRhLmZpbG1HYXVnZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZpbG1HYXVnZSA9IGRhdGEuZmlsbUdhdWdlO1xuXHRcdFx0XHRpZiAoIGRhdGEuZmlsbU9mZnNldCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZpbG1PZmZzZXQgPSBkYXRhLmZpbG1PZmZzZXQ7XG5cdFx0XHRcdGlmICggZGF0YS52aWV3ICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkYXRhLnZpZXcgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCBkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG5cdFx0XHRcdGlmICggZGF0YS56b29tICE9PSB1bmRlZmluZWQgKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcblx0XHRcdFx0aWYgKCBkYXRhLnZpZXcgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIGRhdGEudmlldyApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdBbWJpZW50TGlnaHQnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBBbWJpZW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdQb2ludExpZ2h0JzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuZGVjYXkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnUmVjdEFyZWFMaWdodCc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IFJlY3RBcmVhTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLndpZHRoLCBkYXRhLmhlaWdodCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBTcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLnBlbnVtYnJhLCBkYXRhLmRlY2F5ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IEhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnTGlnaHRQcm9iZSc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IExpZ2h0UHJvYmUoKS5mcm9tSlNPTiggZGF0YSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdTa2lubmVkTWVzaCc6XG5cblx0XHRcdFx0Z2VvbWV0cnkgPSBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApO1xuXHRcdFx0IFx0bWF0ZXJpYWwgPSBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApO1xuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0aWYgKCBkYXRhLmJpbmRNb2RlICE9PSB1bmRlZmluZWQgKSBvYmplY3QuYmluZE1vZGUgPSBkYXRhLmJpbmRNb2RlO1xuXHRcdFx0XHRpZiAoIGRhdGEuYmluZE1hdHJpeCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmJpbmRNYXRyaXguZnJvbUFycmF5KCBkYXRhLmJpbmRNYXRyaXggKTtcblx0XHRcdFx0aWYgKCBkYXRhLnNrZWxldG9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2tlbGV0b24gPSBkYXRhLnNrZWxldG9uO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdNZXNoJzpcblxuXHRcdFx0XHRnZW9tZXRyeSA9IGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICk7XG5cdFx0XHRcdG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0luc3RhbmNlZE1lc2gnOlxuXG5cdFx0XHRcdGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKTtcblx0XHRcdFx0bWF0ZXJpYWwgPSBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApO1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IGRhdGEuY291bnQ7XG5cdFx0XHRcdGNvbnN0IGluc3RhbmNlTWF0cml4ID0gZGF0YS5pbnN0YW5jZU1hdHJpeDtcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VDb2xvciA9IGRhdGEuaW5zdGFuY2VDb2xvcjtcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgSW5zdGFuY2VkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsLCBjb3VudCApO1xuXHRcdFx0XHRvYmplY3QuaW5zdGFuY2VNYXRyaXggPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBpbnN0YW5jZU1hdHJpeC5hcnJheSApLCAxNiApO1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlQ29sb3IgIT09IHVuZGVmaW5lZCApIG9iamVjdC5pbnN0YW5jZUNvbG9yID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggaW5zdGFuY2VDb2xvci5hcnJheSApLCBpbnN0YW5jZUNvbG9yLml0ZW1TaXplICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0JhdGNoZWRNZXNoJzpcblxuXHRcdFx0XHRnZW9tZXRyeSA9IGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICk7XG5cdFx0XHRcdG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgQmF0Y2hlZE1lc2goIGRhdGEubWF4R2VvbWV0cnlDb3VudCwgZGF0YS5tYXhWZXJ0ZXhDb3VudCwgZGF0YS5tYXhJbmRleENvdW50LCBtYXRlcmlhbCApO1xuXHRcdFx0XHRvYmplY3QuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHRcdFx0b2JqZWN0LnBlck9iamVjdEZydXN0dW1DdWxsZWQgPSBkYXRhLnBlck9iamVjdEZydXN0dW1DdWxsZWQ7XG5cdFx0XHRcdG9iamVjdC5zb3J0T2JqZWN0cyA9IGRhdGEuc29ydE9iamVjdHM7XG5cblx0XHRcdFx0b2JqZWN0Ll9kcmF3UmFuZ2VzID0gZGF0YS5kcmF3UmFuZ2VzO1xuXHRcdFx0XHRvYmplY3QuX3Jlc2VydmVkUmFuZ2VzID0gZGF0YS5yZXNlcnZlZFJhbmdlcztcblxuXHRcdFx0XHRvYmplY3QuX3Zpc2liaWxpdHkgPSBkYXRhLnZpc2liaWxpdHk7XG5cdFx0XHRcdG9iamVjdC5fYWN0aXZlID0gZGF0YS5hY3RpdmU7XG5cdFx0XHRcdG9iamVjdC5fYm91bmRzID0gZGF0YS5ib3VuZHMubWFwKCBib3VuZCA9PiB7XG5cblx0XHRcdFx0XHRjb25zdCBib3ggPSBuZXcgQm94MygpO1xuXHRcdFx0XHRcdGJveC5taW4uZnJvbUFycmF5KCBib3VuZC5ib3hNaW4gKTtcblx0XHRcdFx0XHRib3gubWF4LmZyb21BcnJheSggYm91bmQuYm94TWF4ICk7XG5cblx0XHRcdFx0XHRjb25zdCBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cdFx0XHRcdFx0c3BoZXJlLnJhZGl1cyA9IGJvdW5kLnNwaGVyZVJhZGl1cztcblx0XHRcdFx0XHRzcGhlcmUuY2VudGVyLmZyb21BcnJheSggYm91bmQuc3BoZXJlQ2VudGVyICk7XG5cblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0Ym94SW5pdGlhbGl6ZWQ6IGJvdW5kLmJveEluaXRpYWxpemVkLFxuXHRcdFx0XHRcdFx0Ym94OiBib3gsXG5cblx0XHRcdFx0XHRcdHNwaGVyZUluaXRpYWxpemVkOiBib3VuZC5zcGhlcmVJbml0aWFsaXplZCxcblx0XHRcdFx0XHRcdHNwaGVyZTogc3BoZXJlXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0b2JqZWN0Ll9tYXhHZW9tZXRyeUNvdW50ID0gZGF0YS5tYXhHZW9tZXRyeUNvdW50O1xuXHRcdFx0XHRvYmplY3QuX21heFZlcnRleENvdW50ID0gZGF0YS5tYXhWZXJ0ZXhDb3VudDtcblx0XHRcdFx0b2JqZWN0Ll9tYXhJbmRleENvdW50ID0gZGF0YS5tYXhJbmRleENvdW50O1xuXG5cdFx0XHRcdG9iamVjdC5fZ2VvbWV0cnlJbml0aWFsaXplZCA9IGRhdGEuZ2VvbWV0cnlJbml0aWFsaXplZDtcblx0XHRcdFx0b2JqZWN0Ll9nZW9tZXRyeUNvdW50ID0gZGF0YS5nZW9tZXRyeUNvdW50O1xuXG5cdFx0XHRcdG9iamVjdC5fbWF0cmljZXNUZXh0dXJlID0gZ2V0VGV4dHVyZSggZGF0YS5tYXRyaWNlc1RleHR1cmUudXVpZCApO1xuXHRcdFx0XHRpZiAoIGRhdGEuY29sb3JzVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Ll9jb2xvcnNUZXh0dXJlID0gZ2V0VGV4dHVyZSggZGF0YS5jb2xvcnNUZXh0dXJlLnV1aWQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnTE9EJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgTE9EKCk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0xpbmUnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0xpbmVMb29wJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZUxvb3AoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnTGluZVNlZ21lbnRzJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZVNlZ21lbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1BvaW50Q2xvdWQnOlxuXHRcdFx0Y2FzZSAnUG9pbnRzJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1Nwcml0ZSc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IFNwcml0ZSggZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdHcm91cCc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IEdyb3VwKCk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0JvbmUnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBCb25lKCk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IE9iamVjdDNEKCk7XG5cblx0XHR9XG5cblx0XHRvYmplY3QudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcblxuXHRcdGlmICggZGF0YS5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0b2JqZWN0Lm1hdHJpeC5mcm9tQXJyYXkoIGRhdGEubWF0cml4ICk7XG5cblx0XHRcdGlmICggZGF0YS5tYXRyaXhBdXRvVXBkYXRlICE9PSB1bmRlZmluZWQgKSBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGRhdGEubWF0cml4QXV0b1VwZGF0ZTtcblx0XHRcdGlmICggb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgKSBvYmplY3QubWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcblx0XHRcdGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheSggZGF0YS5yb3RhdGlvbiApO1xuXHRcdFx0aWYgKCBkYXRhLnF1YXRlcm5pb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5xdWF0ZXJuaW9uLmZyb21BcnJheSggZGF0YS5xdWF0ZXJuaW9uICk7XG5cdFx0XHRpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZGF0YS51cCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnVwLmZyb21BcnJheSggZGF0YS51cCApO1xuXG5cdFx0aWYgKCBkYXRhLmNhc3RTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5jYXN0U2hhZG93ID0gZGF0YS5jYXN0U2hhZG93O1xuXHRcdGlmICggZGF0YS5yZWNlaXZlU2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IGRhdGEucmVjZWl2ZVNoYWRvdztcblxuXHRcdGlmICggZGF0YS5zaGFkb3cgKSB7XG5cblx0XHRcdGlmICggZGF0YS5zaGFkb3cuYmlhcyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5iaWFzID0gZGF0YS5zaGFkb3cuYmlhcztcblx0XHRcdGlmICggZGF0YS5zaGFkb3cubm9ybWFsQmlhcyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5ub3JtYWxCaWFzID0gZGF0YS5zaGFkb3cubm9ybWFsQmlhcztcblx0XHRcdGlmICggZGF0YS5zaGFkb3cucmFkaXVzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LnJhZGl1cyA9IGRhdGEuc2hhZG93LnJhZGl1cztcblx0XHRcdGlmICggZGF0YS5zaGFkb3cubWFwU2l6ZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5tYXBTaXplLmZyb21BcnJheSggZGF0YS5zaGFkb3cubWFwU2l6ZSApO1xuXHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5jYW1lcmEgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cuY2FtZXJhID0gdGhpcy5wYXJzZU9iamVjdCggZGF0YS5zaGFkb3cuY2FtZXJhICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRhdGEudmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpc2libGUgPSBkYXRhLnZpc2libGU7XG5cdFx0aWYgKCBkYXRhLmZydXN0dW1DdWxsZWQgIT09IHVuZGVmaW5lZCApIG9iamVjdC5mcnVzdHVtQ3VsbGVkID0gZGF0YS5mcnVzdHVtQ3VsbGVkO1xuXHRcdGlmICggZGF0YS5yZW5kZXJPcmRlciAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJlbmRlck9yZGVyID0gZGF0YS5yZW5kZXJPcmRlcjtcblx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XG5cdFx0aWYgKCBkYXRhLmxheWVycyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmxheWVycy5tYXNrID0gZGF0YS5sYXllcnM7XG5cblx0XHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBkYXRhLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0b2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggY2hpbGRyZW5bIGkgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLCB0ZXh0dXJlcywgYW5pbWF0aW9ucyApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGF0YS5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IG9iamVjdEFuaW1hdGlvbnMgPSBkYXRhLmFuaW1hdGlvbnM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG9iamVjdEFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHV1aWQgPSBvYmplY3RBbmltYXRpb25zWyBpIF07XG5cblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMucHVzaCggYW5pbWF0aW9uc1sgdXVpZCBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGF0YS50eXBlID09PSAnTE9EJyApIHtcblxuXHRcdFx0aWYgKCBkYXRhLmF1dG9VcGRhdGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5hdXRvVXBkYXRlID0gZGF0YS5hdXRvVXBkYXRlO1xuXG5cdFx0XHRjb25zdCBsZXZlbHMgPSBkYXRhLmxldmVscztcblxuXHRcdFx0Zm9yICggbGV0IGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBsZXZlbCA9IGxldmVsc1sgbCBdO1xuXHRcdFx0XHRjb25zdCBjaGlsZCA9IG9iamVjdC5nZXRPYmplY3RCeVByb3BlcnR5KCAndXVpZCcsIGxldmVsLm9iamVjdCApO1xuXG5cdFx0XHRcdGlmICggY2hpbGQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5hZGRMZXZlbCggY2hpbGQsIGxldmVsLmRpc3RhbmNlLCBsZXZlbC5oeXN0ZXJlc2lzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdH1cblxuXHRiaW5kU2tlbGV0b25zKCBvYmplY3QsIHNrZWxldG9ucyApIHtcblxuXHRcdGlmICggT2JqZWN0LmtleXMoIHNrZWxldG9ucyApLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0aWYgKCBjaGlsZC5pc1NraW5uZWRNZXNoID09PSB0cnVlICYmIGNoaWxkLnNrZWxldG9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBza2VsZXRvbnNbIGNoaWxkLnNrZWxldG9uIF07XG5cblx0XHRcdFx0aWYgKCBza2VsZXRvbiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBza2VsZXRvbiBmb3VuZCB3aXRoIFVVSUQ6JywgY2hpbGQuc2tlbGV0b24gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y2hpbGQuYmluZCggc2tlbGV0b24sIGNoaWxkLmJpbmRNYXRyaXggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHR9XG5cbn1cblxuY29uc3QgVEVYVFVSRV9NQVBQSU5HID0ge1xuXHRVVk1hcHBpbmc6IFVWTWFwcGluZyxcblx0Q3ViZVJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsXG5cdEN1YmVSZWZyYWN0aW9uTWFwcGluZzogQ3ViZVJlZnJhY3Rpb25NYXBwaW5nLFxuXHRFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsXG5cdEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyxcblx0Q3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nXG59O1xuXG5jb25zdCBURVhUVVJFX1dSQVBQSU5HID0ge1xuXHRSZXBlYXRXcmFwcGluZzogUmVwZWF0V3JhcHBpbmcsXG5cdENsYW1wVG9FZGdlV3JhcHBpbmc6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcbn07XG5cbmNvbnN0IFRFWFRVUkVfRklMVEVSID0ge1xuXHROZWFyZXN0RmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuXHROZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcjogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXI6IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdExpbmVhckZpbHRlcjogTGluZWFyRmlsdGVyLFxuXHRMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyOiBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHRMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI6IExpbmVhck1pcG1hcExpbmVhckZpbHRlclxufTtcblxuY2xhc3MgSW1hZ2VCaXRtYXBMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHRcdHRoaXMuaXNJbWFnZUJpdG1hcExvYWRlciA9IHRydWU7XG5cblx0XHRpZiAoIHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBjcmVhdGVJbWFnZUJpdG1hcCgpIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogZmV0Y2goKSBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMub3B0aW9ucyA9IHsgcHJlbXVsdGlwbHlBbHBoYTogJ25vbmUnIH07XG5cblx0fVxuXG5cdHNldE9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHVybCA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcblxuXHRcdHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKCB1cmwgKTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XG5cblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRcdC8vIElmIGNhY2hlZCBpcyBhIHByb21pc2UsIHdhaXQgZm9yIGl0IHRvIHJlc29sdmVcblx0XHRcdGlmICggY2FjaGVkLnRoZW4gKSB7XG5cblx0XHRcdFx0Y2FjaGVkLnRoZW4oIGltYWdlQml0bWFwID0+IHtcblxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBpbWFnZUJpdG1hcCApO1xuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0XHR9ICkuY2F0Y2goIGUgPT4ge1xuXG5cdFx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGNhY2hlZCBpcyBub3QgYSBwcm9taXNlIChpLmUuLCBpdCdzIGFscmVhZHkgYW4gaW1hZ2VCaXRtYXApXG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdH0sIDAgKTtcblxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGZldGNoT3B0aW9ucyA9IHt9O1xuXHRcdGZldGNoT3B0aW9ucy5jcmVkZW50aWFscyA9ICggdGhpcy5jcm9zc09yaWdpbiA9PT0gJ2Fub255bW91cycgKSA/ICdzYW1lLW9yaWdpbicgOiAnaW5jbHVkZSc7XG5cdFx0ZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSB0aGlzLnJlcXVlc3RIZWFkZXI7XG5cblx0XHRjb25zdCBwcm9taXNlID0gZmV0Y2goIHVybCwgZmV0Y2hPcHRpb25zICkudGhlbiggZnVuY3Rpb24gKCByZXMgKSB7XG5cblx0XHRcdHJldHVybiByZXMuYmxvYigpO1xuXG5cdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggYmxvYiApIHtcblxuXHRcdFx0cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKCBibG9iLCBPYmplY3QuYXNzaWduKCBzY29wZS5vcHRpb25zLCB7IGNvbG9yU3BhY2VDb252ZXJzaW9uOiAnbm9uZScgfSApICk7XG5cblx0XHR9ICkudGhlbiggZnVuY3Rpb24gKCBpbWFnZUJpdG1hcCApIHtcblxuXHRcdFx0Q2FjaGUuYWRkKCB1cmwsIGltYWdlQml0bWFwICk7XG5cblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBpbWFnZUJpdG1hcCApO1xuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHRyZXR1cm4gaW1hZ2VCaXRtYXA7XG5cblx0XHR9ICkuY2F0Y2goIGZ1bmN0aW9uICggZSApIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZSApO1xuXG5cdFx0XHRDYWNoZS5yZW1vdmUoIHVybCApO1xuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0fSApO1xuXG5cdFx0Q2FjaGUuYWRkKCB1cmwsIHByb21pc2UgKTtcblx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0fVxuXG59XG5cbmxldCBfY29udGV4dDtcblxuY2xhc3MgQXVkaW9Db250ZXh0IHtcblxuXHRzdGF0aWMgZ2V0Q29udGV4dCgpIHtcblxuXHRcdGlmICggX2NvbnRleHQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0X2NvbnRleHQgPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIF9jb250ZXh0O1xuXG5cdH1cblxuXHRzdGF0aWMgc2V0Q29udGV4dCggdmFsdWUgKSB7XG5cblx0XHRfY29udGV4dCA9IHZhbHVlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBBdWRpb0xvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGJ1ZmZlci4gVGhlIGBkZWNvZGVBdWRpb0RhdGFgIG1ldGhvZFxuXHRcdFx0XHQvLyBkZXRhY2hlcyB0aGUgYnVmZmVyIHdoZW4gY29tcGxldGUsIHByZXZlbnRpbmcgcmV1c2UuXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlckNvcHkgPSBidWZmZXIuc2xpY2UoIDAgKTtcblxuXHRcdFx0XHRjb25zdCBjb250ZXh0ID0gQXVkaW9Db250ZXh0LmdldENvbnRleHQoKTtcblx0XHRcdFx0Y29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIGJ1ZmZlckNvcHksIGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRvbkxvYWQoIGF1ZGlvQnVmZmVyICk7XG5cblx0XHRcdFx0fSApLmNhdGNoKCBoYW5kbGVFcnJvciApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRoYW5kbGVFcnJvciggZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVFcnJvciggZSApIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5jb25zdCBfZXllUmlnaHQgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfZXllTGVmdCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9wcm9qZWN0aW9uTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5jbGFzcyBTdGVyZW9DYW1lcmEge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy50eXBlID0gJ1N0ZXJlb0NhbWVyYSc7XG5cblx0XHR0aGlzLmFzcGVjdCA9IDE7XG5cblx0XHR0aGlzLmV5ZVNlcCA9IDAuMDY0O1xuXG5cdFx0dGhpcy5jYW1lcmFMID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0dGhpcy5jYW1lcmFMLmxheWVycy5lbmFibGUoIDEgKTtcblx0XHR0aGlzLmNhbWVyYUwubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5jYW1lcmFSID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0dGhpcy5jYW1lcmFSLmxheWVycy5lbmFibGUoIDIgKTtcblx0XHR0aGlzLmNhbWVyYVIubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY2FjaGUgPSB7XG5cdFx0XHRmb2N1czogbnVsbCxcblx0XHRcdGZvdjogbnVsbCxcblx0XHRcdGFzcGVjdDogbnVsbCxcblx0XHRcdG5lYXI6IG51bGwsXG5cdFx0XHRmYXI6IG51bGwsXG5cdFx0XHR6b29tOiBudWxsLFxuXHRcdFx0ZXllU2VwOiBudWxsXG5cdFx0fTtcblxuXHR9XG5cblx0dXBkYXRlKCBjYW1lcmEgKSB7XG5cblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlO1xuXG5cdFx0Y29uc3QgbmVlZHNVcGRhdGUgPSBjYWNoZS5mb2N1cyAhPT0gY2FtZXJhLmZvY3VzIHx8IGNhY2hlLmZvdiAhPT0gY2FtZXJhLmZvdiB8fFxuXHRcdFx0Y2FjaGUuYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3QgfHwgY2FjaGUubmVhciAhPT0gY2FtZXJhLm5lYXIgfHxcblx0XHRcdGNhY2hlLmZhciAhPT0gY2FtZXJhLmZhciB8fCBjYWNoZS56b29tICE9PSBjYW1lcmEuem9vbSB8fCBjYWNoZS5leWVTZXAgIT09IHRoaXMuZXllU2VwO1xuXG5cdFx0aWYgKCBuZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0Y2FjaGUuZm9jdXMgPSBjYW1lcmEuZm9jdXM7XG5cdFx0XHRjYWNoZS5mb3YgPSBjYW1lcmEuZm92O1xuXHRcdFx0Y2FjaGUuYXNwZWN0ID0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0O1xuXHRcdFx0Y2FjaGUubmVhciA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0Y2FjaGUuZmFyID0gY2FtZXJhLmZhcjtcblx0XHRcdGNhY2hlLnpvb20gPSBjYW1lcmEuem9vbTtcblx0XHRcdGNhY2hlLmV5ZVNlcCA9IHRoaXMuZXllU2VwO1xuXG5cdFx0XHQvLyBPZmYtYXhpcyBzdGVyZW9zY29waWMgZWZmZWN0IGJhc2VkIG9uXG5cdFx0XHQvLyBodHRwOi8vcGF1bGJvdXJrZS5uZXQvc3RlcmVvZ3JhcGhpY3Mvc3RlcmVvcmVuZGVyL1xuXG5cdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5jb3B5KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXHRcdFx0Y29uc3QgZXllU2VwSGFsZiA9IGNhY2hlLmV5ZVNlcCAvIDI7XG5cdFx0XHRjb25zdCBleWVTZXBPblByb2plY3Rpb24gPSBleWVTZXBIYWxmICogY2FjaGUubmVhciAvIGNhY2hlLmZvY3VzO1xuXHRcdFx0Y29uc3QgeW1heCA9ICggY2FjaGUubmVhciAqIE1hdGgudGFuKCBERUcyUkFEICogY2FjaGUuZm92ICogMC41ICkgKSAvIGNhY2hlLnpvb207XG5cdFx0XHRsZXQgeG1pbiwgeG1heDtcblxuXHRcdFx0Ly8gdHJhbnNsYXRlIHhPZmZzZXRcblxuXHRcdFx0X2V5ZUxlZnQuZWxlbWVudHNbIDEyIF0gPSAtIGV5ZVNlcEhhbGY7XG5cdFx0XHRfZXllUmlnaHQuZWxlbWVudHNbIDEyIF0gPSBleWVTZXBIYWxmO1xuXG5cdFx0XHQvLyBmb3IgbGVmdCBleWVcblxuXHRcdFx0eG1pbiA9IC0geW1heCAqIGNhY2hlLmFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdHhtYXggPSB5bWF4ICogY2FjaGUuYXNwZWN0ICsgZXllU2VwT25Qcm9qZWN0aW9uO1xuXG5cdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMCBdID0gMiAqIGNhY2hlLm5lYXIgLyAoIHhtYXggLSB4bWluICk7XG5cdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xuXG5cdFx0XHR0aGlzLmNhbWVyYUwucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBfcHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdFx0XHQvLyBmb3IgcmlnaHQgZXllXG5cblx0XHRcdHhtaW4gPSAtIHltYXggKiBjYWNoZS5hc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XG5cdFx0XHR4bWF4ID0geW1heCAqIGNhY2hlLmFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcblxuXHRcdFx0X3Byb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBjYWNoZS5uZWFyIC8gKCB4bWF4IC0geG1pbiApO1xuXHRcdFx0X3Byb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcblxuXHRcdFx0dGhpcy5jYW1lcmFSLnByb2plY3Rpb25NYXRyaXguY29weSggX3Byb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2FtZXJhTC5tYXRyaXhXb3JsZC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKS5tdWx0aXBseSggX2V5ZUxlZnQgKTtcblx0XHR0aGlzLmNhbWVyYVIubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkubXVsdGlwbHkoIF9leWVSaWdodCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBDbG9jayB7XG5cblx0Y29uc3RydWN0b3IoIGF1dG9TdGFydCA9IHRydWUgKSB7XG5cblx0XHR0aGlzLmF1dG9TdGFydCA9IGF1dG9TdGFydDtcblxuXHRcdHRoaXMuc3RhcnRUaW1lID0gMDtcblx0XHR0aGlzLm9sZFRpbWUgPSAwO1xuXHRcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cblx0fVxuXG5cdHN0YXJ0KCkge1xuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSBub3coKTtcblxuXHRcdHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuXHRcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cblx0fVxuXG5cdHN0b3AoKSB7XG5cblx0XHR0aGlzLmdldEVsYXBzZWRUaW1lKCk7XG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5hdXRvU3RhcnQgPSBmYWxzZTtcblxuXHR9XG5cblx0Z2V0RWxhcHNlZFRpbWUoKSB7XG5cblx0XHR0aGlzLmdldERlbHRhKCk7XG5cdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cblx0fVxuXG5cdGdldERlbHRhKCkge1xuXG5cdFx0bGV0IGRpZmYgPSAwO1xuXG5cdFx0aWYgKCB0aGlzLmF1dG9TdGFydCAmJiAhIHRoaXMucnVubmluZyApIHtcblxuXHRcdFx0dGhpcy5zdGFydCgpO1xuXHRcdFx0cmV0dXJuIDA7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMucnVubmluZyApIHtcblxuXHRcdFx0Y29uc3QgbmV3VGltZSA9IG5vdygpO1xuXG5cdFx0XHRkaWZmID0gKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICkgLyAxMDAwO1xuXHRcdFx0dGhpcy5vbGRUaW1lID0gbmV3VGltZTtcblxuXHRcdFx0dGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRpZmY7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIG5vdygpIHtcblxuXHRyZXR1cm4gKCB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnID8gRGF0ZSA6IHBlcmZvcm1hbmNlICkubm93KCk7IC8vIHNlZSAjMTA3MzJcblxufVxuXG5jb25zdCBfcG9zaXRpb24kMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5jb25zdCBfc2NhbGUkMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9vcmllbnRhdGlvbiQxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBBdWRpb0xpc3RlbmVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdBdWRpb0xpc3RlbmVyJztcblxuXHRcdHRoaXMuY29udGV4dCA9IEF1ZGlvQ29udGV4dC5nZXRDb250ZXh0KCk7XG5cblx0XHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuXHRcdHRoaXMuZmlsdGVyID0gbnVsbDtcblxuXHRcdHRoaXMudGltZURlbHRhID0gMDtcblxuXHRcdC8vIHByaXZhdGVcblxuXHRcdHRoaXMuX2Nsb2NrID0gbmV3IENsb2NrKCk7XG5cblx0fVxuXG5cdGdldElucHV0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2FpbjtcblxuXHR9XG5cblx0cmVtb3ZlRmlsdGVyKCkge1xuXG5cdFx0aWYgKCB0aGlzLmZpbHRlciAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyICk7XG5cdFx0XHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblx0XHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblx0XHRcdHRoaXMuZmlsdGVyID0gbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRGaWx0ZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXI7XG5cblx0fVxuXG5cdHNldEZpbHRlciggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcblx0XHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5maWx0ZXIgPSB2YWx1ZTtcblx0XHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcblx0XHR0aGlzLmZpbHRlci5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRNYXN0ZXJWb2x1bWUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cblx0fVxuXG5cdHNldE1hc3RlclZvbHVtZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmdhaW4uZ2Fpbi5zZXRUYXJnZXRBdFRpbWUoIHZhbHVlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsIDAuMDEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdGNvbnN0IGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xuXHRcdGNvbnN0IHVwID0gdGhpcy51cDtcblxuXHRcdHRoaXMudGltZURlbHRhID0gdGhpcy5fY2xvY2suZ2V0RGVsdGEoKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24kMSwgX3F1YXRlcm5pb24kMSwgX3NjYWxlJDEgKTtcblxuXHRcdF9vcmllbnRhdGlvbiQxLnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbiQxICk7XG5cblx0XHRpZiAoIGxpc3RlbmVyLnBvc2l0aW9uWCApIHtcblxuXHRcdFx0Ly8gY29kZSBwYXRoIGZvciBDaHJvbWUgKHNlZSAjMTQzOTMpXG5cblx0XHRcdGNvbnN0IGVuZFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLnRpbWVEZWx0YTtcblxuXHRcdFx0bGlzdGVuZXIucG9zaXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfcG9zaXRpb24kMS54LCBlbmRUaW1lICk7XG5cdFx0XHRsaXN0ZW5lci5wb3NpdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9wb3NpdGlvbiQxLnksIGVuZFRpbWUgKTtcblx0XHRcdGxpc3RlbmVyLnBvc2l0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX3Bvc2l0aW9uJDEueiwgZW5kVGltZSApO1xuXHRcdFx0bGlzdGVuZXIuZm9yd2FyZFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9vcmllbnRhdGlvbiQxLngsIGVuZFRpbWUgKTtcblx0XHRcdGxpc3RlbmVyLmZvcndhcmRZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfb3JpZW50YXRpb24kMS55LCBlbmRUaW1lICk7XG5cdFx0XHRsaXN0ZW5lci5mb3J3YXJkWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX29yaWVudGF0aW9uJDEueiwgZW5kVGltZSApO1xuXHRcdFx0bGlzdGVuZXIudXBYLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCB1cC54LCBlbmRUaW1lICk7XG5cdFx0XHRsaXN0ZW5lci51cFkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIHVwLnksIGVuZFRpbWUgKTtcblx0XHRcdGxpc3RlbmVyLnVwWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggdXAueiwgZW5kVGltZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bGlzdGVuZXIuc2V0UG9zaXRpb24oIF9wb3NpdGlvbiQxLngsIF9wb3NpdGlvbiQxLnksIF9wb3NpdGlvbiQxLnogKTtcblx0XHRcdGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKCBfb3JpZW50YXRpb24kMS54LCBfb3JpZW50YXRpb24kMS55LCBfb3JpZW50YXRpb24kMS56LCB1cC54LCB1cC55LCB1cC56ICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmNsYXNzIEF1ZGlvIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBsaXN0ZW5lciApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQXVkaW8nO1xuXG5cdFx0dGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuXHRcdHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XG5cblx0XHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCBsaXN0ZW5lci5nZXRJbnB1dCgpICk7XG5cblx0XHR0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG5cblx0XHR0aGlzLmJ1ZmZlciA9IG51bGw7XG5cdFx0dGhpcy5kZXR1bmUgPSAwO1xuXHRcdHRoaXMubG9vcCA9IGZhbHNlO1xuXHRcdHRoaXMubG9vcFN0YXJ0ID0gMDtcblx0XHR0aGlzLmxvb3BFbmQgPSAwO1xuXHRcdHRoaXMub2Zmc2V0ID0gMDtcblx0XHR0aGlzLmR1cmF0aW9uID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucGxheWJhY2tSYXRlID0gMTtcblx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gdHJ1ZTtcblx0XHR0aGlzLnNvdXJjZSA9IG51bGw7XG5cdFx0dGhpcy5zb3VyY2VUeXBlID0gJ2VtcHR5JztcblxuXHRcdHRoaXMuX3N0YXJ0ZWRBdCA9IDA7XG5cdFx0dGhpcy5fcHJvZ3Jlc3MgPSAwO1xuXHRcdHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5maWx0ZXJzID0gW107XG5cblx0fVxuXG5cdGdldE91dHB1dCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmdhaW47XG5cblx0fVxuXG5cdHNldE5vZGVTb3VyY2UoIGF1ZGlvTm9kZSApIHtcblxuXHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG5cdFx0dGhpcy5zb3VyY2VUeXBlID0gJ2F1ZGlvTm9kZSc7XG5cdFx0dGhpcy5zb3VyY2UgPSBhdWRpb05vZGU7XG5cdFx0dGhpcy5jb25uZWN0KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0TWVkaWFFbGVtZW50U291cmNlKCBtZWRpYUVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdtZWRpYU5vZGUnO1xuXHRcdHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZSggbWVkaWFFbGVtZW50ICk7XG5cdFx0dGhpcy5jb25uZWN0KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0TWVkaWFTdHJlYW1Tb3VyY2UoIG1lZGlhU3RyZWFtICkge1xuXG5cdFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSBmYWxzZTtcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnbWVkaWFTdHJlYW1Ob2RlJztcblx0XHR0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSggbWVkaWFTdHJlYW0gKTtcblx0XHR0aGlzLmNvbm5lY3QoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRCdWZmZXIoIGF1ZGlvQnVmZmVyICkge1xuXG5cdFx0dGhpcy5idWZmZXIgPSBhdWRpb0J1ZmZlcjtcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcblxuXHRcdGlmICggdGhpcy5hdXRvcGxheSApIHRoaXMucGxheSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHBsYXkoIGRlbGF5ID0gMCApIHtcblxuXHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiBBdWRpbyBpcyBhbHJlYWR5IHBsYXlpbmcuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIGRlbGF5O1xuXG5cdFx0Y29uc3Qgc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHRcdHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcblx0XHRzb3VyY2UubG9vcCA9IHRoaXMubG9vcDtcblx0XHRzb3VyY2UubG9vcFN0YXJ0ID0gdGhpcy5sb29wU3RhcnQ7XG5cdFx0c291cmNlLmxvb3BFbmQgPSB0aGlzLmxvb3BFbmQ7XG5cdFx0c291cmNlLm9uZW5kZWQgPSB0aGlzLm9uRW5kZWQuYmluZCggdGhpcyApO1xuXHRcdHNvdXJjZS5zdGFydCggdGhpcy5fc3RhcnRlZEF0LCB0aGlzLl9wcm9ncmVzcyArIHRoaXMub2Zmc2V0LCB0aGlzLmR1cmF0aW9uICk7XG5cblx0XHR0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cblx0XHR0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuXHRcdHRoaXMuc2V0RGV0dW5lKCB0aGlzLmRldHVuZSApO1xuXHRcdHRoaXMuc2V0UGxheWJhY2tSYXRlKCB0aGlzLnBsYXliYWNrUmF0ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuY29ubmVjdCgpO1xuXG5cdH1cblxuXHRwYXVzZSgpIHtcblxuXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHQvLyB1cGRhdGUgY3VycmVudCBwcm9ncmVzc1xuXG5cdFx0XHR0aGlzLl9wcm9ncmVzcyArPSBNYXRoLm1heCggdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lIC0gdGhpcy5fc3RhcnRlZEF0LCAwICkgKiB0aGlzLnBsYXliYWNrUmF0ZTtcblxuXHRcdFx0aWYgKCB0aGlzLmxvb3AgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Ly8gZW5zdXJlIF9wcm9ncmVzcyBkb2VzIG5vdCBleGNlZWQgZHVyYXRpb24gd2l0aCBsb29wZWQgYXVkaW9zXG5cblx0XHRcdFx0dGhpcy5fcHJvZ3Jlc3MgPSB0aGlzLl9wcm9ncmVzcyAlICggdGhpcy5kdXJhdGlvbiB8fCB0aGlzLmJ1ZmZlci5kdXJhdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc291cmNlLnN0b3AoKTtcblx0XHRcdHRoaXMuc291cmNlLm9uZW5kZWQgPSBudWxsO1xuXG5cdFx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0b3AoKSB7XG5cblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fcHJvZ3Jlc3MgPSAwO1xuXG5cdFx0aWYgKCB0aGlzLnNvdXJjZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xuXHRcdFx0dGhpcy5zb3VyY2Uub25lbmRlZCA9IG51bGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbm5lY3QoKSB7XG5cblx0XHRpZiAoIHRoaXMuZmlsdGVycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmZpbHRlcnNbIDAgXSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmZpbHRlcnNbIGkgLSAxIF0uY29ubmVjdCggdGhpcy5maWx0ZXJzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZpbHRlcnNbIHRoaXMuZmlsdGVycy5sZW5ndGggLSAxIF0uY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNjb25uZWN0KCkge1xuXG5cdFx0aWYgKCB0aGlzLl9jb25uZWN0ZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZmlsdGVycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlcnNbIDAgXSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmZpbHRlcnNbIGkgLSAxIF0uZGlzY29ubmVjdCggdGhpcy5maWx0ZXJzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZpbHRlcnNbIHRoaXMuZmlsdGVycy5sZW5ndGggLSAxIF0uZGlzY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0RmlsdGVycygpIHtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlcnM7XG5cblx0fVxuXG5cdHNldEZpbHRlcnMoIHZhbHVlICkge1xuXG5cdFx0aWYgKCAhIHZhbHVlICkgdmFsdWUgPSBbXTtcblxuXHRcdGlmICggdGhpcy5fY29ubmVjdGVkID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcblx0XHRcdHRoaXMuZmlsdGVycyA9IHZhbHVlLnNsaWNlKCk7XG5cdFx0XHR0aGlzLmNvbm5lY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZmlsdGVycyA9IHZhbHVlLnNsaWNlKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RGV0dW5lKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuZGV0dW5lID0gdmFsdWU7XG5cblx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICYmIHRoaXMuc291cmNlLmRldHVuZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5kZXR1bmUuc2V0VGFyZ2V0QXRUaW1lKCB0aGlzLmRldHVuZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0RGV0dW5lKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGV0dW5lO1xuXG5cdH1cblxuXHRnZXRGaWx0ZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRGaWx0ZXJzKClbIDAgXTtcblxuXHR9XG5cblx0c2V0RmlsdGVyKCBmaWx0ZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKCBmaWx0ZXIgPyBbIGZpbHRlciBdIDogW10gKTtcblxuXHR9XG5cblx0c2V0UGxheWJhY2tSYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xuXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnNldFRhcmdldEF0VGltZSggdGhpcy5wbGF5YmFja1JhdGUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFBsYXliYWNrUmF0ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcblxuXHR9XG5cblx0b25FbmRlZCgpIHtcblxuXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0fVxuXG5cdGdldExvb3AoKSB7XG5cblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubG9vcDtcblxuXHR9XG5cblx0c2V0TG9vcCggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5sb29wID0gdmFsdWU7XG5cblx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldExvb3BTdGFydCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmxvb3BTdGFydCA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldExvb3BFbmQoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5sb29wRW5kID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Vm9sdW1lKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xuXG5cdH1cblxuXHRzZXRWb2x1bWUoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5nYWluLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKCB2YWx1ZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY29uc3QgX3Bvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3F1YXRlcm5pb24gPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5jb25zdCBfc2NhbGUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfb3JpZW50YXRpb24gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNsYXNzIFBvc2l0aW9uYWxBdWRpbyBleHRlbmRzIEF1ZGlvIHtcblxuXHRjb25zdHJ1Y3RvciggbGlzdGVuZXIgKSB7XG5cblx0XHRzdXBlciggbGlzdGVuZXIgKTtcblxuXHRcdHRoaXMucGFubmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuXHRcdHRoaXMucGFubmVyLnBhbm5pbmdNb2RlbCA9ICdIUlRGJztcblx0XHR0aGlzLnBhbm5lci5jb25uZWN0KCB0aGlzLmdhaW4gKTtcblxuXHR9XG5cblx0Y29ubmVjdCgpIHtcblxuXHRcdHN1cGVyLmNvbm5lY3QoKTtcblxuXHRcdHRoaXMucGFubmVyLmNvbm5lY3QoIHRoaXMuZ2FpbiApO1xuXG5cdH1cblxuXHRkaXNjb25uZWN0KCkge1xuXG5cdFx0c3VwZXIuZGlzY29ubmVjdCgpO1xuXG5cdFx0dGhpcy5wYW5uZXIuZGlzY29ubmVjdCggdGhpcy5nYWluICk7XG5cblx0fVxuXG5cdGdldE91dHB1dCgpIHtcblxuXHRcdHJldHVybiB0aGlzLnBhbm5lcjtcblxuXHR9XG5cblx0Z2V0UmVmRGlzdGFuY2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XG5cblx0fVxuXG5cdHNldFJlZkRpc3RhbmNlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Um9sbG9mZkZhY3RvcigpIHtcblxuXHRcdHJldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yO1xuXG5cdH1cblxuXHRzZXRSb2xsb2ZmRmFjdG9yKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXREaXN0YW5jZU1vZGVsKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMucGFubmVyLmRpc3RhbmNlTW9kZWw7XG5cblx0fVxuXG5cdHNldERpc3RhbmNlTW9kZWwoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE1heERpc3RhbmNlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xuXG5cdH1cblxuXHRzZXRNYXhEaXN0YW5jZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhbm5lci5tYXhEaXN0YW5jZSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldERpcmVjdGlvbmFsQ29uZSggY29uZUlubmVyQW5nbGUsIGNvbmVPdXRlckFuZ2xlLCBjb25lT3V0ZXJHYWluICkge1xuXG5cdFx0dGhpcy5wYW5uZXIuY29uZUlubmVyQW5nbGUgPSBjb25lSW5uZXJBbmdsZTtcblx0XHR0aGlzLnBhbm5lci5jb25lT3V0ZXJBbmdsZSA9IGNvbmVPdXRlckFuZ2xlO1xuXHRcdHRoaXMucGFubmVyLmNvbmVPdXRlckdhaW4gPSBjb25lT3V0ZXJHYWluO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gdHJ1ZSAmJiB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCBfcXVhdGVybmlvbiwgX3NjYWxlICk7XG5cblx0XHRfb3JpZW50YXRpb24uc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbiApO1xuXG5cdFx0Y29uc3QgcGFubmVyID0gdGhpcy5wYW5uZXI7XG5cblx0XHRpZiAoIHBhbm5lci5wb3NpdGlvblggKSB7XG5cblx0XHRcdC8vIGNvZGUgcGF0aCBmb3IgQ2hyb21lIGFuZCBGaXJlZm94IChzZWUgIzE0MzkzKVxuXG5cdFx0XHRjb25zdCBlbmRUaW1lID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy5saXN0ZW5lci50aW1lRGVsdGE7XG5cblx0XHRcdHBhbm5lci5wb3NpdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9wb3NpdGlvbi54LCBlbmRUaW1lICk7XG5cdFx0XHRwYW5uZXIucG9zaXRpb25ZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfcG9zaXRpb24ueSwgZW5kVGltZSApO1xuXHRcdFx0cGFubmVyLnBvc2l0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX3Bvc2l0aW9uLnosIGVuZFRpbWUgKTtcblx0XHRcdHBhbm5lci5vcmllbnRhdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9vcmllbnRhdGlvbi54LCBlbmRUaW1lICk7XG5cdFx0XHRwYW5uZXIub3JpZW50YXRpb25ZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfb3JpZW50YXRpb24ueSwgZW5kVGltZSApO1xuXHRcdFx0cGFubmVyLm9yaWVudGF0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX29yaWVudGF0aW9uLnosIGVuZFRpbWUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHBhbm5lci5zZXRQb3NpdGlvbiggX3Bvc2l0aW9uLngsIF9wb3NpdGlvbi55LCBfcG9zaXRpb24ueiApO1xuXHRcdFx0cGFubmVyLnNldE9yaWVudGF0aW9uKCBfb3JpZW50YXRpb24ueCwgX29yaWVudGF0aW9uLnksIF9vcmllbnRhdGlvbi56ICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmNsYXNzIEF1ZGlvQW5hbHlzZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBhdWRpbywgZmZ0U2l6ZSA9IDIwNDggKSB7XG5cblx0XHR0aGlzLmFuYWx5c2VyID0gYXVkaW8uY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuXHRcdHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSA9IGZmdFNpemU7XG5cblx0XHR0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSggdGhpcy5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCApO1xuXG5cdFx0YXVkaW8uZ2V0T3V0cHV0KCkuY29ubmVjdCggdGhpcy5hbmFseXNlciApO1xuXG5cdH1cblxuXG5cdGdldEZyZXF1ZW5jeURhdGEoKSB7XG5cblx0XHR0aGlzLmFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKCB0aGlzLmRhdGEgKTtcblxuXHRcdHJldHVybiB0aGlzLmRhdGE7XG5cblx0fVxuXG5cdGdldEF2ZXJhZ2VGcmVxdWVuY3koKSB7XG5cblx0XHRsZXQgdmFsdWUgPSAwO1xuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YWx1ZSArPSBkYXRhWyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWUgLyBkYXRhLmxlbmd0aDtcblxuXHR9XG5cbn1cblxuY2xhc3MgUHJvcGVydHlNaXhlciB7XG5cblx0Y29uc3RydWN0b3IoIGJpbmRpbmcsIHR5cGVOYW1lLCB2YWx1ZVNpemUgKSB7XG5cblx0XHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuXHRcdHRoaXMudmFsdWVTaXplID0gdmFsdWVTaXplO1xuXG5cdFx0bGV0IG1peEZ1bmN0aW9uLFxuXHRcdFx0bWl4RnVuY3Rpb25BZGRpdGl2ZSxcblx0XHRcdHNldElkZW50aXR5O1xuXG5cdFx0Ly8gYnVmZmVyIGxheW91dDogWyBpbmNvbWluZyB8IGFjY3UwIHwgYWNjdTEgfCBvcmlnIHwgYWRkQWNjdSB8IChvcHRpb25hbCB3b3JrKSBdXG5cdFx0Ly9cblx0XHQvLyBpbnRlcnBvbGF0b3JzIGNhbiB1c2UgLmJ1ZmZlciBhcyB0aGVpciAucmVzdWx0XG5cdFx0Ly8gdGhlIGRhdGEgdGhlbiBnb2VzIHRvICdpbmNvbWluZydcblx0XHQvL1xuXHRcdC8vICdhY2N1MCcgYW5kICdhY2N1MScgYXJlIHVzZWQgZnJhbWUtaW50ZXJsZWF2ZWQgZm9yXG5cdFx0Ly8gdGhlIGN1bXVsYXRpdmUgcmVzdWx0IGFuZCBhcmUgY29tcGFyZWQgdG8gZGV0ZWN0XG5cdFx0Ly8gY2hhbmdlc1xuXHRcdC8vXG5cdFx0Ly8gJ29yaWcnIHN0b3JlcyB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIHByb3BlcnR5XG5cdFx0Ly9cblx0XHQvLyAnYWRkJyBpcyB1c2VkIGZvciBhZGRpdGl2ZSBjdW11bGF0aXZlIHJlc3VsdHNcblx0XHQvL1xuXHRcdC8vICd3b3JrJyBpcyBvcHRpb25hbCBhbmQgaXMgb25seSBwcmVzZW50IGZvciBxdWF0ZXJuaW9uIHR5cGVzLiBJdCBpcyB1c2VkXG5cdFx0Ly8gdG8gc3RvcmUgaW50ZXJtZWRpYXRlIHF1YXRlcm5pb24gbXVsdGlwbGljYXRpb24gcmVzdWx0c1xuXG5cdFx0c3dpdGNoICggdHlwZU5hbWUgKSB7XG5cblx0XHRcdGNhc2UgJ3F1YXRlcm5pb24nOlxuXHRcdFx0XHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NsZXJwO1xuXHRcdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlID0gdGhpcy5fc2xlcnBBZGRpdGl2ZTtcblx0XHRcdFx0c2V0SWRlbnRpdHkgPSB0aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5UXVhdGVybmlvbjtcblxuXHRcdFx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDY0QXJyYXkoIHZhbHVlU2l6ZSAqIDYgKTtcblx0XHRcdFx0dGhpcy5fd29ya0luZGV4ID0gNTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRjYXNlICdib29sJzpcblx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zZWxlY3Q7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSByZWd1bGFyIG1peCBmdW5jdGlvbiBhbmQgZm9yIGFkZGl0aXZlIG9uIHRoZXNlIHR5cGVzLFxuXHRcdFx0XHQvLyBhZGRpdGl2ZSBpcyBub3QgcmVsZXZhbnQgZm9yIG5vbi1udW1lcmljIHR5cGVzXG5cdFx0XHRcdG1peEZ1bmN0aW9uQWRkaXRpdmUgPSB0aGlzLl9zZWxlY3Q7XG5cblx0XHRcdFx0c2V0SWRlbnRpdHkgPSB0aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5T3RoZXI7XG5cblx0XHRcdFx0dGhpcy5idWZmZXIgPSBuZXcgQXJyYXkoIHZhbHVlU2l6ZSAqIDUgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fbGVycDtcblx0XHRcdFx0bWl4RnVuY3Rpb25BZGRpdGl2ZSA9IHRoaXMuX2xlcnBBZGRpdGl2ZTtcblx0XHRcdFx0c2V0SWRlbnRpdHkgPSB0aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5TnVtZXJpYztcblxuXHRcdFx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDY0QXJyYXkoIHZhbHVlU2l6ZSAqIDUgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiA9IG1peEZ1bmN0aW9uO1xuXHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbkFkZGl0aXZlID0gbWl4RnVuY3Rpb25BZGRpdGl2ZTtcblx0XHR0aGlzLl9zZXRJZGVudGl0eSA9IHNldElkZW50aXR5O1xuXHRcdHRoaXMuX29yaWdJbmRleCA9IDM7XG5cdFx0dGhpcy5fYWRkSW5kZXggPSA0O1xuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSA9IDA7XG5cblx0XHR0aGlzLnVzZUNvdW50ID0gMDtcblx0XHR0aGlzLnJlZmVyZW5jZUNvdW50ID0gMDtcblxuXHR9XG5cblx0Ly8gYWNjdW11bGF0ZSBkYXRhIGluIHRoZSAnaW5jb21pbmcnIHJlZ2lvbiBpbnRvICdhY2N1PGk+J1xuXHRhY2N1bXVsYXRlKCBhY2N1SW5kZXgsIHdlaWdodCApIHtcblxuXHRcdC8vIG5vdGU6IGhhcHBpbHkgYWNjdW11bGF0aW5nIG5vdGhpbmcgd2hlbiB3ZWlnaHQgPSAwLCB0aGUgY2FsbGVyIGtub3dzXG5cdFx0Ly8gdGhlIHdlaWdodCBhbmQgc2hvdWxkbid0IGhhdmUgbWFkZSB0aGUgY2FsbCBpbiB0aGUgZmlyc3QgcGxhY2VcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGU7XG5cblx0XHRsZXQgY3VycmVudFdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodDtcblxuXHRcdGlmICggY3VycmVudFdlaWdodCA9PT0gMCApIHtcblxuXHRcdFx0Ly8gYWNjdU4gOj0gaW5jb21pbmcgKiB3ZWlnaHRcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBpIF0gPSBidWZmZXJbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50V2VpZ2h0ID0gd2VpZ2h0O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBpbmNvbWluZyAqIHdlaWdodFxuXG5cdFx0XHRjdXJyZW50V2VpZ2h0ICs9IHdlaWdodDtcblx0XHRcdGNvbnN0IG1peCA9IHdlaWdodCAvIGN1cnJlbnRXZWlnaHQ7XG5cdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24oIGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gY3VycmVudFdlaWdodDtcblxuXHR9XG5cblx0Ly8gYWNjdW11bGF0ZSBkYXRhIGluIHRoZSAnaW5jb21pbmcnIHJlZ2lvbiBpbnRvICdhZGQnXG5cdGFjY3VtdWxhdGVBZGRpdGl2ZSggd2VpZ2h0ICkge1xuXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXIsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdG9mZnNldCA9IHN0cmlkZSAqIHRoaXMuX2FkZEluZGV4O1xuXG5cdFx0aWYgKCB0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gYWRkID0gaWRlbnRpdHlcblxuXHRcdFx0dGhpcy5fc2V0SWRlbnRpdHkoKTtcblxuXHRcdH1cblxuXHRcdC8vIGFkZCA6PSBhZGQgKyBpbmNvbWluZyAqIHdlaWdodFxuXG5cdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUoIGJ1ZmZlciwgb2Zmc2V0LCAwLCB3ZWlnaHQsIHN0cmlkZSApO1xuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlICs9IHdlaWdodDtcblxuXHR9XG5cblx0Ly8gYXBwbHkgdGhlIHN0YXRlIG9mICdhY2N1PGk+JyB0byB0aGUgYmluZGluZyB3aGVuIGFjY3VzIGRpZmZlclxuXHRhcHBseSggYWNjdUluZGV4ICkge1xuXG5cdFx0Y29uc3Qgc3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZSxcblxuXHRcdFx0d2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxuXHRcdFx0d2VpZ2h0QWRkaXRpdmUgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSxcblxuXHRcdFx0YmluZGluZyA9IHRoaXMuYmluZGluZztcblxuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuXG5cdFx0aWYgKCB3ZWlnaHQgPCAxICkge1xuXG5cdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIG9yaWdpbmFsICogKCAxIC0gY3VtdWxhdGl2ZVdlaWdodCApXG5cblx0XHRcdGNvbnN0IG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9vcmlnSW5kZXg7XG5cblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbihcblx0XHRcdFx0YnVmZmVyLCBvZmZzZXQsIG9yaWdpbmFsVmFsdWVPZmZzZXQsIDEgLSB3ZWlnaHQsIHN0cmlkZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB3ZWlnaHRBZGRpdGl2ZSA+IDAgKSB7XG5cblx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgYWRkaXRpdmUgYWNjdU5cblxuXHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUoIGJ1ZmZlciwgb2Zmc2V0LCB0aGlzLl9hZGRJbmRleCAqIHN0cmlkZSwgMSwgc3RyaWRlICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IHN0cmlkZSwgZSA9IHN0cmlkZSArIHN0cmlkZTsgaSAhPT0gZTsgKysgaSApIHtcblxuXHRcdFx0aWYgKCBidWZmZXJbIGkgXSAhPT0gYnVmZmVyWyBpICsgc3RyaWRlIF0gKSB7XG5cblx0XHRcdFx0Ly8gdmFsdWUgaGFzIGNoYW5nZWQgLT4gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRcdFx0YmluZGluZy5zZXRWYWx1ZSggYnVmZmVyLCBvZmZzZXQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gcmVtZW1iZXIgdGhlIHN0YXRlIG9mIHRoZSBib3VuZCBwcm9wZXJ0eSBhbmQgY29weSBpdCB0byBib3RoIGFjY3VzXG5cdHNhdmVPcmlnaW5hbFN0YXRlKCkge1xuXG5cdFx0Y29uc3QgYmluZGluZyA9IHRoaXMuYmluZGluZztcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cblx0XHRcdG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9vcmlnSW5kZXg7XG5cblx0XHRiaW5kaW5nLmdldFZhbHVlKCBidWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcblxuXHRcdC8vIGFjY3VbMC4uMV0gOj0gb3JpZyAtLSBpbml0aWFsbHkgZGV0ZWN0IGNoYW5nZXMgYWdhaW5zdCB0aGUgb3JpZ2luYWxcblx0XHRmb3IgKCBsZXQgaSA9IHN0cmlkZSwgZSA9IG9yaWdpbmFsVmFsdWVPZmZzZXQ7IGkgIT09IGU7ICsrIGkgKSB7XG5cblx0XHRcdGJ1ZmZlclsgaSBdID0gYnVmZmVyWyBvcmlnaW5hbFZhbHVlT2Zmc2V0ICsgKCBpICUgc3RyaWRlICkgXTtcblxuXHRcdH1cblxuXHRcdC8vIEFkZCB0byBpZGVudGl0eSBmb3IgYWRkaXRpdmVcblx0XHR0aGlzLl9zZXRJZGVudGl0eSgpO1xuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSA9IDA7XG5cblx0fVxuXG5cdC8vIGFwcGx5IHRoZSBzdGF0ZSBwcmV2aW91c2x5IHRha2VuIHZpYSAnc2F2ZU9yaWdpbmFsU3RhdGUnIHRvIHRoZSBiaW5kaW5nXG5cdHJlc3RvcmVPcmlnaW5hbFN0YXRlKCkge1xuXG5cdFx0Y29uc3Qgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHRoaXMudmFsdWVTaXplICogMztcblx0XHR0aGlzLmJpbmRpbmcuc2V0VmFsdWUoIHRoaXMuYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0ICk7XG5cblx0fVxuXG5cdF9zZXRBZGRpdGl2ZUlkZW50aXR5TnVtZXJpYygpIHtcblxuXHRcdGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLl9hZGRJbmRleCAqIHRoaXMudmFsdWVTaXplO1xuXHRcdGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIHRoaXMudmFsdWVTaXplO1xuXG5cdFx0Zm9yICggbGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuYnVmZmVyWyBpIF0gPSAwO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfc2V0QWRkaXRpdmVJZGVudGl0eVF1YXRlcm5pb24oKSB7XG5cblx0XHR0aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5TnVtZXJpYygpO1xuXHRcdHRoaXMuYnVmZmVyWyB0aGlzLl9hZGRJbmRleCAqIHRoaXMudmFsdWVTaXplICsgMyBdID0gMTtcblxuXHR9XG5cblx0X3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcigpIHtcblxuXHRcdGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLl9vcmlnSW5kZXggKiB0aGlzLnZhbHVlU2l6ZTtcblx0XHRjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuX2FkZEluZGV4ICogdGhpcy52YWx1ZVNpemU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5idWZmZXJbIHRhcmdldEluZGV4ICsgaSBdID0gdGhpcy5idWZmZXJbIHN0YXJ0SW5kZXggKyBpIF07XG5cblx0XHR9XG5cblx0fVxuXG5cblx0Ly8gbWl4IGZ1bmN0aW9uc1xuXG5cdF9zZWxlY3QoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcblxuXHRcdGlmICggdCA+PSAwLjUgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRcdGJ1ZmZlclsgZHN0T2Zmc2V0ICsgaSBdID0gYnVmZmVyWyBzcmNPZmZzZXQgKyBpIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0X3NsZXJwKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0ICkge1xuXG5cdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQsIHQgKTtcblxuXHR9XG5cblx0X3NsZXJwQWRkaXRpdmUoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcblxuXHRcdGNvbnN0IHdvcmtPZmZzZXQgPSB0aGlzLl93b3JrSW5kZXggKiBzdHJpZGU7XG5cblx0XHQvLyBTdG9yZSByZXN1bHQgaW4gaW50ZXJtZWRpYXRlIGJ1ZmZlciBvZmZzZXRcblx0XHRRdWF0ZXJuaW9uLm11bHRpcGx5UXVhdGVybmlvbnNGbGF0KCBidWZmZXIsIHdvcmtPZmZzZXQsIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHNyY09mZnNldCApO1xuXG5cdFx0Ly8gU2xlcnAgdG8gdGhlIGludGVybWVkaWF0ZSByZXN1bHRcblx0XHRRdWF0ZXJuaW9uLnNsZXJwRmxhdCggYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHdvcmtPZmZzZXQsIHQgKTtcblxuXHR9XG5cblx0X2xlcnAoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcblxuXHRcdGNvbnN0IHMgPSAxIC0gdDtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcblxuXHRcdFx0YnVmZmVyWyBqIF0gPSBidWZmZXJbIGogXSAqIHMgKyBidWZmZXJbIHNyY09mZnNldCArIGkgXSAqIHQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9sZXJwQWRkaXRpdmUoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcblxuXHRcdFx0YnVmZmVyWyBqIF0gPSBidWZmZXJbIGogXSArIGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdICogdDtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gQ2hhcmFjdGVycyBbXS46LyBhcmUgcmVzZXJ2ZWQgZm9yIHRyYWNrIGJpbmRpbmcgc3ludGF4LlxuY29uc3QgX1JFU0VSVkVEX0NIQVJTX1JFID0gJ1xcXFxbXFxcXF1cXFxcLjpcXFxcLyc7XG5jb25zdCBfcmVzZXJ2ZWRSZSA9IG5ldyBSZWdFeHAoICdbJyArIF9SRVNFUlZFRF9DSEFSU19SRSArICddJywgJ2cnICk7XG5cbi8vIEF0dGVtcHRzIHRvIGFsbG93IG5vZGUgbmFtZXMgZnJvbSBhbnkgbGFuZ3VhZ2UuIEVTNSdzIGBcXHdgIHJlZ2V4cCBtYXRjaGVzXG4vLyBvbmx5IGxhdGluIGNoYXJhY3RlcnMsIGFuZCB0aGUgdW5pY29kZSBcXHB7TH0gaXMgbm90IHlldCBzdXBwb3J0ZWQuIFNvXG4vLyBpbnN0ZWFkLCB3ZSBleGNsdWRlIHJlc2VydmVkIGNoYXJhY3RlcnMgYW5kIG1hdGNoIGV2ZXJ5dGhpbmcgZWxzZS5cbmNvbnN0IF93b3JkQ2hhciA9ICdbXicgKyBfUkVTRVJWRURfQ0hBUlNfUkUgKyAnXSc7XG5jb25zdCBfd29yZENoYXJPckRvdCA9ICdbXicgKyBfUkVTRVJWRURfQ0hBUlNfUkUucmVwbGFjZSggJ1xcXFwuJywgJycgKSArICddJztcblxuLy8gUGFyZW50IGRpcmVjdG9yaWVzLCBkZWxpbWl0ZWQgYnkgJy8nIG9yICc6Jy4gQ3VycmVudGx5IHVudXNlZCwgYnV0IG11c3Rcbi8vIGJlIG1hdGNoZWQgdG8gcGFyc2UgdGhlIHJlc3Qgb2YgdGhlIHRyYWNrIG5hbWUuXG5jb25zdCBfZGlyZWN0b3J5UmUgPSAvKkBfX1BVUkVfXyovIC8oKD86V0MrW1xcLzpdKSopLy5zb3VyY2UucmVwbGFjZSggJ1dDJywgX3dvcmRDaGFyICk7XG5cbi8vIFRhcmdldCBub2RlLiBNYXkgY29udGFpbiB3b3JkIGNoYXJhY3RlcnMgKGEtekEtWjAtOV8pIGFuZCAnLicgb3IgJy0nLlxuY29uc3QgX25vZGVSZSA9IC8qQF9fUFVSRV9fKi8gLyhXQ09EKyk/Ly5zb3VyY2UucmVwbGFjZSggJ1dDT0QnLCBfd29yZENoYXJPckRvdCApO1xuXG4vLyBPYmplY3Qgb24gdGFyZ2V0IG5vZGUsIGFuZCBhY2Nlc3Nvci4gTWF5IG5vdCBjb250YWluIHJlc2VydmVkXG4vLyBjaGFyYWN0ZXJzLiBBY2Nlc3NvciBtYXkgY29udGFpbiBhbnkgY2hhcmFjdGVyIGV4Y2VwdCBjbG9zaW5nIGJyYWNrZXQuXG5jb25zdCBfb2JqZWN0UmUgPSAvKkBfX1BVUkVfXyovIC8oPzpcXC4oV0MrKSg/OlxcWyguKylcXF0pPyk/Ly5zb3VyY2UucmVwbGFjZSggJ1dDJywgX3dvcmRDaGFyICk7XG5cbi8vIFByb3BlcnR5IGFuZCBhY2Nlc3Nvci4gTWF5IG5vdCBjb250YWluIHJlc2VydmVkIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heVxuLy8gY29udGFpbiBhbnkgbm9uLWJyYWNrZXQgY2hhcmFjdGVycy5cbmNvbnN0IF9wcm9wZXJ0eVJlID0gLypAX19QVVJFX18qLyAvXFwuKFdDKykoPzpcXFsoLispXFxdKT8vLnNvdXJjZS5yZXBsYWNlKCAnV0MnLCBfd29yZENoYXIgKTtcblxuY29uc3QgX3RyYWNrUmUgPSBuZXcgUmVnRXhwKCAnJ1xuXHQrICdeJ1xuXHQrIF9kaXJlY3RvcnlSZVxuXHQrIF9ub2RlUmVcblx0KyBfb2JqZWN0UmVcblx0KyBfcHJvcGVydHlSZVxuXHQrICckJ1xuKTtcblxuY29uc3QgX3N1cHBvcnRlZE9iamVjdE5hbWVzID0gWyAnbWF0ZXJpYWwnLCAnbWF0ZXJpYWxzJywgJ2JvbmVzJywgJ21hcCcgXTtcblxuY2xhc3MgQ29tcG9zaXRlIHtcblxuXHRjb25zdHJ1Y3RvciggdGFyZ2V0R3JvdXAsIHBhdGgsIG9wdGlvbmFsUGFyc2VkUGF0aCApIHtcblxuXHRcdGNvbnN0IHBhcnNlZFBhdGggPSBvcHRpb25hbFBhcnNlZFBhdGggfHwgUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lKCBwYXRoICk7XG5cblx0XHR0aGlzLl90YXJnZXRHcm91cCA9IHRhcmdldEdyb3VwO1xuXHRcdHRoaXMuX2JpbmRpbmdzID0gdGFyZ2V0R3JvdXAuc3Vic2NyaWJlXyggcGF0aCwgcGFyc2VkUGF0aCApO1xuXG5cdH1cblxuXHRnZXRWYWx1ZSggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdHRoaXMuYmluZCgpOyAvLyBiaW5kIGFsbCBiaW5kaW5nXG5cblx0XHRjb25zdCBmaXJzdFZhbGlkSW5kZXggPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5fYmluZGluZ3NbIGZpcnN0VmFsaWRJbmRleCBdO1xuXG5cdFx0Ly8gYW5kIG9ubHkgY2FsbCAuZ2V0VmFsdWUgb24gdGhlIGZpcnN0XG5cdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSBiaW5kaW5nLmdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XG5cblx0fVxuXG5cdHNldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdGZvciAoIGxldCBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRiaW5kaW5nc1sgaSBdLnNldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGJpbmQoKSB7XG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0uYmluZCgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1bmJpbmQoKSB7XG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0udW5iaW5kKCk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8vIE5vdGU6IFRoaXMgY2xhc3MgdXNlcyBhIFN0YXRlIHBhdHRlcm4gb24gYSBwZXItbWV0aG9kIGJhc2lzOlxuLy8gJ2JpbmQnIHNldHMgJ3RoaXMuZ2V0VmFsdWUnIC8gJ3NldFZhbHVlJyBhbmQgc2hhZG93cyB0aGVcbi8vIHByb3RvdHlwZSB2ZXJzaW9uIG9mIHRoZXNlIG1ldGhvZHMgd2l0aCBvbmUgdGhhdCByZXByZXNlbnRzXG4vLyB0aGUgYm91bmQgc3RhdGUuIFdoZW4gdGhlIHByb3BlcnR5IGlzIG5vdCBmb3VuZCwgdGhlIG1ldGhvZHNcbi8vIGJlY29tZSBuby1vcHMuXG5jbGFzcyBQcm9wZXJ0eUJpbmRpbmcge1xuXG5cdGNvbnN0cnVjdG9yKCByb290Tm9kZSwgcGF0aCwgcGFyc2VkUGF0aCApIHtcblxuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5wYXJzZWRQYXRoID0gcGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcblxuXHRcdHRoaXMubm9kZSA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZSggcm9vdE5vZGUsIHRoaXMucGFyc2VkUGF0aC5ub2RlTmFtZSApO1xuXG5cdFx0dGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xuXG5cdFx0Ly8gaW5pdGlhbCBzdGF0ZSBvZiB0aGVzZSBtZXRob2RzIHRoYXQgY2FsbHMgJ2JpbmQnXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XG5cblx0fVxuXG5cblx0c3RhdGljIGNyZWF0ZSggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApIHtcblxuXHRcdGlmICggISAoIHJvb3QgJiYgcm9vdC5pc0FuaW1hdGlvbk9iamVjdEdyb3VwICkgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIHNwYWNlcyB3aXRoIHVuZGVyc2NvcmVzIGFuZCByZW1vdmVzIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMgZnJvbVxuXHQgKiBub2RlIG5hbWVzLCB0byBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIHBhcnNlVHJhY2tOYW1lKCkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5vZGUgbmFtZSB0byBiZSBzYW5pdGl6ZWQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyBzYW5pdGl6ZU5vZGVOYW1lKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIG5hbWUucmVwbGFjZSggL1xccy9nLCAnXycgKS5yZXBsYWNlKCBfcmVzZXJ2ZWRSZSwgJycgKTtcblxuXHR9XG5cblx0c3RhdGljIHBhcnNlVHJhY2tOYW1lKCB0cmFja05hbWUgKSB7XG5cblx0XHRjb25zdCBtYXRjaGVzID0gX3RyYWNrUmUuZXhlYyggdHJhY2tOYW1lICk7XG5cblx0XHRpZiAoIG1hdGNoZXMgPT09IG51bGwgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Byb3BlcnR5QmluZGluZzogQ2Fubm90IHBhcnNlIHRyYWNrTmFtZTogJyArIHRyYWNrTmFtZSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVzdWx0cyA9IHtcblx0XHRcdC8vIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbIDEgXSwgLy8gKHRzY2h3KSBjdXJyZW50bHkgdW51c2VkXG5cdFx0XHRub2RlTmFtZTogbWF0Y2hlc1sgMiBdLFxuXHRcdFx0b2JqZWN0TmFtZTogbWF0Y2hlc1sgMyBdLFxuXHRcdFx0b2JqZWN0SW5kZXg6IG1hdGNoZXNbIDQgXSxcblx0XHRcdHByb3BlcnR5TmFtZTogbWF0Y2hlc1sgNSBdLCAvLyByZXF1aXJlZFxuXHRcdFx0cHJvcGVydHlJbmRleDogbWF0Y2hlc1sgNiBdXG5cdFx0fTtcblxuXHRcdGNvbnN0IGxhc3REb3QgPSByZXN1bHRzLm5vZGVOYW1lICYmIHJlc3VsdHMubm9kZU5hbWUubGFzdEluZGV4T2YoICcuJyApO1xuXG5cdFx0aWYgKCBsYXN0RG90ICE9PSB1bmRlZmluZWQgJiYgbGFzdERvdCAhPT0gLSAxICkge1xuXG5cdFx0XHRjb25zdCBvYmplY3ROYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoIGxhc3REb3QgKyAxICk7XG5cblx0XHRcdC8vIE9iamVjdCBuYW1lcyBtdXN0IGJlIGNoZWNrZWQgYWdhaW5zdCBhbiBhbGxvd2xpc3QuIE90aGVyd2lzZSwgdGhlcmVcblx0XHRcdC8vIGlzIG5vIHdheSB0byBwYXJzZSAnZm9vLmJhci5iYXonOiAnYmF6JyBtdXN0IGJlIGEgcHJvcGVydHksIGJ1dFxuXHRcdFx0Ly8gJ2JhcicgY291bGQgYmUgdGhlIG9iamVjdE5hbWUsIG9yIHBhcnQgb2YgYSBub2RlTmFtZSAod2hpY2ggY2FuXG5cdFx0XHQvLyBpbmNsdWRlICcuJyBjaGFyYWN0ZXJzKS5cblx0XHRcdGlmICggX3N1cHBvcnRlZE9iamVjdE5hbWVzLmluZGV4T2YoIG9iamVjdE5hbWUgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdHJlc3VsdHMubm9kZU5hbWUgPSByZXN1bHRzLm5vZGVOYW1lLnN1YnN0cmluZyggMCwgbGFzdERvdCApO1xuXHRcdFx0XHRyZXN1bHRzLm9iamVjdE5hbWUgPSBvYmplY3ROYW1lO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHJlc3VsdHMucHJvcGVydHlOYW1lID09PSBudWxsIHx8IHJlc3VsdHMucHJvcGVydHlOYW1lLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnUHJvcGVydHlCaW5kaW5nOiBjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogJyArIHRyYWNrTmFtZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0fVxuXG5cdHN0YXRpYyBmaW5kTm9kZSggcm9vdCwgbm9kZU5hbWUgKSB7XG5cblx0XHRpZiAoIG5vZGVOYW1lID09PSB1bmRlZmluZWQgfHwgbm9kZU5hbWUgPT09ICcnIHx8IG5vZGVOYW1lID09PSAnLicgfHwgbm9kZU5hbWUgPT09IC0gMSB8fCBub2RlTmFtZSA9PT0gcm9vdC5uYW1lIHx8IG5vZGVOYW1lID09PSByb290LnV1aWQgKSB7XG5cblx0XHRcdHJldHVybiByb290O1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2VhcmNoIGludG8gc2tlbGV0b24gYm9uZXMuXG5cdFx0aWYgKCByb290LnNrZWxldG9uICkge1xuXG5cdFx0XHRjb25zdCBib25lID0gcm9vdC5za2VsZXRvbi5nZXRCb25lQnlOYW1lKCBub2RlTmFtZSApO1xuXG5cdFx0XHRpZiAoIGJvbmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gYm9uZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxuXHRcdGlmICggcm9vdC5jaGlsZHJlbiApIHtcblxuXHRcdFx0Y29uc3Qgc2VhcmNoTm9kZVN1YnRyZWUgPSBmdW5jdGlvbiAoIGNoaWxkcmVuICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGNoaWxkTm9kZS5uYW1lID09PSBub2RlTmFtZSB8fCBjaGlsZE5vZGUudXVpZCA9PT0gbm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBjaGlsZE5vZGU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCByZXN1bHQgPSBzZWFyY2hOb2RlU3VidHJlZSggY2hpbGROb2RlLmNoaWxkcmVuICk7XG5cblx0XHRcdFx0XHRpZiAoIHJlc3VsdCApIHJldHVybiByZXN1bHQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBzdWJUcmVlTm9kZSA9IHNlYXJjaE5vZGVTdWJ0cmVlKCByb290LmNoaWxkcmVuICk7XG5cblx0XHRcdGlmICggc3ViVHJlZU5vZGUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHN1YlRyZWVOb2RlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0Ly8gdGhlc2UgYXJlIHVzZWQgdG8gXCJiaW5kXCIgYSBub25leGlzdGVudCBwcm9wZXJ0eVxuXHRfZ2V0VmFsdWVfdW5hdmFpbGFibGUoKSB7fVxuXHRfc2V0VmFsdWVfdW5hdmFpbGFibGUoKSB7fVxuXG5cdC8vIEdldHRlcnNcblxuXHRfZ2V0VmFsdWVfZGlyZWN0KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXTtcblxuXHR9XG5cblx0X2dldFZhbHVlX2FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHNvdXJjZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsrIF0gPSBzb3VyY2VbIGkgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0X2dldFZhbHVlX2FycmF5RWxlbWVudCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXTtcblxuXHR9XG5cblx0X2dldFZhbHVlX3RvQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cblx0fVxuXG5cdC8vIERpcmVjdFxuXG5cdF9zZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy50YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXG5cdH1cblxuXHRfc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV9kaXJlY3Rfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdC8vIEVudGlyZUFycmF5XG5cblx0X3NldFZhbHVlX2FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdGNvbnN0IGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0X3NldFZhbHVlX2FycmF5X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdGNvbnN0IGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcblxuXHRcdH1cblxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0X3NldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc3QgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdC8vIEFycmF5RWxlbWVudFxuXG5cdF9zZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRfc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdC8vIEhhc1RvRnJvbUFycmF5XG5cblx0X3NldFZhbHVlX2Zyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xuXG5cdH1cblxuXHRfc2V0VmFsdWVfZnJvbUFycmF5X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRfc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0X2dldFZhbHVlX3VuYm91bmQoIHRhcmdldEFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmJpbmQoKTtcblx0XHR0aGlzLmdldFZhbHVlKCB0YXJnZXRBcnJheSwgb2Zmc2V0ICk7XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV91bmJvdW5kKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5iaW5kKCk7XG5cdFx0dGhpcy5zZXRWYWx1ZSggc291cmNlQXJyYXksIG9mZnNldCApO1xuXG5cdH1cblxuXHQvLyBjcmVhdGUgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIGEgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoXG5cdGJpbmQoKSB7XG5cblx0XHRsZXQgdGFyZ2V0T2JqZWN0ID0gdGhpcy5ub2RlO1xuXHRcdGNvbnN0IHBhcnNlZFBhdGggPSB0aGlzLnBhcnNlZFBhdGg7XG5cblx0XHRjb25zdCBvYmplY3ROYW1lID0gcGFyc2VkUGF0aC5vYmplY3ROYW1lO1xuXHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IHBhcnNlZFBhdGgucHJvcGVydHlOYW1lO1xuXHRcdGxldCBwcm9wZXJ0eUluZGV4ID0gcGFyc2VkUGF0aC5wcm9wZXJ0eUluZGV4O1xuXG5cdFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcblxuXHRcdFx0dGFyZ2V0T2JqZWN0ID0gUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKCB0aGlzLnJvb3ROb2RlLCBwYXJzZWRQYXRoLm5vZGVOYW1lICk7XG5cblx0XHRcdHRoaXMubm9kZSA9IHRhcmdldE9iamVjdDtcblxuXHRcdH1cblxuXHRcdC8vIHNldCBmYWlsIHN0YXRlIHNvIHdlIGNhbiBqdXN0ICdyZXR1cm4nIG9uIGVycm9yXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYXZhaWxhYmxlO1xuXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmF2YWlsYWJsZTtcblxuXHRcdC8vIGVuc3VyZSB0aGVyZSBpcyBhIHZhbHVlIG5vZGVcblx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IE5vIHRhcmdldCBub2RlIGZvdW5kIGZvciB0cmFjazogJyArIHRoaXMucGF0aCArICcuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3ROYW1lICkge1xuXG5cdFx0XHRsZXQgb2JqZWN0SW5kZXggPSBwYXJzZWRQYXRoLm9iamVjdEluZGV4O1xuXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2VzIHdlcmUgd2UgbmVlZCB0byByZWFjaCBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IHRvIGdldCB0aGUgZmFjZSBtYXRlcmlhbHMuLi4uXG5cdFx0XHRzd2l0Y2ggKCBvYmplY3ROYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ21hdGVyaWFscyc6XG5cblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWwuJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXRlcmlhbHMgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWxzIGFycmF5LicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHM7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdib25lcyc6XG5cblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0LnNrZWxldG9uICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gYm9uZXMgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgc2tlbGV0b24uJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBvcHRpbWl6YXRpb246IHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlclxuXHRcdFx0XHRcdC8vIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5za2VsZXRvbi5ib25lcztcblxuXHRcdFx0XHRcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0YXJnZXRPYmplY3QubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgaSBdLm5hbWUgPT09IG9iamVjdEluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdEluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hcCc6XG5cblx0XHRcdFx0XHRpZiAoICdtYXAnIGluIHRhcmdldE9iamVjdCApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0Lm1hcDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsLicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWFwICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWFwIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hcC4nLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWFwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUgdW5kZWZpbmVkLicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKCBvYmplY3RJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkLicsIHRoaXMsIHRhcmdldE9iamVjdCApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyByZXNvbHZlIHByb3BlcnR5XG5cdFx0Y29uc3Qgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyBwcm9wZXJ0eU5hbWUgXTtcblxuXHRcdGlmICggbm9kZVByb3BlcnR5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGVOYW1lID0gcGFyc2VkUGF0aC5ub2RlTmFtZTtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6ICcgKyBub2RlTmFtZSArXG5cdFx0XHRcdCcuJyArIHByb3BlcnR5TmFtZSArICcgYnV0IGl0IHdhc25cXCd0IGZvdW5kLicsIHRhcmdldE9iamVjdCApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZGV0ZXJtaW5lIHZlcnNpb25pbmcgc2NoZW1lXG5cdFx0bGV0IHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTm9uZTtcblxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xuXG5cdFx0aWYgKCB0YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbWF0ZXJpYWxcblxuXHRcdFx0dmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5OZWVkc1VwZGF0ZTtcblxuXHRcdH0gZWxzZSBpZiAoIHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG5vZGUgdHJhbnNmb3JtXG5cblx0XHRcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblxuXHRcdH1cblxuXHRcdC8vIGRldGVybWluZSBob3cgdGhlIHByb3BlcnR5IGdldHMgYm91bmRcblx0XHRsZXQgYmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkRpcmVjdDtcblxuXHRcdGlmICggcHJvcGVydHlJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBhY2Nlc3MgYSBzdWIgZWxlbWVudCBvZiB0aGUgcHJvcGVydHkgYXJyYXkgKG9ubHkgcHJpbWl0aXZlcyBhcmUgc3VwcG9ydGVkIHJpZ2h0IG5vdylcblxuXHRcdFx0aWYgKCBwcm9wZXJ0eU5hbWUgPT09ICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnICkge1xuXG5cdFx0XHRcdC8vIHBvdGVudGlhbCBvcHRpbWl6YXRpb24sIHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlciwgYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxuXG5cdFx0XHRcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cblx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS4nLCB0aGlzICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuJywgdGhpcyApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3QubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBwcm9wZXJ0eUluZGV4IF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHByb3BlcnR5SW5kZXggPSB0YXJnZXRPYmplY3QubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBwcm9wZXJ0eUluZGV4IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQ7XG5cblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblx0XHRcdHRoaXMucHJvcGVydHlJbmRleCA9IHByb3BlcnR5SW5kZXg7XG5cblx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkuZnJvbUFycmF5ICE9PSB1bmRlZmluZWQgJiYgbm9kZVByb3BlcnR5LnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gbXVzdCB1c2UgY29weSBmb3IgT2JqZWN0M0QuRXVsZXIvUXVhdGVybmlvblxuXG5cdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuSGFzRnJvbVRvQXJyYXk7XG5cblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblxuXHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIG5vZGVQcm9wZXJ0eSApICkge1xuXG5cdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRW50aXJlQXJyYXk7XG5cblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2VsZWN0IGdldHRlciAvIHNldHRlclxuXHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLkdldHRlckJ5QmluZGluZ1R5cGVbIGJpbmRpbmdUeXBlIF07XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuU2V0dGVyQnlCaW5kaW5nVHlwZUFuZFZlcnNpb25pbmdbIGJpbmRpbmdUeXBlIF1bIHZlcnNpb25pbmcgXTtcblxuXHR9XG5cblx0dW5iaW5kKCkge1xuXG5cdFx0dGhpcy5ub2RlID0gbnVsbDtcblxuXHRcdC8vIGJhY2sgdG8gdGhlIHByb3RvdHlwZSB2ZXJzaW9uIG9mIGdldFZhbHVlIC8gc2V0VmFsdWVcblx0XHQvLyBub3RlOiBhdm9pZGluZyB0byBtdXRhdGUgdGhlIHNoYXBlIG9mICd0aGlzJyB2aWEgJ2RlbGV0ZSdcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5ib3VuZDtcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5ib3VuZDtcblxuXHR9XG5cbn1cblxuUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZSA9IENvbXBvc2l0ZTtcblxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5CaW5kaW5nVHlwZSA9IHtcblx0RGlyZWN0OiAwLFxuXHRFbnRpcmVBcnJheTogMSxcblx0QXJyYXlFbGVtZW50OiAyLFxuXHRIYXNGcm9tVG9BcnJheTogM1xufTtcblxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5WZXJzaW9uaW5nID0ge1xuXHROb25lOiAwLFxuXHROZWVkc1VwZGF0ZTogMSxcblx0TWF0cml4V29ybGROZWVkc1VwZGF0ZTogMlxufTtcblxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5HZXR0ZXJCeUJpbmRpbmdUeXBlID0gW1xuXG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX2RpcmVjdCxcblx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fZ2V0VmFsdWVfYXJyYXksXG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX2FycmF5RWxlbWVudCxcblx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fZ2V0VmFsdWVfdG9BcnJheSxcblxuXTtcblxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZyA9IFtcblxuXHRbXG5cdFx0Ly8gRGlyZWN0XG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZGlyZWN0LFxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2RpcmVjdF9zZXROZWVkc1VwZGF0ZSxcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3Rfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSxcblxuXHRdLCBbXG5cblx0XHQvLyBFbnRpcmVBcnJheVxuXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXksXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUsXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSxcblxuXHRdLCBbXG5cblx0XHQvLyBBcnJheUVsZW1lbnRcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheUVsZW1lbnQsXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlLFxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlLFxuXG5cdF0sIFtcblxuXHRcdC8vIEhhc1RvRnJvbUFycmF5XG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZnJvbUFycmF5LFxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZSxcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSxcblxuXHRdXG5cbl07XG5cbi8qKlxuICpcbiAqIEEgZ3JvdXAgb2Ygb2JqZWN0cyB0aGF0IHJlY2VpdmVzIGEgc2hhcmVkIGFuaW1hdGlvbiBzdGF0ZS5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgLSBBZGQgb2JqZWN0cyB5b3Ugd291bGQgb3RoZXJ3aXNlIHBhc3MgYXMgJ3Jvb3QnIHRvIHRoZVxuICogICAgY29uc3RydWN0b3Igb3IgdGhlIC5jbGlwQWN0aW9uIG1ldGhvZCBvZiBBbmltYXRpb25NaXhlci5cbiAqXG4gKiAgLSBJbnN0ZWFkIHBhc3MgdGhpcyBvYmplY3QgYXMgJ3Jvb3QnLlxuICpcbiAqICAtIFlvdSBjYW4gYWxzbyBhZGQgYW5kIHJlbW92ZSBvYmplY3RzIGxhdGVyIHdoZW4gdGhlIG1peGVyXG4gKiAgICBpcyBydW5uaW5nLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAgT2JqZWN0cyBvZiB0aGlzIGNsYXNzIGFwcGVhciBhcyBvbmUgb2JqZWN0IHRvIHRoZSBtaXhlcixcbiAqICAgIHNvIGNhY2hlIGNvbnRyb2wgb2YgdGhlIGluZGl2aWR1YWwgb2JqZWN0cyBtdXN0IGJlIGRvbmVcbiAqICAgIG9uIHRoZSBncm91cC5cbiAqXG4gKiBMaW1pdGF0aW9uOlxuICpcbiAqICAtIFRoZSBhbmltYXRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgY29tcGF0aWJsZSBhbW9uZyB0aGVcbiAqICAgIGFsbCBvYmplY3RzIGluIHRoZSBncm91cC5cbiAqXG4gKiAgLSBBIHNpbmdsZSBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBhXG4gKiAgICB0YXJnZXQgZ3JvdXAgb3IgZGlyZWN0bHksIGJ1dCBub3QgYm90aC5cbiAqL1xuXG5jbGFzcyBBbmltYXRpb25PYmplY3RHcm91cCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLmlzQW5pbWF0aW9uT2JqZWN0R3JvdXAgPSB0cnVlO1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHQvLyBjYWNoZWQgb2JqZWN0cyBmb2xsb3dlZCBieSB0aGUgYWN0aXZlIG9uZXNcblx0XHR0aGlzLl9vYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSAwOyAvLyB0aHJlc2hvbGRcblx0XHQvLyBub3RlOiByZWFkIGJ5IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGVcblxuXHRcdGNvbnN0IGluZGljZXMgPSB7fTtcblx0XHR0aGlzLl9pbmRpY2VzQnlVVUlEID0gaW5kaWNlczsgLy8gZm9yIGJvb2trZWVwaW5nXG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRpbmRpY2VzWyBhcmd1bWVudHNbIGkgXS51dWlkIF0gPSBpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fcGF0aHMgPSBbXTsgLy8gaW5zaWRlOiBzdHJpbmdcblx0XHR0aGlzLl9wYXJzZWRQYXRocyA9IFtdOyAvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XG5cdFx0dGhpcy5fYmluZGluZ3MgPSBbXTsgLy8gaW5zaWRlOiBBcnJheTwgUHJvcGVydHlCaW5kaW5nID5cblx0XHR0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGggPSB7fTsgLy8gaW5zaWRlOiBpbmRpY2VzIGluIHRoZXNlIGFycmF5c1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dGhpcy5zdGF0cyA9IHtcblxuXHRcdFx0b2JqZWN0czoge1xuXHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX29iamVjdHMubGVuZ3RoO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldCBpblVzZSgpIHtcblxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnRvdGFsIC0gc2NvcGUubkNhY2hlZE9iamVjdHNfO1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRnZXQgYmluZGluZ3NQZXJPYmplY3QoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdGFkZCgpIHtcblxuXHRcdGNvbnN0IG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRsZXQga25vd25PYmplY3QgPSB1bmRlZmluZWQsXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuXHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQ7XG5cdFx0XHRsZXQgaW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cblx0XHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyB1bmtub3duIG9iamVjdCAtPiBhZGQgaXQgdG8gdGhlIEFDVElWRSByZWdpb25cblxuXHRcdFx0XHRpbmRleCA9IG5PYmplY3RzICsrO1xuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0b2JqZWN0cy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdFx0YmluZGluZ3NbIGogXS5wdXNoKCBuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcblxuXHRcdFx0XHRrbm93bk9iamVjdCA9IG9iamVjdHNbIGluZGV4IF07XG5cblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgdG8gdGhlIEFDVElWRSByZWdpb25cblxuXHRcdFx0XHRjb25zdCBmaXJzdEFjdGl2ZUluZGV4ID0gLS0gbkNhY2hlZE9iamVjdHMsXG5cdFx0XHRcdFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXTtcblxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0Q2FjaGVkT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuXHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcblxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xuXHRcdFx0XHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBvYmplY3Q7XG5cblx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG5cdFx0XHRcdFx0XHRsYXN0Q2FjaGVkID0gYmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRcdFx0XHRsZXQgYmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcblxuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XG5cblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gc2luY2Ugd2UgZG8gbm90IGJvdGhlciB0byBjcmVhdGUgbmV3IGJpbmRpbmdzXG5cdFx0XHRcdFx0XHQvLyBmb3Igb2JqZWN0cyB0aGF0IGFyZSBjYWNoZWQsIHRoZSBiaW5kaW5nIG1heVxuXHRcdFx0XHRcdFx0Ly8gb3IgbWF5IG5vdCBleGlzdFxuXG5cdFx0XHRcdFx0XHRiaW5kaW5nID0gbmV3IFByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoc1sgaiBdLCBwYXJzZWRQYXRoc1sgaiBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3RzWyBpbmRleCBdICE9PSBrbm93bk9iamVjdCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQW5pbWF0aW9uT2JqZWN0R3JvdXA6IERpZmZlcmVudCBvYmplY3RzIHdpdGggdGhlIHNhbWUgVVVJRCAnICtcblx0XHRcdFx0XHQnZGV0ZWN0ZWQuIENsZWFuIHRoZSBjYWNoZXMgb3IgcmVjcmVhdGUgeW91ciBpbmZyYXN0cnVjdHVyZSB3aGVuIHJlbG9hZGluZyBzY2VuZXMuJyApO1xuXG5cdFx0XHR9IC8vIGVsc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IHdoZXJlIHdlIHdhbnQgaXQgdG8gYmVcblxuXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xuXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblxuXHR9XG5cblx0cmVtb3ZlKCkge1xuXG5cdFx0Y29uc3Qgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRsZXQgbkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuXHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQsXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPj0gbkNhY2hlZE9iamVjdHMgKSB7XG5cblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxuXG5cdFx0XHRcdGNvbnN0IGxhc3RDYWNoZWRJbmRleCA9IG5DYWNoZWRPYmplY3RzICsrLFxuXHRcdFx0XHRcdGZpcnN0QWN0aXZlT2JqZWN0ID0gb2JqZWN0c1sgbGFzdENhY2hlZEluZGV4IF07XG5cblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgZmlyc3RBY3RpdmVPYmplY3QudXVpZCBdID0gaW5kZXg7XG5cdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZU9iamVjdDtcblxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBsYXN0Q2FjaGVkSW5kZXg7XG5cdFx0XHRcdG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdID0gb2JqZWN0O1xuXG5cdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHRjb25zdCBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxuXHRcdFx0XHRcdFx0Zmlyc3RBY3RpdmUgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RDYWNoZWRJbmRleCBdLFxuXHRcdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcblxuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGZpcnN0QWN0aXZlO1xuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXG5cdH1cblxuXHQvLyByZW1vdmUgJiBmb3JnZXRcblx0dW5jYWNoZSgpIHtcblxuXHRcdGNvbnN0IG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0bGV0IG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cblx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkZWxldGUgaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcblxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBjYWNoZWQsIHNocmluayB0aGUgQ0FDSEVEIHJlZ2lvblxuXG5cdFx0XHRcdFx0Y29uc3QgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xuXG5cdFx0XHRcdFx0Ly8gbGFzdCBjYWNoZWQgb2JqZWN0IHRha2VzIHRoaXMgb2JqZWN0J3MgcGxhY2Vcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0Q2FjaGVkT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBsYXN0Q2FjaGVkT2JqZWN0O1xuXG5cdFx0XHRcdFx0Ly8gbGFzdCBvYmplY3QgZ29lcyB0byB0aGUgYWN0aXZhdGVkIHNsb3QgYW5kIHBvcFxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RPYmplY3QudXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcblx0XHRcdFx0XHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0T2JqZWN0O1xuXHRcdFx0XHRcdG9iamVjdHMucG9wKCk7XG5cblx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG5cdFx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdFx0bGFzdCA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdEluZGV4IF07XG5cblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGxhc3Q7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBhY3RpdmUsIGp1c3Qgc3dhcCB3aXRoIHRoZSBsYXN0IGFuZCBwb3BcblxuXHRcdFx0XHRcdGNvbnN0IGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBsYXN0SW5kZXggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RPYmplY3Q7XG5cdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcblxuXHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXTtcblxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IC8vIGNhY2hlZCBvciBhY3RpdmVcblxuXHRcdFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cblxuXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xuXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblxuXHR9XG5cblx0Ly8gSW50ZXJuYWwgaW50ZXJmYWNlIHVzZWQgYnkgYmVmcmllbmRlZCBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlOlxuXG5cdHN1YnNjcmliZV8oIHBhdGgsIHBhcnNlZFBhdGggKSB7XG5cblx0XHQvLyByZXR1cm5zIGFuIGFycmF5IG9mIGJpbmRpbmdzIGZvciB0aGUgZ2l2ZW4gcGF0aCB0aGF0IGlzIGNoYW5nZWRcblx0XHQvLyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRhaW5lZCBvYmplY3RzIGluIHRoZSBncm91cFxuXG5cdFx0Y29uc3QgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aDtcblx0XHRsZXQgaW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF07XG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHJldHVybiBiaW5kaW5nc1sgaW5kZXggXTtcblxuXHRcdGNvbnN0IHBhdGhzID0gdGhpcy5fcGF0aHMsXG5cdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0b2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdGJpbmRpbmdzRm9yUGF0aCA9IG5ldyBBcnJheSggbk9iamVjdHMgKTtcblxuXHRcdGluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0aW5kaWNlc0J5UGF0aFsgcGF0aCBdID0gaW5kZXg7XG5cblx0XHRwYXRocy5wdXNoKCBwYXRoICk7XG5cdFx0cGFyc2VkUGF0aHMucHVzaCggcGFyc2VkUGF0aCApO1xuXHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmdzRm9yUGF0aCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSBuQ2FjaGVkT2JqZWN0cywgbiA9IG9iamVjdHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBvYmplY3QgPSBvYmplY3RzWyBpIF07XG5cdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGkgXSA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcoIG9iamVjdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJpbmRpbmdzRm9yUGF0aDtcblxuXHR9XG5cblx0dW5zdWJzY3JpYmVfKCBwYXRoICkge1xuXG5cdFx0Ly8gdGVsbHMgdGhlIGdyb3VwIHRvIGZvcmdldCBhYm91dCBhIHByb3BlcnR5IHBhdGggYW5kIG5vIGxvbmdlclxuXHRcdC8vIHVwZGF0ZSB0aGUgYXJyYXkgcHJldmlvdXNseSBvYnRhaW5lZCB3aXRoICdzdWJzY3JpYmVfJ1xuXG5cdFx0Y29uc3QgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCxcblx0XHRcdGluZGV4ID0gaW5kaWNlc0J5UGF0aFsgcGF0aCBdO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRsYXN0QmluZGluZ3NJbmRleCA9IGJpbmRpbmdzLmxlbmd0aCAtIDEsXG5cdFx0XHRcdGxhc3RCaW5kaW5ncyA9IGJpbmRpbmdzWyBsYXN0QmluZGluZ3NJbmRleCBdLFxuXHRcdFx0XHRsYXN0QmluZGluZ3NQYXRoID0gcGF0aFsgbGFzdEJpbmRpbmdzSW5kZXggXTtcblxuXHRcdFx0aW5kaWNlc0J5UGF0aFsgbGFzdEJpbmRpbmdzUGF0aCBdID0gaW5kZXg7XG5cblx0XHRcdGJpbmRpbmdzWyBpbmRleCBdID0gbGFzdEJpbmRpbmdzO1xuXHRcdFx0YmluZGluZ3MucG9wKCk7XG5cblx0XHRcdHBhcnNlZFBhdGhzWyBpbmRleCBdID0gcGFyc2VkUGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XG5cdFx0XHRwYXJzZWRQYXRocy5wb3AoKTtcblxuXHRcdFx0cGF0aHNbIGluZGV4IF0gPSBwYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcblx0XHRcdHBhdGhzLnBvcCgpO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5jbGFzcyBBbmltYXRpb25BY3Rpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBtaXhlciwgY2xpcCwgbG9jYWxSb290ID0gbnVsbCwgYmxlbmRNb2RlID0gY2xpcC5ibGVuZE1vZGUgKSB7XG5cblx0XHR0aGlzLl9taXhlciA9IG1peGVyO1xuXHRcdHRoaXMuX2NsaXAgPSBjbGlwO1xuXHRcdHRoaXMuX2xvY2FsUm9vdCA9IGxvY2FsUm9vdDtcblx0XHR0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IGNsaXAudHJhY2tzLFxuXHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXG5cdFx0XHRpbnRlcnBvbGFudHMgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuXHRcdGNvbnN0IGludGVycG9sYW50U2V0dGluZ3MgPSB7XG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuXHRcdH07XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdHJhY2tzWyBpIF0uY3JlYXRlSW50ZXJwb2xhbnQoIG51bGwgKTtcblx0XHRcdGludGVycG9sYW50c1sgaSBdID0gaW50ZXJwb2xhbnQ7XG5cdFx0XHRpbnRlcnBvbGFudC5zZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcblxuXHRcdHRoaXMuX2ludGVycG9sYW50cyA9IGludGVycG9sYW50czsgLy8gYm91bmQgYnkgdGhlIG1peGVyXG5cblx0XHQvLyBpbnNpZGU6IFByb3BlcnR5TWl4ZXIgKG1hbmFnZWQgYnkgdGhlIG1peGVyKVxuXHRcdHRoaXMuX3Byb3BlcnR5QmluZGluZ3MgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuXHRcdHRoaXMuX2NhY2hlSW5kZXggPSBudWxsOyAvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG5cdFx0dGhpcy5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7IC8vIGZvciB0aGUgbWVtb3J5IG1hbmFnZXJcblxuXHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcblx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IG51bGw7XG5cblx0XHR0aGlzLmxvb3AgPSBMb29wUmVwZWF0O1xuXHRcdHRoaXMuX2xvb3BDb3VudCA9IC0gMTtcblxuXHRcdC8vIGdsb2JhbCBtaXhlciB0aW1lIHdoZW4gdGhlIGFjdGlvbiBpcyB0byBiZSBzdGFydGVkXG5cdFx0Ly8gaXQncyBzZXQgYmFjayB0byAnbnVsbCcgdXBvbiBzdGFydCBvZiB0aGUgYWN0aW9uXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdC8vIHNjYWxlZCBsb2NhbCB0aW1lIG9mIHRoZSBhY3Rpb25cblx0XHQvLyBnZXRzIGNsYW1wZWQgb3Igd3JhcHBlZCB0byAwLi5jbGlwLmR1cmF0aW9uIGFjY29yZGluZyB0byBsb29wXG5cdFx0dGhpcy50aW1lID0gMDtcblxuXHRcdHRoaXMudGltZVNjYWxlID0gMTtcblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSAxO1xuXG5cdFx0dGhpcy53ZWlnaHQgPSAxO1xuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IDE7XG5cblx0XHR0aGlzLnJlcGV0aXRpb25zID0gSW5maW5pdHk7IC8vIG5vLiBvZiByZXBldGl0aW9ucyB3aGVuIGxvb3BpbmdcblxuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7IC8vIHRydWUgLT4gemVybyBlZmZlY3RpdmUgdGltZSBzY2FsZVxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7IC8vIGZhbHNlIC0+IHplcm8gZWZmZWN0aXZlIHdlaWdodFxuXG5cdFx0dGhpcy5jbGFtcFdoZW5GaW5pc2hlZCA9IGZhbHNlOy8vIGtlZXAgZmVlZGluZyB0aGUgbGFzdCBmcmFtZT9cblxuXHRcdHRoaXMuemVyb1Nsb3BlQXRTdGFydCA9IHRydWU7Ly8gZm9yIHNtb290aCBpbnRlcnBvbGF0aW9uIHcvbyBzZXBhcmF0ZVxuXHRcdHRoaXMuemVyb1Nsb3BlQXRFbmQgPSB0cnVlOy8vIGNsaXBzIGZvciBzdGFydCwgbG9vcCBhbmQgZW5kXG5cblx0fVxuXG5cdC8vIFN0YXRlICYgU2NoZWR1bGluZ1xuXG5cdHBsYXkoKSB7XG5cblx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdG9wKCkge1xuXG5cdFx0dGhpcy5fbWl4ZXIuX2RlYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcblxuXHRcdHJldHVybiB0aGlzLnJlc2V0KCk7XG5cblx0fVxuXG5cdHJlc2V0KCkge1xuXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy50aW1lID0gMDsgLy8gcmVzdGFydCBjbGlwXG5cdFx0dGhpcy5fbG9vcENvdW50ID0gLSAxOy8vIGZvcmdldCBwcmV2aW91cyBsb29wc1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7Ly8gZm9yZ2V0IHNjaGVkdWxpbmdcblxuXHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKS5zdG9wV2FycGluZygpO1xuXG5cdH1cblxuXHRpc1J1bm5pbmcoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5lbmFibGVkICYmICEgdGhpcy5wYXVzZWQgJiYgdGhpcy50aW1lU2NhbGUgIT09IDAgJiZcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9PT0gbnVsbCAmJiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcblxuXHR9XG5cblx0Ly8gcmV0dXJuIHRydWUgd2hlbiBwbGF5IGhhcyBiZWVuIGNhbGxlZFxuXHRpc1NjaGVkdWxlZCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcblxuXHR9XG5cblx0c3RhcnRBdCggdGltZSApIHtcblxuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRpbWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0TG9vcCggbW9kZSwgcmVwZXRpdGlvbnMgKSB7XG5cblx0XHR0aGlzLmxvb3AgPSBtb2RlO1xuXHRcdHRoaXMucmVwZXRpdGlvbnMgPSByZXBldGl0aW9ucztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvLyBXZWlnaHRcblxuXHQvLyBzZXQgdGhlIHdlaWdodCBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIGZhZGluZ1xuXHQvLyBhbHRob3VnaCAuZW5hYmxlZCA9IGZhbHNlIHlpZWxkcyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIHplcm8sIHRoaXNcblx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5lbmFibGVkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xuXHRzZXRFZmZlY3RpdmVXZWlnaHQoIHdlaWdodCApIHtcblxuXHRcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0O1xuXG5cdFx0Ly8gbm90ZTogc2FtZSBsb2dpYyBhcyB3aGVuIHVwZGF0ZWQgYXQgcnVudGltZVxuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHRoaXMuZW5hYmxlZCA/IHdlaWdodCA6IDA7XG5cblx0XHRyZXR1cm4gdGhpcy5zdG9wRmFkaW5nKCk7XG5cblx0fVxuXG5cdC8vIHJldHVybiB0aGUgd2VpZ2h0IGNvbnNpZGVyaW5nIGZhZGluZyBhbmQgLmVuYWJsZWRcblx0Z2V0RWZmZWN0aXZlV2VpZ2h0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcblxuXHR9XG5cblx0ZmFkZUluKCBkdXJhdGlvbiApIHtcblxuXHRcdHJldHVybiB0aGlzLl9zY2hlZHVsZUZhZGluZyggZHVyYXRpb24sIDAsIDEgKTtcblxuXHR9XG5cblx0ZmFkZU91dCggZHVyYXRpb24gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAxLCAwICk7XG5cblx0fVxuXG5cdGNyb3NzRmFkZUZyb20oIGZhZGVPdXRBY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xuXG5cdFx0ZmFkZU91dEFjdGlvbi5mYWRlT3V0KCBkdXJhdGlvbiApO1xuXHRcdHRoaXMuZmFkZUluKCBkdXJhdGlvbiApO1xuXG5cdFx0aWYgKCB3YXJwICkge1xuXG5cdFx0XHRjb25zdCBmYWRlSW5EdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXG5cdFx0XHRcdGZhZGVPdXREdXJhdGlvbiA9IGZhZGVPdXRBY3Rpb24uX2NsaXAuZHVyYXRpb24sXG5cblx0XHRcdFx0c3RhcnRFbmRSYXRpbyA9IGZhZGVPdXREdXJhdGlvbiAvIGZhZGVJbkR1cmF0aW9uLFxuXHRcdFx0XHRlbmRTdGFydFJhdGlvID0gZmFkZUluRHVyYXRpb24gLyBmYWRlT3V0RHVyYXRpb247XG5cblx0XHRcdGZhZGVPdXRBY3Rpb24ud2FycCggMS4wLCBzdGFydEVuZFJhdGlvLCBkdXJhdGlvbiApO1xuXHRcdFx0dGhpcy53YXJwKCBlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y3Jvc3NGYWRlVG8oIGZhZGVJbkFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XG5cblx0XHRyZXR1cm4gZmFkZUluQWN0aW9uLmNyb3NzRmFkZUZyb20oIHRoaXMsIGR1cmF0aW9uLCB3YXJwICk7XG5cblx0fVxuXG5cdHN0b3BGYWRpbmcoKSB7XG5cblx0XHRjb25zdCB3ZWlnaHRJbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG5cdFx0aWYgKCB3ZWlnaHRJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCB3ZWlnaHRJbnRlcnBvbGFudCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIFRpbWUgU2NhbGUgQ29udHJvbFxuXG5cdC8vIHNldCB0aGUgdGltZSBzY2FsZSBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIHdhcnBpbmdcblx0Ly8gYWx0aG91Z2ggLnBhdXNlZCA9IHRydWUgeWllbGRzIGFuIGVmZmVjdGl2ZSB0aW1lIHNjYWxlIG9mIHplcm8sIHRoaXNcblx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5wYXVzZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXG5cdHNldEVmZmVjdGl2ZVRpbWVTY2FsZSggdGltZVNjYWxlICkge1xuXG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG5cdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGhpcy5wYXVzZWQgPyAwIDogdGltZVNjYWxlO1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuXHR9XG5cblx0Ly8gcmV0dXJuIHRoZSB0aW1lIHNjYWxlIGNvbnNpZGVyaW5nIHdhcnBpbmcgYW5kIC5wYXVzZWRcblx0Z2V0RWZmZWN0aXZlVGltZVNjYWxlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZTtcblxuXHR9XG5cblx0c2V0RHVyYXRpb24oIGR1cmF0aW9uICkge1xuXG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aGlzLl9jbGlwLmR1cmF0aW9uIC8gZHVyYXRpb247XG5cblx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xuXG5cdH1cblxuXHRzeW5jV2l0aCggYWN0aW9uICkge1xuXG5cdFx0dGhpcy50aW1lID0gYWN0aW9uLnRpbWU7XG5cdFx0dGhpcy50aW1lU2NhbGUgPSBhY3Rpb24udGltZVNjYWxlO1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuXHR9XG5cblx0aGFsdCggZHVyYXRpb24gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy53YXJwKCB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUsIDAsIGR1cmF0aW9uICk7XG5cblx0fVxuXG5cdHdhcnAoIHN0YXJ0VGltZVNjYWxlLCBlbmRUaW1lU2NhbGUsIGR1cmF0aW9uICkge1xuXG5cdFx0Y29uc3QgbWl4ZXIgPSB0aGlzLl9taXhlcixcblx0XHRcdG5vdyA9IG1peGVyLnRpbWUsXG5cdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcblxuXHRcdGxldCBpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xuXG5cdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpO1xuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxuXHRcdFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xuXG5cdFx0dGltZXNbIDAgXSA9IG5vdztcblx0XHR0aW1lc1sgMSBdID0gbm93ICsgZHVyYXRpb247XG5cblx0XHR2YWx1ZXNbIDAgXSA9IHN0YXJ0VGltZVNjYWxlIC8gdGltZVNjYWxlO1xuXHRcdHZhbHVlc1sgMSBdID0gZW5kVGltZVNjYWxlIC8gdGltZVNjYWxlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0b3BXYXJwaW5nKCkge1xuXG5cdFx0Y29uc3QgdGltZVNjYWxlSW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuXHRcdGlmICggdGltZVNjYWxlSW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcblx0XHRcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggdGltZVNjYWxlSW50ZXJwb2xhbnQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvLyBPYmplY3QgQWNjZXNzb3JzXG5cblx0Z2V0TWl4ZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbWl4ZXI7XG5cblx0fVxuXG5cdGdldENsaXAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fY2xpcDtcblxuXHR9XG5cblx0Z2V0Um9vdCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9sb2NhbFJvb3QgfHwgdGhpcy5fbWl4ZXIuX3Jvb3Q7XG5cblx0fVxuXG5cdC8vIEludGVybmFcblxuXHRfdXBkYXRlKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApIHtcblxuXHRcdC8vIGNhbGxlZCBieSB0aGUgbWl4ZXJcblxuXHRcdGlmICggISB0aGlzLmVuYWJsZWQgKSB7XG5cblx0XHRcdC8vIGNhbGwgLl91cGRhdGVXZWlnaHQoKSB0byB1cGRhdGUgLl9lZmZlY3RpdmVXZWlnaHRcblxuXHRcdFx0dGhpcy5fdXBkYXRlV2VpZ2h0KCB0aW1lICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRjb25zdCBzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWU7XG5cblx0XHRpZiAoIHN0YXJ0VGltZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gY2hlY2sgZm9yIHNjaGVkdWxlZCBzdGFydCBvZiBhY3Rpb25cblxuXHRcdFx0Y29uc3QgdGltZVJ1bm5pbmcgPSAoIHRpbWUgLSBzdGFydFRpbWUgKSAqIHRpbWVEaXJlY3Rpb247XG5cdFx0XHRpZiAoIHRpbWVSdW5uaW5nIDwgMCB8fCB0aW1lRGlyZWN0aW9uID09PSAwICkge1xuXG5cdFx0XHRcdGRlbHRhVGltZSA9IDA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblxuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsOyAvLyB1bnNjaGVkdWxlXG5cdFx0XHRcdGRlbHRhVGltZSA9IHRpbWVEaXJlY3Rpb24gKiB0aW1lUnVubmluZztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYXBwbHkgdGltZSBzY2FsZSBhbmQgYWR2YW5jZSB0aW1lXG5cblx0XHRkZWx0YVRpbWUgKj0gdGhpcy5fdXBkYXRlVGltZVNjYWxlKCB0aW1lICk7XG5cdFx0Y29uc3QgY2xpcFRpbWUgPSB0aGlzLl91cGRhdGVUaW1lKCBkZWx0YVRpbWUgKTtcblxuXHRcdC8vIG5vdGU6IF91cGRhdGVUaW1lIG1heSBkaXNhYmxlIHRoZSBhY3Rpb24gcmVzdWx0aW5nIGluXG5cdFx0Ly8gYW4gZWZmZWN0aXZlIHdlaWdodCBvZiAwXG5cblx0XHRjb25zdCB3ZWlnaHQgPSB0aGlzLl91cGRhdGVXZWlnaHQoIHRpbWUgKTtcblxuXHRcdGlmICggd2VpZ2h0ID4gMCApIHtcblxuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRzID0gdGhpcy5faW50ZXJwb2xhbnRzO1xuXHRcdFx0Y29uc3QgcHJvcGVydHlNaXhlcnMgPSB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLmJsZW5kTW9kZSApIHtcblxuXHRcdFx0XHRjYXNlIEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlOlxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBtID0gaW50ZXJwb2xhbnRzLmxlbmd0aDsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhbnRzWyBqIF0uZXZhbHVhdGUoIGNsaXBUaW1lICk7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eU1peGVyc1sgaiBdLmFjY3VtdWxhdGVBZGRpdGl2ZSggd2VpZ2h0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZTpcblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IGludGVycG9sYW50cy5sZW5ndGg7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdGludGVycG9sYW50c1sgaiBdLmV2YWx1YXRlKCBjbGlwVGltZSApO1xuXHRcdFx0XHRcdFx0cHJvcGVydHlNaXhlcnNbIGogXS5hY2N1bXVsYXRlKCBhY2N1SW5kZXgsIHdlaWdodCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdF91cGRhdGVXZWlnaHQoIHRpbWUgKSB7XG5cblx0XHRsZXQgd2VpZ2h0ID0gMDtcblxuXHRcdGlmICggdGhpcy5lbmFibGVkICkge1xuXG5cdFx0XHR3ZWlnaHQgPSB0aGlzLndlaWdodDtcblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XG5cblx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKCB0aW1lIClbIDAgXTtcblxuXHRcdFx0XHR3ZWlnaHQgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblxuXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuc3RvcEZhZGluZygpO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnBvbGFudFZhbHVlID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBmYWRlZCBvdXQsIGRpc2FibGVcblx0XHRcdFx0XHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gd2VpZ2h0O1xuXHRcdHJldHVybiB3ZWlnaHQ7XG5cblx0fVxuXG5cdF91cGRhdGVUaW1lU2NhbGUoIHRpbWUgKSB7XG5cblx0XHRsZXQgdGltZVNjYWxlID0gMDtcblxuXHRcdGlmICggISB0aGlzLnBhdXNlZCApIHtcblxuXHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XG5cblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XG5cblx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKCB0aW1lIClbIDAgXTtcblxuXHRcdFx0XHR0aW1lU2NhbGUgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblxuXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuXHRcdFx0XHRcdGlmICggdGltZVNjYWxlID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBtb3Rpb24gaGFzIGhhbHRlZCwgcGF1c2Vcblx0XHRcdFx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHdhcnAgZG9uZSAtIGFwcGx5IGZpbmFsIHRpbWUgc2NhbGVcblx0XHRcdFx0XHRcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGltZVNjYWxlO1xuXHRcdHJldHVybiB0aW1lU2NhbGU7XG5cblx0fVxuXG5cdF91cGRhdGVUaW1lKCBkZWx0YVRpbWUgKSB7XG5cblx0XHRjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb247XG5cdFx0Y29uc3QgbG9vcCA9IHRoaXMubG9vcDtcblxuXHRcdGxldCB0aW1lID0gdGhpcy50aW1lICsgZGVsdGFUaW1lO1xuXHRcdGxldCBsb29wQ291bnQgPSB0aGlzLl9sb29wQ291bnQ7XG5cblx0XHRjb25zdCBwaW5nUG9uZyA9ICggbG9vcCA9PT0gTG9vcFBpbmdQb25nICk7XG5cblx0XHRpZiAoIGRlbHRhVGltZSA9PT0gMCApIHtcblxuXHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0gMSApIHJldHVybiB0aW1lO1xuXG5cdFx0XHRyZXR1cm4gKCBwaW5nUG9uZyAmJiAoIGxvb3BDb3VudCAmIDEgKSA9PT0gMSApID8gZHVyYXRpb24gLSB0aW1lIDogdGltZTtcblxuXHRcdH1cblxuXHRcdGlmICggbG9vcCA9PT0gTG9vcE9uY2UgKSB7XG5cblx0XHRcdGlmICggbG9vcENvdW50ID09PSAtIDEgKSB7XG5cblx0XHRcdFx0Ly8ganVzdCBzdGFydGVkXG5cblx0XHRcdFx0dGhpcy5fbG9vcENvdW50ID0gMDtcblx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggdHJ1ZSwgdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRoYW5kbGVfc3RvcDoge1xuXG5cdFx0XHRcdGlmICggdGltZSA+PSBkdXJhdGlvbiApIHtcblxuXHRcdFx0XHRcdHRpbWUgPSBkdXJhdGlvbjtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aW1lIDwgMCApIHtcblxuXHRcdFx0XHRcdHRpbWUgPSAwO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdFx0YnJlYWsgaGFuZGxlX3N0b3A7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGhpcy5jbGFtcFdoZW5GaW5pc2hlZCApIHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHR0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsXG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPCAwID8gLSAxIDogMVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7IC8vIHJlcGV0aXRpdmUgUmVwZWF0IG9yIFBpbmdQb25nXG5cblx0XHRcdGlmICggbG9vcENvdW50ID09PSAtIDEgKSB7XG5cblx0XHRcdFx0Ly8ganVzdCBzdGFydGVkXG5cblx0XHRcdFx0aWYgKCBkZWx0YVRpbWUgPj0gMCApIHtcblxuXHRcdFx0XHRcdGxvb3BDb3VudCA9IDA7XG5cblx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCB0cnVlLCB0aGlzLnJlcGV0aXRpb25zID09PSAwLCBwaW5nUG9uZyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyB3aGVuIGxvb3BpbmcgaW4gcmV2ZXJzZSBkaXJlY3Rpb24sIHRoZSBpbml0aWFsXG5cdFx0XHRcdFx0Ly8gdHJhbnNpdGlvbiB0aHJvdWdoIHplcm8gY291bnRzIGFzIGEgcmVwZXRpdGlvbixcblx0XHRcdFx0XHQvLyBzbyBsZWF2ZSBsb29wQ291bnQgYXQgLTFcblxuXHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIHRoaXMucmVwZXRpdGlvbnMgPT09IDAsIHRydWUsIHBpbmdQb25nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGltZSA+PSBkdXJhdGlvbiB8fCB0aW1lIDwgMCApIHtcblxuXHRcdFx0XHQvLyB3cmFwIGFyb3VuZFxuXG5cdFx0XHRcdGNvbnN0IGxvb3BEZWx0YSA9IE1hdGguZmxvb3IoIHRpbWUgLyBkdXJhdGlvbiApOyAvLyBzaWduZWRcblx0XHRcdFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcblxuXHRcdFx0XHRsb29wQ291bnQgKz0gTWF0aC5hYnMoIGxvb3BEZWx0YSApO1xuXG5cdFx0XHRcdGNvbnN0IHBlbmRpbmcgPSB0aGlzLnJlcGV0aXRpb25zIC0gbG9vcENvdW50O1xuXG5cdFx0XHRcdGlmICggcGVuZGluZyA8PSAwICkge1xuXG5cdFx0XHRcdFx0Ly8gaGF2ZSB0byBzdG9wIChzd2l0Y2ggc3RhdGUsIGNsYW1wIHRpbWUsIGZpcmUgZXZlbnQpXG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFx0XHRcdFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdHRpbWUgPSBkZWx0YVRpbWUgPiAwID8gZHVyYXRpb24gOiAwO1xuXG5cdFx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcblxuXHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHRcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcblx0XHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lID4gMCA/IDEgOiAtIDFcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGtlZXAgcnVubmluZ1xuXG5cdFx0XHRcdFx0aWYgKCBwZW5kaW5nID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHQvLyBlbnRlcmluZyB0aGUgbGFzdCByb3VuZFxuXG5cdFx0XHRcdFx0XHRjb25zdCBhdFN0YXJ0ID0gZGVsdGFUaW1lIDwgMDtcblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGF0U3RhcnQsICEgYXRTdGFydCwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGZhbHNlLCBmYWxzZSwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcblxuXHRcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cblx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnbG9vcCcsIGFjdGlvbjogdGhpcywgbG9vcERlbHRhOiBsb29wRGVsdGFcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwaW5nUG9uZyAmJiAoIGxvb3BDb3VudCAmIDEgKSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBpbnZlcnQgdGltZSBmb3IgdGhlIFwicG9uZyByb3VuZFwiXG5cblx0XHRcdFx0cmV0dXJuIGR1cmF0aW9uIC0gdGltZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRpbWU7XG5cblx0fVxuXG5cdF9zZXRFbmRpbmdzKCBhdFN0YXJ0LCBhdEVuZCwgcGluZ1BvbmcgKSB7XG5cblx0XHRjb25zdCBzZXR0aW5ncyA9IHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3M7XG5cblx0XHRpZiAoIHBpbmdQb25nICkge1xuXG5cdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFplcm9TbG9wZUVuZGluZztcblx0XHRcdHNldHRpbmdzLmVuZGluZ0VuZCA9IFplcm9TbG9wZUVuZGluZztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGFzc3VtaW5nIGZvciBMb29wT25jZSBhdFN0YXJ0ID09IGF0RW5kID09IHRydWVcblxuXHRcdFx0aWYgKCBhdFN0YXJ0ICkge1xuXG5cdFx0XHRcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gdGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFdyYXBBcm91bmRFbmRpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhdEVuZCApIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgPSB0aGlzLnplcm9TbG9wZUF0RW5kID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgXHQgPSBXcmFwQXJvdW5kRW5kaW5nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdF9zY2hlZHVsZUZhZGluZyggZHVyYXRpb24sIHdlaWdodE5vdywgd2VpZ2h0VGhlbiApIHtcblxuXHRcdGNvbnN0IG1peGVyID0gdGhpcy5fbWl4ZXIsIG5vdyA9IG1peGVyLnRpbWU7XG5cdFx0bGV0IGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XG5cblx0XHRpZiAoIGludGVycG9sYW50ID09PSBudWxsICkge1xuXG5cdFx0XHRpbnRlcnBvbGFudCA9IG1peGVyLl9sZW5kQ29udHJvbEludGVycG9sYW50KCk7XG5cdFx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XG5cblx0XHR0aW1lc1sgMCBdID0gbm93O1xuXHRcdHZhbHVlc1sgMCBdID0gd2VpZ2h0Tm93O1xuXHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcblx0XHR2YWx1ZXNbIDEgXSA9IHdlaWdodFRoZW47XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuY29uc3QgX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCAxICk7XG5cblxuY2xhc3MgQW5pbWF0aW9uTWl4ZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdGNvbnN0cnVjdG9yKCByb290ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX3Jvb3QgPSByb290O1xuXHRcdHRoaXMuX2luaXRNZW1vcnlNYW5hZ2VyKCk7XG5cdFx0dGhpcy5fYWNjdUluZGV4ID0gMDtcblx0XHR0aGlzLnRpbWUgPSAwO1xuXHRcdHRoaXMudGltZVNjYWxlID0gMS4wO1xuXG5cdH1cblxuXHRfYmluZEFjdGlvbiggYWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKSB7XG5cblx0XHRjb25zdCByb290ID0gYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCxcblx0XHRcdHRyYWNrcyA9IGFjdGlvbi5fY2xpcC50cmFja3MsXG5cdFx0XHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcblx0XHRcdGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzLFxuXHRcdFx0aW50ZXJwb2xhbnRzID0gYWN0aW9uLl9pbnRlcnBvbGFudHMsXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lO1xuXG5cdFx0bGV0IGJpbmRpbmdzQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRpZiAoIGJpbmRpbmdzQnlOYW1lID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJpbmRpbmdzQnlOYW1lID0ge307XG5cdFx0XHRiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSA9IGJpbmRpbmdzQnlOYW1lO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuVHJhY2tzOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCB0cmFjayA9IHRyYWNrc1sgaSBdLFxuXHRcdFx0XHR0cmFja05hbWUgPSB0cmFjay5uYW1lO1xuXG5cdFx0XHRsZXQgYmluZGluZyA9IGJpbmRpbmdzQnlOYW1lWyB0cmFja05hbWUgXTtcblxuXHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0KysgYmluZGluZy5yZWZlcmVuY2VDb3VudDtcblx0XHRcdFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBleGlzdGluZyBiaW5kaW5nLCBtYWtlIHN1cmUgdGhlIGNhY2hlIGtub3dzXG5cblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5cblx0XHRcdFx0XHRfcHJvcGVydHlCaW5kaW5nc1sgaSBdLmJpbmRpbmcucGFyc2VkUGF0aDtcblxuXHRcdFx0XHRiaW5kaW5nID0gbmV3IFByb3BlcnR5TWl4ZXIoXG5cdFx0XHRcdFx0UHJvcGVydHlCaW5kaW5nLmNyZWF0ZSggcm9vdCwgdHJhY2tOYW1lLCBwYXRoICksXG5cdFx0XHRcdFx0dHJhY2suVmFsdWVUeXBlTmFtZSwgdHJhY2suZ2V0VmFsdWVTaXplKCkgKTtcblxuXHRcdFx0XHQrKyBiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xuXHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKTtcblxuXHRcdFx0XHRiaW5kaW5nc1sgaSBdID0gYmluZGluZztcblxuXHRcdFx0fVxuXG5cdFx0XHRpbnRlcnBvbGFudHNbIGkgXS5yZXN1bHRCdWZmZXIgPSBiaW5kaW5nLmJ1ZmZlcjtcblxuXHRcdH1cblxuXHR9XG5cblx0X2FjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHRpZiAoICEgdGhpcy5faXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApICkge1xuXG5cdFx0XHRpZiAoIGFjdGlvbi5fY2FjaGVJbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHQvLyB0aGlzIGFjdGlvbiBoYXMgYmVlbiBmb3Jnb3R0ZW4gYnkgdGhlIGNhY2hlLCBidXQgdGhlIHVzZXJcblx0XHRcdFx0Ly8gYXBwZWFycyB0byBiZSBzdGlsbCB1c2luZyBpdCAtPiByZWJpbmRcblxuXHRcdFx0XHRjb25zdCByb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQsXG5cdFx0XHRcdFx0Y2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcblx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cblx0XHRcdFx0dGhpcy5fYmluZEFjdGlvbiggYWN0aW9uLFxuXHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwICYmIGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdICk7XG5cblx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdC8vIGluY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGJpbmRpbmcudXNlQ291bnQgKysgPT09IDAgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl9sZW5kQmluZGluZyggYmluZGluZyApO1xuXHRcdFx0XHRcdGJpbmRpbmcuc2F2ZU9yaWdpbmFsU3RhdGUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGVuZEFjdGlvbiggYWN0aW9uICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHRpZiAoIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcblxuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdC8vIGRlY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblxuXHRcdFx0XHRpZiAoIC0tIGJpbmRpbmcudXNlQ291bnQgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XG5cdFx0XHRcdFx0dGhpcy5fdGFrZUJhY2tCaW5kaW5nKCBiaW5kaW5nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3Rha2VCYWNrQWN0aW9uKCBhY3Rpb24gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gTWVtb3J5IG1hbmFnZXJcblxuXHRfaW5pdE1lbW9yeU1hbmFnZXIoKSB7XG5cblx0XHR0aGlzLl9hY3Rpb25zID0gW107IC8vICduQWN0aXZlQWN0aW9ucycgZm9sbG93ZWQgYnkgaW5hY3RpdmUgb25lc1xuXHRcdHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDtcblxuXHRcdHRoaXMuX2FjdGlvbnNCeUNsaXAgPSB7fTtcblx0XHQvLyBpbnNpZGU6XG5cdFx0Ly8ge1xuXHRcdC8vIFx0a25vd25BY3Rpb25zOiBBcnJheTwgQW5pbWF0aW9uQWN0aW9uID4gLSB1c2VkIGFzIHByb3RvdHlwZXNcblx0XHQvLyBcdGFjdGlvbkJ5Um9vdDogQW5pbWF0aW9uQWN0aW9uIC0gbG9va3VwXG5cdFx0Ly8gfVxuXG5cblx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyAnbkFjdGl2ZUJpbmRpbmdzJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXG5cdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcblxuXHRcdHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSA9IHt9OyAvLyBpbnNpZGU6IE1hcDwgbmFtZSwgUHJvcGVydHlNaXhlciA+XG5cblxuXHRcdHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMgPSBbXTsgLy8gc2FtZSBnYW1lIGFzIGFib3ZlXG5cdFx0dGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgPSAwO1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dGhpcy5zdGF0cyA9IHtcblxuXHRcdFx0YWN0aW9uczoge1xuXHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2FjdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldCBpblVzZSgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fbkFjdGl2ZUFjdGlvbnM7XG5cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJpbmRpbmdzOiB7XG5cdFx0XHRcdGdldCB0b3RhbCgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldCBpblVzZSgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fbkFjdGl2ZUJpbmRpbmdzO1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjb250cm9sSW50ZXJwb2xhbnRzOiB7XG5cdFx0XHRcdGdldCB0b3RhbCgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fY29udHJvbEludGVycG9sYW50cy5sZW5ndGg7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0Z2V0IGluVXNlKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cztcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH1cblxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgQW5pbWF0aW9uQWN0aW9uIG9iamVjdHNcblxuXHRfaXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuXHRcdHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA8IHRoaXMuX25BY3RpdmVBY3Rpb25zO1xuXG5cdH1cblxuXHRfYWRkSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICkge1xuXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcDtcblxuXHRcdGxldCBhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cblx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGFjdGlvbnNGb3JDbGlwID0ge1xuXG5cdFx0XHRcdGtub3duQWN0aW9uczogWyBhY3Rpb24gXSxcblx0XHRcdFx0YWN0aW9uQnlSb290OiB7fVxuXG5cdFx0XHR9O1xuXG5cdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSAwO1xuXG5cdFx0XHRhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdID0gYWN0aW9uc0ZvckNsaXA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBrbm93bkFjdGlvbnMgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cblx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XG5cdFx0XHRrbm93bkFjdGlvbnMucHVzaCggYWN0aW9uICk7XG5cblx0XHR9XG5cblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBhY3Rpb25zLmxlbmd0aDtcblx0XHRhY3Rpb25zLnB1c2goIGFjdGlvbiApO1xuXG5cdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdID0gYWN0aW9uO1xuXG5cdH1cblxuXHRfcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF0sXG5cdFx0XHRjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuXG5cdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XG5cdFx0YWN0aW9ucy5wb3AoKTtcblxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cblxuXHRcdGNvbnN0IGNsaXBVdWlkID0gYWN0aW9uLl9jbGlwLnV1aWQsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSxcblx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnMsXG5cblx0XHRcdGxhc3RLbm93bkFjdGlvbiA9XG5cdFx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXBbIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoIC0gMSBdLFxuXG5cdFx0XHRieUNsaXBDYWNoZUluZGV4ID0gYWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4O1xuXG5cdFx0bGFzdEtub3duQWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gYnlDbGlwQ2FjaGVJbmRleDtcblx0XHRrbm93bkFjdGlvbnNGb3JDbGlwWyBieUNsaXBDYWNoZUluZGV4IF0gPSBsYXN0S25vd25BY3Rpb247XG5cdFx0a25vd25BY3Rpb25zRm9yQ2xpcC5wb3AoKTtcblxuXHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cblxuXHRcdGNvbnN0IGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdCxcblx0XHRcdHJvb3RVdWlkID0gKCBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290ICkudXVpZDtcblxuXHRcdGRlbGV0ZSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRpZiAoIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRkZWxldGUgYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xuXG5cdH1cblxuXHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICkge1xuXG5cdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXG5cdFx0XHRpZiAoIC0tIGJpbmRpbmcucmVmZXJlbmNlQ291bnQgPT09IDAgKSB7XG5cblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0X2xlbmRBY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfCAgaW5hY3RpdmUgYWN0aW9ucyAgXVxuXHRcdC8vIFsgIGFjdGl2ZSBhY3Rpb25zID58IGluYWN0aXZlIGFjdGlvbnMgXVxuXHRcdC8vICAgICAgICAgICAgICAgICBzICAgICAgICBhXG5cdFx0Ly8gICAgICAgICAgICAgICAgICA8LXN3YXAtPlxuXHRcdC8vICAgICAgICAgICAgICAgICBhICAgICAgICBzXG5cblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcblxuXHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMgKyssXG5cblx0XHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBsYXN0QWN0aXZlSW5kZXggXTtcblxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRhY3Rpb25zWyBsYXN0QWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcblxuXHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YWN0aW9uc1sgcHJldkluZGV4IF0gPSBmaXJzdEluYWN0aXZlQWN0aW9uO1xuXG5cdH1cblxuXHRfdGFrZUJhY2tBY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdC8vIFsgIGFjdGl2ZSBhY3Rpb25zICB8IGluYWN0aXZlIGFjdGlvbnMgXVxuXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfDwgaW5hY3RpdmUgYWN0aW9ucyAgXVxuXHRcdC8vICAgICAgICBhICAgICAgICBzXG5cdFx0Ly8gICAgICAgICA8LXN3YXAtPlxuXHRcdC8vICAgICAgICBzICAgICAgICBhXG5cblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cblx0XHRcdGxhc3RBY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcblxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcblxuXHRcdGxhc3RBY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YWN0aW9uc1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlQWN0aW9uO1xuXG5cdH1cblxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgUHJvcGVydHlNaXhlciBvYmplY3RzXG5cblx0X2FkZEluYWN0aXZlQmluZGluZyggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdGxldCBiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IHt9O1xuXHRcdFx0YmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0gPSBiaW5kaW5nQnlOYW1lO1xuXG5cdFx0fVxuXG5cdFx0YmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF0gPSBiaW5kaW5nO1xuXG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XG5cblx0fVxuXG5cdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKSB7XG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0cHJvcEJpbmRpbmcgPSBiaW5kaW5nLmJpbmRpbmcsXG5cdFx0XHRyb290VXVpZCA9IHByb3BCaW5kaW5nLnJvb3ROb2RlLnV1aWQsXG5cdFx0XHR0cmFja05hbWUgPSBwcm9wQmluZGluZy5wYXRoLFxuXHRcdFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXG5cblx0XHRcdGxhc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgYmluZGluZ3MubGVuZ3RoIC0gMSBdLFxuXHRcdFx0Y2FjaGVJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXg7XG5cblx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRiaW5kaW5nc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQmluZGluZztcblx0XHRiaW5kaW5ncy5wb3AoKTtcblxuXHRcdGRlbGV0ZSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcblxuXHRcdGlmICggT2JqZWN0LmtleXMoIGJpbmRpbmdCeU5hbWUgKS5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0X2xlbmRCaW5kaW5nKCBiaW5kaW5nICkge1xuXG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXG5cblx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncyArKyxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgbGFzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xuXHRcdGJpbmRpbmdzWyBsYXN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XG5cblx0XHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRiaW5kaW5nc1sgcHJldkluZGV4IF0gPSBmaXJzdEluYWN0aXZlQmluZGluZztcblxuXHR9XG5cblx0X3Rha2VCYWNrQmluZGluZyggYmluZGluZyApIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuXG5cdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQmluZGluZ3MsXG5cblx0XHRcdGxhc3RBY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xuXG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0bGFzdEFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUJpbmRpbmc7XG5cblx0fVxuXG5cblx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgb2YgSW50ZXJwb2xhbnRzIGZvciB3ZWlnaHQgYW5kIHRpbWUgc2NhbGVcblxuXHRfbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpIHtcblxuXHRcdGNvbnN0IGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyArKztcblxuXHRcdGxldCBpbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRpZiAoIGludGVycG9sYW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGludGVycG9sYW50ID0gbmV3IExpbmVhckludGVycG9sYW50KFxuXHRcdFx0XHRuZXcgRmxvYXQzMkFycmF5KCAyICksIG5ldyBGbG9hdDMyQXJyYXkoIDIgKSxcblx0XHRcdFx0MSwgX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgKTtcblxuXHRcdFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xuXHRcdFx0aW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXSA9IGludGVycG9sYW50O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludGVycG9sYW50O1xuXG5cdH1cblxuXHRfdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIGludGVycG9sYW50ICkge1xuXG5cdFx0Y29uc3QgaW50ZXJwb2xhbnRzID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cyxcblx0XHRcdHByZXZJbmRleCA9IGludGVycG9sYW50Ll9fY2FjaGVJbmRleCxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMsXG5cblx0XHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XG5cblx0XHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XG5cdFx0aW50ZXJwb2xhbnRzWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGludGVycG9sYW50O1xuXG5cdFx0bGFzdEFjdGl2ZUludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRpbnRlcnBvbGFudHNbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUludGVycG9sYW50O1xuXG5cdH1cblxuXHQvLyByZXR1cm4gYW4gYWN0aW9uIGZvciBhIGNsaXAgb3B0aW9uYWxseSB1c2luZyBhIGN1c3RvbSByb290IHRhcmdldFxuXHQvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcblx0Ly8gcHJldmlvdXNseSB1bmtub3duIGNsaXAvcm9vdCBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQpXG5cdGNsaXBBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCwgYmxlbmRNb2RlICkge1xuXG5cdFx0Y29uc3Qgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxuXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQ7XG5cblx0XHRsZXQgY2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/IEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcDtcblxuXHRcdGNvbnN0IGNsaXBVdWlkID0gY2xpcE9iamVjdCAhPT0gbnVsbCA/IGNsaXBPYmplY3QudXVpZCA6IGNsaXA7XG5cblx0XHRjb25zdCBhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cdFx0bGV0IHByb3RvdHlwZUFjdGlvbiA9IG51bGw7XG5cblx0XHRpZiAoIGJsZW5kTW9kZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIGNsaXBPYmplY3QgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0YmxlbmRNb2RlID0gY2xpcE9iamVjdC5ibGVuZE1vZGU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YmxlbmRNb2RlID0gTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGV4aXN0aW5nQWN0aW9uID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0XHRpZiAoIGV4aXN0aW5nQWN0aW9uICE9PSB1bmRlZmluZWQgJiYgZXhpc3RpbmdBY3Rpb24uYmxlbmRNb2RlID09PSBibGVuZE1vZGUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nQWN0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGtub3cgdGhlIGNsaXAsIHNvIHdlIGRvbid0IGhhdmUgdG8gcGFyc2UgYWxsXG5cdFx0XHQvLyB0aGUgYmluZGluZ3MgYWdhaW4gYnV0IGNhbiBqdXN0IGNvcHlcblx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdO1xuXG5cdFx0XHQvLyBhbHNvLCB0YWtlIHRoZSBjbGlwIGZyb20gdGhlIHByb3RvdHlwZSBhY3Rpb25cblx0XHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApXG5cdFx0XHRcdGNsaXBPYmplY3QgPSBwcm90b3R5cGVBY3Rpb24uX2NsaXA7XG5cblx0XHR9XG5cblx0XHQvLyBjbGlwIG11c3QgYmUga25vd24gd2hlbiBzcGVjaWZpZWQgdmlhIHN0cmluZ1xuXHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xuXG5cdFx0Ly8gYWxsb2NhdGUgYWxsIHJlc291cmNlcyByZXF1aXJlZCB0byBydW4gaXRcblx0XHRjb25zdCBuZXdBY3Rpb24gPSBuZXcgQW5pbWF0aW9uQWN0aW9uKCB0aGlzLCBjbGlwT2JqZWN0LCBvcHRpb25hbFJvb3QsIGJsZW5kTW9kZSApO1xuXG5cdFx0dGhpcy5fYmluZEFjdGlvbiggbmV3QWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKTtcblxuXHRcdC8vIGFuZCBtYWtlIHRoZSBhY3Rpb24ga25vd24gdG8gdGhlIG1lbW9yeSBtYW5hZ2VyXG5cdFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oIG5ld0FjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICk7XG5cblx0XHRyZXR1cm4gbmV3QWN0aW9uO1xuXG5cdH1cblxuXHQvLyBnZXQgYW4gZXhpc3RpbmcgYWN0aW9uXG5cdGV4aXN0aW5nQWN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XG5cblx0XHRjb25zdCByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblxuXHRcdFx0Y2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcCxcblxuXHRcdFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcblxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdIHx8IG51bGw7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0Ly8gZGVhY3RpdmF0ZXMgYWxsIHByZXZpb3VzbHkgc2NoZWR1bGVkIGFjdGlvbnNcblx0c3RvcEFsbEFjdGlvbigpIHtcblxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucztcblxuXHRcdGZvciAoIGxldCBpID0gbkFjdGlvbnMgLSAxOyBpID49IDA7IC0tIGkgKSB7XG5cblx0XHRcdGFjdGlvbnNbIGkgXS5zdG9wKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly8gYWR2YW5jZSB0aGUgdGltZSBhbmQgdXBkYXRlIGFwcGx5IHRoZSBhbmltYXRpb25cblx0dXBkYXRlKCBkZWx0YVRpbWUgKSB7XG5cblx0XHRkZWx0YVRpbWUgKj0gdGhpcy50aW1lU2NhbGU7XG5cblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cblx0XHRcdHRpbWUgPSB0aGlzLnRpbWUgKz0gZGVsdGFUaW1lLFxuXHRcdFx0dGltZURpcmVjdGlvbiA9IE1hdGguc2lnbiggZGVsdGFUaW1lICksXG5cblx0XHRcdGFjY3VJbmRleCA9IHRoaXMuX2FjY3VJbmRleCBePSAxO1xuXG5cdFx0Ly8gcnVuIGFjdGl2ZSBhY3Rpb25zXG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBhY3Rpb24gPSBhY3Rpb25zWyBpIF07XG5cblx0XHRcdGFjdGlvbi5fdXBkYXRlKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuQmluZGluZ3M7ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0uYXBwbHkoIGFjY3VJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIEFsbG93cyB5b3UgdG8gc2VlayB0byBhIHNwZWNpZmljIHRpbWUgaW4gYW4gYW5pbWF0aW9uLlxuXHRzZXRUaW1lKCB0aW1lSW5TZWNvbmRzICkge1xuXG5cdFx0dGhpcy50aW1lID0gMDsgLy8gWmVybyBvdXQgdGltZSBhdHRyaWJ1dGUgZm9yIEFuaW1hdGlvbk1peGVyIG9iamVjdDtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY3Rpb25zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5fYWN0aW9uc1sgaSBdLnRpbWUgPSAwOyAvLyBaZXJvIG91dCB0aW1lIGF0dHJpYnV0ZSBmb3IgYWxsIGFzc29jaWF0ZWQgQW5pbWF0aW9uQWN0aW9uIG9iamVjdHMuXG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoIHRpbWVJblNlY29uZHMgKTsgLy8gVXBkYXRlIHVzZWQgdG8gc2V0IGV4YWN0IHRpbWUuIFJldHVybnMgXCJ0aGlzXCIgQW5pbWF0aW9uTWl4ZXIgb2JqZWN0LlxuXG5cdH1cblxuXHQvLyByZXR1cm4gdGhpcyBtaXhlcidzIHJvb3QgdGFyZ2V0IG9iamVjdFxuXHRnZXRSb290KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3Jvb3Q7XG5cblx0fVxuXG5cdC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgY2xpcFxuXHR1bmNhY2hlQ2xpcCggY2xpcCApIHtcblxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0Y2xpcFV1aWQgPSBjbGlwLnV1aWQsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxuXHRcdFx0Ly8gaXRlcmF0aW9uIHN0YXRlIGFuZCBhbHNvIHJlcXVpcmUgdXBkYXRpbmcgdGhlIHN0YXRlIHdlIGNhblxuXHRcdFx0Ly8ganVzdCB0aHJvdyBhd2F5XG5cblx0XHRcdGNvbnN0IGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYWN0aW9uc1RvUmVtb3ZlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRjb25zdCBhY3Rpb24gPSBhY3Rpb25zVG9SZW1vdmVbIGkgXTtcblxuXHRcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcblxuXHRcdFx0XHRjb25zdCBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXHRcdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cblx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRcdFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xuXHRcdFx0XHRhY3Rpb25zLnBvcCgpO1xuXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBmcmVlIGFsbCByZXNvdXJjZXMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIHJvb3QgdGFyZ2V0IG9iamVjdFxuXHR1bmNhY2hlUm9vdCggcm9vdCApIHtcblxuXHRcdGNvbnN0IHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XG5cblx0XHRmb3IgKCBjb25zdCBjbGlwVXVpZCBpbiBhY3Rpb25zQnlDbGlwICkge1xuXG5cdFx0XHRjb25zdCBhY3Rpb25CeVJvb3QgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdLmFjdGlvbkJ5Um9vdCxcblx0XHRcdFx0YWN0aW9uID0gYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0XHRpZiAoIGFjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0aWYgKCBiaW5kaW5nQnlOYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IHRyYWNrTmFtZSBpbiBiaW5kaW5nQnlOYW1lICkge1xuXG5cdFx0XHRcdGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcblx0XHRcdFx0YmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyByZW1vdmUgYSB0YXJnZXRlZCBjbGlwIGZyb20gdGhlIGNhY2hlXG5cdHVuY2FjaGVBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcblxuXHRcdGNvbnN0IGFjdGlvbiA9IHRoaXMuZXhpc3RpbmdBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApO1xuXG5cdFx0aWYgKCBhY3Rpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xuXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5jbGFzcyBVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3RvciggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBVbmlmb3JtKCB0aGlzLnZhbHVlLmNsb25lID09PSB1bmRlZmluZWQgPyB0aGlzLnZhbHVlIDogdGhpcy52YWx1ZS5jbG9uZSgpICk7XG5cblx0fVxuXG59XG5cbmxldCBfaWQgPSAwO1xuXG5jbGFzcyBVbmlmb3Jtc0dyb3VwIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzVW5pZm9ybXNHcm91cCA9IHRydWU7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IF9pZCArKyB9ICk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblxuXHRcdHRoaXMudXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XG5cdFx0dGhpcy51bmlmb3JtcyA9IFtdO1xuXG5cdH1cblxuXHRhZGQoIHVuaWZvcm0gKSB7XG5cblx0XHR0aGlzLnVuaWZvcm1zLnB1c2goIHVuaWZvcm0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyZW1vdmUoIHVuaWZvcm0gKSB7XG5cblx0XHRjb25zdCBpbmRleCA9IHRoaXMudW5pZm9ybXMuaW5kZXhPZiggdW5pZm9ybSApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkgdGhpcy51bmlmb3Jtcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0TmFtZSggbmFtZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0VXNhZ2UoIHZhbHVlICkge1xuXG5cdFx0dGhpcy51c2FnZSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXG5cdFx0Y29uc3QgdW5pZm9ybXNTb3VyY2UgPSBzb3VyY2UudW5pZm9ybXM7XG5cblx0XHR0aGlzLnVuaWZvcm1zLmxlbmd0aCA9IDA7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB1bmlmb3Jtc1NvdXJjZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB1bmlmb3JtcyA9IEFycmF5LmlzQXJyYXkoIHVuaWZvcm1zU291cmNlWyBpIF0gKSA/IHVuaWZvcm1zU291cmNlWyBpIF0gOiBbIHVuaWZvcm1zU291cmNlWyBpIF0gXTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgdW5pZm9ybXMubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdHRoaXMudW5pZm9ybXMucHVzaCggdW5pZm9ybXNbIGogXS5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgZXh0ZW5kcyBJbnRlcmxlYXZlZEJ1ZmZlciB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBzdHJpZGUsIG1lc2hQZXJBdHRyaWJ1dGUgPSAxICkge1xuXG5cdFx0c3VwZXIoIGFycmF5LCBzdHJpZGUgKTtcblxuXHRcdHRoaXMuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IHRydWU7XG5cblx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCBkYXRhICkge1xuXG5cdFx0Y29uc3QgaWIgPSBzdXBlci5jbG9uZSggZGF0YSApO1xuXG5cdFx0aWIubWVzaFBlckF0dHJpYnV0ZSA9IHRoaXMubWVzaFBlckF0dHJpYnV0ZTtcblxuXHRcdHJldHVybiBpYjtcblxuXHR9XG5cblx0dG9KU09OKCBkYXRhICkge1xuXG5cdFx0Y29uc3QganNvbiA9IHN1cGVyLnRvSlNPTiggZGF0YSApO1xuXG5cdFx0anNvbi5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gdHJ1ZTtcblx0XHRqc29uLm1lc2hQZXJBdHRyaWJ1dGUgPSB0aGlzLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0XHRyZXR1cm4ganNvbjtcblxuXHR9XG5cbn1cblxuY2xhc3MgR0xCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBidWZmZXIsIHR5cGUsIGl0ZW1TaXplLCBlbGVtZW50U2l6ZSwgY291bnQgKSB7XG5cblx0XHR0aGlzLmlzR0xCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblx0XHR0aGlzLmVsZW1lbnRTaXplID0gZWxlbWVudFNpemU7XG5cdFx0dGhpcy5jb3VudCA9IGNvdW50O1xuXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblxuXHR9XG5cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG5cdHNldEJ1ZmZlciggYnVmZmVyICkge1xuXG5cdFx0dGhpcy5idWZmZXIgPSBidWZmZXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0VHlwZSggdHlwZSwgZWxlbWVudFNpemUgKSB7XG5cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuZWxlbWVudFNpemUgPSBlbGVtZW50U2l6ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRJdGVtU2l6ZSggaXRlbVNpemUgKSB7XG5cblx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Q291bnQoIGNvdW50ICkge1xuXG5cdFx0dGhpcy5jb3VudCA9IGNvdW50O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9tYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5cbmNsYXNzIFJheWNhc3RlciB7XG5cblx0Y29uc3RydWN0b3IoIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyID0gMCwgZmFyID0gSW5maW5pdHkgKSB7XG5cblx0XHR0aGlzLnJheSA9IG5ldyBSYXkoIG9yaWdpbiwgZGlyZWN0aW9uICk7XG5cdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuXHRcdHRoaXMubmVhciA9IG5lYXI7XG5cdFx0dGhpcy5mYXIgPSBmYXI7XG5cdFx0dGhpcy5jYW1lcmEgPSBudWxsO1xuXHRcdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuXG5cdFx0dGhpcy5wYXJhbXMgPSB7XG5cdFx0XHRNZXNoOiB7fSxcblx0XHRcdExpbmU6IHsgdGhyZXNob2xkOiAxIH0sXG5cdFx0XHRMT0Q6IHt9LFxuXHRcdFx0UG9pbnRzOiB7IHRocmVzaG9sZDogMSB9LFxuXHRcdFx0U3ByaXRlOiB7fVxuXHRcdH07XG5cblx0fVxuXG5cdHNldCggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cblx0XHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxuXG5cdFx0dGhpcy5yYXkuc2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXG5cdH1cblxuXHRzZXRGcm9tQ2FtZXJhKCBjb29yZHMsIGNhbWVyYSApIHtcblxuXHRcdGlmICggY2FtZXJhLmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAwLjUgKS51bnByb2plY3QoIGNhbWVyYSApLnN1YiggdGhpcy5yYXkub3JpZ2luICkubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblxuXHRcdH0gZWxzZSBpZiAoIGNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAoIGNhbWVyYS5uZWFyICsgY2FtZXJhLmZhciApIC8gKCBjYW1lcmEubmVhciAtIGNhbWVyYS5mYXIgKSApLnVucHJvamVjdCggY2FtZXJhICk7IC8vIHNldCBvcmlnaW4gaW4gcGxhbmUgb2YgY2FtZXJhXG5cdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCAwLCAwLCAtIDEgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXHRcdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZTogJyArIGNhbWVyYS50eXBlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldEZyb21YUkNvbnRyb2xsZXIoIGNvbnRyb2xsZXIgKSB7XG5cblx0XHRfbWF0cml4LmlkZW50aXR5KCkuZXh0cmFjdFJvdGF0aW9uKCBjb250cm9sbGVyLm1hdHJpeFdvcmxkICk7XG5cblx0XHR0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjb250cm9sbGVyLm1hdHJpeFdvcmxkICk7XG5cdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHJlY3Vyc2l2ZSA9IHRydWUsIGludGVyc2VjdHMgPSBbXSApIHtcblxuXHRcdGludGVyc2VjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuXHRcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xuXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0fVxuXG5cdGludGVyc2VjdE9iamVjdHMoIG9iamVjdHMsIHJlY3Vyc2l2ZSA9IHRydWUsIGludGVyc2VjdHMgPSBbXSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aW50ZXJzZWN0KCBvYmplY3RzWyBpIF0sIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XG5cblx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gYXNjU29ydCggYSwgYiApIHtcblxuXHRyZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG5cbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0KCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmVjdXJzaXZlICkge1xuXG5cdGxldCBwcm9wYWdhdGUgPSB0cnVlO1xuXG5cdGlmICggb2JqZWN0LmxheWVycy50ZXN0KCByYXljYXN0ZXIubGF5ZXJzICkgKSB7XG5cblx0XHRjb25zdCByZXN1bHQgPSBvYmplY3QucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0XHRpZiAoIHJlc3VsdCA9PT0gZmFsc2UgKSBwcm9wYWdhdGUgPSBmYWxzZTtcblxuXHR9XG5cblx0aWYgKCBwcm9wYWdhdGUgPT09IHRydWUgJiYgcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpbnRlcnNlY3QoIGNoaWxkcmVuWyBpIF0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG4vKipcbiAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXG4gKlxuICogcGhpICh0aGUgcG9sYXIgYW5nbGUpIGlzIG1lYXN1cmVkIGZyb20gdGhlIHBvc2l0aXZlIHktYXhpcy4gVGhlIHBvc2l0aXZlIHktYXhpcyBpcyB1cC5cbiAqIHRoZXRhICh0aGUgYXppbXV0aGFsIGFuZ2xlKSBpcyBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB6LWF4aXMuXG4gKi9cbmNsYXNzIFNwaGVyaWNhbCB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIHBoaSA9IDAsIHRoZXRhID0gMCApIHtcblxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHRcdHRoaXMucGhpID0gcGhpOyAvLyBwb2xhciBhbmdsZVxuXHRcdHRoaXMudGhldGEgPSB0aGV0YTsgLy8gYXppbXV0aGFsIGFuZ2xlXG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0KCByYWRpdXMsIHBoaSwgdGhldGEgKSB7XG5cblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHR0aGlzLnBoaSA9IHBoaTtcblx0XHR0aGlzLnRoZXRhID0gdGhldGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggb3RoZXIgKSB7XG5cblx0XHR0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcblx0XHR0aGlzLnBoaSA9IG90aGVyLnBoaTtcblx0XHR0aGlzLnRoZXRhID0gb3RoZXIudGhldGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gRVBTIGFuZCBQSS1FUFNcblx0bWFrZVNhZmUoKSB7XG5cblx0XHRjb25zdCBFUFMgPSAwLjAwMDAwMTtcblx0XHR0aGlzLnBoaSA9IE1hdGgubWF4KCBFUFMsIE1hdGgubWluKCBNYXRoLlBJIC0gRVBTLCB0aGlzLnBoaSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVZlY3RvcjMoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ2FydGVzaWFuQ29vcmRzKCB2LngsIHYueSwgdi56ICk7XG5cblx0fVxuXG5cdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggeCAqIHggKyB5ICogeSArIHogKiB6ICk7XG5cblx0XHRpZiAoIHRoaXMucmFkaXVzID09PSAwICkge1xuXG5cdFx0XHR0aGlzLnRoZXRhID0gMDtcblx0XHRcdHRoaXMucGhpID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMudGhldGEgPSBNYXRoLmF0YW4yKCB4LCB6ICk7XG5cdFx0XHR0aGlzLnBoaSA9IE1hdGguYWNvcyggY2xhbXAoIHkgLyB0aGlzLnJhZGl1cywgLSAxLCAxICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N5bGluZHJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXG4gKi9cblxuY2xhc3MgQ3lsaW5kcmljYWwge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCB0aGV0YSA9IDAsIHkgPSAwICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7IC8vIGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiB0byBhIHBvaW50IGluIHRoZSB4LXogcGxhbmVcblx0XHR0aGlzLnRoZXRhID0gdGhldGE7IC8vIGNvdW50ZXJjbG9ja3dpc2UgYW5nbGUgaW4gdGhlIHgteiBwbGFuZSBtZWFzdXJlZCBpbiByYWRpYW5zIGZyb20gdGhlIHBvc2l0aXZlIHotYXhpc1xuXHRcdHRoaXMueSA9IHk7IC8vIGhlaWdodCBhYm92ZSB0aGUgeC16IHBsYW5lXG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0KCByYWRpdXMsIHRoZXRhLCB5ICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggb3RoZXIgKSB7XG5cblx0XHR0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcblx0XHR0aGlzLnRoZXRhID0gb3RoZXIudGhldGE7XG5cdFx0dGhpcy55ID0gb3RoZXIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tVmVjdG9yMyggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21DYXJ0ZXNpYW5Db29yZHMoIHYueCwgdi55LCB2LnogKTtcblxuXHR9XG5cblx0c2V0RnJvbUNhcnRlc2lhbkNvb3JkcyggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCB4ICogeCArIHogKiB6ICk7XG5cdFx0dGhpcy50aGV0YSA9IE1hdGguYXRhbjIoIHgsIHogKTtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfdmVjdG9yJDQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5cbmNsYXNzIEJveDIge1xuXG5cdGNvbnN0cnVjdG9yKCBtaW4gPSBuZXcgVmVjdG9yMiggKyBJbmZpbml0eSwgKyBJbmZpbml0eSApLCBtYXggPSBuZXcgVmVjdG9yMiggLSBJbmZpbml0eSwgLSBJbmZpbml0eSApICkge1xuXG5cdFx0dGhpcy5pc0JveDIgPSB0cnVlO1xuXG5cdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0dGhpcy5tYXggPSBtYXg7XG5cblx0fVxuXG5cdHNldCggbWluLCBtYXggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21DZW50ZXJBbmRTaXplKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRjb25zdCBoYWxmU2l6ZSA9IF92ZWN0b3IkNC5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcHkoIGJveCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZUVtcHR5KCkge1xuXG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSArIEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLSBJbmZpbml0eTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpc0VtcHR5KCkge1xuXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuXHRcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApO1xuXG5cdH1cblxuXHRnZXRDZW50ZXIoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoIDAsIDAgKSA6IHRhcmdldC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0fVxuXG5cdGdldFNpemUoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoIDAsIDAgKSA6IHRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuXHR9XG5cblx0ZXhwYW5kQnlQb2ludCggcG9pbnQgKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XG5cdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4cGFuZEJ5VmVjdG9yKCB2ZWN0b3IgKSB7XG5cblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuXHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcblx0XHR0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbnRhaW5zUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSA/IGZhbHNlIDogdHJ1ZTtcblxuXHR9XG5cblx0Y29udGFpbnNCb3goIGJveCApIHtcblxuXHRcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJlxuXHRcdFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4Lnk7XG5cblx0fVxuXG5cdGdldFBhcmFtZXRlciggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG5cdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuXHRcdHJldHVybiB0YXJnZXQuc2V0KFxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApXG5cdFx0KTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c0JveCggYm94ICkge1xuXG5cdFx0Ly8gdXNpbmcgNCBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnNcblxuXHRcdHJldHVybiBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcblx0XHRcdGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSA/IGZhbHNlIDogdHJ1ZTtcblxuXHR9XG5cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGFtcFBvaW50KCBwb2ludCwgX3ZlY3RvciQ0ICkuZGlzdGFuY2VUbyggcG9pbnQgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0KCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVuaW9uKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIG9mZnNldCApIHtcblxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIGJveCApIHtcblxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3N0YXJ0UCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9zdGFydEVuZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgTGluZTMge1xuXG5cdGNvbnN0cnVjdG9yKCBzdGFydCA9IG5ldyBWZWN0b3IzKCksIGVuZCA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cblx0fVxuXG5cdHNldCggc3RhcnQsIGVuZCApIHtcblxuXHRcdHRoaXMuc3RhcnQuY29weSggc3RhcnQgKTtcblx0XHR0aGlzLmVuZC5jb3B5KCBlbmQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBsaW5lICkge1xuXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cdFx0dGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDZW50ZXIoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5zdGFydCwgdGhpcy5lbmQgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0fVxuXG5cdGRlbHRhKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKCB0aGlzLmVuZCApO1xuXG5cdH1cblxuXHRhdCggdCwgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHRhcmdldCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XG5cblx0fVxuXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApIHtcblxuXHRcdF9zdGFydFAuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMuc3RhcnQgKTtcblx0XHRfc3RhcnRFbmQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcblxuXHRcdGNvbnN0IHN0YXJ0RW5kMiA9IF9zdGFydEVuZC5kb3QoIF9zdGFydEVuZCApO1xuXHRcdGNvbnN0IHN0YXJ0RW5kX3N0YXJ0UCA9IF9zdGFydEVuZC5kb3QoIF9zdGFydFAgKTtcblxuXHRcdGxldCB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG5cdFx0aWYgKCBjbGFtcFRvTGluZSApIHtcblxuXHRcdFx0dCA9IGNsYW1wKCB0LCAwLCAxICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdDtcblxuXHR9XG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIGNsYW1wVG9MaW5lLCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKTtcblxuXHRcdHJldHVybiB0aGlzLmRlbHRhKCB0YXJnZXQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblx0XHR0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggbGluZSApIHtcblxuXHRcdHJldHVybiBsaW5lLnN0YXJ0LmVxdWFscyggdGhpcy5zdGFydCApICYmIGxpbmUuZW5kLmVxdWFscyggdGhpcy5lbmQgKTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF92ZWN0b3IkMyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgU3BvdExpZ2h0SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgY29sb3IgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0SGVscGVyJztcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXG5cdFx0XHQwLCAwLCAwLCBcdDAsIDAsIDEsXG5cdFx0XHQwLCAwLCAwLCBcdDEsIDAsIDEsXG5cdFx0XHQwLCAwLCAwLFx0LSAxLCAwLCAxLFxuXHRcdFx0MCwgMCwgMCwgXHQwLCAxLCAxLFxuXHRcdFx0MCwgMCwgMCwgXHQwLCAtIDEsIDFcblx0XHRdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBqID0gMSwgbCA9IDMyOyBpIDwgbDsgaSArKywgaiArKyApIHtcblxuXHRcdFx0Y29uc3QgcDEgPSAoIGkgLyBsICkgKiBNYXRoLlBJICogMjtcblx0XHRcdGNvbnN0IHAyID0gKCBqIC8gbCApICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdHBvc2l0aW9ucy5wdXNoKFxuXHRcdFx0XHRNYXRoLmNvcyggcDEgKSwgTWF0aC5zaW4oIHAxICksIDEsXG5cdFx0XHRcdE1hdGguY29zKCBwMiApLCBNYXRoLnNpbiggcDIgKSwgMVxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlLCB0b25lTWFwcGVkOiBmYWxzZSB9ICk7XG5cblx0XHR0aGlzLmNvbmUgPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXHRcdHRoaXMubGlnaHQudGFyZ2V0LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0Ly8gdXBkYXRlIHRoZSBsb2NhbCBtYXRyaXggYmFzZWQgb24gdGhlIHBhcmVudCBhbmQgbGlnaHQgdGFyZ2V0IHRyYW5zZm9ybXNcblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xuXG5cdFx0XHR0aGlzLnBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSApO1xuXG5cdFx0XHR0aGlzLm1hdHJpeFxuXHRcdFx0XHQuY29weSggdGhpcy5wYXJlbnQubWF0cml4V29ybGQgKVxuXHRcdFx0XHQuaW52ZXJ0KClcblx0XHRcdFx0Lm11bHRpcGx5KCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLm1hdHJpeC5jb3B5KCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblxuXHRcdGNvbnN0IGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDA7XG5cdFx0Y29uc3QgY29uZVdpZHRoID0gY29uZUxlbmd0aCAqIE1hdGgudGFuKCB0aGlzLmxpZ2h0LmFuZ2xlICk7XG5cblx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xuXG5cdFx0X3ZlY3RvciQzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblxuXHRcdHRoaXMuY29uZS5sb29rQXQoIF92ZWN0b3IkMyApO1xuXG5cdFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmNvbnN0IF92ZWN0b3IkMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ib25lTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX21hdHJpeFdvcmxkSW52ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5cbmNsYXNzIFNrZWxldG9uSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblxuXHRjb25zdHJ1Y3Rvciggb2JqZWN0ICkge1xuXG5cdFx0Y29uc3QgYm9uZXMgPSBnZXRCb25lTGlzdCggb2JqZWN0ICk7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBjb2xvcnMgPSBbXTtcblxuXHRcdGNvbnN0IGNvbG9yMSA9IG5ldyBDb2xvciggMCwgMCwgMSApO1xuXHRcdGNvbnN0IGNvbG9yMiA9IG5ldyBDb2xvciggMCwgMSwgMCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBib25lID0gYm9uZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUgKSB7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iICk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiB0cnVlLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdG9uZU1hcHBlZDogZmFsc2UsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMuaXNTa2VsZXRvbkhlbHBlciA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2tlbGV0b25IZWxwZXInO1xuXG5cdFx0dGhpcy5yb290ID0gb2JqZWN0O1xuXHRcdHRoaXMuYm9uZXMgPSBib25lcztcblxuXHRcdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRjb25zdCBib25lcyA9IHRoaXMuYm9uZXM7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdF9tYXRyaXhXb3JsZEludi5jb3B5KCB0aGlzLnJvb3QubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaiA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGJvbmUgPSBib25lc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcblxuXHRcdFx0XHRfYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBfbWF0cml4V29ybGRJbnYsIGJvbmUubWF0cml4V29ybGQgKTtcblx0XHRcdFx0X3ZlY3RvciQyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggX2JvbmVNYXRyaXggKTtcblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBqLCBfdmVjdG9yJDIueCwgX3ZlY3RvciQyLnksIF92ZWN0b3IkMi56ICk7XG5cblx0XHRcdFx0X2JvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggX21hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRfdmVjdG9yJDIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBfYm9uZU1hdHJpeCApO1xuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGogKyAxLCBfdmVjdG9yJDIueCwgX3ZlY3RvciQyLnksIF92ZWN0b3IkMi56ICk7XG5cblx0XHRcdFx0aiArPSAyO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxufVxuXG5cbmZ1bmN0aW9uIGdldEJvbmVMaXN0KCBvYmplY3QgKSB7XG5cblx0Y29uc3QgYm9uZUxpc3QgPSBbXTtcblxuXHRpZiAoIG9iamVjdC5pc0JvbmUgPT09IHRydWUgKSB7XG5cblx0XHRib25lTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuXHR9XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdGJvbmVMaXN0LnB1c2guYXBwbHkoIGJvbmVMaXN0LCBnZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xuXG5cdH1cblxuXHRyZXR1cm4gYm9uZUxpc3Q7XG5cbn1cblxuY2xhc3MgUG9pbnRMaWdodEhlbHBlciBleHRlbmRzIE1lc2gge1xuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgc3BoZXJlU2l6ZSwgY29sb3IgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvaW50TGlnaHRIZWxwZXInO1xuXG5cdFx0dGhpcy5tYXRyaXggPSB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXG5cdFx0Lypcblx0Ly8gVE9ETzogZGVsZXRlIHRoaXMgY29tbWVudD9cblx0Y29uc3QgZGlzdGFuY2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KCAxLCAyICk7XG5cdGNvbnN0IGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcblx0dGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcblxuXHRjb25zdCBkID0gbGlnaHQuZGlzdGFuY2U7XG5cblx0aWYgKCBkID09PSAwLjAgKSB7XG5cblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG5cdH0gZWxzZSB7XG5cblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cblx0fVxuXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0RGlzdGFuY2UgKTtcblx0Ki9cblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcblxuXHRcdH1cblxuXHRcdC8qXG5cdFx0Y29uc3QgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XG5cblx0XHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblxuXHRcdH1cblx0XHQqL1xuXG5cdH1cblxufVxuXG5jb25zdCBfdmVjdG9yJDEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfY29sb3IxID0gLypAX19QVVJFX18qLyBuZXcgQ29sb3IoKTtcbmNvbnN0IF9jb2xvcjIgPSAvKkBfX1BVUkVfXyovIG5ldyBDb2xvcigpO1xuXG5jbGFzcyBIZW1pc3BoZXJlTGlnaHRIZWxwZXIgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoIGxpZ2h0LCBzaXplLCBjb2xvciApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cblx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXG5cdFx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodEhlbHBlcic7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBPY3RhaGVkcm9uR2VvbWV0cnkoIHNpemUgKTtcblx0XHRnZW9tZXRyeS5yb3RhdGVZKCBNYXRoLlBJICogMC41ICk7XG5cblx0XHR0aGlzLm1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXHRcdGlmICggdGhpcy5jb2xvciA9PT0gdW5kZWZpbmVkICkgdGhpcy5tYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRjb25zdCBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbi5jb3VudCAqIDMgKTtcblxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdHRoaXMuYWRkKCBuZXcgTWVzaCggZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKSApO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuY2hpbGRyZW5bIDAgXS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jaGlsZHJlblsgMCBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0dXBkYXRlKCkge1xuXG5cdFx0Y29uc3QgbWVzaCA9IHRoaXMuY2hpbGRyZW5bIDAgXTtcblxuXHRcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgY29sb3JzID0gbWVzaC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdjb2xvcicgKTtcblxuXHRcdFx0X2NvbG9yMS5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XG5cdFx0XHRfY29sb3IyLmNvcHkoIHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY29sb3JzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjb2xvciA9ICggaSA8ICggbCAvIDIgKSApID8gX2NvbG9yMSA6IF9jb2xvcjI7XG5cblx0XHRcdFx0Y29sb3JzLnNldFhZWiggaSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0bWVzaC5sb29rQXQoIF92ZWN0b3IkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBHcmlkSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblxuXHRjb25zdHJ1Y3Rvciggc2l6ZSA9IDEwLCBkaXZpc2lvbnMgPSAxMCwgY29sb3IxID0gMHg0NDQ0NDQsIGNvbG9yMiA9IDB4ODg4ODg4ICkge1xuXG5cdFx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgKTtcblx0XHRjb2xvcjIgPSBuZXcgQ29sb3IoIGNvbG9yMiApO1xuXG5cdFx0Y29uc3QgY2VudGVyID0gZGl2aXNpb25zIC8gMjtcblx0XHRjb25zdCBzdGVwID0gc2l6ZSAvIGRpdmlzaW9ucztcblx0XHRjb25zdCBoYWxmU2l6ZSA9IHNpemUgLyAyO1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXSwgY29sb3JzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGogPSAwLCBrID0gLSBoYWxmU2l6ZTsgaSA8PSBkaXZpc2lvbnM7IGkgKyssIGsgKz0gc3RlcCApIHtcblxuXHRcdFx0dmVydGljZXMucHVzaCggLSBoYWxmU2l6ZSwgMCwgaywgaGFsZlNpemUsIDAsIGsgKTtcblx0XHRcdHZlcnRpY2VzLnB1c2goIGssIDAsIC0gaGFsZlNpemUsIGssIDAsIGhhbGZTaXplICk7XG5cblx0XHRcdGNvbnN0IGNvbG9yID0gaSA9PT0gY2VudGVyID8gY29sb3IxIDogY29sb3IyO1xuXG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuXHRcdFx0Y29sb3IudG9BcnJheSggY29sb3JzLCBqICk7IGogKz0gMztcblx0XHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogdHJ1ZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0dyaWRIZWxwZXInO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFBvbGFyR3JpZEhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEwLCBzZWN0b3JzID0gMTYsIHJpbmdzID0gOCwgZGl2aXNpb25zID0gNjQsIGNvbG9yMSA9IDB4NDQ0NDQ0LCBjb2xvcjIgPSAweDg4ODg4OCApIHtcblxuXHRcdGNvbG9yMSA9IG5ldyBDb2xvciggY29sb3IxICk7XG5cdFx0Y29sb3IyID0gbmV3IENvbG9yKCBjb2xvcjIgKTtcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3QgY29sb3JzID0gW107XG5cblx0XHQvLyBjcmVhdGUgdGhlIHNlY3RvcnNcblxuXHRcdGlmICggc2VjdG9ycyA+IDEgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNlY3RvcnM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdiA9ICggaSAvIHNlY3RvcnMgKSAqICggTWF0aC5QSSAqIDIgKTtcblxuXHRcdFx0XHRjb25zdCB4ID0gTWF0aC5zaW4oIHYgKSAqIHJhZGl1cztcblx0XHRcdFx0Y29uc3QgeiA9IE1hdGguY29zKCB2ICkgKiByYWRpdXM7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB4LCAwLCB6ICk7XG5cblx0XHRcdFx0Y29uc3QgY29sb3IgPSAoIGkgJiAxICkgPyBjb2xvcjEgOiBjb2xvcjI7XG5cblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIHRoZSByaW5nc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcmluZ3M7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNvbG9yID0gKCBpICYgMSApID8gY29sb3IxIDogY29sb3IyO1xuXG5cdFx0XHRjb25zdCByID0gcmFkaXVzIC0gKCByYWRpdXMgLyByaW5ncyAqIGkgKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgZGl2aXNpb25zOyBqICsrICkge1xuXG5cdFx0XHRcdC8vIGZpcnN0IHZlcnRleFxuXG5cdFx0XHRcdGxldCB2ID0gKCBqIC8gZGl2aXNpb25zICkgKiAoIE1hdGguUEkgKiAyICk7XG5cblx0XHRcdFx0bGV0IHggPSBNYXRoLnNpbiggdiApICogcjtcblx0XHRcdFx0bGV0IHogPSBNYXRoLmNvcyggdiApICogcjtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB4LCAwLCB6ICk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XG5cblx0XHRcdFx0Ly8gc2Vjb25kIHZlcnRleFxuXG5cdFx0XHRcdHYgPSAoICggaiArIDEgKSAvIGRpdmlzaW9ucyApICogKCBNYXRoLlBJICogMiApO1xuXG5cdFx0XHRcdHggPSBNYXRoLnNpbiggdiApICogcjtcblx0XHRcdFx0eiA9IE1hdGguY29zKCB2ICkgKiByO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogdHJ1ZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvbGFyR3JpZEhlbHBlcic7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBEaXJlY3Rpb25hbExpZ2h0SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgc2l6ZSwgY29sb3IgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXG5cdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblxuXHRcdHRoaXMudHlwZSA9ICdEaXJlY3Rpb25hbExpZ2h0SGVscGVyJztcblxuXHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IDE7XG5cblx0XHRsZXQgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbXG5cdFx0XHQtIHNpemUsIHNpemUsIDAsXG5cdFx0XHRzaXplLCBzaXplLCAwLFxuXHRcdFx0c2l6ZSwgLSBzaXplLCAwLFxuXHRcdFx0LSBzaXplLCAtIHNpemUsIDAsXG5cdFx0XHQtIHNpemUsIHNpemUsIDBcblx0XHRdLCAzICkgKTtcblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKTtcblxuXHRcdHRoaXMubGlnaHRQbGFuZSA9IG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5saWdodFBsYW5lICk7XG5cblx0XHRnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMCwgMSBdLCAzICkgKTtcblxuXHRcdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0dXBkYXRlKCkge1xuXG5cdFx0dGhpcy5saWdodC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblx0XHR0aGlzLmxpZ2h0LnRhcmdldC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF92MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRfdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXHRcdF92My5zdWJWZWN0b3JzKCBfdjIsIF92MSApO1xuXG5cdFx0dGhpcy5saWdodFBsYW5lLmxvb2tBdCggX3YyICk7XG5cblx0XHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xuXHRcdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnRhcmdldExpbmUubG9va0F0KCBfdjIgKTtcblx0XHR0aGlzLnRhcmdldExpbmUuc2NhbGUueiA9IF92My5sZW5ndGgoKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9jYW1lcmEgPSAvKkBfX1BVUkVfXyovIG5ldyBDYW1lcmEoKTtcblxuLyoqXG4gKlx0LSBzaG93cyBmcnVzdHVtLCBsaW5lIG9mIHNpZ2h0IGFuZCB1cCBvZiB0aGUgY2FtZXJhXG4gKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXG4gKiBcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcbiAqXHRcdGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9saWdodGdsLmpzL2Jsb2IvbWFzdGVyL3Rlc3RzL3NoYWRvd21hcC5odG1sXG4gKi9cblxuY2xhc3MgQ2FtZXJhSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblxuXHRjb25zdHJ1Y3RvciggY2FtZXJhICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogdHJ1ZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBjb2xvcnMgPSBbXTtcblxuXHRcdGNvbnN0IHBvaW50TWFwID0ge307XG5cblx0XHQvLyBuZWFyXG5cblx0XHRhZGRMaW5lKCAnbjEnLCAnbjInICk7XG5cdFx0YWRkTGluZSggJ24yJywgJ240JyApO1xuXHRcdGFkZExpbmUoICduNCcsICduMycgKTtcblx0XHRhZGRMaW5lKCAnbjMnLCAnbjEnICk7XG5cblx0XHQvLyBmYXJcblxuXHRcdGFkZExpbmUoICdmMScsICdmMicgKTtcblx0XHRhZGRMaW5lKCAnZjInLCAnZjQnICk7XG5cdFx0YWRkTGluZSggJ2Y0JywgJ2YzJyApO1xuXHRcdGFkZExpbmUoICdmMycsICdmMScgKTtcblxuXHRcdC8vIHNpZGVzXG5cblx0XHRhZGRMaW5lKCAnbjEnLCAnZjEnICk7XG5cdFx0YWRkTGluZSggJ24yJywgJ2YyJyApO1xuXHRcdGFkZExpbmUoICduMycsICdmMycgKTtcblx0XHRhZGRMaW5lKCAnbjQnLCAnZjQnICk7XG5cblx0XHQvLyBjb25lXG5cblx0XHRhZGRMaW5lKCAncCcsICduMScgKTtcblx0XHRhZGRMaW5lKCAncCcsICduMicgKTtcblx0XHRhZGRMaW5lKCAncCcsICduMycgKTtcblx0XHRhZGRMaW5lKCAncCcsICduNCcgKTtcblxuXHRcdC8vIHVwXG5cblx0XHRhZGRMaW5lKCAndTEnLCAndTInICk7XG5cdFx0YWRkTGluZSggJ3UyJywgJ3UzJyApO1xuXHRcdGFkZExpbmUoICd1MycsICd1MScgKTtcblxuXHRcdC8vIHRhcmdldFxuXG5cdFx0YWRkTGluZSggJ2MnLCAndCcgKTtcblx0XHRhZGRMaW5lKCAncCcsICdjJyApO1xuXG5cdFx0Ly8gY3Jvc3NcblxuXHRcdGFkZExpbmUoICdjbjEnLCAnY24yJyApO1xuXHRcdGFkZExpbmUoICdjbjMnLCAnY240JyApO1xuXG5cdFx0YWRkTGluZSggJ2NmMScsICdjZjInICk7XG5cdFx0YWRkTGluZSggJ2NmMycsICdjZjQnICk7XG5cblx0XHRmdW5jdGlvbiBhZGRMaW5lKCBhLCBiICkge1xuXG5cdFx0XHRhZGRQb2ludCggYSApO1xuXHRcdFx0YWRkUG9pbnQoIGIgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFBvaW50KCBpZCApIHtcblxuXHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdFx0Y29sb3JzLnB1c2goIDAsIDAsIDAgKTtcblxuXHRcdFx0aWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XG5cblx0XHRcdH1cblxuXHRcdFx0cG9pbnRNYXBbIGlkIF0ucHVzaCggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgLSAxICk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDYW1lcmFIZWxwZXInO1xuXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdFx0aWYgKCB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ICkgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0Ly8gY29sb3JzXG5cblx0XHRjb25zdCBjb2xvckZydXN0dW0gPSBuZXcgQ29sb3IoIDB4ZmZhYTAwICk7XG5cdFx0Y29uc3QgY29sb3JDb25lID0gbmV3IENvbG9yKCAweGZmMDAwMCApO1xuXHRcdGNvbnN0IGNvbG9yVXAgPSBuZXcgQ29sb3IoIDB4MDBhYWZmICk7XG5cdFx0Y29uc3QgY29sb3JUYXJnZXQgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cdFx0Y29uc3QgY29sb3JDcm9zcyA9IG5ldyBDb2xvciggMHgzMzMzMzMgKTtcblxuXHRcdHRoaXMuc2V0Q29sb3JzKCBjb2xvckZydXN0dW0sIGNvbG9yQ29uZSwgY29sb3JVcCwgY29sb3JUYXJnZXQsIGNvbG9yQ3Jvc3MgKTtcblxuXHR9XG5cblx0c2V0Q29sb3JzKCBmcnVzdHVtLCBjb25lLCB1cCwgdGFyZ2V0LCBjcm9zcyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGNvbnN0IGNvbG9yQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAnY29sb3InICk7XG5cblx0XHQvLyBuZWFyXG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDAsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4xLCBuMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMiwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDMsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjIsIG40XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNSwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBuNCwgbjNcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDYsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA3LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4zLCBuMVxuXG5cdFx0Ly8gZmFyXG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDgsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA5LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIGYxLCBmMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTAsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxMSwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBmMiwgZjRcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDEyLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTMsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gZjQsIGYzXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxNCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDE1LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIGYzLCBmMVxuXG5cdFx0Ly8gc2lkZXNcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTYsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxNywgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBuMSwgZjFcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDE4LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTksIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjIsIGYyXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyMCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDIxLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4zLCBmM1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjIsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyMywgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBuNCwgZjRcblxuXHRcdC8vIGNvbmVcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjQsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyNSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuMVxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjYsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyNywgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjgsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyOSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuM1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzAsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzMSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuNFxuXG5cdFx0Ly8gdXBcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzIsIHVwLnIsIHVwLmcsIHVwLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzMywgdXAuciwgdXAuZywgdXAuYiApOyAvLyB1MSwgdTJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM0LCB1cC5yLCB1cC5nLCB1cC5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzUsIHVwLnIsIHVwLmcsIHVwLmIgKTsgLy8gdTIsIHUzXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzNiwgdXAuciwgdXAuZywgdXAuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM3LCB1cC5yLCB1cC5nLCB1cC5iICk7IC8vIHUzLCB1MVxuXG5cdFx0Ly8gdGFyZ2V0XG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM4LCB0YXJnZXQuciwgdGFyZ2V0LmcsIHRhcmdldC5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzksIHRhcmdldC5yLCB0YXJnZXQuZywgdGFyZ2V0LmIgKTsgLy8gYywgdFxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDAsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0MSwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyAvLyBwLCBjXG5cblx0XHQvLyBjcm9zc1xuXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0MiwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQzLCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IC8vIGNuMSwgY24yXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0NCwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ1LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IC8vIGNuMywgY240XG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ2LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDcsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgLy8gY2YxLCBjZjJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ4LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDksIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgLy8gY2YzLCBjZjRcblxuXHRcdGNvbG9yQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0dXBkYXRlKCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcblxuXHRcdGNvbnN0IHcgPSAxLCBoID0gMTtcblxuXHRcdC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXggaW52ZXJzZVxuXHRcdC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XG5cblx0XHRfY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkoIHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XG5cblx0XHQvLyBjZW50ZXIgLyB0YXJnZXRcblxuXHRcdHNldFBvaW50KCAnYycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgMCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoICd0JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCAwLCAxICk7XG5cblx0XHQvLyBuZWFyXG5cblx0XHRzZXRQb2ludCggJ24xJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIC0gaCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoICduMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgLSBoLCAtIDEgKTtcblx0XHRzZXRQb2ludCggJ24zJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIGgsIC0gMSApO1xuXHRcdHNldFBvaW50KCAnbjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIGgsIC0gMSApO1xuXG5cdFx0Ly8gZmFyXG5cblx0XHRzZXRQb2ludCggJ2YxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIC0gaCwgMSApO1xuXHRcdHNldFBvaW50KCAnZjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIC0gaCwgMSApO1xuXHRcdHNldFBvaW50KCAnZjMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC0gdywgaCwgMSApO1xuXHRcdHNldFBvaW50KCAnZjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIGgsIDEgKTtcblxuXHRcdC8vIHVwXG5cblx0XHRzZXRQb2ludCggJ3UxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcblx0XHRzZXRQb2ludCggJ3UyJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xuXHRcdHNldFBvaW50KCAndTMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIGggKiAyLCAtIDEgKTtcblxuXHRcdC8vIGNyb3NzXG5cblx0XHRzZXRQb2ludCggJ2NmMScsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLSB3LCAwLCAxICk7XG5cdFx0c2V0UG9pbnQoICdjZjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIDAsIDEgKTtcblx0XHRzZXRQb2ludCggJ2NmMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgLSBoLCAxICk7XG5cdFx0c2V0UG9pbnQoICdjZjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIGgsIDEgKTtcblxuXHRcdHNldFBvaW50KCAnY24xJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIDAsIC0gMSApO1xuXHRcdHNldFBvaW50KCAnY24yJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCAwLCAtIDEgKTtcblx0XHRzZXRQb2ludCggJ2NuMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgLSBoLCAtIDEgKTtcblx0XHRzZXRQb2ludCggJ2NuNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCwgLSAxICk7XG5cblx0XHRnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cbn1cblxuXG5mdW5jdGlvbiBzZXRQb2ludCggcG9pbnQsIHBvaW50TWFwLCBnZW9tZXRyeSwgY2FtZXJhLCB4LCB5LCB6ICkge1xuXG5cdF92ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuXHRjb25zdCBwb2ludHMgPSBwb2ludE1hcFsgcG9pbnQgXTtcblxuXHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRwb3NpdGlvbi5zZXRYWVooIHBvaW50c1sgaSBdLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmNvbnN0IF9ib3ggPSAvKkBfX1BVUkVfXyovIG5ldyBCb3gzKCk7XG5cbmNsYXNzIEJveEhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cblx0Y29uc3RydWN0b3IoIG9iamVjdCwgY29sb3IgPSAweGZmZmYwMCApIHtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XG5cdFx0Y29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgdG9uZU1hcHBlZDogZmFsc2UgfSApICk7XG5cblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XHR0aGlzLnR5cGUgPSAnQm94SGVscGVyJztcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXHR9XG5cblx0dXBkYXRlKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3hIZWxwZXI6IC51cGRhdGUoKSBoYXMgbm8gbG9uZ2VyIGFyZ3VtZW50cy4nICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdF9ib3guc2V0RnJvbU9iamVjdCggdGhpcy5vYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdGlmICggX2JveC5pc0VtcHR5KCkgKSByZXR1cm47XG5cblx0XHRjb25zdCBtaW4gPSBfYm94Lm1pbjtcblx0XHRjb25zdCBtYXggPSBfYm94Lm1heDtcblxuXHRcdC8qXG5cdFx0XHQ1X19fXzRcblx0XHQxL19fXzAvfFxuXHRcdHwgNl9ffF83XG5cdFx0Mi9fX18zL1xuXG5cdFx0MDogbWF4LngsIG1heC55LCBtYXguelxuXHRcdDE6IG1pbi54LCBtYXgueSwgbWF4Lnpcblx0XHQyOiBtaW4ueCwgbWluLnksIG1heC56XG5cdFx0MzogbWF4LngsIG1pbi55LCBtYXguelxuXHRcdDQ6IG1heC54LCBtYXgueSwgbWluLnpcblx0XHQ1OiBtaW4ueCwgbWF4LnksIG1pbi56XG5cdFx0NjogbWluLngsIG1pbi55LCBtaW4uelxuXHRcdDc6IG1heC54LCBtaW4ueSwgbWluLnpcblx0XHQqL1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcblxuXHRcdGFycmF5WyAwIF0gPSBtYXgueDsgYXJyYXlbIDEgXSA9IG1heC55OyBhcnJheVsgMiBdID0gbWF4Lno7XG5cdFx0YXJyYXlbIDMgXSA9IG1pbi54OyBhcnJheVsgNCBdID0gbWF4Lnk7IGFycmF5WyA1IF0gPSBtYXguejtcblx0XHRhcnJheVsgNiBdID0gbWluLng7IGFycmF5WyA3IF0gPSBtaW4ueTsgYXJyYXlbIDggXSA9IG1heC56O1xuXHRcdGFycmF5WyA5IF0gPSBtYXgueDsgYXJyYXlbIDEwIF0gPSBtaW4ueTsgYXJyYXlbIDExIF0gPSBtYXguejtcblx0XHRhcnJheVsgMTIgXSA9IG1heC54OyBhcnJheVsgMTMgXSA9IG1heC55OyBhcnJheVsgMTQgXSA9IG1pbi56O1xuXHRcdGFycmF5WyAxNSBdID0gbWluLng7IGFycmF5WyAxNiBdID0gbWF4Lnk7IGFycmF5WyAxNyBdID0gbWluLno7XG5cdFx0YXJyYXlbIDE4IF0gPSBtaW4ueDsgYXJyYXlbIDE5IF0gPSBtaW4ueTsgYXJyYXlbIDIwIF0gPSBtaW4uejtcblx0XHRhcnJheVsgMjEgXSA9IG1heC54OyBhcnJheVsgMjIgXSA9IG1pbi55OyBhcnJheVsgMjMgXSA9IG1pbi56O1xuXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHR9XG5cblx0c2V0RnJvbU9iamVjdCggb2JqZWN0ICkge1xuXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLm9iamVjdCA9IHNvdXJjZS5vYmplY3Q7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxufVxuXG5jbGFzcyBCb3gzSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblxuXHRjb25zdHJ1Y3RvciggYm94LCBjb2xvciA9IDB4ZmZmZjAwICkge1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3IF0gKTtcblxuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFsgMSwgMSwgMSwgLSAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgLSAxLCAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAxLCAtIDEsIC0gMSBdO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcblxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKSApO1xuXG5cdFx0dGhpcy5ib3ggPSBib3g7XG5cblx0XHR0aGlzLnR5cGUgPSAnQm94M0hlbHBlcic7XG5cblx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRjb25zdCBib3ggPSB0aGlzLmJveDtcblxuXHRcdGlmICggYm94LmlzRW1wdHkoKSApIHJldHVybjtcblxuXHRcdGJveC5nZXRDZW50ZXIoIHRoaXMucG9zaXRpb24gKTtcblxuXHRcdGJveC5nZXRTaXplKCB0aGlzLnNjYWxlICk7XG5cblx0XHR0aGlzLnNjYWxlLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFBsYW5lSGVscGVyIGV4dGVuZHMgTGluZSB7XG5cblx0Y29uc3RydWN0b3IoIHBsYW5lLCBzaXplID0gMSwgaGV4ID0gMHhmZmZmMDAgKSB7XG5cblx0XHRjb25zdCBjb2xvciA9IGhleDtcblxuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFsgMSwgLSAxLCAwLCAtIDEsIDEsIDAsIC0gMSwgLSAxLCAwLCAxLCAxLCAwLCAtIDEsIDEsIDAsIC0gMSwgLSAxLCAwLCAxLCAtIDEsIDAsIDEsIDEsIDAgXTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgdG9uZU1hcHBlZDogZmFsc2UgfSApICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGxhbmVIZWxwZXInO1xuXG5cdFx0dGhpcy5wbGFuZSA9IHBsYW5lO1xuXG5cdFx0dGhpcy5zaXplID0gc2l6ZTtcblxuXHRcdGNvbnN0IHBvc2l0aW9uczIgPSBbIDEsIDEsIDAsIC0gMSwgMSwgMCwgLSAxLCAtIDEsIDAsIDEsIDEsIDAsIC0gMSwgLSAxLCAwLCAxLCAtIDEsIDAgXTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5Mi5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMyLCAzICkgKTtcblx0XHRnZW9tZXRyeTIuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHR0aGlzLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5MiwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgb3BhY2l0eTogMC4yLCB0cmFuc3BhcmVudDogdHJ1ZSwgZGVwdGhXcml0ZTogZmFsc2UsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKSApICk7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdHRoaXMucG9zaXRpb24uc2V0KCAwLCAwLCAwICk7XG5cblx0XHR0aGlzLnNjYWxlLnNldCggMC41ICogdGhpcy5zaXplLCAwLjUgKiB0aGlzLnNpemUsIDEgKTtcblxuXHRcdHRoaXMubG9va0F0KCB0aGlzLnBsYW5lLm5vcm1hbCApO1xuXG5cdFx0dGhpcy50cmFuc2xhdGVaKCAtIHRoaXMucGxhbmUuY29uc3RhbnQgKTtcblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jaGlsZHJlblsgMCBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmNoaWxkcmVuWyAwIF0ubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxufVxuXG5jb25zdCBfYXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmxldCBfbGluZUdlb21ldHJ5LCBfY29uZUdlb21ldHJ5O1xuXG5jbGFzcyBBcnJvd0hlbHBlciBleHRlbmRzIE9iamVjdDNEIHtcblxuXHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0Y29uc3RydWN0b3IoIGRpciA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICksIG9yaWdpbiA9IG5ldyBWZWN0b3IzKCAwLCAwLCAwICksIGxlbmd0aCA9IDEsIGNvbG9yID0gMHhmZmZmMDAsIGhlYWRMZW5ndGggPSBsZW5ndGggKiAwLjIsIGhlYWRXaWR0aCA9IGhlYWRMZW5ndGggKiAwLjIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0Fycm93SGVscGVyJztcblxuXHRcdGlmICggX2xpbmVHZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRfbGluZUdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRfbGluZUdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMSwgMCBdLCAzICkgKTtcblxuXHRcdFx0X2NvbmVHZW9tZXRyeSA9IG5ldyBDeWxpbmRlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcblx0XHRcdF9jb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBvcmlnaW4gKTtcblxuXHRcdHRoaXMubGluZSA9IG5ldyBMaW5lKCBfbGluZUdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB0b25lTWFwcGVkOiBmYWxzZSB9ICkgKTtcblx0XHR0aGlzLmxpbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuYWRkKCB0aGlzLmxpbmUgKTtcblxuXHRcdHRoaXMuY29uZSA9IG5ldyBNZXNoKCBfY29uZUdlb21ldHJ5LCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB0b25lTWFwcGVkOiBmYWxzZSB9ICkgKTtcblx0XHR0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcblxuXHRcdHRoaXMuc2V0RGlyZWN0aW9uKCBkaXIgKTtcblx0XHR0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcblxuXHR9XG5cblx0c2V0RGlyZWN0aW9uKCBkaXIgKSB7XG5cblx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xuXG5cdFx0fSBlbHNlIGlmICggZGlyLnkgPCAtIDAuOTk5OTkgKSB7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9heGlzLnNldCggZGlyLnosIDAsIC0gZGlyLnggKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Y29uc3QgcmFkaWFucyA9IE1hdGguYWNvcyggZGlyLnkgKTtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIF9heGlzLCByYWRpYW5zICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoID0gbGVuZ3RoICogMC4yLCBoZWFkV2lkdGggPSBoZWFkTGVuZ3RoICogMC4yICkge1xuXG5cdFx0dGhpcy5saW5lLnNjYWxlLnNldCggMSwgTWF0aC5tYXgoIDAuMDAwMSwgbGVuZ3RoIC0gaGVhZExlbmd0aCApLCAxICk7IC8vIHNlZSAjMTc0NThcblx0XHR0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBoZWFkV2lkdGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xuXHRcdHRoaXMuY29uZS5wb3NpdGlvbi55ID0gbGVuZ3RoO1xuXHRcdHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcblxuXHR9XG5cblx0c2V0Q29sb3IoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcblx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIGZhbHNlICk7XG5cblx0XHR0aGlzLmxpbmUuY29weSggc291cmNlLmxpbmUgKTtcblx0XHR0aGlzLmNvbmUuY29weSggc291cmNlLmNvbmUgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5saW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmxpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgQXhlc0hlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cblx0Y29uc3RydWN0b3IoIHNpemUgPSAxICkge1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXG5cdFx0XHQwLCAwLCAwLFx0c2l6ZSwgMCwgMCxcblx0XHRcdDAsIDAsIDAsXHQwLCBzaXplLCAwLFxuXHRcdFx0MCwgMCwgMCxcdDAsIDAsIHNpemVcblx0XHRdO1xuXG5cdFx0Y29uc3QgY29sb3JzID0gW1xuXHRcdFx0MSwgMCwgMCxcdDEsIDAuNiwgMCxcblx0XHRcdDAsIDEsIDAsXHQwLjYsIDEsIDAsXG5cdFx0XHQwLCAwLCAxLFx0MCwgMC42LCAxXG5cdFx0XTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IHRydWUsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdBeGVzSGVscGVyJztcblxuXHR9XG5cblx0c2V0Q29sb3JzKCB4QXhpc0NvbG9yLCB5QXhpc0NvbG9yLCB6QXhpc0NvbG9yICkge1xuXG5cdFx0Y29uc3QgY29sb3IgPSBuZXcgQ29sb3IoKTtcblx0XHRjb25zdCBhcnJheSA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheTtcblxuXHRcdGNvbG9yLnNldCggeEF4aXNDb2xvciApO1xuXHRcdGNvbG9yLnRvQXJyYXkoIGFycmF5LCAwICk7XG5cdFx0Y29sb3IudG9BcnJheSggYXJyYXksIDMgKTtcblxuXHRcdGNvbG9yLnNldCggeUF4aXNDb2xvciApO1xuXHRcdGNvbG9yLnRvQXJyYXkoIGFycmF5LCA2ICk7XG5cdFx0Y29sb3IudG9BcnJheSggYXJyYXksIDkgKTtcblxuXHRcdGNvbG9yLnNldCggekF4aXNDb2xvciApO1xuXHRcdGNvbG9yLnRvQXJyYXkoIGFycmF5LCAxMiApO1xuXHRcdGNvbG9yLnRvQXJyYXkoIGFycmF5LCAxNSApO1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFNoYXBlUGF0aCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhcGVQYXRoJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoKTtcblxuXHRcdHRoaXMuc3ViUGF0aHMgPSBbXTtcblx0XHR0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcblxuXHR9XG5cblx0bW92ZVRvKCB4LCB5ICkge1xuXG5cdFx0dGhpcy5jdXJyZW50UGF0aCA9IG5ldyBQYXRoKCk7XG5cdFx0dGhpcy5zdWJQYXRocy5wdXNoKCB0aGlzLmN1cnJlbnRQYXRoICk7XG5cdFx0dGhpcy5jdXJyZW50UGF0aC5tb3ZlVG8oIHgsIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsaW5lVG8oIHgsIHkgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRQYXRoLmxpbmVUbyggeCwgeSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHF1YWRyYXRpY0N1cnZlVG8oIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcblxuXHRcdHRoaXMuY3VycmVudFBhdGgucXVhZHJhdGljQ3VydmVUbyggYUNQeCwgYUNQeSwgYVgsIGFZICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YmV6aWVyQ3VydmVUbyggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcblxuXHRcdHRoaXMuY3VycmVudFBhdGguYmV6aWVyQ3VydmVUbyggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNwbGluZVRocnUoIHB0cyApIHtcblxuXHRcdHRoaXMuY3VycmVudFBhdGguc3BsaW5lVGhydSggcHRzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9TaGFwZXMoIGlzQ0NXICkge1xuXG5cdFx0ZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xuXG5cdFx0XHRjb25zdCBzaGFwZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5TdWJwYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHRtcFBhdGggPSBpblN1YnBhdGhzWyBpIF07XG5cblx0XHRcdFx0Y29uc3QgdG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcblx0XHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cblx0XHRcdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNoYXBlcztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XG5cblx0XHRcdGNvbnN0IHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xuXG5cdFx0XHQvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxuXHRcdFx0Ly8gdG9nZ2xpbmcgb2YgaW5zaWRlL291dHNpZGUgYXQgZXZlcnkgc2luZ2xlISBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgYW4gZWRnZVxuXHRcdFx0Ly8gIHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxuXHRcdFx0Ly8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcblx0XHRcdGxldCBpbnNpZGUgPSBmYWxzZTtcblx0XHRcdGZvciAoIGxldCBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHEgKysgKSB7XG5cblx0XHRcdFx0bGV0IGVkZ2VMb3dQdCA9IGluUG9seWdvblsgcCBdO1xuXHRcdFx0XHRsZXQgZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcSBdO1xuXG5cdFx0XHRcdGxldCBlZGdlRHggPSBlZGdlSGlnaFB0LnggLSBlZGdlTG93UHQueDtcblx0XHRcdFx0bGV0IGVkZ2VEeSA9IGVkZ2VIaWdoUHQueSAtIGVkZ2VMb3dQdC55O1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIGVkZ2VEeSApID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHQvLyBub3QgcGFyYWxsZWxcblx0XHRcdFx0XHRpZiAoIGVkZ2VEeSA8IDAgKSB7XG5cblx0XHRcdFx0XHRcdGVkZ2VMb3dQdCA9IGluUG9seWdvblsgcSBdOyBlZGdlRHggPSAtIGVkZ2VEeDtcblx0XHRcdFx0XHRcdGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHAgXTsgZWRnZUR5ID0gLSBlZGdlRHk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgXHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBpblB0LnkgPT09IGVkZ2VMb3dQdC55ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKVx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XG5cdFx0XHRcdFx0XHQvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHBlcnBFZGdlID0gZWRnZUR5ICogKCBpblB0LnggLSBlZGdlTG93UHQueCApIC0gZWRnZUR4ICogKCBpblB0LnkgLSBlZGdlTG93UHQueSApO1xuXHRcdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA9PT0gMCApXHRcdFx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XG5cdFx0XHRcdFx0XHRpZiAoIHBlcnBFZGdlIDwgMCApIFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRpbnNpZGUgPSAhIGluc2lkZTtcdFx0Ly8gdHJ1ZSBpbnRlcnNlY3Rpb24gbGVmdCBvZiBpblB0XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuXHRcdFx0XHRcdGlmICggaW5QdC55ICE9PSBlZGdlTG93UHQueSApIFx0XHRjb250aW51ZTtcdFx0XHQvLyBwYXJhbGxlbFxuXHRcdFx0XHRcdC8vIGVkZ2UgbGllcyBvbiB0aGUgc2FtZSBob3Jpem9udGFsIGxpbmUgYXMgaW5QdFxuXHRcdFx0XHRcdGlmICggKCAoIGVkZ2VIaWdoUHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlTG93UHQueCApICkgfHxcblx0XHRcdFx0XHRcdCAoICggZWRnZUxvd1B0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUhpZ2hQdC54ICkgKSApXHRcdHJldHVyblx0dHJ1ZTtcdC8vIGluUHQ6IFBvaW50IG9uIGNvbnRvdXIgIVxuXHRcdFx0XHRcdC8vIGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm5cdGluc2lkZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGlzQ2xvY2tXaXNlID0gU2hhcGVVdGlscy5pc0Nsb2NrV2lzZTtcblxuXHRcdGNvbnN0IHN1YlBhdGhzID0gdGhpcy5zdWJQYXRocztcblx0XHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcblxuXHRcdGxldCBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGU7XG5cdFx0Y29uc3Qgc2hhcGVzID0gW107XG5cblx0XHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XG5cdFx0XHR0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xuXHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblx0XHRcdHJldHVybiBzaGFwZXM7XG5cblx0XHR9XG5cblx0XHRsZXQgaG9sZXNGaXJzdCA9ICEgaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcblx0XHRob2xlc0ZpcnN0ID0gaXNDQ1cgPyAhIGhvbGVzRmlyc3QgOiBob2xlc0ZpcnN0O1xuXG5cdFx0Ly8gY29uc29sZS5sb2coXCJIb2xlcyBmaXJzdFwiLCBob2xlc0ZpcnN0KTtcblxuXHRcdGNvbnN0IGJldHRlclNoYXBlSG9sZXMgPSBbXTtcblx0XHRjb25zdCBuZXdTaGFwZXMgPSBbXTtcblx0XHRsZXQgbmV3U2hhcGVIb2xlcyA9IFtdO1xuXHRcdGxldCBtYWluSWR4ID0gMDtcblx0XHRsZXQgdG1wUG9pbnRzO1xuXG5cdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XG5cdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcblx0XHRcdHRtcFBvaW50cyA9IHRtcFBhdGguZ2V0UG9pbnRzKCk7XG5cdFx0XHRzb2xpZCA9IGlzQ2xvY2tXaXNlKCB0bXBQb2ludHMgKTtcblx0XHRcdHNvbGlkID0gaXNDQ1cgPyAhIHNvbGlkIDogc29saWQ7XG5cblx0XHRcdGlmICggc29saWQgKSB7XG5cblx0XHRcdFx0aWYgKCAoICEgaG9sZXNGaXJzdCApICYmICggbmV3U2hhcGVzWyBtYWluSWR4IF0gKSApXHRtYWluSWR4ICsrO1xuXG5cdFx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdID0geyBzOiBuZXcgU2hhcGUoKSwgcDogdG1wUG9pbnRzIH07XG5cdFx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cblx0XHRcdFx0aWYgKCBob2xlc0ZpcnN0IClcdG1haW5JZHggKys7XG5cdFx0XHRcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xuXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2N3JywgaSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdLnB1c2goIHsgaDogdG1wUGF0aCwgcDogdG1wUG9pbnRzWyAwIF0gfSApO1xuXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2NjdycsIGkpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBvbmx5IEhvbGVzPyAtPiBwcm9iYWJseSBhbGwgU2hhcGVzIHdpdGggd3Jvbmcgb3JpZW50YXRpb25cblx0XHRpZiAoICEgbmV3U2hhcGVzWyAwIF0gKVx0cmV0dXJuXHR0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XG5cblxuXHRcdGlmICggbmV3U2hhcGVzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdGxldCBhbWJpZ3VvdXMgPSBmYWxzZTtcblx0XHRcdGxldCB0b0NoYW5nZSA9IDA7XG5cblx0XHRcdGZvciAoIGxldCBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXG5cdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNobyA9IG5ld1NoYXBlSG9sZXNbIHNJZHggXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4ICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaG8gPSBzaG9bIGhJZHggXTtcblx0XHRcdFx0XHRsZXQgaG9sZV91bmFzc2lnbmVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBzMklkeCA9IDA7IHMySWR4IDwgbmV3U2hhcGVzLmxlbmd0aDsgczJJZHggKysgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggaXNQb2ludEluc2lkZVBvbHlnb24oIGhvLnAsIG5ld1NoYXBlc1sgczJJZHggXS5wICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBzSWR4ICE9PSBzMklkeCApXHR0b0NoYW5nZSArKztcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0YW1iaWd1b3VzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaG9sZV91bmFzc2lnbmVkICkge1xuXG5cdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0ucHVzaCggaG8gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0b0NoYW5nZSA+IDAgJiYgYW1iaWd1b3VzID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0bGV0IHRtcEhvbGVzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5ld1NoYXBlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dG1wU2hhcGUgPSBuZXdTaGFwZXNbIGkgXS5zO1xuXHRcdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG5cdFx0XHR0bXBIb2xlcyA9IG5ld1NoYXBlSG9sZXNbIGkgXTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdHRtcFNoYXBlLmhvbGVzLnB1c2goIHRtcEhvbGVzWyBqIF0uaCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcblxuXHRcdHJldHVybiBzaGFwZXM7XG5cblx0fVxuXG59XG5cbmNsYXNzIFdlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzIGV4dGVuZHMgV2ViR0xSZW5kZXJUYXJnZXQgeyAvLyBAZGVwcmVjYXRlZCwgcjE2MlxuXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGNvdW50ID0gMSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHIxNzIuIFVzZSBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCBhbmQgc2V0IHRoZSBcImNvdW50XCIgcGFyYW1ldGVyIHRvIGVuYWJsZSBNUlQuJyApO1xuXG5cdFx0c3VwZXIoIHdpZHRoLCBoZWlnaHQsIHsgLi4ub3B0aW9ucywgY291bnQgfSApO1xuXG5cdFx0dGhpcy5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0IHRleHR1cmUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlcztcblxuXHR9XG5cbn1cblxuaWYgKCB0eXBlb2YgX19USFJFRV9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyApIHtcblxuXHRfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KCAncmVnaXN0ZXInLCB7IGRldGFpbDoge1xuXHRcdHJldmlzaW9uOiBSRVZJU0lPTixcblx0fSB9ICkgKTtcblxufVxuXG5pZiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICkge1xuXG5cdGlmICggd2luZG93Ll9fVEhSRUVfXyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE11bHRpcGxlIGluc3RhbmNlcyBvZiBUaHJlZS5qcyBiZWluZyBpbXBvcnRlZC4nICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHdpbmRvdy5fX1RIUkVFX18gPSBSRVZJU0lPTjtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nLCBBZGRFcXVhdGlvbiwgQWRkT3BlcmF0aW9uLCBBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSwgQWRkaXRpdmVCbGVuZGluZywgQWdYVG9uZU1hcHBpbmcsIEFscGhhRm9ybWF0LCBBbHdheXNDb21wYXJlLCBBbHdheXNEZXB0aCwgQWx3YXlzU3RlbmNpbEZ1bmMsIEFtYmllbnRMaWdodCwgQW5pbWF0aW9uQWN0aW9uLCBBbmltYXRpb25DbGlwLCBBbmltYXRpb25Mb2FkZXIsIEFuaW1hdGlvbk1peGVyLCBBbmltYXRpb25PYmplY3RHcm91cCwgQW5pbWF0aW9uVXRpbHMsIEFyY0N1cnZlLCBBcnJheUNhbWVyYSwgQXJyb3dIZWxwZXIsIEF0dGFjaGVkQmluZE1vZGUsIEF1ZGlvLCBBdWRpb0FuYWx5c2VyLCBBdWRpb0NvbnRleHQsIEF1ZGlvTGlzdGVuZXIsIEF1ZGlvTG9hZGVyLCBBeGVzSGVscGVyLCBCYWNrU2lkZSwgQmFzaWNEZXB0aFBhY2tpbmcsIEJhc2ljU2hhZG93TWFwLCBCYXRjaGVkTWVzaCwgQm9uZSwgQm9vbGVhbktleWZyYW1lVHJhY2ssIEJveDIsIEJveDMsIEJveDNIZWxwZXIsIEJveEdlb21ldHJ5LCBCb3hIZWxwZXIsIEJ1ZmZlckF0dHJpYnV0ZSwgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckdlb21ldHJ5TG9hZGVyLCBCeXRlVHlwZSwgQ2FjaGUsIENhbWVyYSwgQ2FtZXJhSGVscGVyLCBDYW52YXNUZXh0dXJlLCBDYXBzdWxlR2VvbWV0cnksIENhdG11bGxSb21DdXJ2ZTMsIENpbmVvblRvbmVNYXBwaW5nLCBDaXJjbGVHZW9tZXRyeSwgQ2xhbXBUb0VkZ2VXcmFwcGluZywgQ2xvY2ssIENvbG9yLCBDb2xvcktleWZyYW1lVHJhY2ssIENvbG9yTWFuYWdlbWVudCwgQ29tcHJlc3NlZEFycmF5VGV4dHVyZSwgQ29tcHJlc3NlZEN1YmVUZXh0dXJlLCBDb21wcmVzc2VkVGV4dHVyZSwgQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsIENvbmVHZW9tZXRyeSwgQ29uc3RhbnRBbHBoYUZhY3RvciwgQ29uc3RhbnRDb2xvckZhY3RvciwgQ3ViZUNhbWVyYSwgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIEN1YmVUZXh0dXJlLCBDdWJlVGV4dHVyZUxvYWRlciwgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcsIEN1YmljQmV6aWVyQ3VydmUsIEN1YmljQmV6aWVyQ3VydmUzLCBDdWJpY0ludGVycG9sYW50LCBDdWxsRmFjZUJhY2ssIEN1bGxGYWNlRnJvbnQsIEN1bGxGYWNlRnJvbnRCYWNrLCBDdWxsRmFjZU5vbmUsIEN1cnZlLCBDdXJ2ZVBhdGgsIEN1c3RvbUJsZW5kaW5nLCBDdXN0b21Ub25lTWFwcGluZywgQ3lsaW5kZXJHZW9tZXRyeSwgQ3lsaW5kcmljYWwsIERhdGEzRFRleHR1cmUsIERhdGFBcnJheVRleHR1cmUsIERhdGFUZXh0dXJlLCBEYXRhVGV4dHVyZUxvYWRlciwgRGF0YVV0aWxzLCBEZWNyZW1lbnRTdGVuY2lsT3AsIERlY3JlbWVudFdyYXBTdGVuY2lsT3AsIERlZmF1bHRMb2FkaW5nTWFuYWdlciwgRGVwdGhGb3JtYXQsIERlcHRoU3RlbmNpbEZvcm1hdCwgRGVwdGhUZXh0dXJlLCBEZXRhY2hlZEJpbmRNb2RlLCBEaXJlY3Rpb25hbExpZ2h0LCBEaXJlY3Rpb25hbExpZ2h0SGVscGVyLCBEaXNjcmV0ZUludGVycG9sYW50LCBEaXNwbGF5UDNDb2xvclNwYWNlLCBEb2RlY2FoZWRyb25HZW9tZXRyeSwgRG91YmxlU2lkZSwgRHN0QWxwaGFGYWN0b3IsIERzdENvbG9yRmFjdG9yLCBEeW5hbWljQ29weVVzYWdlLCBEeW5hbWljRHJhd1VzYWdlLCBEeW5hbWljUmVhZFVzYWdlLCBFZGdlc0dlb21ldHJ5LCBFbGxpcHNlQ3VydmUsIEVxdWFsQ29tcGFyZSwgRXF1YWxEZXB0aCwgRXF1YWxTdGVuY2lsRnVuYywgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nLCBFdWxlciwgRXZlbnREaXNwYXRjaGVyLCBFeHRydWRlR2VvbWV0cnksIEZpbGVMb2FkZXIsIEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUsIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsIEZsb2F0VHlwZSwgRm9nLCBGb2dFeHAyLCBGcmFtZWJ1ZmZlclRleHR1cmUsIEZyb250U2lkZSwgRnJ1c3R1bSwgR0xCdWZmZXJBdHRyaWJ1dGUsIEdMU0wxLCBHTFNMMywgR3JlYXRlckNvbXBhcmUsIEdyZWF0ZXJEZXB0aCwgR3JlYXRlckVxdWFsQ29tcGFyZSwgR3JlYXRlckVxdWFsRGVwdGgsIEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jLCBHcmVhdGVyU3RlbmNpbEZ1bmMsIEdyaWRIZWxwZXIsIEdyb3VwLCBIYWxmRmxvYXRUeXBlLCBIZW1pc3BoZXJlTGlnaHQsIEhlbWlzcGhlcmVMaWdodEhlbHBlciwgSWNvc2FoZWRyb25HZW9tZXRyeSwgSW1hZ2VCaXRtYXBMb2FkZXIsIEltYWdlTG9hZGVyLCBJbWFnZVV0aWxzLCBJbmNyZW1lbnRTdGVuY2lsT3AsIEluY3JlbWVudFdyYXBTdGVuY2lsT3AsIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSwgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLCBJbnN0YW5jZWRNZXNoLCBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSwgSW50MzJCdWZmZXJBdHRyaWJ1dGUsIEludDhCdWZmZXJBdHRyaWJ1dGUsIEludFR5cGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJwb2xhbnQsIEludGVycG9sYXRlRGlzY3JldGUsIEludGVycG9sYXRlTGluZWFyLCBJbnRlcnBvbGF0ZVNtb290aCwgSW52ZXJ0U3RlbmNpbE9wLCBLZWVwU3RlbmNpbE9wLCBLZXlmcmFtZVRyYWNrLCBMT0QsIExhdGhlR2VvbWV0cnksIExheWVycywgTGVzc0NvbXBhcmUsIExlc3NEZXB0aCwgTGVzc0VxdWFsQ29tcGFyZSwgTGVzc0VxdWFsRGVwdGgsIExlc3NFcXVhbFN0ZW5jaWxGdW5jLCBMZXNzU3RlbmNpbEZ1bmMsIExpZ2h0LCBMaWdodFByb2JlLCBMaW5lLCBMaW5lMywgTGluZUJhc2ljTWF0ZXJpYWwsIExpbmVDdXJ2ZSwgTGluZUN1cnZlMywgTGluZURhc2hlZE1hdGVyaWFsLCBMaW5lTG9vcCwgTGluZVNlZ21lbnRzLCBMaW5lYXJEaXNwbGF5UDNDb2xvclNwYWNlLCBMaW5lYXJGaWx0ZXIsIExpbmVhckludGVycG9sYW50LCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgTGluZWFyU1JHQkNvbG9yU3BhY2UsIExpbmVhclRvbmVNYXBwaW5nLCBMaW5lYXJUcmFuc2ZlciwgTG9hZGVyLCBMb2FkZXJVdGlscywgTG9hZGluZ01hbmFnZXIsIExvb3BPbmNlLCBMb29wUGluZ1BvbmcsIExvb3BSZXBlYXQsIEx1bWluYW5jZUFscGhhRm9ybWF0LCBMdW1pbmFuY2VGb3JtYXQsIE1PVVNFLCBNYXRlcmlhbCwgTWF0ZXJpYWxMb2FkZXIsIE1hdGhVdGlscywgTWF0cml4MywgTWF0cml4NCwgTWF4RXF1YXRpb24sIE1lc2gsIE1lc2hCYXNpY01hdGVyaWFsLCBNZXNoRGVwdGhNYXRlcmlhbCwgTWVzaERpc3RhbmNlTWF0ZXJpYWwsIE1lc2hMYW1iZXJ0TWF0ZXJpYWwsIE1lc2hNYXRjYXBNYXRlcmlhbCwgTWVzaE5vcm1hbE1hdGVyaWFsLCBNZXNoUGhvbmdNYXRlcmlhbCwgTWVzaFBoeXNpY2FsTWF0ZXJpYWwsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBNZXNoVG9vbk1hdGVyaWFsLCBNaW5FcXVhdGlvbiwgTWlycm9yZWRSZXBlYXRXcmFwcGluZywgTWl4T3BlcmF0aW9uLCBNdWx0aXBseUJsZW5kaW5nLCBNdWx0aXBseU9wZXJhdGlvbiwgTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciwgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBOZXV0cmFsVG9uZU1hcHBpbmcsIE5ldmVyQ29tcGFyZSwgTmV2ZXJEZXB0aCwgTmV2ZXJTdGVuY2lsRnVuYywgTm9CbGVuZGluZywgTm9Db2xvclNwYWNlLCBOb1RvbmVNYXBwaW5nLCBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUsIE5vcm1hbEJsZW5kaW5nLCBOb3RFcXVhbENvbXBhcmUsIE5vdEVxdWFsRGVwdGgsIE5vdEVxdWFsU3RlbmNpbEZ1bmMsIE51bWJlcktleWZyYW1lVHJhY2ssIE9iamVjdDNELCBPYmplY3RMb2FkZXIsIE9iamVjdFNwYWNlTm9ybWFsTWFwLCBPY3RhaGVkcm9uR2VvbWV0cnksIE9uZUZhY3RvciwgT25lTWludXNDb25zdGFudEFscGhhRmFjdG9yLCBPbmVNaW51c0NvbnN0YW50Q29sb3JGYWN0b3IsIE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IsIE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IsIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IsIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgUDNQcmltYXJpZXMsIFBDRlNoYWRvd01hcCwgUENGU29mdFNoYWRvd01hcCwgUE1SRU1HZW5lcmF0b3IsIFBhdGgsIFBlcnNwZWN0aXZlQ2FtZXJhLCBQbGFuZSwgUGxhbmVHZW9tZXRyeSwgUGxhbmVIZWxwZXIsIFBvaW50TGlnaHQsIFBvaW50TGlnaHRIZWxwZXIsIFBvaW50cywgUG9pbnRzTWF0ZXJpYWwsIFBvbGFyR3JpZEhlbHBlciwgUG9seWhlZHJvbkdlb21ldHJ5LCBQb3NpdGlvbmFsQXVkaW8sIFByb3BlcnR5QmluZGluZywgUHJvcGVydHlNaXhlciwgUXVhZHJhdGljQmV6aWVyQ3VydmUsIFF1YWRyYXRpY0JlemllckN1cnZlMywgUXVhdGVybmlvbiwgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCwgUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCwgUkVEX1JHVEMxX0Zvcm1hdCwgUkVWSVNJT04sIFJHQkFEZXB0aFBhY2tpbmcsIFJHQkFGb3JtYXQsIFJHQkFJbnRlZ2VyRm9ybWF0LCBSR0JBX0FTVENfMTB4MTBfRm9ybWF0LCBSR0JBX0FTVENfMTB4NV9Gb3JtYXQsIFJHQkFfQVNUQ18xMHg2X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDhfRm9ybWF0LCBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0LCBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0LCBSR0JBX0FTVENfNHg0X0Zvcm1hdCwgUkdCQV9BU1RDXzV4NF9Gb3JtYXQsIFJHQkFfQVNUQ181eDVfRm9ybWF0LCBSR0JBX0FTVENfNng1X0Zvcm1hdCwgUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQsIFJHQkFfQVNUQ184eDVfRm9ybWF0LCBSR0JBX0FTVENfOHg2X0Zvcm1hdCwgUkdCQV9BU1RDXzh4OF9Gb3JtYXQsIFJHQkFfQlBUQ19Gb3JtYXQsIFJHQkFfRVRDMl9FQUNfRm9ybWF0LCBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQsIFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDFfRm9ybWF0LCBSR0JBX1MzVENfRFhUM19Gb3JtYXQsIFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCwgUkdCRm9ybWF0LCBSR0JfQlBUQ19TSUdORURfRm9ybWF0LCBSR0JfQlBUQ19VTlNJR05FRF9Gb3JtYXQsIFJHQl9FVEMxX0Zvcm1hdCwgUkdCX0VUQzJfRm9ybWF0LCBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQsIFJHQl9TM1RDX0RYVDFfRm9ybWF0LCBSR0Zvcm1hdCwgUkdJbnRlZ2VyRm9ybWF0LCBSYXdTaGFkZXJNYXRlcmlhbCwgUmF5LCBSYXljYXN0ZXIsIFJlYzcwOVByaW1hcmllcywgUmVjdEFyZWFMaWdodCwgUmVkRm9ybWF0LCBSZWRJbnRlZ2VyRm9ybWF0LCBSZWluaGFyZFRvbmVNYXBwaW5nLCBSZW5kZXJUYXJnZXQsIFJlcGVhdFdyYXBwaW5nLCBSZXBsYWNlU3RlbmNpbE9wLCBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiwgUmluZ0dlb21ldHJ5LCBTSUdORURfUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCwgU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQsIFNSR0JDb2xvclNwYWNlLCBTUkdCVHJhbnNmZXIsIFNjZW5lLCBTaGFkZXJDaHVuaywgU2hhZGVyTGliLCBTaGFkZXJNYXRlcmlhbCwgU2hhZG93TWF0ZXJpYWwsIFNoYXBlLCBTaGFwZUdlb21ldHJ5LCBTaGFwZVBhdGgsIFNoYXBlVXRpbHMsIFNob3J0VHlwZSwgU2tlbGV0b24sIFNrZWxldG9uSGVscGVyLCBTa2lubmVkTWVzaCwgU291cmNlLCBTcGhlcmUsIFNwaGVyZUdlb21ldHJ5LCBTcGhlcmljYWwsIFNwaGVyaWNhbEhhcm1vbmljczMsIFNwbGluZUN1cnZlLCBTcG90TGlnaHQsIFNwb3RMaWdodEhlbHBlciwgU3ByaXRlLCBTcHJpdGVNYXRlcmlhbCwgU3JjQWxwaGFGYWN0b3IsIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IsIFNyY0NvbG9yRmFjdG9yLCBTdGF0aWNDb3B5VXNhZ2UsIFN0YXRpY0RyYXdVc2FnZSwgU3RhdGljUmVhZFVzYWdlLCBTdGVyZW9DYW1lcmEsIFN0cmVhbUNvcHlVc2FnZSwgU3RyZWFtRHJhd1VzYWdlLCBTdHJlYW1SZWFkVXNhZ2UsIFN0cmluZ0tleWZyYW1lVHJhY2ssIFN1YnRyYWN0RXF1YXRpb24sIFN1YnRyYWN0aXZlQmxlbmRpbmcsIFRPVUNILCBUYW5nZW50U3BhY2VOb3JtYWxNYXAsIFRldHJhaGVkcm9uR2VvbWV0cnksIFRleHR1cmUsIFRleHR1cmVMb2FkZXIsIFRvcnVzR2VvbWV0cnksIFRvcnVzS25vdEdlb21ldHJ5LCBUcmlhbmdsZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBUcmlhbmdsZXNEcmF3TW9kZSwgVHViZUdlb21ldHJ5LCBVVk1hcHBpbmcsIFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSwgVWludDMyQnVmZmVyQXR0cmlidXRlLCBVaW50OEJ1ZmZlckF0dHJpYnV0ZSwgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlLCBVbmlmb3JtLCBVbmlmb3Jtc0dyb3VwLCBVbmlmb3Jtc0xpYiwgVW5pZm9ybXNVdGlscywgVW5zaWduZWRCeXRlVHlwZSwgVW5zaWduZWRJbnQyNDhUeXBlLCBVbnNpZ25lZEludDU5OTlUeXBlLCBVbnNpZ25lZEludFR5cGUsIFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSwgVW5zaWduZWRTaG9ydDU1NTFUeXBlLCBVbnNpZ25lZFNob3J0VHlwZSwgVlNNU2hhZG93TWFwLCBWZWN0b3IyLCBWZWN0b3IzLCBWZWN0b3I0LCBWZWN0b3JLZXlmcmFtZVRyYWNrLCBWaWRlb1RleHR1cmUsIFdlYkdMM0RSZW5kZXJUYXJnZXQsIFdlYkdMQXJyYXlSZW5kZXJUYXJnZXQsIFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSwgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0LCBXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cywgV2ViR0xSZW5kZXJUYXJnZXQsIFdlYkdMUmVuZGVyZXIsIFdlYkdMVXRpbHMsIFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0sIFdpcmVmcmFtZUdlb21ldHJ5LCBXcmFwQXJvdW5kRW5kaW5nLCBaZXJvQ3VydmF0dXJlRW5kaW5nLCBaZXJvRmFjdG9yLCBaZXJvU2xvcGVFbmRpbmcsIFplcm9TdGVuY2lsT3AsIGNyZWF0ZUNhbnZhc0VsZW1lbnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///75\n")},12:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   z: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);\n\n\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\nconst _ray = new three__WEBPACK_IMPORTED_MODULE_0__/* .Ray */ .zHn();\nconst _plane = new three__WEBPACK_IMPORTED_MODULE_0__/* .Plane */ .JOQ();\nconst TILT_LIMIT = Math.cos( 70 * three__WEBPACK_IMPORTED_MODULE_0__/* .MathUtils */ .M8C.DEG2RAD );\n\nclass OrbitControls extends three__WEBPACK_IMPORTED_MODULE_0__/* .EventDispatcher */ .pBf {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper();\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\t\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4();\n\n\t\t// Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect\n\t\tthis.cursor = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// Limit camera target within a spherical area around the cursor\n\t\tthis.minTargetRadius = 0;\n\t\tthis.maxTargetRadius = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.05;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.panSpeed = 1.0;\n\t\tthis.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\t\tthis.zoomToCursor = false;\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { LEFT: three__WEBPACK_IMPORTED_MODULE_0__/* .MOUSE */ .RsA.ROTATE, MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__/* .MOUSE */ .RsA.DOLLY, RIGHT: three__WEBPACK_IMPORTED_MODULE_0__/* .MOUSE */ .RsA.PAN };\n\n\t\t// Touch fingers\n\t\tthis.touches = { ONE: three__WEBPACK_IMPORTED_MODULE_0__/* .TOUCH */ .QmN.ROTATE, TWO: three__WEBPACK_IMPORTED_MODULE_0__/* .TOUCH */ .QmN.DOLLY_PAN };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// the target DOM element for key events\n\t\tthis._domElementKeyEvents = null;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.getDistance = function () {\n\n\t\t\treturn this.object.position.distanceTo( this.target );\n\n\t\t};\n\n\t\tthis.listenToKeyEvents = function ( domElement ) {\n\n\t\t\tdomElement.addEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = domElement;\n\n\t\t};\n\n\t\tthis.stopListenToKeyEvents = function () {\n\n\t\t\tthis._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = null;\n\n\t\t};\n\n\t\tthis.saveState = function () {\n\n\t\t\tscope.target0.copy( scope.target );\n\t\t\tscope.position0.copy( scope.object.position );\n\t\t\tscope.zoom0 = scope.object.zoom;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function () {\n\n\t\t\tconst offset = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tconst quat = new three__WEBPACK_IMPORTED_MODULE_0__/* .Quaternion */ ._fP().setFromUnitVectors( object.up, new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4( 0, 1, 0 ) );\n\t\t\tconst quatInverse = quat.clone().invert();\n\n\t\t\tconst lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4();\n\t\t\tconst lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__/* .Quaternion */ ._fP();\n\t\t\tconst lastTargetPosition = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4();\n\n\t\t\tconst twoPI = 2 * Math.PI;\n\n\t\t\treturn function update( deltaTime = null ) {\n\n\t\t\t\tconst position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle( deltaTime ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.enableDamping ) {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta * scope.dampingFactor;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t}\n\n\t\t\t\t// restrict theta to be between desired limits\n\n\t\t\t\tlet min = scope.minAzimuthAngle;\n\t\t\t\tlet max = scope.maxAzimuthAngle;\n\n\t\t\t\tif ( isFinite( min ) && isFinite( max ) ) {\n\n\t\t\t\t\tif ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;\n\n\t\t\t\t\tif ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;\n\n\t\t\t\t\tif ( min <= max ) {\n\n\t\t\t\t\t\tspherical.theta = Math.max( min, Math.min( max, spherical.theta ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tspherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?\n\t\t\t\t\t\t\tMath.max( min, spherical.theta ) :\n\t\t\t\t\t\t\tMath.min( max, spherical.theta );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\t// move target to panned location\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tscope.target.addScaledVector( panOffset, scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\t}\n\n\t\t\t\t// Limit the target distance from the cursor to create a sphere around the center of interest\n\t\t\t\tscope.target.sub( scope.cursor );\n\t\t\t\tscope.target.clampLength( scope.minTargetRadius, scope.maxTargetRadius );\n\t\t\t\tscope.target.add( scope.cursor );\n\n\t\t\t\tlet zoomChanged = false;\n\t\t\t\t// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n\t\t\t\t// we adjust zoom later in these cases\n\t\t\t\tif ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\tspherical.radius = clampDistance( spherical.radius );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst prevRadius = spherical.radius;\n\t\t\t\t\tspherical.radius = clampDistance( spherical.radius * scale );\n\t\t\t\t\tzoomChanged = prevRadius != spherical.radius;\n\n\t\t\t\t}\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\t// adjust camera position\n\t\t\t\tif ( scope.zoomToCursor && performCursorZoom ) {\n\n\t\t\t\t\tlet newRadius = null;\n\t\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t\t// move the camera down the pointer ray\n\t\t\t\t\t\t// this method avoids floating point error\n\t\t\t\t\t\tconst prevRadius = offset.length();\n\t\t\t\t\t\tnewRadius = clampDistance( prevRadius * scale );\n\n\t\t\t\t\t\tconst radiusDelta = prevRadius - newRadius;\n\t\t\t\t\t\tscope.object.position.addScaledVector( dollyDirection, radiusDelta );\n\t\t\t\t\t\tscope.object.updateMatrixWorld();\n\n\t\t\t\t\t\tzoomChanged = !! radiusDelta;\n\n\t\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t\t// adjust the ortho camera position based on zoom changes\n\t\t\t\t\t\tconst mouseBefore = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4( mouse.x, mouse.y, 0 );\n\t\t\t\t\t\tmouseBefore.unproject( scope.object );\n\n\t\t\t\t\t\tconst prevZoom = scope.object.zoom;\n\t\t\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );\n\t\t\t\t\t\tscope.object.updateProjectionMatrix();\n\n\t\t\t\t\t\tzoomChanged = prevZoom !== scope.object.zoom;\n\n\t\t\t\t\t\tconst mouseAfter = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4( mouse.x, mouse.y, 0 );\n\t\t\t\t\t\tmouseAfter.unproject( scope.object );\n\n\t\t\t\t\t\tscope.object.position.sub( mouseAfter ).add( mouseBefore );\n\t\t\t\t\t\tscope.object.updateMatrixWorld();\n\n\t\t\t\t\t\tnewRadius = offset.length();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );\n\t\t\t\t\t\tscope.zoomToCursor = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// handle the placement of the target\n\t\t\t\t\tif ( newRadius !== null ) {\n\n\t\t\t\t\t\tif ( this.screenSpacePanning ) {\n\n\t\t\t\t\t\t\t// position the orbit target in front of the new camera position\n\t\t\t\t\t\t\tscope.target.set( 0, 0, - 1 )\n\t\t\t\t\t\t\t\t.transformDirection( scope.object.matrix )\n\t\t\t\t\t\t\t\t.multiplyScalar( newRadius )\n\t\t\t\t\t\t\t\t.add( scope.object.position );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// get the ray and translation plane to compute target\n\t\t\t\t\t\t\t_ray.origin.copy( scope.object.position );\n\t\t\t\t\t\t\t_ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix );\n\n\t\t\t\t\t\t\t// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n\t\t\t\t\t\t\t// extremely large values\n\t\t\t\t\t\t\tif ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {\n\n\t\t\t\t\t\t\t\tobject.lookAt( scope.target );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t_plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );\n\t\t\t\t\t\t\t\t_ray.intersectPlane( _plane, scope.target );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\tconst prevZoom = scope.object.zoom;\n\t\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );\n\n\t\t\t\t\tif ( prevZoom !== scope.object.zoom ) {\n\n\t\t\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\t\t\tzoomChanged = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tperformCursorZoom = false;\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||\n\t\t\t\t\tlastTargetPosition.distanceToSquared( scope.target ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tlastTargetPosition.copy( scope.target );\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function () {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu );\n\n\t\t\tscope.domElement.removeEventListener( 'pointerdown', onPointerDown );\n\t\t\tscope.domElement.removeEventListener( 'pointercancel', onPointerUp );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel );\n\n\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\tdocument.removeEventListener( 'keydown', interceptControlDown, { capture: true } );\n\n\t\t\tif ( scope._domElementKeyEvents !== null ) {\n\n\t\t\t\tscope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\t\t\t\tscope._domElementKeyEvents = null;\n\n\t\t\t}\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tconst scope = this;\n\n\t\tconst STATE = {\n\t\t\tNONE: - 1,\n\t\t\tROTATE: 0,\n\t\t\tDOLLY: 1,\n\t\t\tPAN: 2,\n\t\t\tTOUCH_ROTATE: 3,\n\t\t\tTOUCH_PAN: 4,\n\t\t\tTOUCH_DOLLY_PAN: 5,\n\t\t\tTOUCH_DOLLY_ROTATE: 6\n\t\t};\n\n\t\tlet state = STATE.NONE;\n\n\t\tconst EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tconst spherical = new three__WEBPACK_IMPORTED_MODULE_0__/* .Spherical */ .$V();\n\t\tconst sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__/* .Spherical */ .$V();\n\n\t\tlet scale = 1;\n\t\tconst panOffset = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4();\n\n\t\tconst rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\t\tconst rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\t\tconst rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\n\t\tconst panStart = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\t\tconst panEnd = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\t\tconst panDelta = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\n\t\tconst dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\t\tconst dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\t\tconst dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\n\t\tconst dollyDirection = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4();\n\t\tconst mouse = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\t\tlet performCursorZoom = false;\n\n\t\tconst pointers = [];\n\t\tconst pointerPositions = {};\n\n\t\tlet controlActive = false;\n\n\t\tfunction getAutoRotationAngle( deltaTime ) {\n\n\t\t\tif ( deltaTime !== null ) {\n\n\t\t\t\treturn ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime;\n\n\t\t\t} else {\n\n\t\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getZoomScale( delta ) {\n\n\t\t\tconst normalizedDelta = Math.abs( delta * 0.01 );\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed * normalizedDelta );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tconst panLeft = function () {\n\n\t\t\tconst v = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tconst panUp = function () {\n\n\t\t\tconst v = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tif ( scope.screenSpacePanning === true ) {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t\t\tv.crossVectors( scope.object.up, v );\n\n\t\t\t\t}\n\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tconst pan = function () {\n\n\t\t\tconst offset = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector3 */ .Pa4();\n\n\t\t\treturn function pan( deltaX, deltaY ) {\n\n\t\t\t\tconst element = scope.domElement;\n\n\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tconst position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tlet targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateZoomParameters( x, y ) {\n\n\t\t\tif ( ! scope.zoomToCursor ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tperformCursorZoom = true;\n\n\t\t\tconst rect = scope.domElement.getBoundingClientRect();\n\t\t\tconst dx = x - rect.left;\n\t\t\tconst dy = y - rect.top;\n\t\t\tconst w = rect.width;\n\t\t\tconst h = rect.height;\n\n\t\t\tmouse.x = ( dx / w ) * 2 - 1;\n\t\t\tmouse.y = - ( dy / h ) * 2 + 1;\n\n\t\t\tdollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize();\n\n\t\t}\n\n\t\tfunction clampDistance( dist ) {\n\n\t\t\treturn Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\tupdateZoomParameters( event.clientX, event.clientX );\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale( dollyDelta.y ) );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale( dollyDelta.y ) );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\tupdateZoomParameters( event.clientX, event.clientY );\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale( event.deltaY ) );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale( event.deltaY ) );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tswitch ( event.code ) {\n\n\t\t\t\tcase scope.keys.UP:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tscope.update();\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\trotateStart.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\trotateStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartPan( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanStart.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tpanStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly( event ) {\n\n\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchStartPan( event );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchStartRotate( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\tif ( pointers.length == 1 ) {\n\n\t\t\t\trotateEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\trotateEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tpanEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\n\n\t\t\tdollyOut( dollyDelta.y );\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tconst centerX = ( event.pageX + position.x ) * 0.5;\n\t\t\tconst centerY = ( event.pageY + position.y ) * 0.5;\n\n\t\t\tupdateZoomParameters( centerX, centerY );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchMovePan( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchMoveRotate( event );\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onPointerDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.setPointerCapture( event.pointerId );\n\n\t\t\t\tscope.domElement.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( isTrackingPointer( event ) ) return;\n\n\t\t\t//\n\n\t\t\taddPointer( event );\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchStart( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseDown( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchMove( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseMove( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerUp( event ) {\n\n\t\t\tremovePointer( event );\n\n\t\t\tswitch ( pointers.length ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tscope.domElement.releasePointerCapture( event.pointerId );\n\n\t\t\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tconst pointerId = pointers[ 0 ];\n\t\t\t\t\tconst position = pointerPositions[ pointerId ];\n\n\t\t\t\t\t// minimal placeholder event - allows state correction on pointer-up\n\t\t\t\t\tonTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tlet mouseAction;\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.LEFT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.MIDDLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.RIGHT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tmouseAction = - 1;\n\n\t\t\t}\n\n\t\t\tswitch ( mouseAction ) {\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__/* .MOUSE */ .RsA.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__/* .MOUSE */ .RsA.ROTATE:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__/* .MOUSE */ .RsA.PAN:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\thandleMouseWheel( customWheelEvent( event ) );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tfunction customWheelEvent( event ) {\n\n\t\t\tconst mode = event.deltaMode;\n\n\t\t\t// minimal wheel event altered to meet delta-zoom demand\n\t\t\tconst newEvent = {\n\t\t\t\tclientX: event.clientX,\n\t\t\t\tclientY: event.clientY,\n\t\t\t\tdeltaY: event.deltaY,\n\t\t\t};\n\n\t\t\tswitch ( mode ) {\n\n\t\t\t\tcase 1: // LINE_MODE\n\t\t\t\t\tnewEvent.deltaY *= 16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // PAGE_MODE\n\t\t\t\t\tnewEvent.deltaY *= 100;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// detect if event was triggered by pinching\n\t\t\tif ( event.ctrlKey && ! controlActive ) {\n\n\t\t\t\tnewEvent.deltaY *= 10;\n\n\t\t\t}\n\n\t\t\treturn newEvent;\n\n\t\t}\n\n\t\tfunction interceptControlDown( event ) {\n\n\t\t\tif ( event.key === 'Control' ) {\n\n\t\t\t\tcontrolActive = true;\n\n\n\t\t\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\t\tdocument.addEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction interceptControlUp( event ) {\n\n\t\t\tif ( event.key === 'Control' ) {\n\n\t\t\t\tcontrolActive = false;\n\n\n\t\t\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\t\tdocument.removeEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( pointers.length ) {\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tswitch ( scope.touches.ONE ) {\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__/* .TOUCH */ .QmN.ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__/* .TOUCH */ .QmN.PAN:\n\n\t\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartPan( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tswitch ( scope.touches.TWO ) {\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__/* .TOUCH */ .QmN.DOLLY_PAN:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyPan( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__/* .TOUCH */ .QmN.DOLLY_ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyRotate( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.TOUCH_ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_PAN:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyPan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\tfunction addPointer( event ) {\n\n\t\t\tpointers.push( event.pointerId );\n\n\t\t}\n\n\t\tfunction removePointer( event ) {\n\n\t\t\tdelete pointerPositions[ event.pointerId ];\n\n\t\t\tfor ( let i = 0; i < pointers.length; i ++ ) {\n\n\t\t\t\tif ( pointers[ i ] == event.pointerId ) {\n\n\t\t\t\t\tpointers.splice( i, 1 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTrackingPointer( event ) {\n\n\t\t\tfor ( let i = 0; i < pointers.length; i ++ ) {\n\n\t\t\t\tif ( pointers[ i ] == event.pointerId ) return true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfunction trackPointer( event ) {\n\n\t\t\tlet position = pointerPositions[ event.pointerId ];\n\n\t\t\tif ( position === undefined ) {\n\n\t\t\t\tposition = new three__WEBPACK_IMPORTED_MODULE_0__/* .Vector2 */ .FM8();\n\t\t\t\tpointerPositions[ event.pointerId ] = position;\n\n\t\t\t}\n\n\t\t\tposition.set( event.pageX, event.pageY );\n\n\t\t}\n\n\t\tfunction getSecondPointerPosition( event ) {\n\n\t\t\tconst pointerId = ( event.pointerId === pointers[ 0 ] ) ? pointers[ 1 ] : pointers[ 0 ];\n\n\t\t\treturn pointerPositions[ pointerId ];\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu );\n\n\t\tscope.domElement.addEventListener( 'pointerdown', onPointerDown );\n\t\tscope.domElement.addEventListener( 'pointercancel', onPointerUp );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );\n\n\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\tdocument.addEventListener( 'keydown', interceptControlDown, { passive: true, capture: true } );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQVdlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixpQkFBaUIsaURBQUc7QUFDcEIsbUJBQW1CLG1EQUFLO0FBQ3hCLGtDQUFrQyx1REFBUzs7QUFFM0MsNEJBQTRCLDZEQUFlOztBQUUzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFEQUFPOztBQUUzQjtBQUNBLG9CQUFvQixxREFBTzs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0Esd0JBQXdCLE1BQU0sbURBQUssaUJBQWlCLG1EQUFLLGVBQWUsbURBQUs7O0FBRTdFO0FBQ0EsbUJBQW1CLEtBQUssbURBQUssY0FBYyxtREFBSzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixxREFBTzs7QUFFN0I7QUFDQSxvQkFBb0Isd0RBQVUsc0NBQXNDLHFEQUFPO0FBQzNFOztBQUVBLDRCQUE0QixxREFBTztBQUNuQyw4QkFBOEIsd0RBQVU7QUFDeEMsa0NBQWtDLHFEQUFPOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEM7O0FBRTFDLDBDQUEwQzs7QUFFMUM7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQSw4QkFBOEIscURBQU87QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZCQUE2QixxREFBTztBQUNwQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0Q7O0FBRXBELG9FQUFvRSxnQkFBZ0I7O0FBRXBGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLGtCQUFrQixHQUFHOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0Isc0RBQVM7QUFDakMsNkJBQTZCLHNEQUFTOztBQUV0QztBQUNBLHdCQUF3QixxREFBTzs7QUFFL0IsMEJBQTBCLHFEQUFPO0FBQ2pDLHdCQUF3QixxREFBTztBQUMvQiwwQkFBMEIscURBQU87O0FBRWpDLHVCQUF1QixxREFBTztBQUM5QixxQkFBcUIscURBQU87QUFDNUIsdUJBQXVCLHFEQUFPOztBQUU5Qix5QkFBeUIscURBQU87QUFDaEMsdUJBQXVCLHFEQUFPO0FBQzlCLHlCQUF5QixxREFBTzs7QUFFaEMsNkJBQTZCLHFEQUFPO0FBQ3BDLG9CQUFvQixxREFBTztBQUMzQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUIscURBQU87O0FBRXhCOztBQUVBLDhDQUE4QztBQUM5Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLGlCQUFpQixxREFBTzs7QUFFeEI7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsc0NBQXNDO0FBQ3RDOztBQUVBLHNCQUFzQixxREFBTzs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxRUFBcUU7O0FBRXJFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxRUFBcUU7O0FBRXJFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiw2REFBNkQ7O0FBRWxGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFNBQVMsbURBQUs7O0FBRWQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUyxtREFBSzs7QUFFZDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFNBQVMsbURBQUs7O0FBRWQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQSxxREFBcUQ7O0FBRXJELDhEQUE4RCwrQkFBK0I7O0FBRTdGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQSxxREFBcUQ7O0FBRXJELGlFQUFpRSwrQkFBK0I7O0FBRWhHOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsbURBQUs7O0FBRWhCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsbURBQUs7O0FBRWhCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsbURBQUs7O0FBRWhCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsbURBQUs7O0FBRWhCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixxQkFBcUI7O0FBRXpDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHFCQUFxQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHFEQUFPO0FBQzFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCOztBQUUvRSxtREFBbUQ7O0FBRW5ELGdFQUFnRSwrQkFBK0I7O0FBRS9GOztBQUVBOztBQUVBOztBQUVBOztBQUV5QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy10ZXh0dXJlLXN3aXRjaGluZy1sb2FkZXIvLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHMuanM/MDgzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRFdmVudERpc3BhdGNoZXIsXG5cdE1PVVNFLFxuXHRRdWF0ZXJuaW9uLFxuXHRTcGhlcmljYWwsXG5cdFRPVUNILFxuXHRWZWN0b3IyLFxuXHRWZWN0b3IzLFxuXHRQbGFuZSxcblx0UmF5LFxuXHRNYXRoVXRpbHNcbn0gZnJvbSAndGhyZWUnO1xuXG4vLyBPcmJpdENvbnRyb2xzIHBlcmZvcm1zIG9yYml0aW5nLCBkb2xseWluZyAoem9vbWluZyksIGFuZCBwYW5uaW5nLlxuLy8gVW5saWtlIFRyYWNrYmFsbENvbnRyb2xzLCBpdCBtYWludGFpbnMgdGhlIFwidXBcIiBkaXJlY3Rpb24gb2JqZWN0LnVwICgrWSBieSBkZWZhdWx0KS5cbi8vXG4vLyAgICBPcmJpdCAtIGxlZnQgbW91c2UgLyB0b3VjaDogb25lLWZpbmdlciBtb3ZlXG4vLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3by1maW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxuLy8gICAgUGFuIC0gcmlnaHQgbW91c2UsIG9yIGxlZnQgbW91c2UgKyBjdHJsL21ldGEvc2hpZnRLZXksIG9yIGFycm93IGtleXMgLyB0b3VjaDogdHdvLWZpbmdlciBtb3ZlXG5cbmNvbnN0IF9jaGFuZ2VFdmVudCA9IHsgdHlwZTogJ2NoYW5nZScgfTtcbmNvbnN0IF9zdGFydEV2ZW50ID0geyB0eXBlOiAnc3RhcnQnIH07XG5jb25zdCBfZW5kRXZlbnQgPSB7IHR5cGU6ICdlbmQnIH07XG5jb25zdCBfcmF5ID0gbmV3IFJheSgpO1xuY29uc3QgX3BsYW5lID0gbmV3IFBsYW5lKCk7XG5jb25zdCBUSUxUX0xJTUlUID0gTWF0aC5jb3MoIDcwICogTWF0aFV0aWxzLkRFRzJSQUQgKTtcblxuY2xhc3MgT3JiaXRDb250cm9scyBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoIG9iamVjdCwgZG9tRWxlbWVudCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuXHRcdHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJzsgLy8gZGlzYWJsZSB0b3VjaCBzY3JvbGxcblxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cblx0XHQvLyBcInRhcmdldFwiIHNldHMgdGhlIGxvY2F0aW9uIG9mIGZvY3VzLCB3aGVyZSB0aGUgb2JqZWN0IG9yYml0cyBhcm91bmRcblx0XHR0aGlzLnRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBTZXRzIHRoZSAzRCBjdXJzb3IgKHNpbWlsYXIgdG8gQmxlbmRlciksIGZyb20gd2hpY2ggdGhlIG1heFRhcmdldFJhZGl1cyB0YWtlcyBlZmZlY3Rcblx0XHR0aGlzLmN1cnNvciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBIb3cgZmFyIHlvdSBjYW4gZG9sbHkgaW4gYW5kIG91dCAoIFBlcnNwZWN0aXZlQ2FtZXJhIG9ubHkgKVxuXHRcdHRoaXMubWluRGlzdGFuY2UgPSAwO1xuXHRcdHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcblxuXHRcdC8vIEhvdyBmYXIgeW91IGNhbiB6b29tIGluIGFuZCBvdXQgKCBPcnRob2dyYXBoaWNDYW1lcmEgb25seSApXG5cdFx0dGhpcy5taW5ab29tID0gMDtcblx0XHR0aGlzLm1heFpvb20gPSBJbmZpbml0eTtcblxuXHRcdC8vIExpbWl0IGNhbWVyYSB0YXJnZXQgd2l0aGluIGEgc3BoZXJpY2FsIGFyZWEgYXJvdW5kIHRoZSBjdXJzb3Jcblx0XHR0aGlzLm1pblRhcmdldFJhZGl1cyA9IDA7XG5cdFx0dGhpcy5tYXhUYXJnZXRSYWRpdXMgPSBJbmZpbml0eTtcblxuXHRcdC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCB2ZXJ0aWNhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuXHRcdC8vIFJhbmdlIGlzIDAgdG8gTWF0aC5QSSByYWRpYW5zLlxuXHRcdHRoaXMubWluUG9sYXJBbmdsZSA9IDA7IC8vIHJhZGlhbnNcblx0XHR0aGlzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJOyAvLyByYWRpYW5zXG5cblx0XHQvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgaG9yaXpvbnRhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuXHRcdC8vIElmIHNldCwgdGhlIGludGVydmFsIFsgbWluLCBtYXggXSBtdXN0IGJlIGEgc3ViLWludGVydmFsIG9mIFsgLSAyIFBJLCAyIFBJIF0sIHdpdGggKCBtYXggLSBtaW4gPCAyIFBJIClcblx0XHR0aGlzLm1pbkF6aW11dGhBbmdsZSA9IC0gSW5maW5pdHk7IC8vIHJhZGlhbnNcblx0XHR0aGlzLm1heEF6aW11dGhBbmdsZSA9IEluZmluaXR5OyAvLyByYWRpYW5zXG5cblx0XHQvLyBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgZGFtcGluZyAoaW5lcnRpYSlcblx0XHQvLyBJZiBkYW1waW5nIGlzIGVuYWJsZWQsIHlvdSBtdXN0IGNhbGwgY29udHJvbHMudXBkYXRlKCkgaW4geW91ciBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuZW5hYmxlRGFtcGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuZGFtcGluZ0ZhY3RvciA9IDAuMDU7XG5cblx0XHQvLyBUaGlzIG9wdGlvbiBhY3R1YWxseSBlbmFibGVzIGRvbGx5aW5nIGluIGFuZCBvdXQ7IGxlZnQgYXMgXCJ6b29tXCIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHpvb21pbmdcblx0XHR0aGlzLmVuYWJsZVpvb20gPSB0cnVlO1xuXHRcdHRoaXMuem9vbVNwZWVkID0gMS4wO1xuXG5cdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcm90YXRpbmdcblx0XHR0aGlzLmVuYWJsZVJvdGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5yb3RhdGVTcGVlZCA9IDEuMDtcblxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHBhbm5pbmdcblx0XHR0aGlzLmVuYWJsZVBhbiA9IHRydWU7XG5cdFx0dGhpcy5wYW5TcGVlZCA9IDEuMDtcblx0XHR0aGlzLnNjcmVlblNwYWNlUGFubmluZyA9IHRydWU7IC8vIGlmIGZhbHNlLCBwYW4gb3J0aG9nb25hbCB0byB3b3JsZC1zcGFjZSBkaXJlY3Rpb24gY2FtZXJhLnVwXG5cdFx0dGhpcy5rZXlQYW5TcGVlZCA9IDcuMDtcdC8vIHBpeGVscyBtb3ZlZCBwZXIgYXJyb3cga2V5IHB1c2hcblx0XHR0aGlzLnpvb21Ub0N1cnNvciA9IGZhbHNlO1xuXG5cdFx0Ly8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcblx0XHQvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgb3JiaXQgd2hlbiBmcHMgaXMgNjBcblxuXHRcdC8vIFRoZSBmb3VyIGFycm93IGtleXNcblx0XHR0aGlzLmtleXMgPSB7IExFRlQ6ICdBcnJvd0xlZnQnLCBVUDogJ0Fycm93VXAnLCBSSUdIVDogJ0Fycm93UmlnaHQnLCBCT1RUT006ICdBcnJvd0Rvd24nIH07XG5cblx0XHQvLyBNb3VzZSBidXR0b25zXG5cdFx0dGhpcy5tb3VzZUJ1dHRvbnMgPSB7IExFRlQ6IE1PVVNFLlJPVEFURSwgTUlERExFOiBNT1VTRS5ET0xMWSwgUklHSFQ6IE1PVVNFLlBBTiB9O1xuXG5cdFx0Ly8gVG91Y2ggZmluZ2Vyc1xuXHRcdHRoaXMudG91Y2hlcyA9IHsgT05FOiBUT1VDSC5ST1RBVEUsIFRXTzogVE9VQ0guRE9MTFlfUEFOIH07XG5cblx0XHQvLyBmb3IgcmVzZXRcblx0XHR0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXHRcdHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcblx0XHR0aGlzLnpvb20wID0gdGhpcy5vYmplY3Quem9vbTtcblxuXHRcdC8vIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnQgZm9yIGtleSBldmVudHNcblx0XHR0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzID0gbnVsbDtcblxuXHRcdC8vXG5cdFx0Ly8gcHVibGljIG1ldGhvZHNcblx0XHQvL1xuXG5cdFx0dGhpcy5nZXRQb2xhckFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gc3BoZXJpY2FsLnBoaTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEF6aW11dGhhbEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gc3BoZXJpY2FsLnRoZXRhO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm9iamVjdC5wb3NpdGlvbi5kaXN0YW5jZVRvKCB0aGlzLnRhcmdldCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMubGlzdGVuVG9LZXlFdmVudHMgPSBmdW5jdGlvbiAoIGRvbUVsZW1lbnQgKSB7XG5cblx0XHRcdGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24gKTtcblx0XHRcdHRoaXMuX2RvbUVsZW1lbnRLZXlFdmVudHMgPSBkb21FbGVtZW50O1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc3RvcExpc3RlblRvS2V5RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duICk7XG5cdFx0XHR0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzID0gbnVsbDtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0c2NvcGUudGFyZ2V0MC5jb3B5KCBzY29wZS50YXJnZXQgKTtcblx0XHRcdHNjb3BlLnBvc2l0aW9uMC5jb3B5KCBzY29wZS5vYmplY3QucG9zaXRpb24gKTtcblx0XHRcdHNjb3BlLnpvb20wID0gc2NvcGUub2JqZWN0Lnpvb207XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0c2NvcGUudGFyZ2V0LmNvcHkoIHNjb3BlLnRhcmdldDAgKTtcblx0XHRcdHNjb3BlLm9iamVjdC5wb3NpdGlvbi5jb3B5KCBzY29wZS5wb3NpdGlvbjAgKTtcblx0XHRcdHNjb3BlLm9iamVjdC56b29tID0gc2NvcGUuem9vbTA7XG5cblx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfY2hhbmdlRXZlbnQgKTtcblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH07XG5cblx0XHQvLyB0aGlzIG1ldGhvZCBpcyBleHBvc2VkLCBidXQgcGVyaGFwcyBpdCB3b3VsZCBiZSBiZXR0ZXIgaWYgd2UgY2FuIG1ha2UgaXQgcHJpdmF0ZS4uLlxuXHRcdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBzbyBjYW1lcmEudXAgaXMgdGhlIG9yYml0IGF4aXNcblx0XHRcdGNvbnN0IHF1YXQgPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21Vbml0VmVjdG9ycyggb2JqZWN0LnVwLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApICk7XG5cdFx0XHRjb25zdCBxdWF0SW52ZXJzZSA9IHF1YXQuY2xvbmUoKS5pbnZlcnQoKTtcblxuXHRcdFx0Y29uc3QgbGFzdFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGxhc3RRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRcdGNvbnN0IGxhc3RUYXJnZXRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGNvbnN0IHR3b1BJID0gMiAqIE1hdGguUEk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGRlbHRhVGltZSA9IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG5cblx0XHRcdFx0b2Zmc2V0LmNvcHkoIHBvc2l0aW9uICkuc3ViKCBzY29wZS50YXJnZXQgKTtcblxuXHRcdFx0XHQvLyByb3RhdGUgb2Zmc2V0IHRvIFwieS1heGlzLWlzLXVwXCIgc3BhY2Vcblx0XHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdCApO1xuXG5cdFx0XHRcdC8vIGFuZ2xlIGZyb20gei1heGlzIGFyb3VuZCB5LWF4aXNcblx0XHRcdFx0c3BoZXJpY2FsLnNldEZyb21WZWN0b3IzKCBvZmZzZXQgKTtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmF1dG9Sb3RhdGUgJiYgc3RhdGUgPT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdFx0XHRyb3RhdGVMZWZ0KCBnZXRBdXRvUm90YXRpb25BbmdsZSggZGVsdGFUaW1lICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVEYW1waW5nICkge1xuXG5cdFx0XHRcdFx0c3BoZXJpY2FsLnRoZXRhICs9IHNwaGVyaWNhbERlbHRhLnRoZXRhICogc2NvcGUuZGFtcGluZ0ZhY3Rvcjtcblx0XHRcdFx0XHRzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaSAqIHNjb3BlLmRhbXBpbmdGYWN0b3I7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHNwaGVyaWNhbC50aGV0YSArPSBzcGhlcmljYWxEZWx0YS50aGV0YTtcblx0XHRcdFx0XHRzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzdHJpY3QgdGhldGEgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXG5cdFx0XHRcdGxldCBtaW4gPSBzY29wZS5taW5BemltdXRoQW5nbGU7XG5cdFx0XHRcdGxldCBtYXggPSBzY29wZS5tYXhBemltdXRoQW5nbGU7XG5cblx0XHRcdFx0aWYgKCBpc0Zpbml0ZSggbWluICkgJiYgaXNGaW5pdGUoIG1heCApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBtaW4gPCAtIE1hdGguUEkgKSBtaW4gKz0gdHdvUEk7IGVsc2UgaWYgKCBtaW4gPiBNYXRoLlBJICkgbWluIC09IHR3b1BJO1xuXG5cdFx0XHRcdFx0aWYgKCBtYXggPCAtIE1hdGguUEkgKSBtYXggKz0gdHdvUEk7IGVsc2UgaWYgKCBtYXggPiBNYXRoLlBJICkgbWF4IC09IHR3b1BJO1xuXG5cdFx0XHRcdFx0aWYgKCBtaW4gPD0gbWF4ICkge1xuXG5cdFx0XHRcdFx0XHRzcGhlcmljYWwudGhldGEgPSBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBzcGhlcmljYWwudGhldGEgKSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c3BoZXJpY2FsLnRoZXRhID0gKCBzcGhlcmljYWwudGhldGEgPiAoIG1pbiArIG1heCApIC8gMiApID9cblx0XHRcdFx0XHRcdFx0TWF0aC5tYXgoIG1pbiwgc3BoZXJpY2FsLnRoZXRhICkgOlxuXHRcdFx0XHRcdFx0XHRNYXRoLm1pbiggbWF4LCBzcGhlcmljYWwudGhldGEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcblx0XHRcdFx0c3BoZXJpY2FsLnBoaSA9IE1hdGgubWF4KCBzY29wZS5taW5Qb2xhckFuZ2xlLCBNYXRoLm1pbiggc2NvcGUubWF4UG9sYXJBbmdsZSwgc3BoZXJpY2FsLnBoaSApICk7XG5cblx0XHRcdFx0c3BoZXJpY2FsLm1ha2VTYWZlKCk7XG5cblxuXHRcdFx0XHQvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRzY29wZS50YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBwYW5PZmZzZXQsIHNjb3BlLmRhbXBpbmdGYWN0b3IgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2NvcGUudGFyZ2V0LmFkZCggcGFuT2Zmc2V0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExpbWl0IHRoZSB0YXJnZXQgZGlzdGFuY2UgZnJvbSB0aGUgY3Vyc29yIHRvIGNyZWF0ZSBhIHNwaGVyZSBhcm91bmQgdGhlIGNlbnRlciBvZiBpbnRlcmVzdFxuXHRcdFx0XHRzY29wZS50YXJnZXQuc3ViKCBzY29wZS5jdXJzb3IgKTtcblx0XHRcdFx0c2NvcGUudGFyZ2V0LmNsYW1wTGVuZ3RoKCBzY29wZS5taW5UYXJnZXRSYWRpdXMsIHNjb3BlLm1heFRhcmdldFJhZGl1cyApO1xuXHRcdFx0XHRzY29wZS50YXJnZXQuYWRkKCBzY29wZS5jdXJzb3IgKTtcblxuXHRcdFx0XHRsZXQgem9vbUNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0Ly8gYWRqdXN0IHRoZSBjYW1lcmEgcG9zaXRpb24gYmFzZWQgb24gem9vbSBvbmx5IGlmIHdlJ3JlIG5vdCB6b29taW5nIHRvIHRoZSBjdXJzb3Igb3IgaWYgaXQncyBhbiBvcnRobyBjYW1lcmFcblx0XHRcdFx0Ly8gd2UgYWRqdXN0IHpvb20gbGF0ZXIgaW4gdGhlc2UgY2FzZXNcblx0XHRcdFx0aWYgKCBzY29wZS56b29tVG9DdXJzb3IgJiYgcGVyZm9ybUN1cnNvclpvb20gfHwgc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0c3BoZXJpY2FsLnJhZGl1cyA9IGNsYW1wRGlzdGFuY2UoIHNwaGVyaWNhbC5yYWRpdXMgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc3QgcHJldlJhZGl1cyA9IHNwaGVyaWNhbC5yYWRpdXM7XG5cdFx0XHRcdFx0c3BoZXJpY2FsLnJhZGl1cyA9IGNsYW1wRGlzdGFuY2UoIHNwaGVyaWNhbC5yYWRpdXMgKiBzY2FsZSApO1xuXHRcdFx0XHRcdHpvb21DaGFuZ2VkID0gcHJldlJhZGl1cyAhPSBzcGhlcmljYWwucmFkaXVzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvZmZzZXQuc2V0RnJvbVNwaGVyaWNhbCggc3BoZXJpY2FsICk7XG5cblx0XHRcdFx0Ly8gcm90YXRlIG9mZnNldCBiYWNrIHRvIFwiY2FtZXJhLXVwLXZlY3Rvci1pcy11cFwiIHNwYWNlXG5cdFx0XHRcdG9mZnNldC5hcHBseVF1YXRlcm5pb24oIHF1YXRJbnZlcnNlICk7XG5cblx0XHRcdFx0cG9zaXRpb24uY29weSggc2NvcGUudGFyZ2V0ICkuYWRkKCBvZmZzZXQgKTtcblxuXHRcdFx0XHRzY29wZS5vYmplY3QubG9va0F0KCBzY29wZS50YXJnZXQgKTtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRzcGhlcmljYWxEZWx0YS50aGV0YSAqPSAoIDEgLSBzY29wZS5kYW1waW5nRmFjdG9yICk7XG5cdFx0XHRcdFx0c3BoZXJpY2FsRGVsdGEucGhpICo9ICggMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3IgKTtcblxuXHRcdFx0XHRcdHBhbk9mZnNldC5tdWx0aXBseVNjYWxhciggMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3IgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c3BoZXJpY2FsRGVsdGEuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdFx0XHRwYW5PZmZzZXQuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFkanVzdCBjYW1lcmEgcG9zaXRpb25cblx0XHRcdFx0aWYgKCBzY29wZS56b29tVG9DdXJzb3IgJiYgcGVyZm9ybUN1cnNvclpvb20gKSB7XG5cblx0XHRcdFx0XHRsZXQgbmV3UmFkaXVzID0gbnVsbDtcblx0XHRcdFx0XHRpZiAoIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0XHQvLyBtb3ZlIHRoZSBjYW1lcmEgZG93biB0aGUgcG9pbnRlciByYXlcblx0XHRcdFx0XHRcdC8vIHRoaXMgbWV0aG9kIGF2b2lkcyBmbG9hdGluZyBwb2ludCBlcnJvclxuXHRcdFx0XHRcdFx0Y29uc3QgcHJldlJhZGl1cyA9IG9mZnNldC5sZW5ndGgoKTtcblx0XHRcdFx0XHRcdG5ld1JhZGl1cyA9IGNsYW1wRGlzdGFuY2UoIHByZXZSYWRpdXMgKiBzY2FsZSApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCByYWRpdXNEZWx0YSA9IHByZXZSYWRpdXMgLSBuZXdSYWRpdXM7XG5cdFx0XHRcdFx0XHRzY29wZS5vYmplY3QucG9zaXRpb24uYWRkU2NhbGVkVmVjdG9yKCBkb2xseURpcmVjdGlvbiwgcmFkaXVzRGVsdGEgKTtcblx0XHRcdFx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHRcdFx0XHR6b29tQ2hhbmdlZCA9ICEhIHJhZGl1c0RlbHRhO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0XHQvLyBhZGp1c3QgdGhlIG9ydGhvIGNhbWVyYSBwb3NpdGlvbiBiYXNlZCBvbiB6b29tIGNoYW5nZXNcblx0XHRcdFx0XHRcdGNvbnN0IG1vdXNlQmVmb3JlID0gbmV3IFZlY3RvcjMoIG1vdXNlLngsIG1vdXNlLnksIDAgKTtcblx0XHRcdFx0XHRcdG1vdXNlQmVmb3JlLnVucHJvamVjdCggc2NvcGUub2JqZWN0ICk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHByZXZab29tID0gc2NvcGUub2JqZWN0Lnpvb207XG5cdFx0XHRcdFx0XHRzY29wZS5vYmplY3Quem9vbSA9IE1hdGgubWF4KCBzY29wZS5taW5ab29tLCBNYXRoLm1pbiggc2NvcGUubWF4Wm9vbSwgc2NvcGUub2JqZWN0Lnpvb20gLyBzY2FsZSApICk7XG5cdFx0XHRcdFx0XHRzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0XHRcdFx0XHR6b29tQ2hhbmdlZCA9IHByZXZab29tICE9PSBzY29wZS5vYmplY3Quem9vbTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbW91c2VBZnRlciA9IG5ldyBWZWN0b3IzKCBtb3VzZS54LCBtb3VzZS55LCAwICk7XG5cdFx0XHRcdFx0XHRtb3VzZUFmdGVyLnVucHJvamVjdCggc2NvcGUub2JqZWN0ICk7XG5cblx0XHRcdFx0XHRcdHNjb3BlLm9iamVjdC5wb3NpdGlvbi5zdWIoIG1vdXNlQWZ0ZXIgKS5hZGQoIG1vdXNlQmVmb3JlICk7XG5cdFx0XHRcdFx0XHRzY29wZS5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0XHRcdFx0bmV3UmFkaXVzID0gb2Zmc2V0Lmxlbmd0aCgpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gem9vbSB0byBjdXJzb3IgZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRcdFx0c2NvcGUuem9vbVRvQ3Vyc29yID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBoYW5kbGUgdGhlIHBsYWNlbWVudCBvZiB0aGUgdGFyZ2V0XG5cdFx0XHRcdFx0aWYgKCBuZXdSYWRpdXMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdGhpcy5zY3JlZW5TcGFjZVBhbm5pbmcgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcG9zaXRpb24gdGhlIG9yYml0IHRhcmdldCBpbiBmcm9udCBvZiB0aGUgbmV3IGNhbWVyYSBwb3NpdGlvblxuXHRcdFx0XHRcdFx0XHRzY29wZS50YXJnZXQuc2V0KCAwLCAwLCAtIDEgKVxuXHRcdFx0XHRcdFx0XHRcdC50cmFuc2Zvcm1EaXJlY3Rpb24oIHNjb3BlLm9iamVjdC5tYXRyaXggKVxuXHRcdFx0XHRcdFx0XHRcdC5tdWx0aXBseVNjYWxhciggbmV3UmFkaXVzIClcblx0XHRcdFx0XHRcdFx0XHQuYWRkKCBzY29wZS5vYmplY3QucG9zaXRpb24gKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBnZXQgdGhlIHJheSBhbmQgdHJhbnNsYXRpb24gcGxhbmUgdG8gY29tcHV0ZSB0YXJnZXRcblx0XHRcdFx0XHRcdFx0X3JheS5vcmlnaW4uY29weSggc2NvcGUub2JqZWN0LnBvc2l0aW9uICk7XG5cdFx0XHRcdFx0XHRcdF9yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNhbWVyYSBpcyAyMCBkZWdyZWVzIGFib3ZlIHRoZSBob3Jpem9uIHRoZW4gZG9uJ3QgYWRqdXN0IHRoZSBmb2N1cyB0YXJnZXQgdG8gYXZvaWRcblx0XHRcdFx0XHRcdFx0Ly8gZXh0cmVtZWx5IGxhcmdlIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBzY29wZS5vYmplY3QudXAuZG90KCBfcmF5LmRpcmVjdGlvbiApICkgPCBUSUxUX0xJTUlUICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0Lmxvb2tBdCggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdF9wbGFuZS5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggc2NvcGUub2JqZWN0LnVwLCBzY29wZS50YXJnZXQgKTtcblx0XHRcdFx0XHRcdFx0XHRfcmF5LmludGVyc2VjdFBsYW5lKCBfcGxhbmUsIHNjb3BlLnRhcmdldCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHByZXZab29tID0gc2NvcGUub2JqZWN0Lnpvb207XG5cdFx0XHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heCggc2NvcGUubWluWm9vbSwgTWF0aC5taW4oIHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tIC8gc2NhbGUgKSApO1xuXG5cdFx0XHRcdFx0aWYgKCBwcmV2Wm9vbSAhPT0gc2NvcGUub2JqZWN0Lnpvb20gKSB7XG5cblx0XHRcdFx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHRcdFx0XHR6b29tQ2hhbmdlZCA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjYWxlID0gMTtcblx0XHRcdFx0cGVyZm9ybUN1cnNvclpvb20gPSBmYWxzZTtcblxuXHRcdFx0XHQvLyB1cGRhdGUgY29uZGl0aW9uIGlzOlxuXHRcdFx0XHQvLyBtaW4oY2FtZXJhIGRpc3BsYWNlbWVudCwgY2FtZXJhIHJvdGF0aW9uIGluIHJhZGlhbnMpXjIgPiBFUFNcblx0XHRcdFx0Ly8gdXNpbmcgc21hbGwtYW5nbGUgYXBwcm94aW1hdGlvbiBjb3MoeC8yKSA9IDEgLSB4XjIgLyA4XG5cblx0XHRcdFx0aWYgKCB6b29tQ2hhbmdlZCB8fFxuXHRcdFx0XHRcdGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggc2NvcGUub2JqZWN0LnBvc2l0aW9uICkgPiBFUFMgfHxcblx0XHRcdFx0XHQ4ICogKCAxIC0gbGFzdFF1YXRlcm5pb24uZG90KCBzY29wZS5vYmplY3QucXVhdGVybmlvbiApICkgPiBFUFMgfHxcblx0XHRcdFx0XHRsYXN0VGFyZ2V0UG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoIHNjb3BlLnRhcmdldCApID4gRVBTICkge1xuXG5cdFx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX2NoYW5nZUV2ZW50ICk7XG5cblx0XHRcdFx0XHRsYXN0UG9zaXRpb24uY29weSggc2NvcGUub2JqZWN0LnBvc2l0aW9uICk7XG5cdFx0XHRcdFx0bGFzdFF1YXRlcm5pb24uY29weSggc2NvcGUub2JqZWN0LnF1YXRlcm5pb24gKTtcblx0XHRcdFx0XHRsYXN0VGFyZ2V0UG9zaXRpb24uY29weSggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpO1xuXG5cdFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUgKTtcblxuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duICk7XG5cdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVyY2FuY2VsJywgb25Qb2ludGVyVXAgKTtcblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgb25Nb3VzZVdoZWVsICk7XG5cblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSApO1xuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcnVwJywgb25Qb2ludGVyVXAgKTtcblxuXHRcdFx0Y29uc3QgZG9jdW1lbnQgPSBzY29wZS5kb21FbGVtZW50LmdldFJvb3ROb2RlKCk7IC8vIG9mZnNjcmVlbiBjYW52YXMgY29tcGF0aWJpbGl0eVxuXG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIGludGVyY2VwdENvbnRyb2xEb3duLCB7IGNhcHR1cmU6IHRydWUgfSApO1xuXG5cdFx0XHRpZiAoIHNjb3BlLl9kb21FbGVtZW50S2V5RXZlbnRzICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHNjb3BlLl9kb21FbGVtZW50S2V5RXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duICk7XG5cdFx0XHRcdHNjb3BlLl9kb21FbGVtZW50S2V5RXZlbnRzID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL3Njb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTsgLy8gc2hvdWxkIHRoaXMgYmUgYWRkZWQgaGVyZT9cblxuXHRcdH07XG5cblx0XHQvL1xuXHRcdC8vIGludGVybmFsc1xuXHRcdC8vXG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBTVEFURSA9IHtcblx0XHRcdE5PTkU6IC0gMSxcblx0XHRcdFJPVEFURTogMCxcblx0XHRcdERPTExZOiAxLFxuXHRcdFx0UEFOOiAyLFxuXHRcdFx0VE9VQ0hfUk9UQVRFOiAzLFxuXHRcdFx0VE9VQ0hfUEFOOiA0LFxuXHRcdFx0VE9VQ0hfRE9MTFlfUEFOOiA1LFxuXHRcdFx0VE9VQ0hfRE9MTFlfUk9UQVRFOiA2XG5cdFx0fTtcblxuXHRcdGxldCBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRjb25zdCBFUFMgPSAwLjAwMDAwMTtcblxuXHRcdC8vIGN1cnJlbnQgcG9zaXRpb24gaW4gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG5cdFx0Y29uc3Qgc3BoZXJpY2FsID0gbmV3IFNwaGVyaWNhbCgpO1xuXHRcdGNvbnN0IHNwaGVyaWNhbERlbHRhID0gbmV3IFNwaGVyaWNhbCgpO1xuXG5cdFx0bGV0IHNjYWxlID0gMTtcblx0XHRjb25zdCBwYW5PZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Y29uc3Qgcm90YXRlU3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IHJvdGF0ZUVuZCA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0Y29uc3Qgcm90YXRlRGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Y29uc3QgcGFuU3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IHBhbkVuZCA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0Y29uc3QgcGFuRGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Y29uc3QgZG9sbHlTdGFydCA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0Y29uc3QgZG9sbHlFbmQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IGRvbGx5RGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Y29uc3QgZG9sbHlEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG1vdXNlID0gbmV3IFZlY3RvcjIoKTtcblx0XHRsZXQgcGVyZm9ybUN1cnNvclpvb20gPSBmYWxzZTtcblxuXHRcdGNvbnN0IHBvaW50ZXJzID0gW107XG5cdFx0Y29uc3QgcG9pbnRlclBvc2l0aW9ucyA9IHt9O1xuXG5cdFx0bGV0IGNvbnRyb2xBY3RpdmUgPSBmYWxzZTtcblxuXHRcdGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCBkZWx0YVRpbWUgKSB7XG5cblx0XHRcdGlmICggZGVsdGFUaW1lICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHJldHVybiAoIDIgKiBNYXRoLlBJIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQgKSAqIGRlbHRhVGltZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gMiAqIE1hdGguUEkgLyA2MCAvIDYwICogc2NvcGUuYXV0b1JvdGF0ZVNwZWVkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRab29tU2NhbGUoIGRlbHRhICkge1xuXG5cdFx0XHRjb25zdCBub3JtYWxpemVkRGVsdGEgPSBNYXRoLmFicyggZGVsdGEgKiAwLjAxICk7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIDAuOTUsIHNjb3BlLnpvb21TcGVlZCAqIG5vcm1hbGl6ZWREZWx0YSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcm90YXRlTGVmdCggYW5nbGUgKSB7XG5cblx0XHRcdHNwaGVyaWNhbERlbHRhLnRoZXRhIC09IGFuZ2xlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcm90YXRlVXAoIGFuZ2xlICkge1xuXG5cdFx0XHRzcGhlcmljYWxEZWx0YS5waGkgLT0gYW5nbGU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYW5MZWZ0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zdCB2ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHBhbkxlZnQoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XG5cblx0XHRcdFx0di5zZXRGcm9tTWF0cml4Q29sdW1uKCBvYmplY3RNYXRyaXgsIDAgKTsgLy8gZ2V0IFggY29sdW1uIG9mIG9iamVjdE1hdHJpeFxuXHRcdFx0XHR2Lm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlICk7XG5cblx0XHRcdFx0cGFuT2Zmc2V0LmFkZCggdiApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpO1xuXG5cdFx0Y29uc3QgcGFuVXAgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnN0IHYgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuVXAoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5zY3JlZW5TcGFjZVBhbm5pbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMCApO1xuXHRcdFx0XHRcdHYuY3Jvc3NWZWN0b3JzKCBzY29wZS5vYmplY3QudXAsIHYgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0di5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKTtcblxuXHRcdFx0XHRwYW5PZmZzZXQuYWRkKCB2ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCk7XG5cblx0XHQvLyBkZWx0YVggYW5kIGRlbHRhWSBhcmUgaW4gcGl4ZWxzOyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcblx0XHRjb25zdCBwYW4gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBwYW4oIGRlbHRhWCwgZGVsdGFZICkge1xuXG5cdFx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0XHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHQvLyBwZXJzcGVjdGl2ZVxuXHRcdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuXHRcdFx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cdFx0XHRcdFx0bGV0IHRhcmdldERpc3RhbmNlID0gb2Zmc2V0Lmxlbmd0aCgpO1xuXG5cdFx0XHRcdFx0Ly8gaGFsZiBvZiB0aGUgZm92IGlzIGNlbnRlciB0byB0b3Agb2Ygc2NyZWVuXG5cdFx0XHRcdFx0dGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oICggc2NvcGUub2JqZWN0LmZvdiAvIDIgKSAqIE1hdGguUEkgLyAxODAuMCApO1xuXG5cdFx0XHRcdFx0Ly8gd2UgdXNlIG9ubHkgY2xpZW50SGVpZ2h0IGhlcmUgc28gYXNwZWN0IHJhdGlvIGRvZXMgbm90IGRpc3RvcnQgc3BlZWRcblx0XHRcdFx0XHRwYW5MZWZ0KCAyICogZGVsdGFYICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXHRcdFx0XHRcdHBhblVwKCAyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRcdC8vIG9ydGhvZ3JhcGhpY1xuXHRcdFx0XHRcdHBhbkxlZnQoIGRlbHRhWCAqICggc2NvcGUub2JqZWN0LnJpZ2h0IC0gc2NvcGUub2JqZWN0LmxlZnQgKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRXaWR0aCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXHRcdFx0XHRcdHBhblVwKCBkZWx0YVkgKiAoIHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tICkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGNhbWVyYSBuZWl0aGVyIG9ydGhvZ3JhcGhpYyBub3IgcGVyc3BlY3RpdmVcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRcdHNjb3BlLmVuYWJsZVBhbiA9IGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH0oKTtcblxuXHRcdGZ1bmN0aW9uIGRvbGx5T3V0KCBkb2xseVNjYWxlICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhIHx8IHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRzY2FsZSAvPSBkb2xseVNjYWxlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRzY29wZS5lbmFibGVab29tID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRvbGx5SW4oIGRvbGx5U2NhbGUgKSB7XG5cblx0XHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgfHwgc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdHNjYWxlICo9IGRvbGx5U2NhbGU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC4nICk7XG5cdFx0XHRcdHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlWm9vbVBhcmFtZXRlcnMoIHgsIHkgKSB7XG5cblx0XHRcdGlmICggISBzY29wZS56b29tVG9DdXJzb3IgKSB7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBlcmZvcm1DdXJzb3Jab29tID0gdHJ1ZTtcblxuXHRcdFx0Y29uc3QgcmVjdCA9IHNjb3BlLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRjb25zdCBkeCA9IHggLSByZWN0LmxlZnQ7XG5cdFx0XHRjb25zdCBkeSA9IHkgLSByZWN0LnRvcDtcblx0XHRcdGNvbnN0IHcgPSByZWN0LndpZHRoO1xuXHRcdFx0Y29uc3QgaCA9IHJlY3QuaGVpZ2h0O1xuXG5cdFx0XHRtb3VzZS54ID0gKCBkeCAvIHcgKSAqIDIgLSAxO1xuXHRcdFx0bW91c2UueSA9IC0gKCBkeSAvIGggKSAqIDIgKyAxO1xuXG5cdFx0XHRkb2xseURpcmVjdGlvbi5zZXQoIG1vdXNlLngsIG1vdXNlLnksIDEgKS51bnByb2plY3QoIHNjb3BlLm9iamVjdCApLnN1Yiggc2NvcGUub2JqZWN0LnBvc2l0aW9uICkubm9ybWFsaXplKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjbGFtcERpc3RhbmNlKCBkaXN0ICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoIHNjb3BlLm1pbkRpc3RhbmNlLCBNYXRoLm1pbiggc2NvcGUubWF4RGlzdGFuY2UsIGRpc3QgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblx0XHQvLyBldmVudCBjYWxsYmFja3MgLSB1cGRhdGUgdGhlIG9iamVjdCBzdGF0ZVxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Sb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0XHRyb3RhdGVTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bkRvbGx5KCBldmVudCApIHtcblxuXHRcdFx0dXBkYXRlWm9vbVBhcmFtZXRlcnMoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFggKTtcblx0XHRcdGRvbGx5U3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICkge1xuXG5cdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApLm11bHRpcGx5U2NhbGFyKCBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0XHRjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTsgLy8geWVzLCBoZWlnaHRcblxuXHRcdFx0cm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdFx0ZG9sbHlFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHRcdGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcblxuXHRcdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoIGRvbGx5RGVsdGEueSApICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGRvbGx5RGVsdGEueSA8IDAgKSB7XG5cblx0XHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCBkb2xseURlbHRhLnkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVQYW4oIGV2ZW50ICkge1xuXG5cdFx0XHRwYW5FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKS5tdWx0aXBseVNjYWxhciggc2NvcGUucGFuU3BlZWQgKTtcblxuXHRcdFx0cGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cblx0XHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG5cdFx0XHR1cGRhdGVab29tUGFyYW1ldGVycyggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0XHRpZiAoIGV2ZW50LmRlbHRhWSA8IDAgKSB7XG5cblx0XHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCBldmVudC5kZWx0YVkgKSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBldmVudC5kZWx0YVkgPiAwICkge1xuXG5cdFx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoIGV2ZW50LmRlbHRhWSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVLZXlEb3duKCBldmVudCApIHtcblxuXHRcdFx0bGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmNvZGUgKSB7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLlVQOlxuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgKSB7XG5cblx0XHRcdFx0XHRcdHJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHNjb3BlLnJvdGF0ZVNwZWVkIC8gc2NvcGUuZG9tRWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgKSB7XG5cblx0XHRcdFx0XHRcdHJvdGF0ZVVwKCAtIDIgKiBNYXRoLlBJICogc2NvcGUucm90YXRlU3BlZWQgLyBzY29wZS5kb21FbGVtZW50LmNsaWVudEhlaWdodCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0cGFuKCAwLCAtIHNjb3BlLmtleVBhblNwZWVkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLkxFRlQ6XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSApIHtcblxuXHRcdFx0XHRcdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiBzY29wZS5yb3RhdGVTcGVlZCAvIHNjb3BlLmRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwYW4oIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLlJJR0hUOlxuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgKSB7XG5cblx0XHRcdFx0XHRcdHJvdGF0ZUxlZnQoIC0gMiAqIE1hdGguUEkgKiBzY29wZS5yb3RhdGVTcGVlZCAvIHNjb3BlLmRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwYW4oIC0gc2NvcGUua2V5UGFuU3BlZWQsIDAgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdC8vIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBzY3JvbGxpbmcgb24gY3Vyc29yIGtleXNcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdFx0fVxuXG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBwb2ludGVycy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC5wYWdlWCwgZXZlbnQucGFnZVkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbiggZXZlbnQgKTtcblxuXHRcdFx0XHRjb25zdCB4ID0gMC41ICogKCBldmVudC5wYWdlWCArIHBvc2l0aW9uLnggKTtcblx0XHRcdFx0Y29uc3QgeSA9IDAuNSAqICggZXZlbnQucGFnZVkgKyBwb3NpdGlvbi55ICk7XG5cblx0XHRcdFx0cm90YXRlU3RhcnQuc2V0KCB4LCB5ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRQYW4oIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHBvaW50ZXJzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKCBldmVudCApO1xuXG5cdFx0XHRcdGNvbnN0IHggPSAwLjUgKiAoIGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueCApO1xuXHRcdFx0XHRjb25zdCB5ID0gMC41ICogKCBldmVudC5wYWdlWSArIHBvc2l0aW9uLnkgKTtcblxuXHRcdFx0XHRwYW5TdGFydC5zZXQoIHgsIHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5KCBldmVudCApIHtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oIGV2ZW50ICk7XG5cblx0XHRcdGNvbnN0IGR4ID0gZXZlbnQucGFnZVggLSBwb3NpdGlvbi54O1xuXHRcdFx0Y29uc3QgZHkgPSBldmVudC5wYWdlWSAtIHBvc2l0aW9uLnk7XG5cblx0XHRcdGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG5cdFx0XHRkb2xseVN0YXJ0LnNldCggMCwgZGlzdGFuY2UgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseVBhbiggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSApIGhhbmRsZVRvdWNoU3RhcnREb2xseSggZXZlbnQgKTtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gKSBoYW5kbGVUb3VjaFN0YXJ0UGFuKCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5Um90YXRlKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tICkgaGFuZGxlVG91Y2hTdGFydERvbGx5KCBldmVudCApO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSApIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHBvaW50ZXJzLmxlbmd0aCA9PSAxICkge1xuXG5cdFx0XHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKCBldmVudCApO1xuXG5cdFx0XHRcdGNvbnN0IHggPSAwLjUgKiAoIGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueCApO1xuXHRcdFx0XHRjb25zdCB5ID0gMC41ICogKCBldmVudC5wYWdlWSArIHBvc2l0aW9uLnkgKTtcblxuXHRcdFx0XHRyb3RhdGVFbmQuc2V0KCB4LCB5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApLm11bHRpcGx5U2NhbGFyKCBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0XHRjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTsgLy8geWVzLCBoZWlnaHRcblxuXHRcdFx0cm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUGFuKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBwb2ludGVycy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0cGFuRW5kLnNldCggZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oIGV2ZW50ICk7XG5cblx0XHRcdFx0Y29uc3QgeCA9IDAuNSAqICggZXZlbnQucGFnZVggKyBwb3NpdGlvbi54ICk7XG5cdFx0XHRcdGNvbnN0IHkgPSAwLjUgKiAoIGV2ZW50LnBhZ2VZICsgcG9zaXRpb24ueSApO1xuXG5cdFx0XHRcdHBhbkVuZC5zZXQoIHgsIHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICkubXVsdGlwbHlTY2FsYXIoIHNjb3BlLnBhblNwZWVkICk7XG5cblx0XHRcdHBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG5cdFx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oIGV2ZW50ICk7XG5cblx0XHRcdGNvbnN0IGR4ID0gZXZlbnQucGFnZVggLSBwb3NpdGlvbi54O1xuXHRcdFx0Y29uc3QgZHkgPSBldmVudC5wYWdlWSAtIHBvc2l0aW9uLnk7XG5cblx0XHRcdGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG5cdFx0XHRkb2xseUVuZC5zZXQoIDAsIGRpc3RhbmNlICk7XG5cblx0XHRcdGRvbGx5RGVsdGEuc2V0KCAwLCBNYXRoLnBvdyggZG9sbHlFbmQueSAvIGRvbGx5U3RhcnQueSwgc2NvcGUuem9vbVNwZWVkICkgKTtcblxuXHRcdFx0ZG9sbHlPdXQoIGRvbGx5RGVsdGEueSApO1xuXG5cdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHRcdGNvbnN0IGNlbnRlclggPSAoIGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueCApICogMC41O1xuXHRcdFx0Y29uc3QgY2VudGVyWSA9ICggZXZlbnQucGFnZVkgKyBwb3NpdGlvbi55ICkgKiAwLjU7XG5cblx0XHRcdHVwZGF0ZVpvb21QYXJhbWV0ZXJzKCBjZW50ZXJYLCBjZW50ZXJZICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseVBhbiggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSApIGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiApIGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5Um90YXRlKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tICkgaGFuZGxlVG91Y2hNb3ZlRG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlICkgaGFuZGxlVG91Y2hNb3ZlUm90YXRlKCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblx0XHQvLyBldmVudCBoYW5kbGVycyAtIEZTTTogbGlzdGVuIGZvciBldmVudHMgYW5kIHJlc2V0IHN0YXRlXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIHBvaW50ZXJzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRzY29wZS5kb21FbGVtZW50LnNldFBvaW50ZXJDYXB0dXJlKCBldmVudC5wb2ludGVySWQgKTtcblxuXHRcdFx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUgKTtcblx0XHRcdFx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcnVwJywgb25Qb2ludGVyVXAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRpZiAoIGlzVHJhY2tpbmdQb2ludGVyKCBldmVudCApICkgcmV0dXJuO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRhZGRQb2ludGVyKCBldmVudCApO1xuXG5cdFx0XHRpZiAoIGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnICkge1xuXG5cdFx0XHRcdG9uVG91Y2hTdGFydCggZXZlbnQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvbk1vdXNlRG93biggZXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Qb2ludGVyTW92ZSggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGlmICggZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgKSB7XG5cblx0XHRcdFx0b25Ub3VjaE1vdmUoIGV2ZW50ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0b25Nb3VzZU1vdmUoIGV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uUG9pbnRlclVwKCBldmVudCApIHtcblxuXHRcdFx0cmVtb3ZlUG9pbnRlciggZXZlbnQgKTtcblxuXHRcdFx0c3dpdGNoICggcG9pbnRlcnMubGVuZ3RoICkge1xuXG5cdFx0XHRcdGNhc2UgMDpcblxuXHRcdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKCBldmVudC5wb2ludGVySWQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSApO1xuXHRcdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwICk7XG5cblx0XHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfZW5kRXZlbnQgKTtcblxuXHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMTpcblxuXHRcdFx0XHRcdGNvbnN0IHBvaW50ZXJJZCA9IHBvaW50ZXJzWyAwIF07XG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBwb2ludGVyUG9zaXRpb25zWyBwb2ludGVySWQgXTtcblxuXHRcdFx0XHRcdC8vIG1pbmltYWwgcGxhY2Vob2xkZXIgZXZlbnQgLSBhbGxvd3Mgc3RhdGUgY29ycmVjdGlvbiBvbiBwb2ludGVyLXVwXG5cdFx0XHRcdFx0b25Ub3VjaFN0YXJ0KCB7IHBvaW50ZXJJZDogcG9pbnRlcklkLCBwYWdlWDogcG9zaXRpb24ueCwgcGFnZVk6IHBvc2l0aW9uLnkgfSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VEb3duKCBldmVudCApIHtcblxuXHRcdFx0bGV0IG1vdXNlQWN0aW9uO1xuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC5idXR0b24gKSB7XG5cblx0XHRcdFx0Y2FzZSAwOlxuXG5cdFx0XHRcdFx0bW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuTEVGVDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDE6XG5cblx0XHRcdFx0XHRtb3VzZUFjdGlvbiA9IHNjb3BlLm1vdXNlQnV0dG9ucy5NSURETEU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAyOlxuXG5cdFx0XHRcdFx0bW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuUklHSFQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdG1vdXNlQWN0aW9uID0gLSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAoIG1vdXNlQWN0aW9uICkge1xuXG5cdFx0XHRcdGNhc2UgTU9VU0UuRE9MTFk6XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0aGFuZGxlTW91c2VEb3duRG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLkRPTExZO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNT1VTRS5ST1RBVEU6XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuUEFOO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRoYW5kbGVNb3VzZURvd25Sb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNT1VTRS5QQU46XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRoYW5kbGVNb3VzZURvd25Sb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuUEFOO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIF9zdGFydEV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCBldmVudCApIHtcblxuXHRcdFx0c3dpdGNoICggc3RhdGUgKSB7XG5cblx0XHRcdFx0Y2FzZSBTVEFURS5ST1RBVEU6XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVNb3VzZU1vdmVSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFNUQVRFLkRPTExZOlxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBTVEFURS5QQU46XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVNb3VzZU1vdmVQYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZVdoZWVsKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSB8fCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHJldHVybjtcblxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX3N0YXJ0RXZlbnQgKTtcblxuXHRcdFx0aGFuZGxlTW91c2VXaGVlbCggY3VzdG9tV2hlZWxFdmVudCggZXZlbnQgKSApO1xuXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfZW5kRXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGN1c3RvbVdoZWVsRXZlbnQoIGV2ZW50ICkge1xuXG5cdFx0XHRjb25zdCBtb2RlID0gZXZlbnQuZGVsdGFNb2RlO1xuXG5cdFx0XHQvLyBtaW5pbWFsIHdoZWVsIGV2ZW50IGFsdGVyZWQgdG8gbWVldCBkZWx0YS16b29tIGRlbWFuZFxuXHRcdFx0Y29uc3QgbmV3RXZlbnQgPSB7XG5cdFx0XHRcdGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG5cdFx0XHRcdGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG5cdFx0XHRcdGRlbHRhWTogZXZlbnQuZGVsdGFZLFxuXHRcdFx0fTtcblxuXHRcdFx0c3dpdGNoICggbW9kZSApIHtcblxuXHRcdFx0XHRjYXNlIDE6IC8vIExJTkVfTU9ERVxuXHRcdFx0XHRcdG5ld0V2ZW50LmRlbHRhWSAqPSAxNjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDI6IC8vIFBBR0VfTU9ERVxuXHRcdFx0XHRcdG5ld0V2ZW50LmRlbHRhWSAqPSAxMDA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZGV0ZWN0IGlmIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgcGluY2hpbmdcblx0XHRcdGlmICggZXZlbnQuY3RybEtleSAmJiAhIGNvbnRyb2xBY3RpdmUgKSB7XG5cblx0XHRcdFx0bmV3RXZlbnQuZGVsdGFZICo9IDEwO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXdFdmVudDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGludGVyY2VwdENvbnRyb2xEb3duKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBldmVudC5rZXkgPT09ICdDb250cm9sJyApIHtcblxuXHRcdFx0XHRjb250cm9sQWN0aXZlID0gdHJ1ZTtcblxuXG5cdFx0XHRcdGNvbnN0IGRvY3VtZW50ID0gc2NvcGUuZG9tRWxlbWVudC5nZXRSb290Tm9kZSgpOyAvLyBvZmZzY3JlZW4gY2FudmFzIGNvbXBhdGliaWxpdHlcblxuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCBpbnRlcmNlcHRDb250cm9sVXAsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGludGVyY2VwdENvbnRyb2xVcCggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggZXZlbnQua2V5ID09PSAnQ29udHJvbCcgKSB7XG5cblx0XHRcdFx0Y29udHJvbEFjdGl2ZSA9IGZhbHNlO1xuXG5cblx0XHRcdFx0Y29uc3QgZG9jdW1lbnQgPSBzY29wZS5kb21FbGVtZW50LmdldFJvb3ROb2RlKCk7IC8vIG9mZnNjcmVlbiBjYW52YXMgY29tcGF0aWJpbGl0eVxuXG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGludGVyY2VwdENvbnRyb2xVcCwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25LZXlEb3duKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRoYW5kbGVLZXlEb3duKCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCBldmVudCApIHtcblxuXHRcdFx0dHJhY2tQb2ludGVyKCBldmVudCApO1xuXG5cdFx0XHRzd2l0Y2ggKCBwb2ludGVycy5sZW5ndGggKSB7XG5cblx0XHRcdFx0Y2FzZSAxOlxuXG5cdFx0XHRcdFx0c3dpdGNoICggc2NvcGUudG91Y2hlcy5PTkUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgVE9VQ0guUk9UQVRFOlxuXG5cdFx0XHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRPVUNILlBBTjpcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydFBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDI6XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBzY29wZS50b3VjaGVzLlRXTyApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSBUT1VDSC5ET0xMWV9QQU46XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnREb2xseVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZX1BBTjtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBUT1VDSC5ET0xMWV9ST1RBVEU6XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnREb2xseVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZX1JPVEFURTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX3N0YXJ0RXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaE1vdmUoIGV2ZW50ICkge1xuXG5cdFx0XHR0cmFja1BvaW50ZXIoIGV2ZW50ICk7XG5cblx0XHRcdHN3aXRjaCAoIHN0YXRlICkge1xuXG5cdFx0XHRcdGNhc2UgU1RBVEUuVE9VQ0hfUk9UQVRFOlxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0aGFuZGxlVG91Y2hNb3ZlUm90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFNUQVRFLlRPVUNIX1BBTjpcblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBTVEFURS5UT1VDSF9ET0xMWV9QQU46XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBTVEFURS5UT1VDSF9ET0xMWV9ST1RBVEU6XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0TWVudSggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRQb2ludGVyKCBldmVudCApIHtcblxuXHRcdFx0cG9pbnRlcnMucHVzaCggZXZlbnQucG9pbnRlcklkICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVQb2ludGVyKCBldmVudCApIHtcblxuXHRcdFx0ZGVsZXRlIHBvaW50ZXJQb3NpdGlvbnNbIGV2ZW50LnBvaW50ZXJJZCBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBwb2ludGVyc1sgaSBdID09IGV2ZW50LnBvaW50ZXJJZCApIHtcblxuXHRcdFx0XHRcdHBvaW50ZXJzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzVHJhY2tpbmdQb2ludGVyKCBldmVudCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcG9pbnRlcnNbIGkgXSA9PSBldmVudC5wb2ludGVySWQgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmFja1BvaW50ZXIoIGV2ZW50ICkge1xuXG5cdFx0XHRsZXQgcG9zaXRpb24gPSBwb2ludGVyUG9zaXRpb25zWyBldmVudC5wb2ludGVySWQgXTtcblxuXHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBvc2l0aW9uID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdFx0cG9pbnRlclBvc2l0aW9uc1sgZXZlbnQucG9pbnRlcklkIF0gPSBwb3NpdGlvbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRwb3NpdGlvbi5zZXQoIGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnRlcklkID0gKCBldmVudC5wb2ludGVySWQgPT09IHBvaW50ZXJzWyAwIF0gKSA/IHBvaW50ZXJzWyAxIF0gOiBwb2ludGVyc1sgMCBdO1xuXG5cdFx0XHRyZXR1cm4gcG9pbnRlclBvc2l0aW9uc1sgcG9pbnRlcklkIF07XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51ICk7XG5cblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24gKTtcblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVyY2FuY2VsJywgb25Qb2ludGVyVXAgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd3aGVlbCcsIG9uTW91c2VXaGVlbCwgeyBwYXNzaXZlOiBmYWxzZSB9ICk7XG5cblx0XHRjb25zdCBkb2N1bWVudCA9IHNjb3BlLmRvbUVsZW1lbnQuZ2V0Um9vdE5vZGUoKTsgLy8gb2Zmc2NyZWVuIGNhbnZhcyBjb21wYXRpYmlsaXR5XG5cblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIGludGVyY2VwdENvbnRyb2xEb3duLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSApO1xuXG5cdFx0Ly8gZm9yY2UgYW4gdXBkYXRlIGF0IHN0YXJ0XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBPcmJpdENvbnRyb2xzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n")}}]);